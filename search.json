[{"title":"java-虚拟机（上）","url":"/2024/04/08/java-虚拟机（上）/","content":"# JVM组成\n按照大的来分可以分为三部分：\n1. 类加载器，由于java是纯面向对象语言，类加载器会把java类转换成成字节码\n2. 运行时数据区（内存分区）：再细分可以分为共享的方法区和堆，线程不共享的虚拟机栈和本地方法栈，还有每个线程的指针\n3. 执行引擎：将中间代码转换成机器指令（x86，arm等）\n4. 本地库接口\n\n# 运行时数据区详细介绍\n- 堆（线程共享）\n- 方法区（线程共享）\n- 程序计数器（线程独占）\n- 虚拟机栈（线程独占）\n- 本地方法栈（线程独占）\n## 程序计数器\n就如同cpu中的pc，虚拟机中也有对应代码的pc，为了实现并发，每一个线程程序运行到哪里都不一样，也就需要保存，恢复上下文也方便。所以在jvm中程序计数器是私有的。\n\n注意：pc是唯一一个不会发生OOM的内存区域，估计是因为本来就放一个指针，再怎么样也超不出去。生存周期，随着线程的创建而创建，随着线程死亡而死亡。\n\n## 虚拟机栈\n这里的虚拟机栈跟真实的用c语言编译的栈类似，都是存函数调用的，有返回地址，局部变量，操作数，这里还有一个**动态链接**\n- 局部变量表：主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n- 操作数栈：主要是作为方法调用的中间站，比如addi a,b,a（估计不是这么写的，反正就是a+b计算出来的值再赋给a），存放的那个临时变量就a+b就放在操作数栈\n- 动态链接：运行到一定位置的时候可能会需要调用其他的类或者方法，这个时候就要把**符号引用转换为调用方法的直接引用**，因为再编译的时候都是用的常量池，在常量池引用的，一层套一层，这个时候就要把最核心的那个函数给拿出来，变成直接引用\n虚拟机栈超出会报错的，栈帧数量不能多于一个值。比如无限递归，最后报错报的是栈溢出，而不是堆溢出，因为在爆堆之前就已经爆栈\n\n## 本地方法栈\n这个跟虚拟机栈很像，但是虚拟机栈是为了java语句服务的，本地方法栈是使用到的本地native方法服务\n\n## 堆\n> 注意，我们在这里说的这五个其实是逻辑部分，就好像计算机组成原理中那五个部分一样，但是实际cpu又是控制器和运算器组合的。\n> \n> 这里也是类似，可以理解为这是jvm的逻辑设计图，具体实现的比如jdk1.7的持久代和1.8的元空间，其实也只是方法区的一个实现罢了\n\n## 持久代和元空间\n\n最大的一块，jdk1.7主要是三块，新生代，老年代和持久代，1.8把持久代取消了，取而代之的是元空间\n\n个人理解，本来在堆中就完成了方法区的设计，在持久区放静态变量，代码块和编译好的代码，但是由于可能会出现oom，以及越来越多的动态类，时的很容易爆堆，这个时候不如把它提出虚拟机吧！放在实际内存下面，这样就有更广阔的空间给你爆了。\n\n于是元空间这个概念就出来了，但是也不是无限扩大，有大小限制的\n\n**为什么使用元空间？**\n- 1）由于 PermGen 内存经常会溢出，引发OutOfMemoryError，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM。\n- 2）移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。\n- 3）减轻gc的负担，放在外面的元空间可以不用gc\n\n准确来说，Perm 区中的字符串常量池被移到了堆内存中是在 Java7 之后，Java 8 时，PermGen 被元空间代替，其他内容比如**类元信息、字段、静态属性、方法、常量**等都移动到元空间区。比如 java/lang/Object 类元信息、静态属性 System.out、整型常量等。\n\n元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。\n\n## 新生代和老年代\n\n- 年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到老年代区间。\n- 老年代主要保存生命周期长的对象，一般是一些老的对象\n\n这就涉及到后面的垃圾回收算法了\n\n## 方法区\n一般来存静态变量，常量以及编译好的代码\n\n> 这里要注意，既然方法区里面有常量，那也会有运行时常量池。这里要区分**字符串常量池**，jdk1.7之前，字符串常量池是跟持久代放在一起的，是持久代的一个组成部分，1.7之后，字符串常量池就放在堆空间里了，也就是说提出来了，直到现在也还是在堆空间\n> \n> **为什么？**\n> \n> 主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。\n> \n> 而运行时常量池是放在方法区的，也就是元空间\n\n# 类加载器与双亲委派模型\n> 这里的加载有点像dns的递归查找\n- bootstrapClassLoader：根加载器，每个都会从它开始\n- ExtClassLoader：扩展功能的一些jar包里面的类\n- AppClassLoader：应用类加载器\n- 自定义，可以重写方法\n\n**双亲委派模型**\n\n如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就返回成功；只有父类加载器无法完成此加载任务时，才由下一级去加载。 \n\n双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现两个不同的 Object 类。双亲委派模型可以保证加载的是 JRE 里的那个 Object 类，而不是你写的 Object 类。这是因为 AppClassLoader 在加载你的 Object 类时，会委托给 ExtClassLoader 去加载，而 ExtClassLoader 又会委托给 BootstrapClassLoader，BootstrapClassLoader 发现自己已经加载过了 Object 类，会直接返回，不会去加载你写的 Object 类\n\n\n好处：\n- 防止核心库被篡改\n- 不重复加载类\n\n# 打破双亲委派\ntomcat，重写了loadClass方法\n","tags":["Java"]},{"title":"java-多线程-ThreadLocal和线程池","url":"/2024/04/07/java-多线程（中/","content":"# ThreadLocal\n\n通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？\n\nJDK 中自带的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。\n\n如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。\n\n再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。\n\n## 数据结构\n\n![](../img/Java/img_5.png)\n\n其实不是ThreadLocal有这个数据结构，是Thread持有的，有一个ThreadLocalMap的数组，专门放键值对，K为ThreadLocal的类对象，V为ThreadLocal泛型的数据。\n\n也就是说，在一个线程中，如果有多个ThreadLocal，查找Map键为这个ThreadLocal变量，就可以很轻松拿到存的值。\n\n```java\npublic void set(T value) {\n    //获取当前请求的线程\n    Thread t = Thread.currentThread();\n    //取出 Thread 类内部的 threadLocals 变量(哈希表结构)\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        // 将需要存储的值放入到这个哈希表中\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n```\n## 内存泄露问题\n\n这个Map里面，Key是弱引用的，也就是说每次gc都会回收key，而value是强引用的。这个时候就会出现，key被gc回收了为null，value还有的情况。这个时候就会产生内存泄露。\n\n解决方法：释放的时候手动remove。\n\n# 线程池的四个种类\n1. newCachedThreadPool创建一个可缓存的线程池，默认阻塞队列是SynchronousQueue\n2. newFixedThreadPool创建一个定长的线程池，默认阻塞队列是LinkedBlockingQueue\n3. newSingleThreadExecutor创建一个单例线程，默认也是LinkedBlockingQueue\n4. newScheduled创建一个可以设置定时任务的线程\n\n# 线程池的核心参数\n\n除了上面四种封装好的，还可以自己创建\n\n```java\n    /**\n     * 用给定的初始参数创建一个新的ThreadPoolExecutor。\n     */\n    public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量\n                              int maximumPoolSize,//线程池的最大线程数\n                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间\n                              TimeUnit unit,//时间单位\n                              BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列\n                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可\n                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务\n                               ) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n```\n\n七个核心参数：\n1. 核心线程数量\n2. 最大线程数量\n3. 过期时间：如果线程池的线程数量大于核心线程数量，如果没有新的任务提交，那么已经到期的线程不会立刻销毁，而是等一段时间销毁\n4. 过期时间单位：可以是秒，毫秒\n5. 阻塞队列：刚刚提的那些，后面还会说\n6. 饱和缩略\n7. 线程工厂类：一般都是默认的，可以定制线程对象的创建，例如设置线程名字、是否是守护线程等\n\n# 饱和策略\n当阻塞队列满了，而且最大线程数量也满了，就会触发饱和策略\n1. 抛出异常，不让加了\n2. 线程不走线程池，提交线程的那个线程自己来运行\n3. 不报错，直接丢弃\n4. 丢弃队列最前面那个，然后加进队列\n\n# 如何确定线程数量\n- io密集型：2n+1\n- cpu密集型：n+1\n这里的n都是当前机器的虚拟内核数量，io密集型主要都是io时间多，对于cpu负载并不大\n","tags":["Java"]},{"title":"java-多线程-volatile，synchronized和lock","url":"/2024/04/07/zjava-多线程-上/","content":"> 由于东西很多很乱，就按照Q&A的方式整理以下\n\n# 进程与线程的区别\n\n- 调度方面：在传统计算机中，进程是调度的基本单位，但是在引入线程之后，线程是调度的基本单位。同一个进程下的线程切换不会引起进程切换，但是不同的就会影响\n- 拥有资源方面：进程是拥有资源的单位，线程之间共享内存空间\n- 切换方面：进程切换要保存上下文程序计数器很多东西，而线程切换只用保存一些寄存器。开销远小于进程\n- 并发性：同一个进程下的线程可以并发，不同进程下的线程也可以并发\n\n# volatile关键字\nvolatile是不稳定的意思，不止用于java，c++也有使用，声明了这个关键字的变量会禁用缓存，每一次都从内存找最新的值，这样就能保证可见性，但是不会保证原子性，例如下面这段代码\n```java\npublic class VolatileAtomicityDemo {\n    public volatile static int inc = 0;\n\n    public void increase() {\n        inc++;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService threadPool = Executors.newFixedThreadPool(5);\n        VolatileAtomicityDemo volatileAtomicityDemo = new VolatileAtomicityDemo();\n        for (int i = 0; i < 5; i++) {\n            threadPool.execute(() -> {\n                for (int j = 0; j < 500; j++) {\n                    volatileAtomicityDemo.increase();\n                }\n            });\n        }\n        // 等待1.5秒，保证上面程序执行完成\n        Thread.sleep(1500);\n        System.out.println(inc);\n        threadPool.shutdown();\n    }\n}\n```\n这里得不到结果的主要原因是，inc++不是一个原子操作，其实是由三个操作并成，先读取inc，再++，最后写回，可能两个线程同时都读到inc为100，这个时候再同时更改写回内存，这样就会达不到预期，所以volatile关键之**只能保证可见性，不能保证原子性**\n\n如果要保证原子性，可以使用：\n- synchronized关键字上锁increase方法\n- 既然可以用synchronized方法，那肯定也可以用ReentrantLock，关于这两者的区别后文再说\n- ReentrantLock基于CAS和AQS，那肯定用CAS的原子方法也可以解决，后文再说\n\n# 乐观锁和悲观锁\n- 悲观锁：悲观的觉得临界区一定会有人来竞争，所以每次访问的时候一定要上锁，synchronized和ReentrantLock就是比较典型的悲观锁\n- 乐观锁：很投机的觉得，这段代码可能不会有别的线程访问，就算有我也不上锁，用其他的方法，例如队列，链表的方式，比较典型的就是CAS（其实我觉得MVCC多少也有点这种思想）\n最大的区别就是锁的粒度不一样，悲观锁由于每一次都要上锁，肯定效率没有乐观锁高，反而言之，如果频繁发生冲突，乐观锁的效率也是很低的。总而言之，在读多写少的场景，可以使用乐观锁，写多读少的情况下，使用悲观锁。\n\n# CAS和自旋锁\n## CAS\ncompare and swap，比较并且交换，主要思想是给出三个数据：要修改的数据的更新值，这个要修改的数据的预期值，要修改数据的实际值。什么意思呢，例如我们要把一个等于1的数据修改成6，我对于这个要修改数据的预期值就是1，当且仅当数据是1的时候，我才会把它修改成6.\n这个思想怎么在并发的环境下体现呢？比如这个时候两个线程都要修改这个数据，有一个别的线程抢占先机，由于这个是由volatile修饰的，另一边立即会就看到修改成了另外一个值，不再是预期值1，这个时候cas就会失效，从而保证了并发。\n\n**为什么这样就能作为锁呢？**\n\n理由很简单，cas**保证原子性**，为什么他敢理直气壮的说自己是原子的。这就要涉及到一个神奇的类Unsafe，在实现java虚拟机的时候，由于jvm的隔离性，使得java很难接近底层操作系统，Unsafe这个类里面全都是native方法，也就是用的本地方法，对于cas而言，这个底层的方法不是java实现的，是由Unsafe调用dll动态库，也就是c++实现的，cas这条操作可以理解成汇编的一个原子指令，既然是一条指令，那么肯定是可以保证原子性的。\n\n那么问题来了，为什么不直接弄一条锁的原子指令，而这么拐弯抹角的用到这个语句间接完成乐观锁，小编也不知道\n\n## 自旋锁\n\n我们有了这个CAS操作，到底怎么用到锁上面呢？我们先看一个用CAS的例子：\n\nAtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。AtomicInteger是一个操作Integer类型的原子操作类，这里的getAndAddInt可以保证线程安全，获取Object对象在内存偏移量，然后在+i\n```java\npublic final int getAndAddInt (Object var1, Long var2, int var4) {\n\tint var5;\n    //自循环的思想，每一次循环都找Object的偏移量为var2的那个值，这个获得的就是预期值，\n    //循环条件是如果跟他一样就断开，如果不一样，不阻塞，不释放CPU，但是也达到了锁的功能\n    //能加就加，加不上就一只循环一直尝试\n\tdo {\n\t\tvar5 = this.getIntVolatile(var1, var2);\n\t} while( !this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\t\n\treturn var5;\n}\n\n\n```\n主要思想是加的上就加，加不上一直尝试，即使没有加锁，但是也达到了锁的功能。\n\n这种思想称为**自旋**，我们把这种dowhile的思想运用到类上就是**自旋锁**，我猜取这个名字的原因是因为一直循环，很像自己一个人在转\n```java\npublic class SpinLock {\n    private AtomicReference<Thread> owner = new AtomicReference<Thread>();\n\n    public void lock() {\n        Thread currentThread = Thread.currentThread();\n        // 如果锁未被占用，则设置当前线程为锁的拥有者\n        while (!owner.compareAndSet(null, currentThread)) {\n        }\n    }\n\n    public void unlock() {\n        Thread currentThread = Thread.currentThread();\n        // 只有锁的拥有者才能释放锁\n        owner.compareAndSet(currentThread, null);\n    }\n}\n```\nAtomicReference是一个原子类，提供的compareAndSet方法封装了CAS方法，参数中前面是预期值，后面是要修改的值，如果预期值和实际值是一样的，那么就设置为修改值。\n\n上锁过程：owner这里空参数构造，所以我的预期值是空，如果这个时候只有一个线程，那么没有人上锁肯定也是空，所以实际值也是空，满足条件，那么就把空设置为当前线程。如果有两个线程，都同时要上锁，先进来的那个上了锁，下一个compareAndSet方法肯定是假，就会一直while，不会释放cpu\n\n解锁过程：预期值为当前线程，这个线程刚刚上锁了，所以实际值肯定存的也是这个，最后满足条件就把锁设置为null，此时第二个线程终于不用自旋了，就会获取锁。\n\n通过这个过程也看到了，自旋的优点和缺点都很明显，优点是如果时间短的话，可以免去线程的上下文切换时间；但是如果时间长，那就是很消耗cpu的，一直不释放，这个缺点有改进措施，可以用**自适应自旋锁**，也就说，不再是无限循环，可以设置一个最大循环次数，就不会导致死循环的情况。\n\n## ABA问题\nCAS存在一个问题，判断实际值和预期值相同，其实不一定就能说明没改过，有可能预期值是A，实际值从A变成了B再变成了A，这个问题其实蛮严重的，如果是变量还好，如果在链表中，判断头节点没变化，不代表接下来的节点没有变化，就会导致完全不一样的结果。\n\n如何避免？\n\n加时间戳，上文用了AtomicReference，这回用AtomicStampedReference，这里使用了时间戳，只有当时间戳相同并且实际值等于预期值，才可以。\n\n# Synchronized关键字\n\n在 Java 早期版本中，synchronized 属于 重量级锁，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。\n\n不过，在 Java 6 之后， synchronized 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 synchronized 锁的效率提升了很多。因此， synchronized 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 synchronized 。\n\n关于偏向锁多补充一点：由于偏向锁增加了 JVM 的复杂性，同时也并没有为所有应用都带来性能提升。因此，在 JDK15 中，偏向锁被默认关闭（仍然可以使用 -XX:+UseBiasedLocking 启用偏向锁），在 JDK18 中，偏向锁已经被彻底废弃（无法通过命令行打开）。\n\n## 如何使用Synchronized关键字？\n1. 修饰方法\n2. 修饰静态方法（锁住当前类）：注意修饰静态方法是没有互斥性的，因为静态方法是放在进程中静态代码块那一部分的，所有线程共享，每一个线程都可以访问\n3. 修饰代码块：\n- synchronized(object) 表示进入同步代码库前要获得 给定对象的锁。\n- synchronized(类.class) 表示进入同步代码前要获得 给定 Class 的锁\n\n总结：\n- synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁；\n- synchronized 关键字加到实例方法上是给对象实例上锁；\n- 尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能。\n\n## 构造方法可以被Synchronized修饰吗》\n不可以，因为本身构造方法就已经是线程安全的了\n\n## Synchronized底层原理\n\n基于jvm的monitor,在java编译的时候会给加锁代码加上monitorenter和两个monitorexit，在这中间的就是互斥的，为什么要有两个呢，线程有的时候会抛出异常或者错误，这个时候就会走第二个exit，用两个是为了保证一定能退出。\n\nmonitor也是基于c++的，分为三个部分，一个是当前获取锁的对象，还有一个是等待队列，一个是阻塞队列。\n\n上锁成功的标志是monitor的拥有者为当前线程，当释放的时候会唤醒阻塞进程，有一点要说明的是这个过程是非公平，也就是运行不在队列里的新进程也来抢。\n\n## Synchronized锁升级原理\n\n> 这一块暂时还没有细细研究。\n\n有四种锁等级，锁的重量依次递增：\n1. 不加锁\n2. 加偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令。这也是某种投机行为，乐观锁思想，在很少有进程竞争的时候比较节约资源\n3. 加轻度锁：也就是自旋锁等，每次操作都是cas，还是乐观锁思想，这个就比偏向锁稍微控制了一点\n4. 重度锁，使用monitor那种悲观锁\n\nSynchronized发生竞争会依次升级锁，高并发下变成悲观锁\n\n## Synchronized和volatile什么区别\n\n1. Synchronized修饰方法，静态方法，代码块等，而volatile修饰变量\n2. volatile是线程同步的轻量实现，具有可见性但是没有原子性，Synchronized可以保证可见性和原子性\n3. volatile性能肯定比Synchronized好，但是主要解决的是变量的问题，Synchronized解决方法的同步和互斥。\n\n# ReentrantLock\n\n可重入锁，实现了Lock接口，相比Synchronized功能更多，实现了轮询，超时，中断，公平锁和非公平锁。\n\n公平和非公平锁主要是Sync里面实现的，而Sync继承自**AQS**，也就是说ReentrantLock用的就是AQS思想。\n\n## AQS\n主要数据结构是CLH，最早的CLH是一个虚拟的单向链表，为什么是虚拟的呢，因为甚至连指针都没有，一个CLH节点就包含两个结构，一个是当前线程，另外一个是一个bool变量，用来表示是否获得了锁。\n\n**那是怎么运作的呢？**\n\n初始化一个尾节点，线程那部分为空，bool部分为true，也就是说可以被上锁，每一个线程都用**自旋的方式**尝试获得来的时候的尾节点的bool值，那么这个时候来了一个线程，用CAS尝试获取现在的尾节点的bool，为真，那就可以上锁为false，同时自己的bool也为false，表示前面的节点都不能用，所以下一个也不能。\n\n来了一个线程2，现在的尾节点是线程1，他的bool是false，线程2会一直自旋的获取前一个节点的bool值，后面的也是，如果此时线程1好了，那么线程2监听到前面一个变成了true，那就会开始线程2，以此类推。\n\n优点很明显：如果时间短，那么获取和释放锁的开销小。CLH 的锁状态不再是单一的原子变量，而是分散在每个节点的状态中，降低了自旋锁在竞争激烈时频繁同步的开销。还有就是公平，先进先出\n\n这样的CLH有什么缺点呢，首先是都是自旋，如果时间短还好，长了那肯定浪费资源。功能单一，不能支持ReentrantLock的那些接口功能。\n\n**AQS对于CLH的改造**\n\n针对自旋，AQS都改造成了阻塞，还是不能用自旋。针对第二个功能单一的缺点，使用了双向链表和一个全局变量state（其实我觉得之前那种看上一个节点情况的机制还蛮好的，这不是又重新变成信号量那种机制了）\n\nstate属性表示资源的状态，为0表示可以抢了，为1表示不能，为1时候来的线程进阻塞队列\n- 公平与非公平，公平就是直接每次都唤醒队列头的，非公平就是来的也一起竞争，但是可能会导致饥饿\n- 可重入：一个线程多次进入可以state自增，如果重入两次那么state就是2，但是要保证加锁几次就解锁几次，保证最终还是0\n\n# ReentrantLock和synchronized区别\n\n1. 首先两者都是悲观锁，也都是可重入的，synchronized是一个关键字，基于jvm实现，ReentrantLock是一个是实现类，实现Lock接口，使用的时候需要声明。\n2. ReentrantLock功能比较多，实现了可中断（中断也就说如果得不到锁就去干别的事情了，synchronized不可中断），可超时（ReentrantLock实现了，如果超时多少就不去争抢锁了，syn实现不了），锁可以绑定多个条件（Condition类，就相当于不同的信号量，可以控制一部分Condition下的进程等待，另一部分的执行）\n3. 没有竞争的时候synchronized优化很多，锁没有升级的时候性能很好；重度的时候Lock的性能比较好，因为底层还是用了cas的一部分乐观机制，相比synchronized的monitor还是好一点\n\n","tags":["Java"]},{"title":"mysql-索引和索引失效","url":"/2024/04/05/mysql-索引和索引失效/","content":"# 索引失效\n## 左匹配或者左右匹配\n当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效。\n\n**为什么 like 关键字左或者左右模糊匹配无法走索引呢？**\n\n因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。\n\n举个例子，下面这张二级索引图（图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行），是以 name 字段有序排列存储的。\n\n![](../img/Mysql/img_13.png)\n\n\n假设我们要查询 name 字段前缀为「林」的数据，也就是 name like '林%'，扫描索引的过程（这里中文都是按照某种排序，不知道是不是按照utf-8的编码值比较的，但是这个规则不影响寻找到逻辑）：\n- 节点1判断出“林”小于“周”并且大于“陈”（这个步骤是通过**页目录**进行搜索的，回顾一下：假设这里头指针是一个分组，陈是一个分组，剩下两个和尾指针是一个分组，二分查找目录项，由于目录项指向分组的最大值，那么“林”是大于陈小于周的，按照目录项的规则，从*包含尾指针的那个分组开始*，但是由于存的是最大值也就是尾指针，为了从头开始遍历，就要找到上一个槽的指针，往后数一个就是当前的最小值，结果发现当前的最小值“周”还是大于“林”，这样就定位在“陈”和“周”之间，按照存储规则，**非叶子节点存的是下一个节点的最小值**，那就要在“陈”这个节点找）\n- 节点2继续比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4\n- 节点4查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。\n  \n如果使用 name like '%林' 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。\n> 总而言之，索引是从左边开始匹配的，如果左边第一个都不能确定，那就要全部遍历\n## 对索引使用函数\n有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。\n\n**为什么对索引使用函数，就无法走索引了呢？**\n\n因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。\n\n不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。\n\n举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。\n\n```text\nalter table t_user add key idx_name_length ((length(name)));\n```\n> 总而言之，索引保存的是原始值，使用函数后重新计算导致不能索引到，就失效了，但是如果对这个函数也建立一个索引，那也可以走索引\n## 数据类型强制转换\n> 这个印象比较深刻：首先举一个例子，select \"10\" > 9，通过这个例子可以看出来在mysql是怎么处理字符串的\n> - 如果是结果是1，也就是select 10>9，那么内部会把字符串处理成数字\n> - 如果结果是0，也就是select \"10\" > \"9\"，字符串是比较首位，1肯定小于9，所以这个结果是0，那么内部把数字处理成字符串\n> 结果是1，也就是**mysql内部把字符串变成数字进行比较**\n\n假设phone在数据库是用varchar存的，有了这个结论，那么\n```text\nselect * from t_user where phone = 1300000001;\n```\n这个代码就会变成：\n```text\nselect * from t_user where CAST(phone AS signed int) = 1300000001;\n```\n因为内部会把索引的字符串变成整数进行比较，相当于给索引使用了函数，所以就会失效\n\n如果查询条件是字符串，id在数据库用int存的\n```text\nselect * from t_user where id = \"1\";\n```\n那么就会变成：\n```text\nselect * from t_user where id = CAST(\"1\" AS signed int);\n```\n也就是说，只有这个查询条件会要用这个函数，索引没有用，索引就不失效\n## 对索引进行表达式计算\n在查询条件中对索引进行表达式计算，也是无法走索引的。\n\n比如，下面这条查询语句，执行计划中 type = ALL，说明是通过全表扫描的方式查询数据的：\n\n```text\nexplain select * from t_user where id + 1 = 10;\n```\n\n**为什么对索引进行表达式计算，就无法走索引了呢？**\n\n原因跟对索引使用函数差不多。\n\n因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。\n\n有的同学可能会说，这种对索引进行简单的表达式计算，在代码特殊处理下，应该是可以做到索引扫描的，比方将 id + 1 = 10 变成 id = 10 - 1。\n\n是的，是能够实现，但是 MySQL 还是偷了这个懒，没有实现。\n\n我的想法是，可能也是因为，表达式计算的情况多种多样，每种都要考虑的话，代码可能会很臃肿，所以干脆将这种索引失效的场景告诉程序员，让程序员自己保证在查询条件中不要对索引进行表达式计算。\n\n## 联合索引的左匹配问题\n对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。\n\n那么多个普通字段组合在一起创建的索引就叫做联合索引，也叫组合索引。\n\n创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。\n\n联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配。\n\n比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：\n- where a=1；\n- where a=1 and b=2 and c=3；\n- where a=1 and b=2；\n需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。\n\n但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:\n- where b=2；\n- where c=3；\n- where b=2 and c=3；\n> 其实类似第一种情况，不管是字符串还是索引，都是按照最左匹配的，如果连第一个都没有，那就会导致索引失效，这里还有一个**索引下推**的机制，等以后再来补。\n## or导致的失效问题\n\n在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。\n\n这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。\n\n> or就是两个里面满足一个，也就是索引要有两个，才可以一起用索引，and其实是只要有一个是索引就可以走索引的，要注意","tags":["Mysql"]},{"title":"mysql-Buffer Pool","url":"/2024/04/05/mysql-Buffer-Pool/"},{"title":"mysql-事务隔离级别与MVCC","url":"/2024/04/05/mysql-事务隔离级别与MVCC/","content":"# 事务的特性（ACID）\n- 原子性（Atomicity）：要么一起成功，要么一起失败，是一个操作，不可分割\n- 一致性（Consistency）：是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行前后，数据库都必须处于一致性状态。换句话说，事务的执行结果必须是使数据库从一个一致性状态转变到另一个一致性状态。\n- 隔离性（Isolation）：多个并发事务操作是隔离的，不会彼此打扰\n- 持久性（Durability）：修改之后是持久的，不会掉电就失效了\n# 并发导致的不一致性\n- 脏读\n**如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。**\n\n假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。\n\n![](../img/Mysql/img_14.png)\n\n因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读\n> 也就是事务B在A还没提交之前就已经读到了修改的数据，但是A因为某些原因回滚了，这个时候B就读到了脏数据，称为脏读\n- 不可重复读\n**在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。**\n\n假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。\n\n![](../img/Mysql/img_15.png)\n\n> 也就是A读到了B修改前和修改后的两次数据，不一致的问题，就是不可重复读\n- 幻读\n\n","tags":["Mysql"]},{"title":"mysql-B+树与数据页","url":"/2024/04/03/mysql-B-树与数据块/","content":"> 我们先从最基本的存储引擎InnoDB开始学起，[原文链接](https://blog.csdn.net/liang921119/article/details/130556995)\n# InnoDB 是如何存储数据的？\nMySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同的，我们最常使用的是 InnoDB 存储引擎，所以就跟大家图解下InnoDB 是如何存储数据的。\n\n记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。\n\n因此，InnoDB 的数据是按「数据页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。\n# 数据页\n数据库的 I/O 操作的最小单位是页，InnoDB 数据页的默认大小是 16KB，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。\n\n数据页包括七个部分，结构如下图：\n\n![](../img/Mysql/img.png)\n\n![](../img/Mysql/img_1.png)\n> 这里最重要的是最小和最大记录，以及用户记录\n\n## 用户真实记录在数据页中的存储（Free Space）\n在页的7个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。这个过程的图示如下：\n\n![](../img/Mysql/img_2.png)\n\n为了更好的管理在User Records中的这些记录，InnoDB可费了一番力气呢，在哪费力气了呢？不就是把记录按照指定的行格式一条一条摆在User Records部分么？其实这话还得从记录行格式的记录头信息中说起\n\n## 记录头信息引出的数据页“记录”结构\n我们这里先创建一张表\n\n```text\nmysql> create table demo5 (c1 int, c2 int, c3 varchar(10000),primary key (c1)) charset=ascii row_format=compact;\n\nQuery OK, 0 rows affected (0.04 sec)\n```\n\n这个新建的表有三个列，c1和c2列是用来存储整数的，c3存储的字符串，但是我们指定c1位主键，所以在具体的行格式中，Innodb就没有必要给我们创建row_id隐藏列了 **（这里说的隐藏列是在没有明确给主键的时候，mysql会自己找一个unique并且没有空值的列为主键索引，这个就是隐藏列）**。所以表中的行格式示意图如下：\n\n![](../img/Mysql/img_3.png)\n\n![](../img/Mysql/img_4.png)\n\n\n| 名称\t          | ⼤⼩（单位：bit）\t | 描述                                              |\n|--------------|-------------|-------------------------------------------------|\n| 预留位1\t        | 1           | \t没有使⽤                                           | \n| 预留位2\t        | 1\t          | 没有使⽤                                            | \n| delete_mask\t | 1\t          | 标记该记录是否被删除                                      |\n| min_rec_mask | \t1\t         | B+树的每层⾮叶⼦节点中的最⼩记录都会添加该标记                        |\n| n_owned\t     | 4\t          | 表示当前记录拥有的记录数                                    | \n| heap_no\t     | 13\t         | 表示当前记录在记录堆的位置信息                                 |  \n| record_type  | \t3\t         | 表示当前记录的类型，0表示普通记录，1表示B+树⾮叶⼦节点记录，2表示最⼩记录，3表示最⼤记录 |   \n| next_record\t | 16\t         | 表示下⼀条记录的相对位置                                    |\n\n假设我们插入了几条数据：\n\n![](../img/Mysql/img_5.png)\n\n接下来会一个个解释这几个字段\n\n### delete_mask\n这个属性标记当前记录是否被删除，占用一个二进制位，为0为没有删除，为1被删除\n> 被删除的记录不立即从磁盘上移除，因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为所谓的可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。这个delete_mask位设置为1和将被删除的记录加入到垃圾链表中是两个阶段\n\n### min_rec_mask\nB+树的每层非叶子节点中的最小记录都会添加该标记。值为1，表示该条记录是B+树的非叶子节点中的最小记录；值为0，意味着该条数据不是B+树的非叶子节点中的最小记录 **（暂时还不知道这个具体作用，可能就是记录每一层的头节点？）**\n\n### n_owned\n这个涉及到**分组**的概念了，存的就是当前分组有多少个元素，后续会介绍\n\n### heap_no\n这个属性表示当前记录在本页中的位置（类似页表中的本页地址字段，但是这个单纯用来比较顺序）。MySQL自动给每个页里边儿加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录（这就是最前面介绍的7部分中的 **最大最小记录**）。\n\n记录也可以比大小，对于一条完整的记录来说，比较记录的大小就是比较主键的大小。但是不管我们向页中插入了多少自己的记录，InnoDB规定他们定义的两条伪记录分别为最小记录与最大记录。这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。\n\n![](../img/Mysql/img_6.png)\n> 这里规定的最小记录的heapno为0，最大记录的为1\n\n### record_type\n这个属性表示当前记录的类型，一共有4种类型的记录，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们record_type值都是0，而最小记录和最大记录的record_type值分别为2和3，至于record_type为1的情况，我们之后在说索引的时候会重点强调的。\n\n### next_record\n\n这个信息非常重要，表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。如果你熟悉数据结构的话，就立即明白了，这其实是个链表，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是，下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是Supremum记录（也就是最大记录） ，为了更形象的表示一下这个next_record起到的作用，我们用箭头来替代一下next_record中的地址偏移量：\n\n![](../img/Mysql/img_7.png)\n\n假设删掉第2条记录后，由于删除只是标记为删除，实际上没有删除，就会变成：\n\n![](../img/Mysql/img_8.png)\n\n从图中可以看出来，删除第2条记录前后主要发生了这些变化：\n\n- 第2条记录并没有从存储空间中移除，而是把该条记录的delete_mask值设置为1。\n- 第2条记录的next_record值变为了0，意味着该记录没有下一条记录了。\n- 第1条记录的next_record值变为了64，指向了第3条记录。\n- 最大记录的n_owned值从5变成了4，关于这一点的变化我们稍后会详细说明的。\n所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的\n\n## 页目录（重要）\n> 页目录的存在意义主要是加速检索速度，并不是将他们重新分组，我最开始以为是将记录再分成几块进行检索，但是其实只是一个方便二分查找的工具\n\n现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？比如说这样的查询语句：\n```text\nselect * from where c1=3;\n```\n最笨的办法：从Infimum记录（最小记录）开始，沿着链表一直往后找，总会找到。在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。\n\n但是InnoDB能用这么笨的办法么，当然是要设计一种更快的查找方式，于是乎从书的目录中找到了灵感。\n\n我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。InnoDB为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：\n\n- 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。\n- 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。\n- 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的Page Directory，也就是页目录。页面目录中的这些地址偏移量被称为槽（英文名：Slot），所以这个页面目录就是由槽组成的。\n需要注意的是，Page Directory是逆序存放的，每个槽占2字节\n\n![](../img/Mysql/img_9.png)\n> 这里第一个slot为什么是99？因为是从页的第一位开始算 ~~（文件头+页头+最小记录前的6字节=38+56+5=100，但是是0开始的，所以）~~ 最小记录单成一个分组，那slot也就指向的是最小记录的数据\n\n从这个图中我们需要注意这么几点：\n\n现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。\n\n注意最小和最大记录的头信息中的n_owned属性\n\n最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。\n\n最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。\n\n99和112这样的地址偏移量很不直观，我们用箭头指向的方式替代数字，这样更易于我们理解，所以修改后的示意图就是这样：\n\n![](../img/Mysql/img_10.png)\n\n![](../img/Mysql/img_11.png)\n\n\nInnoDB对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1 ~ 8条之间，剩下的分组中记录的条数范围只能在是4 ~ 8条之间。所以分组是按照下边的步骤进行的：\n- 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。\n- 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。\n- 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。\n\n### 举例\n\n```text\ninsert into demo5 values(1,100,'aaaa'),(2,200,'bbbb'),(3,300,'cccc'),(4,400,'dddd');\ninsert into demo5 values(5, 500, 'eeee');\ninsert into demo5 values(6, 600, 'ffff');\ninsert into demo5 values(7, 700, 'gggg');\ninsert into demo5 values(8, 800, 'hhhh');\ninsert into demo5 values(9, 900, 'iiii');\ninsert into demo5 values(10, 1000, 'jjjj');\ninsert into demo5 values(11, 1100, 'kkkk');\ninsert into demo5 values(12, 1200, 'llll');\ninsert into demo5 values(13, 1300, 'mmmm');\ninsert into demo5 values(14, 1400, 'nnnn');\ninsert into demo5 values(15, 1500, 'oooo');\ninsert into demo5 values(16, 1600, 'pppp');\n```\n![](../img/Mysql/img_12.png)\n\n因为把16条记录的全部信息都画在一张图里太占地方，让人眼花缭乱的，所以只保留了用户记录头信息中的n_owned和next_record属性，也省略了各个记录之间的箭头，我没画不等于没有啊！现在看怎么从这个页目录中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为6的记录，过程是这样的：\n- 计算中间槽的位置：(0+4)/2=2，所以查看槽2，对应记录的主键值为8，又因为8 > 6，所以设置high=2，low保持不变。\n- 重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4，又因为4 < 6，所以设置low=1，high保持不变。\n- 因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中，此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。\n\n所以在一个数据页中查找指定主键值的记录的过程分为两步：\n- 通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。\n- 通过记录的next_record属性遍历该槽所在的组中的各个记录\n\n# B+树","tags":["Mysql"]},{"title":"redis-读写一致性","url":"/2024/04/03/redis-读写一致性/","content":"# Mysql如何与Redis保持同步\n\n![](../img/Redis/img_24.png)\n\n类比计算机组成原理中的cache和内存，redis也就是mysql的缓存，那么保持读写一致性也是十分重要的，我们在修改数据库的同时，缓存中也要对应更新。\n- 读操作：缓存命中就直接返回，缓存未命中就查找数据库，然后更新缓存\n- 写操作：**延迟双删**\n![](../img/Redis/img_25.png)\n\n## 先删除缓存，再更新数据库\n1. **正常情况**\n\n![](../img/Redis/img_26.png)\n\n首先线程1删除缓存，然后更新数据库，此时没有任何线程来打扰，完成操作以后线程2再来查找缓存，这个时候由于线程1已经删除了缓存，那就会查找数据库找到刚刚更新的数据，最后写入缓存。这个过程不会出现读写一致性问题\n\n2. **特殊情况**\n> 其实下面先写后删除的特殊情况也适用于本例中，首先线程1查询到了一个过期key，去数据库找，暂时保存，但是没写进redis。此时另一个进程是写进程，先删除了这个key，随后更新，最后才轮到线程1，写回刚刚的旧数据到redis，同样会有数据不一致\n\n![](../img/Redis/img_27.png)\n\n我们假设线程1删除缓存之后，由于线程是并发的，线程2来查询，此时由于还没有更新数据库，找到的还是原来的数据，随后放回缓存，这个时候才轮到线程1，更新数据库，但是此时redis还是用的以前的数据，数据库的是刚刚更新的，就出现了读写一致性问题\n## 先更新数据库，再更新缓存\n> 那如果我们先更新数据库，在更新缓存是不是正确的呢？**答案是还是会有读写一致性问题**\n\n1. **正常情况**\n\n ![](../img/Redis/img_28.png)\n线程2先更新数据库，然后删除，跟上面的一样，只要两个操作是原子性的就不会有问题，但是只要是线程是并发的，那就肯定不一致\n\n2. **特殊情况**\n\n![](../img/Redis/img_29.png)\n\n>如果在不在这个刚刚过期的时间节点，那会怎么样呢？其实如果不是刚刚要过期，那就直接会拿走缓存中的数据，也不会删除缓存，那写进程后续先改再写redis也不会出现读写一致性问题，个人觉得核心的问题在于读进程的机制，没查到或者过期的缓存就会主动去数据库里调用，会扰乱正常的写进程导致不一致\n> \n> 如果是命中的读进程，那就根本不会扰乱写进程，只是脏数据的问题，redis和mysql最终都是一致的。而这里讨论的刚好过期，才会导致读进程写redis，才会有不一致性的问题发生）\n\n线程1先去查询缓存，这个时候刚好key过期，就要去数据库找，在数据库找到的是旧数据，先保存下来，但是此时线程2更新了数据库，然后删除，最后才是线程1写回旧数据到redis，出现不一致。\n\n## 解决方法\n- **分布式锁**：在更新缓存前先加个分布式锁，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。\n- **延迟双删**：针对「先删除缓存，再更新数据库」方案在「读 + 写」并发请求而造成缓存不一致的解决办法是「延迟双删」。\n- - 为什么要双删？因为刚刚在[先删除缓存，再更新数据库]方案中会出现读写一致问题，这个时候只要再去删除一次缓存就可以了，下一个来的读请求会发现不存在对应的key，然后从数据库找，最终达到一致性 \n- - 为什么要延迟？主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。\n所以，请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。因为这个延时时间不好控制，在极端情况下还是会出现读写不一致的现象。\n- **使用「先更新数据库，再删除缓存」方案**：其实这种方案的特殊情况很难遇见，因为**缓存的写入通常要远远快于数据库的写入**，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。\n而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。**（意思是即使B先写了数据库，A再写旧的值，因为数据库涉及io（扯远点就是io中断）阻塞进程B直到时间片到了，进程会交替执行而io搁一边，可能当执行到A写完了旧值，更新才刚刚结束，这个时候B再执行删除，就可以保证一致性）**\n\n## 在不那么要求强一致性的场景\n有的时候可以容忍一瞬间的脏数据，但是要保持最终一致性的场景，可以使用以下两种方法：\n- 基于消息队列（例如kafka）：写入数据库后，发一个消息给mq通知redis更新缓存，这种方式的可靠性主要取决于mq，肯定是有一定的延时的，但是最终会保证一致\n- 基于阿里巴巴的Canal中间件：「先更新数据库，再删缓存」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。\nCanal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。\n","tags":["Redis"]},{"title":"leetcode-2024-4-2","url":"/2024/04/02/leetcode-2024-4-2/","content":"# 894 所有可能的真二叉树\n给你一个整数 n ，请你找出所有可能含 n 个节点的 真二叉树 ，并以列表形式返回。答案中每棵树的每个节点都必须符合 Node.val == 0 。\n\n答案的每个元素都是一棵真二叉树的根节点。你可以按 任意顺序 返回最终的真二叉树列表。\n\n真二叉树 是一类二叉树，树中每个节点恰好有 0 或 2 个子节点。\n\n![](../img/2024_4_2_1.png)\n> 感觉很像之前写过的一道题\n## 记忆化搜索\n由分析知道，n不能为偶数，叶子节点为（n+1）/2，度为二的节点为(n-1)/2，n=1的时候就只有一个节点，n可以拆分出[x,1,y]三个，x和y都必须是奇数，x和y都比n小而且一定在之前的遍历中已经计算过，只要深拷贝n=x和n=y的数组，作为左边右边，就可以得到最终答案\n\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    //记忆化保存的数组\n    List<List<TreeNode>> list = new ArrayList<>();\n    List<TreeNode> treeNodeList;\n    public List<TreeNode> allPossibleFBT(int n) {\n        //排除偶数\n        if (n%2==0){\n            return new ArrayList<>();\n        }\n        treeNodeList = new ArrayList<>();\n        treeNodeList.add(new TreeNode(0));\n        list.add(treeNodeList);\n        for (int k = 3; k <= n; k+=2) {\n            treeNodeList = new ArrayList<>();\n            for (int i = 1; i < k-1; i+=2) {\n                //System.out.println(i);\n                //由于i是+=2的，对应的list下标是++，所以要/2\n                List<TreeNode> left = new ArrayList<>(list.get(i/2));\n                List<TreeNode> right = new ArrayList<>(list.get((k-1-i)/2));\n                for (int p = 0; p < left.size(); p++) {\n                    for (int q = 0; q < right.size(); q++) {\n                        TreeNode root = new TreeNode(0);\n                        root.left = left.get(p);\n                        root.right = right.get(q);\n                        //先保存到treenodeList里\n                        treeNodeList.add(root);\n                    }\n                }\n            }\n            //System.out.println(treeNodeList.size());\n            //最后加上这个\n            list.add(treeNodeList);\n        }\n        //System.out.println(list.get(n/2).size());\n        //返回记忆化搜索最后一个\n        return list.get(n/2);\n\n    }\n}\n```","tags":["刷题笔记"]},{"title":"redis-高可用篇","url":"/2024/04/02/redis-高可用篇/","content":"# 主从复制\n\n单点Redis的并发能力是由上限的，如果都存储在一台服务器上，出事了就会有很严重的影响。\n- 如果出现了宕机，那么数据恢复需要时间，而且主进程在此期间不能服务新请求，\n- 硬盘出了问题那就会造成数据丢失。\n如何解决这种问题，并且还要进一步提高并发性？可以搭建**主从模式**，实现读写分离。\n\n> **读写分离**:\n> 主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。\n> ![](../img/Redis/img_12.png)\n> \n> 也就是说，所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。\n\n## 第一次同步\n多台服务器之间要通过什么方式来确定谁是主服务器，或者谁是从服务器呢？\n\n我们可以使用 replicaof（Redis 5.0 之前使用 slaveof）命令形成主服务器和从服务器的关系。\n\n比如，现在有服务器 A 和 服务器 B，我们在服务器 B 上执行下面这条命令：\n\n```text\n# 服务器 B 执行这条命令\nreplicaof <服务器 A 的 IP 地址> <服务器 A 的 Redis 端口号>\n```\n\n接着，服务器 B 就会变成服务器 A 的「从服务器」，然后与主服务器进行第一次同步。\n\n主从服务器间的第一次同步的过程可分为三个阶段：\n\n- 第一阶段是建立链接、协商同步；\n- 第二阶段是主服务器同步数据给从服务器；\n- 第三阶段是主服务器发送新写操作命令给从服务器。\n\n![](../img/Redis/img_13.png)\n\n> 1. 一个从服务器要加入主服务器的从节点，首先执行上面这条replicaof，告诉主服务器我是新加入的\n> 2. 然后建立连接。这里有两个关键参数**replication id**，标识一个数据集，每一个master都会有一个这个id，相当于标记了一块空间，当slave加入时，并不知道master的这个id，就给“？”，还有一个参数**offset**也就是偏移量，表示复制的进度，初始化为-1，（***有点类似TCP的序号和确认号***）。\n> 执行psync命令，告诉主服务器一个从节点要建立连接了\n> 3. 主服务器判断来的这个replication id是否是自己的，如果不是自己的说明是第一次加入的从服务器，返回前面的这两个值，自己的id和当前的复制进度。\n> 4. 从服务器收到响应之后会记录这两个值，准备进行**全量复制**\n> 5. 此时主服务器fork一个子进程完成bgsave命令，生成**RDB**文件，然后传输给从服务器。此时不会阻塞主进程，还是能接收新的数据，那么就需要一个数据结构来存这些刚刚加入，但是没有写入RDB文件的数据，这里就有一个**replication buffer**缓冲区用来存这些数据\n> 6. 从服务器收到了bump.rdb文件，然后进行载入，在此之前清空当前数据\n> 7. 对于主服务器在**复制传输和子服务器重建**过程中新到的数据，缓冲区内的数据发送新的写命令给从服务器。\n\n**第一阶段：建立链接、协商同步**\n\n执行了 replicaof 命令后，从服务器就会给主服务器发送 psync 命令，表示要进行数据同步。\n\npsync 命令包含两个参数，分别是主服务器的 runID 和复制进度 offset。\n\nrunID，每个 Redis 服务器在启动时都会自动生产一个随机的 ID 来唯一标识自己。当从服务器和主服务器第一次同步时，因为不知道主服务器的 run ID，所以将其设置为 \"?\"。\noffset，表示复制的进度，第一次同步时，其值为 -1。\n主服务器收到 psync 命令后，会用 FULLRESYNC 作为响应命令返回给对方。\n\n并且这个响应命令会带上两个参数：主服务器的 runID 和主服务器目前的复制进度 offset。从服务器收到响应后，会记录这两个值。\n\nFULLRESYNC 响应命令的意图是采用全量复制的方式，也就是主服务器会把所有的数据都同步给从服务器。\n\n所以，第一阶段的工作时为了全量复制做准备。\n\n那具体怎么全量同步呀呢？我们可以往下看第二阶段。\n\n**第二阶段：主服务器同步数据给从服务器**\n\n接着，主服务器会执行 bgsave 命令来生成 RDB 文件，然后把文件发送给从服务器。\n\n从服务器收到 RDB 文件后，会先清空当前的数据，然后载入 RDB 文件。\n\n这里有一点要注意，主服务器生成 RDB 这个过程是不会阻塞主线程的，因为 bgsave 命令是产生了一个子进程来做生成 RDB 文件的工作，是异步工作的，这样 Redis 依然可以正常处理命令。\n\n但是，这期间的写操作命令并没有记录到刚刚生成的 RDB 文件中，这时主从服务器间的数据就不一致了。\n\n那么为了保证主从服务器的数据一致性，主服务器在下面这三个时间间隙中将收到的写操作命令，写入到 replication buffer 缓冲区里：\n\n- 主服务器生成 RDB 文件期间；\n- 主服务器发送 RDB 文件给从服务器期间；\n- 「从服务器」加载 RDB 文件期间；\n\n**第三阶段：主服务器发送新写操作命令给从服务器**\n\n在主服务器生成的 RDB 文件发送完，从服务器收到 RDB 文件后，丢弃所有旧数据，将 RDB 数据载入到内存。完成 RDB 的载入后，会回复一个确认消息给主服务器。\n\n接着，主服务器将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，从服务器执行来自主服务器 replication buffer 缓冲区里发来的命令，这时主从服务器的数据就一致了。\n\n至此，主从服务器的第一次同步的工作就完成了。\n\n## 命令传播\n主从服务器在完成第一次同步以后就会维护一个Tcp连接。\n\n![](../img/Redis/img_14.png)\n\n后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。\n\n而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。\n\n上面的这个过程被称为基于长连接的命令传播，通过这种方式来保证第一次同步后的主从服务器的数据一致性。\n\n## 增量复制\n> 主从服务器在第一次同步之后，就会建立一个tcp长连接完成命令传输。但是此时网络产生延迟或者断开。那么就不能进行命令传播了（这里的断开网络指的是主从服务器之间的同步被打断），那么客户端还是可以从从服务器读到旧的数据产生不一致性。\n\n![](../img/Redis/img_15.png)\n\n如果此时网络又恢复正常了，从服务器已经落后主服务器，要进行再次同步，这个时候用**全局复制**造成的开销会很大，可以采用**增量复制**的方法进行同步，只会把网络断开期间主服务器收到的写操作同步给从服务器，利用的就是offset之间的差值。\n![](../img/Redis/img_16.png)\n>1. 恢复连接后从服务器给主服务器发送id和offset\n>2. 主服务器知道id是自己的，但是offest落后的有点多，这个时候就会计算自己的offset和从服务器给的offset之间差了多少，然后发送CONTINUE命令，告诉从服务器要发送增量数据。\n>3. 从服务器重新执行这些命令\n\n**offset具体怎么计算？**\n- repl_backlog_buffer，是一个「环形」缓冲区，用于主从服务器断连后，从中找到差异的数据；\n- replication offset，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 master_repl_offset 来记录自己「写」到的位置，从服务器使用 slave_repl_offset 来记录自己「读」到的位置。\n\n**那 repl_backlog_buffer 缓冲区是什么时候写入的呢？**\n\n在主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会将写命令写入到 repl_backlog_buffer 缓冲区里，因此 这个缓冲区里会保存着最近传播的写命令。\n\n网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：\n\n- 如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用增量同步的方式；\n- 相反，如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用全量同步的方式。（这是由于缓冲区是环形的，时间过长就会导致原来的数据被覆盖）\n\n**环形缓冲区repl_backlog_buffer**\n\n当主服务器在 repl_backlog_buffer 中找到主从服务器差异（增量）的数据后，就会将增量的数据写入到 replication buffer 缓冲区，这个缓冲区我们前面也提到过，它是缓存将要传播给从服务器的命令。\n\nrepl_backlog_buffer 缓行缓冲区的默认大小是 1M，并且由于它是一个环形缓冲区，所以当缓冲区写满后，主服务器继续写入的话，就会覆盖之前的数据。因此，当主服务器的写入速度远超于从服务器的读取速度，缓冲区的数据一下就会被覆盖。\n\n那么在网络恢复时，如果从服务器想读的数据已经被覆盖了，主服务器就会采用全量同步，这个方式比增量同步的性能损耗要大很多。\n\n因此，为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，我们应该调整下 repl_backlog_buffer 缓冲区大小，尽可能的大一些，减少出现从服务器要读取的数据被覆盖的概率，从而使得主服务器采用增量同步的方式。\n\n**repl_backlog_buffer 缓冲区具体要调整到多大呢？**\n\n$$\nsecond * write_size_per_second\n$$\n \n- second为从服务器掉线以后重新连上主服务器所需的平均时间（以秒计算）\n- write_size_per_second为主服务器平均每秒产生的写命令数据量大小\n\n> 环形缓冲区的大小不能低于平均掉线时间*主服务器平均每秒产生的数据量，要不然会频繁bgsave影响主进程，开销大\n> \n> 举个例子，如果主服务器平均每秒产生 1 MB 的写命令，而从服务器断线之后平均要 5 秒才能重新连接主服务器。\n>\n> 那么 repl_backlog_buffer 大小就不能低于 5 MB，否则新写地命令就会覆盖旧数据了。\n>\n> 当然，为了应对一些突发的情况，可以将 repl_backlog_buffer 的大小设置为此基础上的 2 倍，也就是 10 MB。\n> \n> 关于 repl_backlog_buffer 大小修改的方法，只需要修改配置文件里下面这个参数项的值就可以。 repl-backlog-size 1mb\n\n\n# 哨兵机制\n\n在 Redis 的主从架构中，由于主从模式是读写分离的，如果主节点（master）挂了，那么将没有主节点来服务客户端的写操作请求，也没有主节点给从节点（slave）进行数据同步了。\n![](../img/Redis/img_17.png)\n这时如果要恢复服务的话，需要人工介入，选择一个「从节点」切换为「主节点」，然后让其他从节点指向新的主节点，同时还需要通知上游那些连接 Redis 主节点的客户端，将其配置中的主节点 IP 地址更新为「新主节点」的 IP 地址。\n\n这样也不太“智能”了，要是有一个节点能监控「主节点」的状态，当发现主节点挂了，它自动将一个「从节点」切换为「主节点」的话，那么可以节省我们很多事情啊！\n\nRedis 在 2.8 版本以后提供的**哨兵（Sentinel）机制**，它的作用是实现**主从节点故障转移**。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端\n\n\n## 哨兵的功能\n- 监控：Sentinel会定期检查master和slave是否按照预期工作（通过心跳机制）\n- 自动故障恢复：如果master故障，就选举出一个slave作为新的master，然后进行主节点故障迁移\n- 通知：当发生故障转移时，会将最新信息发送给Redis客户端 ![](../img/Redis/img_18.png)\n\n## 服务状态监控\n\n> Sentinel基于心跳机制ping-pong，每隔1秒向每个集群内的实例发送ping。\n> - 主观下线：如果某sentinel节点发现实例没有在规定时间内响应，那就标记成**主观下线**，这个规定的时间是配置项down-after-milliseconds 参数设定的，单位是毫秒。\n> - 客观下线：有的时候主节点其实并没有发生故障，只是因为网络拥塞，导致没有在规定时间响应Ping。为了减少误判的情况，哨兵不会之配置成一个节点（至少有三台机器来部署哨兵集群）如果超过指定数量（quorum）的哨兵认为该实例主观下线，那么该节点就是**客观下线**，那就被认为是故障。\n\n哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。\n\n如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「主观下线」。这个「规定的时间」是配置项 down-after-milliseconds 参数设定的，单位是毫秒。\n\n之所以针对「主节点」设计「主观下线」和「客观下线」两个状态，是因为有可能「主节点」其实并没有故障，可能只是因为主节点的系统压力比较大或者网络发送了拥塞，导致主节点没有在规定时间内响应哨兵的 PING 命令。\n\n所以，为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成哨兵集群（最少需要三台机器来部署哨兵集群），通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。\n\n具体是怎么判定主节点为「客观下线」的呢？\n\n当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。\n\n![](../img/Redis/img_19.png)\n\n当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。\n\n例如，现在有 3 个哨兵，quorum 配置的是 2，那么一个哨兵需要 2 张赞成票，就可以标记主节点为“客观下线”了。这 2 张赞成票包括哨兵自己的一张赞成票和另外两个哨兵的赞成票（**包括自己的一票**）。\n\nPS：quorum 的值一般设置为哨兵个数的二分之一加 1，例如 3 个哨兵就设置 2。\n\n哨兵判断完主节点客观下线后，哨兵就要开始在多个「从节点」中，选出一个从节点来做新主节点\n\n## 由哪个哨兵进行主从故障转移？\n> 假设刚刚在哨兵的内部已经将主节点标记成了**客观下线**，那么哨兵集群哪个节点来对其进行故障转移呢？\n> \n> 这个时候需要选举一个哨兵集群的leader来进行故障转移，但是在投票之前肯定需要一个**候选者**，这个候选者一般是首先发现主节点的哨兵。\n> \n> 那么怎么样成为leader呢，哨兵集群需要进行投票，每个哨兵只有一次投票机会，只有候选者能够投给自己（一般也只有一个候选者，除非出现同一时间点有两个哨兵发现了主节点故障发起主观下线）\n> \n> 在投票过程中，只要候选者达到以下条件就可以变成leader：\n> - 第一，拿到半数以上的赞成票\n> - 第二，票数还要同时大于等于quorum 值\n\n**如果某个时间点，刚好有两个哨兵节点判断到主节点为客观下线，那这时不就有两个候选者了？这时该如何决定谁是 Leader 呢？**\n\n每位候选者都会先给自己投一票，然后向其他哨兵发起投票请求。如果投票者先收到「候选者 A」的投票请求，就会先投票给它，如果投票者用完投票机会后，收到「候选者 B」的投票请求后，就会拒绝投票。这时，候选者 A 先满足了上面的那两个条件，所以「候选者 A」就会被选举为 Leader。\n\n**Redis 1 主 4 从，5 个哨兵，quorum 设置为 3，如果 2 个哨兵故障，当主节点宕机时，哨兵能否判断主节点“客观下线”？主从能否自动切换？**\n\n- 哨兵集群可以判定主节点“客观下线”。哨兵集群还剩下 3 个哨兵，当一个哨兵判断主节点“主观下线”后，询问另外 2 个哨兵后，有可能能拿到 3 张赞同票，这时就达到了 quorum 的值，因此，哨兵集群可以判定主节点为“客观下线”。\n\n- 哨兵集群可以完成主从切换。当有个哨兵标记主节点为「客观下线」后，就会进行选举 Leader 的过程，因为此时哨兵集群还剩下 3 个哨兵，那么还是可以拿到半数以上（5/2+1=3）的票，而且也达到了 quorum 值，满足了选举 Leader 的两个条件，所以就能选举成功，因此哨兵集群可以完成主从切换。\n\n如果 quorum 设置为 2，并且如果有 3 个哨兵故障的话。此时哨兵集群还是可以判定主节点为“客观下线”，但是哨兵不能完成主从切换了，大家可以自己推演下。\n\n如果 quorum 设置为 3，并且如果有 3 个哨兵故障的话，哨兵集群即不能判定主节点为“客观下线”，也不能完成主从切换了。\n\n可以看到，quorum 为 2 的时候，并且如果有 3 个哨兵故障的话，虽然可以判定主节点为“客观下线”，但是不能完成主从切换，这样感觉「判定主节点为客观下线」这件事情白做了一样，既然这样，还不如不要做，quorum 为 3 的时候，就可以避免这种无用功。\n\n**所以，quorum 的值建议设置为哨兵个数的二分之一加 1，例如 3 个哨兵就设置 2，5 个哨兵设置为 3，而且哨兵节点的数量应该是奇数。**\n\n## 主从故障转移的过程\n\n> 主从故障转移操作包含以下四个步骤： \n> - 第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。\n> - 第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；\n> - 第三步：将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端； \n> - 第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点\n\n### 步骤一：选出新节点\n\n故障转移操作第一步要做的就是在已下线主节点属下的所有「从节点」中，挑选出一个状态良好、数据完整的从节点，然后向这个「从节点」发送 SLAVEOF no one 命令，将这个「从节点」转换为「主节点」。\n\n那么多「从节点」，到底选择哪个从节点作为新主节点的？\n\n随机的方式好吗？随机的方式，实现起来很简单，但是如果选到一个网络状态不好的从节点作为新主节点，那么可能在将来不久又要做一次主从故障迁移。\n\n所以，我们首先要把网络状态不好的从节点给过滤掉。首先把已经下线的从节点过滤掉，然后把以往网络连接状态不好的从节点也给过滤掉。\n\n怎么判断从节点之前的网络连接状态不好呢？\n\nRedis 有个叫 down-after-milliseconds * 10 配置项，其 down-after-milliseconds 是主从节点断连的最大连接超时时间。如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从节点的网络状况不好，不适合作为新主节点。\n\n至此，我们就把网络状态不好的从节点过滤掉了，接下来要对所有从节点进行三轮考察：**优先级、复制进度、ID 号**。在进行每一轮考察的时候，哪个从节点优先胜出，就选择其作为新主节点。\n\n1. 第一轮考察：哨兵首先会根据从节点的优先级来进行排序，优先级越小排名越靠前， \n2. 第二轮考察：如果优先级相同，则查看复制的下标，哪个从「主节点」接收的复制数据多，哪个就靠前（也就是offset更靠近主节点那个）\n3. 第三轮考察：如果优先级和下标都相同，就选择从节点 ID 较小的那个。\n\n![](../img/Redis/img_20.png)\n\n### 步骤二：将从节点指向主节点\n\n当新主节点出现之后，哨兵 leader 下一步要做的就是，让已下线主节点属下的所有「从节点」指向「新主节点」，这一动作可以通过向「从节点」发送 SLAVEOF 命令来实现。\n\n如下图，哨兵 leader 向所有从节点（server3 和 server4）发送 SLAVEOF ，让它们成为新主节点的从节点。\n\n![](../img/Redis/img_21.png)\n\n![](../img/Redis/img_22.png)\n\n### 步骤三：通知客户的主节点已更换\n\n经过前面一系列的操作后，哨兵集群终于完成主从切换的工作，那么新主节点的信息要如何通知给客户端呢？\n\n这主要通过 Redis 的发布者/订阅者机制来实现的。每个哨兵节点提供发布者/订阅者机制，客户端可以从哨兵订阅消息。\n\n> 类似kafka那种订阅机制，也可以想象成计网的那种广播信道，每个哨兵进行广播，客户端接受相应表头的时间，完成通知\n\n哨兵提供的消息订阅频道有很多，不同频道包含了主从节点切换过程中的不同关键事件，几个常见的事件如下：\n![](../img/Redis/img_23.png)\n\n客户端和哨兵建立连接后，客户端会订阅哨兵提供的频道。主从切换完成后，哨兵就会向 +switch-master 频道发布新主节点的 IP 地址和端口的消息，这个时候客户端就可以收到这条信息，然后用这里面的新主节点的 IP 地址和端口进行通信了。\n\n通过发布者/订阅者机制机制，有了这些事件通知，客户端不仅可以在主从切换后得到新主节点的连接信息，还可以监控到主从节点切换过程中发生的各个重要事件。这样，客户端就可以知道主从切换进行到哪一步了，有助于了解切换进度。\n\n### 步骤四：将旧主节点变为从节点\n\n故障转移操作最后要做的是，继续监视旧主节点，当旧主节点重新上线时，哨兵集群就会向它发送 SLAVEOF 命令，让它成为新主节点的从节点\n\n至此，整个主从节点的故障转移的工作结束","tags":["Redis"]},{"title":"redis-持久化篇","url":"/2024/04/01/redis-持久化篇/","content":"# Redis持久化\nRedis 是**内存数据库**，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了**持久化功能 **!\n## RDB\nRDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是定期把内存所有数据都记录到磁盘中。\n\n一旦Redis实例出现故障重启，就会从磁盘中读取快照文件，恢复数据\n\n> 什么是快照？可以理解成定期给当前的内存中的redis数据拍一张照，然后保存下来。\n\n### RDB触发机制\n  可以分为手动触发和自动触发，手动的save占用主进程，bgsave是fork一个新进程来完成快照保存，在此期间主进程通过copyonwrite的机制（类似copyonwrite的Arraylist那样），拷贝一份当前数据，在拷贝的地方进行修改，等到子进程完成磁盘写之后再进行覆盖。\n\n  自动触发写在redis.conf上，save X Y，表示在X秒内如果有Y个key修改，那么就save（注意这里触发的还是bgsave）\n![](../img/Redis/img_7.png)\n- 手动触发\n![](../img/Redis/img_6.png)\n用bgsave可以防止主进程被阻塞，提高效率\n\nfork采用的是copy-on-write\n- 当主进程执行读操作的时候可以访问共享内存\n- 当主进程执行写操作的时候，则会拷贝一份数据\n\n![](../img/Redis/img_9.png)\n> 子进程和主线程怎么共享内存，也就是怎么让子进程知道redis的内存是那些块？通过拷贝主进程的页表（没错就是计组那个页表），这样就知道主进程占用的虚拟地址和物理地址的映射关系，从而找到这些块。\n> \n> copyonwrite会将此时的共享内存变成**只读**，主进程来读的时候就可以直接读，写的时候拷贝一份。\n- 自动触发\n![](../img/Redis/img_8.png)\n> 注意这里save其实也是bgsave，一般都不会影响主进程\n\n### 优缺点\n**优点**：\n- 只有一个dump.rdb，方便持久化，是一个紧凑的二进制文件，恢复的时候速度也比AOF更快，在数据量大的时候更明显。\n- 实现了性能的最大化，fork子进程来完成而不影响主进程，保证了Redis的高性能。\n\n**缺点**：\n- 可能存在数据丢失，在两次RDB的时间里，如果出现宕机，这段时间没有写入的数据都将丢失\n- 没有办法做到秒级持久化/实时持久化\n- 对于cpu和内存的开销比较大，毕竟要fork一个新进程占用cpu，还要进行COW占用内存而，AOF主要占用的是IO资源\n\n**使用场景**：\n- 可以容忍数分钟数据丢失，追求更快的启动速度和恢复速度。\n\n## AOF\nAOF（append only file） 持久化，采用日志的形式来记录每个写操作，追加到AOF文件的末尾。\n> 意思就是把操作的每一条语句都记录下来，那肯定占用的空间大\n\nRedis默认情况是不开启AOF的。重启时再重新执行AOF文件中的命令来恢复数据。它主要解决数据持久化的实时性问题。\n\n![](../img/Redis/img_10.png)\n\nAOF是**执行完命令后才记录日志**的。为什么不先记录日志再执行命令呢？这是因为Redis在向AOF记录日志时，不会先对这些命令进行语法检查，如果先记录日志再执行命令，日志中可能记录了错误的命令，Redis使用日志回复数据时，可能会出错。\n\n正是因为执行完命令后才记录日志，所以不会阻塞当前的写操作。但是会存在两个风险：\n\n- 更执行完命令还没记录日志时，宕机了会导致数据丢失\n- AOF不会阻塞当前命令，但是可能会阻塞下一个操作。\n\n> 这两个风险最好的解决方案是折中妙用AOF机制的三种写回策略 appendfsync：\n>- always，同步写回，每个子命令执行完，都立即将日志写回磁盘。\n>- everysec，每个命令执行完，只是先把日志写到AOF内存缓冲区，每隔一秒同步到磁盘。\n>- no：只是先把日志写到AOF内存缓冲区，有操作系统去决定何时写入磁盘。\n\n![](../img/Redis/img_11.png)\n\nalways同步写回，可以基本保证数据不丢失，no策略则性能高但是数据可能会丢失，一般可以考虑折中选择everysec。\n\n如果接受的命令越来越多，AOF文件也会越来越大，文件过大还是会带来性能问题。日志文件过大怎么办呢？\n> **AOF重写机制**就是随着时间推移，AOF文件会有一些冗余的命令如：无效命令、过期数据的命令等等，AOF重写机制就是把它们合并为一个命令（类似批处理命令），从而达到精简压缩空间的目的。\n> \n> AOF重写会阻塞嘛？AOF日志是由主线程会写的，而重写则不一样，重写过程是由后台子进程bgrewriteaof完成。\n\n\n### 优缺点\n**优点**：\n- 实时持久化，数据安全，AOF持久化配置为always就可以基本上避免丢失，但是开销比较大，通常用容忍1s内丢失的everysec\n- 通过append模式写文件，那么即使中途服务器宕机，也可以尽量解决一致性问题（取决于刷盘策略）\n- 重写机制，在文件太大的时候可以压缩空间\n\n**缺点**：\n- 文件比RDB大，恢复时间也会慢很多\n- 启动效率低\n- 文件体积迅速变大，需要定期执行重写机制降低文件体积。\n\n\n**使用场景**：\n- 对数据安全性有较高需求的场景\n\n> Redis4.0开始支持RDB和AOF的混合持久化，就是内存快照以一定频率执行，两次快照之间，再使用AOF记录这期间的所有命令操作。\n\n","tags":["Redis"]},{"title":"redis-缓存三兄弟","url":"/2024/03/31/redis-缓存三兄弟/","content":"# 缓存穿透\n> 这里的redis可以全部想象成cache，数据库可以想象成cpu，穿透有点绕过redis的意思\n\n![](../img/Redis/img.png)\n假设有一个请求api/news/getById/1，但是这个id为1的键并**不存在**于数据库，所以也不会存在于缓存，那么如果有很多这种请求，那么都会绕过redis去查询数据库，造成数据库的负载。\n\n## 解决方法\n1. 缓存空数据，就算是数据库找不到也要缓存一个空数据给redis，要不然就会一直会去绕过redis去找数据库。比如给的key=1但是mysql没有相应数据，那么在redis上缓存一个key=1，value=null的键值对。\n- **优点**：非常简单，维护方便\n- **缺点**：会造成额外的内存消耗，因为redis是存在内存中的，有多少个没有的键就会有多少个空，浪费内存。还可能造成**短期不一致**问题，如果在redis里面存了这个空但是这个时候数据库更新了这个键值对，那么在这一段时间访问redis的还是null，就会造成不一致的问题\n2. 布隆过滤器\n在客户端与Redis之间加了一个布隆过滤器，对于请求进行过滤。\n\n![](../img/Redis/img_1.png)\n\n> **布隆过滤器**\n> - bitmap（位图）:bit位的数组，数组的元素是0或者1，所以布隆过滤器占用的内存小\n> - ![](../img/Redis/img_2.png)\n> - 作用：可以用来检索元素，相当于一种校验电路\n> - 实现原理：类似hashmap，假设来了一个键，用三种不同的hash算法得到位图的三个位置，然后这些位置都置为1，这里要跟redis缓存的保持一致，在初始化的时候就要预热进布隆过滤器。那么就会有很多重复的，数组越大这种情况会越少。那么此时有一个**确实不存在的元素**，但是计算出来的三个哈希值就是都是1，那么还是会发生缓存穿透的现象\n> - 判断不存在的时候一定不存在，也就是说3个地方一定都不为1\n> - 判断存在的时候不一定存在，因为有可能会有误判\n> - **优点**：内存占用小，没有多余key\n> - **缺点**：实现比较复杂，存在误判，大概在5%左右，但是对于数据库也是可以接受的\n\n布隆过滤器的大致的原理：布隆过滤器中存放二进制位。数据库的数据通过hash算法计算其hash值并存放到布隆过滤器中，之后判断数据是否存在的时候，就是判断该hash值是0还是1。\n\n但是这个玩意是一种概率上的统计，当其判断不存在的时候就一定是不存在；当其判断存在的时候就不一定存在。所以有一定的穿透风险！！！\n\n# 缓存击穿\n缓存击穿，指的是一个key在不断地支撑高并发，高并发持续对这个点进行访问，当这个点在失效的瞬间，50ms左右，大量的高并发就冲坡缓存请求数据库，造成数据库瘫痪。\n\n对于一般的网站而言很难有缓存击穿的级别，一般是热门网站或者秒杀瞬时高并发。\n## 解决方法\n1. 互斥锁\n\n![](../img/Redis/img_3.png)\n\n类似pv操作，给临界区上互斥锁，一段时间只要一个线程在重建数据就行，但是这样会造成其他线程等待。通常是需要强一致性的应用需要这种策略。\n- **优点**：强一致性，在redis没有更新完之前都不许访问，只能要最新的，一般涉及钱的都会有这种逻辑\n- **缺点**：性能差\n\n2. 逻辑过期\n\n![](../img/Redis/img_4.png)\n\n逻辑过期就是在一个键值对的最后加上逻辑时间，并不真实设置过期时间。也就是说，不会真正的过期只会逻辑上的过期。\n\n当一个线程去访问一个逻辑时间到了的键值对，那么其实redis也还有这部分，他还是**那这部分旧的数据**，但是会开启一个新的线程来完成数据库到mysql的更新\n- **优点**：可用性强，性能强在不注重强一致性的场景，不会有其他线程等待的情况，但是拿的都是旧数据\n- **缺点**：一致性弱\n\n\n# 缓存雪崩\n\n如果缓存集中在一段时间内过期，那么会有大量的缓存穿透，所有的查询都落在数据库上，造成缓存雪崩\n\n> 缓存雪崩和缓存击穿的区别：缓存击穿是针对某一个key，缓存雪崩是针对很多key集中过期，\n\n![](../img/Redis/img_5.png)\n\n## 解决方法：\n1. 给不同的key的TTL添加随机值\n2. 多个redis集群提高服务的可用性","tags":["Redis"]},{"title":"周赛2024-3-31","url":"/2024/03/31/周赛2024-3-31/","content":"> 因为第三题long被卡了三发wa，所以即使做出了第三题也没上次排名高\n\n# 第一题：哈沙德数\n\n如果一个整数能够被其各个数位上的数字之和整除，则称之为 **哈沙德数**（Harshad number）。给你一个整数 x 。如果 x 是 **哈沙德数** ，则返回 x 各个数位上的数字之和，否则，返回 -1 。\n\n> 字符串拆分成数组，然后累计和，最后做个判断\n```java\nclass Solution {\n    public int sumOfTheDigitsOfHarshadNumber(int x) {\n        String num = \"\"+x;\n        String[] split = num.split(\"\");\n        int ans = 0;\n        //System.out.println(Arrays.toString(split));\n        for (int i = 0; i < split.length; i++) {\n            ans+=Integer.parseInt(split[i]);\n        }\n        if (x % ans ==0){\n            return ans;\n        }\n        else {\n            return -1;\n        }\n    }\n}\n```\n# 第二题：换水问题\n给你两个整数 numBottles 和 numExchange 。\n\nnumBottles 代表你最初拥有的满水瓶数量。在一次操作中，你可以执行以下操作之一：\n\n- 喝掉任意数量的满水瓶，使它们变成空水瓶。\n- 用 numExchange 个空水瓶交换一个满水瓶。然后，将 numExchange 的值增加 1 。\n注意，你不能使用相同的 numExchange 值交换多批空水瓶。例如，如果 numBottles == 3 并且 numExchange == 1 ，则不能用 3 个空水瓶交换成 3 个满水瓶。\n\n返回你 **最多** 可以喝到多少瓶水。\n\n![](../img/2024_3_31_2.png)\n> 小学奥数貌似碰到过这样的问题，就是没兑换一次，兑换的要求就多一瓶，直接暴力模拟就行\n```java\nclass Solution {\n    public int maxBottlesDrunk(int numBottles, int numExchange) {\n        int empty = numBottles;\n        int ans = numBottles;\n        //直到换不了了\n        while (empty >= numExchange){\n            //兑换新的之后剩下的\n            empty -=numExchange;\n            numExchange++;\n            //兑换多的\n            empty +=1;\n            ans++;\n        }\n        return ans;\n    }\n}\n```\n# 第三题：交替子数组计数\n给你一个**二进制数组**nums 。\n\n如果一个子数组中 **不存在** 两个 **相邻** 元素的值 **相同** 的情况，我们称这样的子数组为 **交替子数组** 。\n\n返回数组 nums 中交替子数组的数量。\n\n示例 1：\n\n输入： nums = [0,1,1,1]\n\n输出： 5\n\n解释： 以下子数组是交替子数组：[0] 、[1] 、[1] 、[1] 以及 [0,1] 。\n> 这里有个用例真的好恶心，wa三次都是这一个用例没过，需要全开long或者long long才能过\n## 记忆化搜索超出内存限制\n> 最早的思路是用一个二维数组存dp[i][j]是否是一个交替子数组，为1表示i到j是一个交替子数组，判断条件$$ dp[i][j-1] == 1 && nums[j] != nums[j-1] $$\n> \n> 其实完全不用这么大的空间，二维数组超空间也是应该的\n```java\nclass Solution {\n    public long countAlternatingSubarrays(int[] nums) {\n        //记忆化搜索\n        int[][] dp = new int[nums.length][nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i; j < nums.length; j++) {\n                //对角线肯定是交替子数组\n                if (i==j){\n                    dp[i][j] = 1;\n                }\n                else {\n                    //只有前面是一个交替子数组并且不等于最后的那个元素\n                    if (dp[i][j-1] == 1 && nums[j] != nums[j-1]){\n                        dp[i][j] = 1;\n                    }\n                    else {\n                        dp[i][j] = 0;\n                    }\n                }\n            }\n        }\n        //最后再遍历一次数组，每一个1就是一个交替子数组\n        long ans = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i; j < nums.length; j++) {\n                if (dp[i][j] == 1){\n                    ans+=1;\n                }\n            }\n        }\n        return ans;\n\n    }\n}\n```\n\n## 双指针(AC)\n> 思路是，如果一个数组是交替数组，那么子数组肯定也是，利用双指针找到尽量最长的交替子数组存起来，最后遍历这些最长的交替子数组。由于他们的子数组肯定也是交替的，那就是等差数列求和就可以算出。最后累加得到答案\n```java\nclass Solution {\n    public long countAlternatingSubarrays(int[] nums) {\n        //恶心的long\n        List<long[]> list = new ArrayList<>();\n        long head = 0;\n        long rear = 0;\n        //双指针找到长的数组，存起来他们的下标\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] == nums[i-1]){\n                list.add(new long[]{head,rear});\n                head = i;\n            }\n            rear++;\n        }\n        //最后一个没加上就退出循环了，需要最后加上\n        list.add(new long[]{head,rear});\n        long ans = 0;\n        for (int i = 0; i < list.size(); i++) {\n            long length = list.get(i)[1]-list.get(i)[0]+1;\n            //子数组的数量\n            ans += length *(length+1)/2;\n        }\n        return ans;\n    }\n}\n```\n时间复杂度:o(n)\n空间复杂度：o(n)","tags":["刷题笔记"]},{"title":"leetcode-2024-3-31","url":"/2024/03/31/leetcode-2024-3-31/","content":"# 331 验证二叉树的前序序列化（Medium）\n\n序列化二叉树的一种方法是使用 **前序遍历** 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。\n![](../img/2024_3_31_1.png)\n\n例如，上面的二叉树可以被序列化为字符串 \"9,3,4,#,#,1,#,#,2,#,6,#,#\"，其中 # 代表一个空节点。\n\n给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。\n\n保证 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。\n\n你可以认为输入格式总是有效的\n\n例如它永远不会包含两个连续的逗号，比如 \"1,,3\" 。\n\n注意：不允许重建树。\n\n## 栈\n> 由于是先序遍历，我们考虑栈。栈的存放一个数组，第一位表示在split中的下标，第二位表示左边是否有节点，第三位表示右边是否有节点\n> \n> 遍历这个数组，然后如果栈非空，当前元素就是栈顶元素的左孩子或者右孩子，更新栈顶数组，每次遍历都要判断栈顶元素是否左右都有，如果有就出栈。\n> 遍历完看栈是否为空，为空说明是二叉树\n\n> 这里有两个细节，\n> - 首先是可能出现多棵树的情况，也就是说以上算法对于两个完整的树拼在一起的字符串结果还是为true，需要一个计数器，如果在循环过程中栈就已经空了，就返回false\n> - 还有就是这里用了trycatch，如果出现异常情况比如栈顶为空了，那肯定是出问题了，直接返回false，也算是一种偷懒吧。\n```java\npublic boolean isValidSerialization(String preorder) {\n    try {\n        int count = 0;\n        String[] split = preorder.split(\",\");\n        if (split.length == 1 && Objects.equals(split[0], \"#\")){\n            return true;\n        }\n        Stack<int[]> stack = new Stack<>();\n        for (int i = 0; i < split.length; i++) {\n            if (!Objects.equals(split[i], \"#\")){\n                if (!stack.isEmpty()){\n                    if (stack.peek()[1] ==0 && stack.peek()[2] == 0){\n                        stack.peek()[1]  = 1;\n                    }\n                    else if (stack.peek()[1] == 1 && stack.peek()[2] == 0){\n                        stack.peek()[2] = 1;\n                    }\n\n                }\n                stack.add(new int[]{i,0,0});\n            }\n            else {\n                if (stack.peek()[1] == 0 && stack.peek()[2] ==0){\n                    stack.peek()[1]  = 1;\n                }\n                else if (stack.peek()[1] == 1 && stack.peek()[2] == 0){\n                    stack.peek()[2] = 1;\n                }\n            }\n            while (!stack.isEmpty() && stack.peek()[1] == 1 && stack.peek()[2] == 1){\n                stack.pop();\n            }\n            if (stack.isEmpty() && i != split.length-1){\n                count++;\n            }\n        }\n        if (count!=0){\n            return false;\n        }\n        return stack.isEmpty();\n    }\n    catch (Exception e){\n        return false;\n    }\n\n}\n```\n时间复杂度：O(n)，其中 n 为字符串的长度。我们每个字符只遍历一次，同时每个字符对应的操作都是常数时间的。\n\n空间复杂度：O(n)。此为栈所需要使用的空间。\n","tags":["刷题笔记"]},{"title":"leetcode-2024-3-30","url":"/2024/03/30/leetcode-2024-3-30/","content":"# 2952 需要添加的硬币的最小数量（Medium）\n> 这道题止中等？\n> \n给你一个下标从 0 开始的整数数组 coins，表示可用的硬币的面值，以及一个整数 target 。\n\n如果存在某个 coins 的子序列总和为 x，那么整数 x 就是一个 **可取得的金额** 。\n\n返回需要添加到数组中的 **任意面值** 硬币的 最小数量 ，使范围 $[1, target]$ 内的每个整数都属于 **可取得的金额** 。\n\n数组的 **子序列** 是通过删除原始数组的一些（**可能不删除**）元素而形成的新的 **非空** 数组，删除过程不会改变剩余元素的相对位置。\n\n\n\n示例 1：\n\n输入：coins = [1,4,10], target = 19\n\n输出：2\n\n解释：需要添加面值为 2 和 8 的硬币各一枚，得到硬币数组 [1,2,4,8,10] 。\n\n可以证明从 1 到 19 的所有整数都可由数组中的硬币组合得到，且需要添加到数组中的硬币数目最小为 2 。\n\n> 自己想没想出来\n## 官方解：贪心算法\n\n为方便描述，把 0也算作可以得到的数。\n\n假设现在得到了区间 $[0,s−1]$ 中的所有整数，如果此时遍历到整数 $x=coins[i]$，那么把 $[0,s−1]$ 中的每个整数都增加 x，我们就得到了区间 $[x,s+x−1]$ 中的所有整数。\n\n把 coins 从小到大排序，遍历 $x=coins[i]$。分类讨论，看是否要添加数字：\n- 如果 x≤s，那么合并 $[0,s−1]$ 和 $[x,s+x−1]$这两个区间，我们可以得到 $[0,s+x−1]$ 中的所有整数。\n- 如果 x>s，或者遍历完了 coins 数组，这意味着我们无法得到 s，那么就一定要把 s 加到数组中（加一个比 s 还小的数字就没法得到更大的数，不够贪），这样就可以得到了 $[s,2s−1]$ 中的所有整数，再与 $[0,s−1]$ 合并，可以得到 $[0,2s−1]$ 中的所有整数。然后再考虑 x 和 2s 的大小关系，继续分类讨论。\n当 s>targets 时，我们就得到了 $[1,target]$ 中的所有整数，退出循环。\n\n```java\nclass Solution {\n    public int minimumAddedCoins(int[] coins, int target) {\n        Arrays.sort(coins);\n        int ans = 0, s = 1, i = 0;\n        while (s <= target) {\n            if (i < coins.length && coins[i] <= s) {\n                s += coins[i++];\n            } else {\n                s *= 2; // 必须添加 s\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n```","tags":["刷题笔记"]},{"title":"leetcode-2024-3-29","url":"/2024/03/29/leetcode-2024-3-29/","content":"> 经过一天的冲业绩终于上了200题，说实话有点追求数量不追求质量了。但是我确实也感觉记性没以前那么好了，菜就多练。\n> \n> ![](../img/2024_3_29_2.png)\n\n# 2908 元素和最小的山形三元组（Eazy）\n\n给你一个下标从 0 开始的整数数组 nums 。\n\n如果下标三元组$ (i, j, k) $满足下述全部条件，则认为它是一个 **山形三元组** ：\n\n- $i < j < k$\n- $nums[i] < nums[j]$ 且 $nums[k] < nums[j]$\n请你找出 nums 中 **元素和最小** 的山形三元组，并返回其 **元素和** 。如果不存在满足条件的三元组，返回 -1 。\n\n\n\n示例 1：\n\n输入：$nums = [8,6,1,5,3]$\n输出：9\n解释：三元组 (2, 3, 4) 是一个元素和等于 9 的山形三元组，因为：\n- 2 < 3 < 4\n- $nums[2] < nums[3]$ 且 $nums[4] < nums[3]$\n\n这个三元组的元素和等于 $nums[2] + nums[3] + nums[4] = 9$ 。可以证明不存在元素和小于 9 的山形三元组。\n\n## 暴力枚举（居然没超时）\n> 没什么好说的直接遍历所有三元组，判断是否是山形\n```java\nclass Solution {\n    public int minimumSum(int[] nums) {\n        int min = Integer.MAX_VALUE;\n        //遍历所有三元组\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i+1; j < nums.length-1; j++) {\n                for (int k = j+1; k < nums.length; k++) {\n                    if (nums[i] < nums[j] && nums[j] >nums[k]){\n                        //找最小值\n                        min = Math.min(min,nums[i]+nums[j]+nums[k]);\n                    }\n                }\n            }\n        }\n        if (min == Integer.MAX_VALUE){\n            min = -1;\n        }\n        return min;\n    }\n}\n```\n时间复杂度：o(n^3)，这么高的复杂度没超时就算了，居然还77%？有点搞笑了\n空间复杂度：o(1)，只用了一个min来保存最大值\n\n# 有效的括号（Easy）\n\n> 今天的主菜是各种栈，先从最简单的说起\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n1. 左括号必须用相同类型的右括号闭合。\n2. 左括号必须以正确的顺序闭合。\n3. 每个右括号都有一个对应的相同类型的左括号。\n\n示例 1：\n\n输入：s = \"()\"\n\n输出：true\n\n示例 2：\n\n输入：s = \"()[]{}\"\n\n输出：true\n\n示例 3：\n\n输入：s = \"(]\"\n\n输出：false\n\n## 简单栈\n> 最基础的括号匹配问题，所有左边括号进栈，如果能和右边括号匹配就出栈，到最后如果还有括号没有匹配上，就返回false，如果为空就是true\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<>();\n        //flag用来表示栈顶不是匹配的，比如“]”，栈顶没有元素，返回false\n        boolean flag = true;\n        for (int i = 0; i < s.length(); i++) {\n            char temp = s.charAt(i);\n            if (temp == '}'){\n                //匹配左边括号，出栈\n                if (!stack.isEmpty()&&stack.peek() == '{'){\n                    stack.pop();\n                }\n                else {\n                    flag = false;\n                }\n            }\n            else if (temp == ')'){\n                //匹配左边括号，出栈\n                if (!stack.isEmpty()&&stack.peek() == '('){\n                    stack.pop();\n                }\n                else {\n                    flag = false;\n                }\n            }\n            else if (temp == ']'){\n                //匹配左边括号，出栈\n                if (!stack.isEmpty()&&stack.peek() == '['){\n                    stack.pop();\n                }\n                else {\n                    flag = false;\n                }\n            }\n            //不是右边括号的话进栈\n            else stack.push(temp);\n        }\n        return flag & stack.isEmpty();\n    }\n}\n```\n时间复杂度:o(n)\n空间复杂度:o(n)，因为维护了一个栈\n\n# 394 字符串解码（Medium）\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: $k[encoded_string]$，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n\n输出：\"aaabcbc\"\n\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n\n输出：\"accaccacc\"\n\n## 简单栈\n> 先进后出，又是用栈的经典问题，维护两个栈，一个放数字，一个放符号，这里考虑到数字也会又多位数字，所以在字符串中需要特意考虑多位数字。\n> 另一个栈用于放字符串，这里刚开始考虑用Char的栈，但是这样就会频繁出栈入栈，所以还不如就用字符串。\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<String> stack = new Stack<>();\n        Stack<Integer> numstack = new Stack<>();\n        //这里i手动改，因为涉及到多位数字的问题，需要拼接字符串\n        for (int i = 0; i < s.length();) {\n            //如果是数字，需要考虑多位数字的情况\n            if (judgeNumOrChar(s.charAt(i))){\n                StringBuilder num = new StringBuilder();\n                //拼接字符串\n                while (judgeNumOrChar(s.charAt(i))){\n                    num.append(s.charAt(i));\n                    i++;\n                }\n                //此时i的位置肯定是[\n                numstack.push(Integer.parseInt(num.toString()));\n            }\n            else {\n                //左括号直接进\n                if (s.charAt(i) != ']'){\n                    stack.push(\"\"+s.charAt(i));\n                }\n                else {\n                    StringBuilder temp = new StringBuilder();\n                    //当前的数字出栈\n                    int count = numstack.pop();\n                    //字符串拼接加在左边，因为先进后出\n                    while (!Objects.equals(stack.peek(), \"[\")){\n                        temp.insert(0, stack.pop());\n                        //System.out.println(stack);\n                    }\n                    //最后一个左括号出栈\n                    stack.pop();\n                    //接下来就是循环count次，字符串入栈，这里其实也可以拼接好了再放一个位置，我怕会有问题就没这么做\n                    for (int j = 0; j < count; j++) {\n                        stack.push(temp.toString());\n                    }\n\n                }\n                i++;\n\n            }\n            //System.out.println(stack);\n            //System.out.println(numstack);\n\n        }\n        StringBuilder ans = new StringBuilder();\n        while (!stack.isEmpty()){\n            ans.insert(0, stack.pop());\n        }\n        return ans.toString();\n    }\n    //判断是否为数字\n    public boolean judgeNumOrChar(Character character){\n        return (character < 'a' || character > 'z') && character != '[' && character != ']';\n    }\n}\n```\n时间复杂度o(n)\n空间复杂度，就是解码出的字符串的长度，这个没办法跟n有关\n\n# 739 每日温度（Medium）\n给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n\n示例 1:\n\n输入: temperatures = [73,74,75,71,69,72,76,73]\n\n输出: [1,1,4,2,1,1,0,0]\n\n## 单调栈\n> 维护一个存储下标的单调递减栈，当要进入的元素比栈顶元素大的时候，弹出栈顶，那么栈顶对应的今日最高温度就是当前这个，数组中放进两者的日期差值，以此循环。直到进入元素比栈顶小\n```java\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        //int[]，0表示当前元素，1表示下标\n        //其实可以完全存下标的，这里浪费空间了\n        Stack<int[]> monoStack = new Stack<>();\n        int[] ans = new int[temperatures.length];\n        for (int i = 0; i < temperatures.length; i++) {\n            //进入元素比栈顶大，直到比栈顶小\n            while (!monoStack.isEmpty() && monoStack.peek()[0] < temperatures[i]){\n                int[] latest = monoStack.pop();\n                //计算当前元素和出栈的差值，放在出栈的那个元素的下标位置\n                ans[latest[1]] = i-latest[1];\n            }\n            monoStack.push(new int[]{temperatures[i],i});\n        }\n        //最后如果留下几个递减的元素，那么表示后续没有更高温度，就全部为0\n        while (!monoStack.isEmpty()){\n            int[] latest = monoStack.pop();\n            ans[latest[1]] = 0;\n        }\n        return ans;\n    }\n}\n```\n时间复杂度o(n)\n空间复杂度o(n)\n> 接下来是两个单调栈难题\n# 84 柱状图中最大的矩形（Hard）\n\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n![](../img/2024_3_29_3.png)\n\n## 单调栈\n\n> 假设当前元素nums[i]，我只要找到在他左边第一个比当前元素小，和右边第一个比当前元素小的，那么他们围成的矩形的高度就是nums[i]，长度就是右边-左边-1（因为实际上不能到比它小的位置），\n> \n> 这样问题就简化了，有了左边右边这些元素，只需要遍历一次，计算（右边-左边-1）*当前元素，找到最大值就是答案。\n> \n> 那么怎么样找到这些第一个比它小的元素呢，用**单调栈**\n> \n> 对于左边来说，维护一个单调递增的栈，那么每一个比栈顶进去大的元素，最左边第一个比它小的元素肯定是栈顶的。如果进入元素比栈顶小，那就一直出栈，直到进入元素比栈顶大，这个时候出栈的元素肯定都是大于当前元素的，\n> 也就是不是最左边比它小的元素，此时栈顶的才比它小，这就算出了最左边比它小的元素位置，但是如果此时栈空了，说明左边的全比自己大，那就返回-1.\n> \n> 右边的同理，只不过栈空对应的是nums.length\n```java\nclass Solution {\n    public int largestRectangleArea(int[] nums) {\n        Stack<Integer> stack = new Stack<>();\n        //保存最左边的比当前元素小的下标\n        int[] left = new int[nums.length];\n        //保存最右边的比当前元素小的下标\n        int[] right = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            //单调栈的下一个肯定是比当前元素小的，也肯定是最左边的\n            while (!stack.isEmpty() && nums[stack.peek()] >= nums[i]){\n                stack.pop();\n            }\n            if (stack.isEmpty()){\n                left[i] = -1;\n            }\n            else {\n                left[i] = stack.peek();\n            }\n            stack.push(i);\n            //System.out.println(stack);\n        }\n        stack = new Stack<>();\n        for (int i = nums.length-1; i >= 0; i--) {\n            while (!stack.isEmpty() && nums[stack.peek()] >= nums[i]){\n                stack.pop();\n            }\n            if (stack.isEmpty()){\n                right[i] = nums.length;\n            }\n            else {\n                right[i] = stack.peek();\n            }\n            stack.push(i);\n        }\n        //System.out.println(Arrays.toString(left));\n        //System.out.println(Arrays.toString(right));\n        int max = Integer.MIN_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            //计算宽度\n            max = Math.max(max,(right[i]-left[i]-1)*nums[i]);\n        }\n        return max;\n    }\n}\n```\n> 很重要这个题，这种思想已经不是第一次见到了，分别按照左边右边两个数组，遍历三次\n\n时间复杂度：o(n)\n空间复杂度：o(n)\n\n# 接雨水（Hard）\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n![](../img/2024_3_29_4.png)\n\n## 动态规划\n>其实也用了上一题的思想\n\n对于下标 i，下雨后水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去 height[i]。\n\n朴素的做法是对于数组 height 中的每个元素，分别向左和向右扫描并记录左边和右边的最大高度，然后计算每个下标位置能接的雨水量。假设数组 height 的长度为 n，该做法需要对每个下标位置使用 O(n) 的时间向两边扫描并得到最大高度，因此总时间复杂度是 O(n^2)\n\n上述做法的时间复杂度较高是因为需要对每个下标位置都向两边扫描。如果已经知道每个位置两边的最大高度，则可以在 O(n)的时间内得到能接的雨水总量。使用动态规划的方法，可以在 O(n) 的时间内预处理得到每个位置两边的最大高度。\n\n创建两个长度为 n 的数组 leftMax 和 rightMax。对于 0≤i<n0 ，leftMax[i] 表示下标 i 及其左边的位置中，height 的最大高度，rightMax[i] 表示下标 i 及其右边的位置中，height 的最大高度。\n\n显然，$leftMax[0]=height[0]$，$rightMax[n−1]=height[n−1]$。两个数组的其余元素的计算如下：\n\n- 当 $1≤i≤n−1$ 时，$leftMax[i]=max(leftMax[i−1],height[i])$；\n- 当 $0≤i≤n−2$ 时，$rightMax[i]=max(rightMax[i+1],height[i])$。\n\n因此可以正向遍历数组 height 得到数组 leftMax 的每个元素值，反向遍历数组 height 得到数组 rightMax 的每个元素值。\n\n在得到数组 leftMax 和 rightMax 的每个元素值之后，对于 0≤i<n，下标 i 处能接的雨水量等于 $min(leftMax[i],rightMax[i])−height[i]$。遍历每个下标位置即可得到能接的雨水总量。\n\n![](../img/2024_3_29_5.png)\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        int[] left = new int[height.length];\n        left[0] = height[0];\n        int[] right = new int[height.length];\n        right[height.length-1] = height[height.length-1];\n        for (int i = 1; i < height.length; i++) {\n            left[i] = Math.max(left[i-1],height[i]);\n        }\n        for (int i = height.length-2; i >=0 ; i--) {\n            right[i] = Math.max(right[i+1],height[i]);\n        }\n        int ans = 0;\n        for (int i = 0; i < height.length; i++) {\n            ans += Math.min(left[i],right[i])-height[i];\n        }\n        return ans;\n    }\n}\n```\n\n## 单调栈\n> 这个挺难理解的\n\n除了计算并存储每个位置两边的最大高度以外，也可以用单调栈计算能接的雨水总量。\n\n维护一个单调栈，单调栈存储的是下标，满足从栈底到栈顶的下标对应的数组 height 中的元素递减。\n\n从左到右遍历数组，遍历到下标 i 时，如果栈内至少有两个元素，记栈顶元素为 top，top 的下面一个元素是 left，则一定有 $height[left]≥height[top]$。如果 $height[i]>height[top]$，则得到一个可以接雨水的区域，该区域的宽度是 $i−left−1$，高度是 $min(height[left],height[i])−height[top]$，根据宽度和高度即可计算得到该区域能接的雨水量。\n\n为了得到 left，需要将 top 出栈。在对 top 计算能接的雨水量之后，left 变成新的 top，重复上述操作，直到栈变为空，或者栈顶下标对应的 height 中的元素大于或等于 height[i]。\n\n在对下标 i 处计算能接的雨水量之后，将 i 入栈，继续遍历后面的下标，计算能接的雨水量。遍历结束之后即可得到能接的雨水总量。\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        Stack<Integer> stack = new Stack<>();\n        int ans = 0;\n        for (int i = 0; i < height.length; i++) {\n            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {\n                int top = stack.pop();\n                if (stack.isEmpty()) {\n                    break;\n                }\n                int left = stack.peek();\n                int currWidth = i - left - 1;\n                int currHeight = Math.min(height[left], height[i]) - height[top];\n                ans += currWidth * currHeight;\n            }\n\n            stack.push(i);\n        }\n        return ans;\n    }\n}\n```","tags":["刷题笔记"]},{"title":"leetcode-2024-3-28","url":"/2024/03/28/leetcode-2024-3-28/","content":"> 今天斗胆试了一下蓝桥杯的题，实在是感觉太难了，不暴力根本不会做，以后有机会再写题解吧。\n> \n> 我觉得这种程序设计竞赛还是得好好研究算法才行，我这种野路子还有很长一段路要走\n# 1997 访问完所有房间的第一天（Medium）\n你需要访问 n 个房间，房间从 0 到 n - 1 编号。同时，每一天都有一个日期编号，从 0 开始，依天数递增。你每天都会访问一个房间。\n\n最开始的第 0 天，你访问 0 号房间。给你一个长度为 n 且 下标从 0 开始 的数组 nextVisit 。在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定：\n\n- 假设某一天，你访问 i 号房间。\n- 如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间，其中 0 <= nextVisit[i] <= i 。\n- 如果算上本次访问，访问 i 号房间的次数为 偶数 ，那么 第二天 需要访问 (i + 1) mod n 号房间。\n\n请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 109 + 7 取余后的结果\n## 暴力超时：简陋的动态规划\n> 虽然超时了但是思路跟答案是一样的。\n>\n> 分析题意发现 nextVisited[i]的范围属于 [0,i]，意味着当你首次到达房间 i 时会回退到房间 nextVisited[i]。而只有访问过该房间偶数次时才会到达下一个房间，进而推断出到达 i 时，[0,i)的房间已经被访问过偶数次。\n\n>定义 f[i] 表示从奇数次到房间 i，到奇数次到达房间 i+1 所需要的天数。以下用 to 代表 nextVisited[i]，回退到房间 to 时是奇数次访问，又需要花费 f[to] 才会到达房间 to+1。从 iii 访问 to 和 i+1 又分别需要花费一天，所以有转移方程:\n\n$$\nf[i] = \\sum\\limits_{j=to}^{i-1}f[j]+2\n$$\n![](../img/2024_3_28_1.PNG)\n```java\nclass Solution {\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\n        int[] dp = new int[nextVisit.length];\n        int MOD = 1000000007;\n        for (int i = 0; i < nextVisit.length; i++) {\n            //第一次进来然后去nextVisited[i]，第二次回来才变成偶数\n            int temp = 2;\n            //访问到nextVisited[i]，把之后所有的都会再访问一遍，全部都加起来\n            for (int j = nextVisit[i]; j < i; j++) {\n                temp = (dp[j]+temp)%MOD;\n            }\n            dp[i] = temp;\n        }\n        int ans = 0;\n        //dp存放的只是这个节点的次数，要总体的还要全部加起来\n        for (int i = 0; i < nextVisit.length-1; i++) {\n            ans=(dp[i]+ans)%MOD;\n        }\n        return ans;\n    }\n\n}\n```\n时间复杂度o(n^2)，那肯定暴力超时\n## 优化版：前缀和\n定义前缀和\n$$\ns[0]=0,s[i+1] = \\sum\\limits_{j=0}^{i}f[i]\n$$\n\n对于\n$$\nf[i] = \\sum\\limits_{j=to}^{i-1}f[j]+2\n$$\n可以化简为\n$$\nf[i] = 2+s[i]-s[j]\n$$\n对于前缀和 s，有如下递推式\n$$\ns[i+1] = 2*s[i]-s[j]+2\n$$\n这样我们就不用计算原先的dp数组，通过前缀和就得到答案。\n\n```java\nclass Solution {\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\n        final long MOD = 1_000_000_007;\n        int n = nextVisit.length;\n        long[] s = new long[n];\n        for (int i = 0; i < n - 1; i++) {\n            int j = nextVisit[i];\n            s[i + 1] = (s[i] * 2 - s[j] + 2 + MOD) % MOD; // + MOD 避免算出负数\n        }\n        return (int) s[n - 1];\n    }\n}\n```\n\n# 221 最大正方形（Medium）\n\n在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。\n![](../img/2024_3_28_3.png)\n> 由于是在上课的时候看的，没有自己动手写，直接看的答案。我估计自己写也是智能暴力解法\n## 二维动态规划\n> 有点像“编辑距离”和某一天的那个截木块的每日一题，$dp[i][j]$表示以这个点为右下角的最大正方形的边长，那么如果$matrix[i][j]=0$，那dp肯定也为0，我们考虑为1的情况。\n> \n> 这里的状态转移方程是\n> $$\n> dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1\n> $$\n> ![](../img/2024_3_28_2.png)\n\n```java\nclass Solution {\n    public int maximalSquare(char[][] matrix) {\n        int[][] dp = new int[matrix.length][matrix[0].length];\n        int ans = 0;\n        for (int i = 0; i < dp.length; i++) {\n            for (int j = 0; j < dp[0].length; j++) {\n                if (i != 0 || j !=0){\n                    if (matrix[i][j] == '1'){\n                        int left = 0,up = 0,up_left = 0;\n                        if (i-1 >= 0){\n                            up = dp[i-1][j];\n                        }\n                        if (j-1 >=0){\n                            left = dp[i][j-1];\n                        }\n                        if (i-1 >=0 && j-1>=0){\n                            up_left = dp[i-1][j-1];\n                        }\n                        dp[i][j] = Math.min(Math.min(left,up),up_left)+1;\n                        ans = Math.max(ans,dp[i][j]);\n                    }\n                }\n                else {\n                    if (matrix[i][j] == '1'){\n                        dp[i][j] = 1;\n                        ans = Math.max(ans,dp[i][j]);\n                    }\n                    else {\n                        dp[i][j] = 0;\n                    }\n                }\n\n            }\n        }\n        //System.out.println(Arrays.deepToString(dp));\n        return ans*ans;\n    }\n}\n```\n","tags":["刷题笔记"]},{"title":"leetcode-2024-3-27","url":"/2024/03/27/leetcode-2024-3-27/","content":"# 2580 统计将重叠区间合并成组的方案数（Medium）\n\n给你一个二维整数数组 ranges ，其中 ranges[i] = [starti, endi] 表示 starti 到 endi 之间（包括二者）的所有整数都包含在第 i 个区间中。\n\n你需要将 ranges 分成 两个 组（可以为空），满足：\n\n每个区间只属于一个组。\n两个有 交集 的区间必须在 同一个 组内。\n如果两个区间有至少 一个 公共整数，那么这两个区间是 有交集 的。\n\n比方说，区间 [1, 3] 和 [2, 5] 有交集，因为 2 和 3 在两个区间中都被包含。\n请你返回将 ranges 划分成两个组的 总方案数 。由于答案可能很大，将它对 109 + 7 取余 后返回。\n\n\n\n示例 1：\n\n输入：ranges = [[6,10],[5,15]]\n输出：2\n解释：\n两个区间有交集，所以它们必须在同一个组内。\n所以有两种方案：\n- 将两个区间都放在第 1 个组中。\n- 将两个区间都放在第 2 个组中。\n\n## 区间合并+组合数\n> 思路是将里面的区间先合并，得到长度。然后就相当于两个桶子，最终的结果为组合数相加，也就是一个杨辉三角，那么一行的总数就是2^n\n\n![](../img/2024_3_27_1.png)\n\n> 区间合并：设置一个动态数组，首先按照左括号排序，接着从后往前遍历，如果两个区间存在重合，就把后面的删除，前面的改成合并以后的新区间。\n>\n> 这样主要是可以避免下标的影响，从前面遍历删除会乱序号\n> \n> 但是这样还不够，比如这个例子[[2,3],[4,5],[6,7],[8,9],[1,10]]，排序以后[[1,10],[2,3],[4,5],[6,7],[8,9]]，这样以来排序也没用，结果是[[1,10],[4,5],[6,7],[8,9]]，面对这种情况需要多循环几次，每次减少1个，当长度不再变化的时候就停止\n```java\nclass Solution {\n    public int countWays(int[][] ranges) {\n        int MOD = 1000000007;\n        int length = merge(ranges).length;\n        int ans = 1;\n        for (int i = 0; i < length; i++) {\n            ans = ans *2%MOD;\n        }\n        return ans;\n    }\n\n    /**\n     * 合并区间的代码\n     * @param intervals\n     * @return\n     */\n    public int[][] merge(int[][] intervals){\n        int[][] temp1 = mergeTemp(intervals);\n        int[][] temp2 = mergeTemp(temp1);\n        while (temp1.length != temp2.length){\n            temp1 = mergeTemp(temp2);\n            temp2 = mergeTemp(temp1);\n        }\n        return temp1;\n    }\n    public int[][] mergeTemp(int[][] intervals) {\n        //先排序\n        Arrays.sort(intervals, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if(o1[0]==o2[0]){\n                    return o1[1] - o2[1];\n                }\n                return o1[0] - o2[0];\n            }\n        });\n        List<int[]> arrList = new ArrayList<>();\n        int rear = intervals.length-1;\n        for (int[] interval : intervals) {\n            arrList.add(interval);\n        }\n        while (rear > 0){\n            int[] front = arrList.get(rear-1);\n            int[] behind = arrList.get(rear);\n            int temp;\n            if (front[1] >= behind[0]){\n                temp = Math.max(front[1],behind[1]);\n                arrList.set(rear-1,new int[]{\n                        arrList.get(rear-1)[0],temp\n                });\n                arrList.remove(rear);\n                rear--;\n            }\n            else rear--;\n        }\n        int[][] ans = new int[arrList.size()][2];\n        for (int i = 0; i < arrList.size(); i++) {\n            ans[i] = arrList.get(i);\n        }\n        return ans;\n    }\n}\n```\n\n> 当初在做合并区间的时候就有点侥幸了，这个题后续还要多看\n\n# 25 K个一组翻转链表(Hard)\n\n给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。\n\nk 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换\n\n![](../img/2024_3_27_2.png)\n\n>其实也没那么Hard，就是麻烦了一点\n\n## 模拟\n```java\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        //如果间隔是1，那么就不进行下面的逻辑直接返回\n        if (k==1){\n            return head;\n        }\n        ListNode p = head;\n        //首先遍历统计节点数\n        int count = 0;\n        while (p!=null){\n            count++;\n            p = p.next;\n        }\n        p = head;\n        ListNode pre = head;\n        List<ListNode> listNodes = new ArrayList<>();\n        //对于每一个完整的组，不完整的直接接在尾部就行\n        for (int i = 1; i <= count / k; i++) {\n            //pre找的是下一个的完整组的头节点，也就是下个p\n            pre = getNext(pre,k);\n            //将反转后的头节点放进数组保存\n            listNodes.add(reverse(p,k));\n            p = pre;\n        }\n        //遍历数组，一段一段接起来\n        ListNode temp = listNodes.get(0);\n        for (int i = 0; i < listNodes.size()-1; i++) {\n            temp= listNodes.get(i);\n            while (temp.next != null){\n                temp = temp.next;\n            }\n            temp.next = listNodes.get(i+1);\n        }\n        //这里最后一段还没遍历，为了找到尾指针接上落单的那几个节点\n        while (temp.next != null){\n            temp = temp.next;\n        }\n        //接上落单的几个节点\n        temp.next = pre;\n        //返回最终的头节点\n        ListNode ans = listNodes.get(0);\n        \n        return listNodes.get(0);\n\n    }\n\n    /**\n     * 返回下一段的头节点\n     * @param p\n     * @param k\n     * @return\n     */\n    public ListNode getNext(ListNode p,int k){\n        for (int i = 0; i < k; i++) {\n            p = p.next;\n        }\n        return p;\n    }\n\n    /**\n     * 反转当前段\n     * @param head 原顺序的第一个节点\n     * @param k 本段长多少\n     * @return 返回这一段反转完的头节点\n     */\n    public ListNode reverse(ListNode head,int k){\n        //首先返回的头节点肯定是动过的，头节点是最末尾那个，在这里是k-1次循环后的那个节点\n        ListNode ans = head;\n        for (int i = 0; i < k - 1; i++) {\n            ans = ans.next;\n        }\n        //执行倒序逻辑\n        ListNode pre =null,p = head,pa;\n        for (int i = 0; i < k; i++) {\n            pa = p.next;\n            p.next = pre;\n            pre = p;\n            p = pa;\n        }\n        return ans;\n    }\n}\n```\n\n# 136 只出现一次的数字（Easy）\n\n给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n\n示例 1 ：\n\n输入：nums = [2,2,1]\n\n输出：1\n\n## 哈希表\n\n> 这里我的思路是遍历一次然后加入哈希表进行统计，再遍历一次哈希表找出其中为1的，这样时间空间复杂度肯定都0(n)了\n\n## 技巧-位运算\n\n> 通过异或，因为只有两个两个的，两个相同的异或结果就是0，0和任何异或都是自身，那么所有进行异或得到的就是落单的\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int single = 0;\n        for (int num : nums) {\n            single ^= num;\n        }\n        return single;\n    }\n}\n\n``` \n\n","tags":["刷题笔记"]},{"title":"Collections集合篇-Map","url":"/2024/03/26/Collections集合篇-Map/","content":"# HashMap\n> 最常用的Map结构，使用的是拉链法\n\n## 数据结构\nHashMap采用Entry数组来存储key-value,Entry有四个属性，Key，value，哈希值和下一个的指针\n![](../img/Java/img_2.png)\n> 这里是1.8的版本，Node是Entry的一种实现\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n}\n```\n表的数据结构就是一个个的Entry\n```java\ntransient Node<K,V>[] table;\n```\n## 属性\n```java\n/**\n * 初始的大小\n */\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n/**\n * 为什么这里是2^31呢，因为hashCode是int类型的值，\n * 对于数组下标而言不能有负数，整数的范围就是0-2^31-1\n */\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n\n/**\n * 阈值的计算参数，太多了可能会造成链表变长而降低查找效率\n * 太低了可能频繁扩容也会影响效率\n * 这个值是通过泊松分布计算出来的\n */\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n/**\n * 意味着如果链表的长度大于8就要转化为红黑树\n */\nstatic final int TREEIFY_THRESHOLD = 8;\n\n/**\n * 相反的，如果当前树节点小于6个就要将其转化为链表\n */\nstatic final int UNTREEIFY_THRESHOLD = 6;\n\n/**\n * 链表的长度大于8且数组长度大于64转化为红黑树\n */\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n\n```\n## hashCode()和equals()方法\n首先看Object的hashCode方法：\n\n作用：返回对象的哈希码值，用于在哈希表等数据结构中快速定位对象，提高哈希表的性能。\n\n默认实现：Object类中的hashCode()方法默认返回对象的内存地址的哈希码值。\n\n> 这个默认的方法是根据地址计算出来的，\n> 如果两个对象的hashCode()返回值相同，不一定表示这两个对象相等(一般情况下是可以说明两个对象相等)，因为可能存在哈希冲突。\n> \n> **哈希值不能等价于地址，因为Java是在JVM中执行的，并不是真正的地址。**\n```java\npublic class Hashcode {\n    public static void main(String[] args) {\n        A a = new A();\n        A a1 = new A();\n        A a2 = a1;\n        System.out.println(a.hashCode());//460141958\n        System.out.println(a1.hashCode());//1163157884\n        System.out.println(a2.hashCode());//1163157884\n    }\n}\n \nclass A{\n}\n```\n\n我们再看HashMap重写的hashCode\n> 这里选择高十六位和第十六位进行异或运算，是为了尽量提取全部位的特征参与哈希计算，使得其更加分散\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n1. int h;：定义一个整型变量 h，用于存储计算出的哈希值。\n2. (key == null) ? 0 : (h = key.hashCode())：这是一个三元运算符，用于判断给定的键是否为 null。如果键为 null，则将哈希值 h 设为 0；否则，调用键的 hashCode() 方法获取其哈希码，并将结果赋给变量 h。\n3. (h >>> 16)：这是一个无符号右移运算，将变量 h 的二进制表示向右移动 16 位。这么做的目的是为了增加哈希值的随机性，使得哈希值的高位和低位都参与了哈希码的计算。\n4. (h = key.hashCode()) ^ (h >>> 16)：这是一个按位异或运算，将哈希值 h 和右移后的哈希值进行异或运算。按位异或运算是一种常用的混合哈希函数，用于将高位的信息与低位的信息混合在一起，增加哈希值的随机性。\n5. return：将计算出的哈希值返回。\n\n> 在put操作里面是这样判断hashcode和equals的\n```\np.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))\n```\n- 首先判断两个的哈希是否相等，如果哈希不相等那么肯定不存在冲突\n- 如果哈希相等，可能是哈希碰撞，也可能是真的就是一样的元素，需要对具体的k进行判断\n- p.key == key判断的是**引用是否相等**，也就是指针，有的时候两个类的指针指向的是同一块空间，那么这个时候就肯定是相等的\n- key.equals(k)判断的是**内容是否相等**，有的时候两个指针指得确实是不一样的，但是他们包含的内容是一样的，那么肯定也不能放进哈希表，new Student(\"yyf\")和new Student(\"xxy\")指针肯定是不同的，因为指向不同的内存空间，但是内容不一样。这个检测就需要equal来检测了\n\n> 看源码这一段判断，书里的长篇大论都可以不看了：\n> \n> hashcode一致，内容不一样的两个肯定是能进哈希表的，这就是哈希碰撞\n> \n> hashcode一致，equals返回true那肯定是不能进的，这里逻辑是或，就是内容或者引用满足一个相等就不能放了\n> \n> 重写了hashcode，但是equals返回true是可以放进去的，因为逻辑是与\n\n## put操作\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n```\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n> 这里主要有几点注意：\n> - (n - 1) & hash是怎么来的，其实这就是一个取余的操作，因为n为2的整数倍，那么n-1肯定是末尾全为1前面全为0的，用位运算会比%快\n> - p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))在前面已经讲过了\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    //判断数组是否未初始化,这里table已经赋值给tab了，n也同理\n    if ((tab = table) == null || (n = tab.length) == 0)\n        //如果未初始化，调用resize方法 进行初始化\n        n = (tab = resize()).length;\n    //通过 & 运算求出该数据（key）的数组下标并判断该下标位置是否有数据\n    /**\n     * 这里是取余操作，位运算更快\n     * 由于n必然是2的倍数，那么-1就是除了最高位其他都为1，这个时候就相当于掩码，与hash进行与运算\n     * 就可以得到余数，非常神奇\n     */\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        //如果没有，直接将数据放在该下标位置\n        tab[i] = newNode(hash, key, value, null);\n    //该数组下标有数据的情况\n    else {\n        Node<K,V> e; K k;\n        //判断该位置数据的key和新来的数据是否一样\n        if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))\n            //如果一样，证明为修改操作，该节点的数据赋值给e,后边会用到\n            e = p;\n        //判断是不是红黑树\n        else if (p instanceof TreeNode)\n            //如果是红黑树的话，进行红黑树的操作\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        //新数据和当前数组既不相同，也不是红黑树节点，证明是链表\n        else {\n            //遍历链表\n            for (int binCount = 0; ; ++binCount) {\n                //判断next节点，如果为空的话，证明遍历到链表尾部了\n                if ((e = p.next) == null) {\n                    //把新值放入链表尾部\n                    p.next = newNode(hash, key, value, null);\n                    //因为新插入了一条数据，所以判断链表长度是不是大于等于8\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        //如果是，进行转换红黑树操作\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                //判断链表当中有数据相同的值，如果一样，证明为修改操作\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                //把下一个节点赋值为当前节点\n                p = e;\n            }\n        }\n        //判断e是否为空（e值为修改操作存放原数据的变量）\n        if (e != null) { // existing mapping for key\n            //不为空的话证明是修改操作，取出老值\n            V oldValue = e.value;\n            //一定会执行  onlyIfAbsent传进来的是false\n            if (!onlyIfAbsent || oldValue == null)\n                //将新值赋值当前节点\n                e.value = value;\n            afterNodeAccess(e);\n            //返回老值\n            return oldValue;\n        }\n    }\n    //计数器，计算当前节点的修改次数\n    ++modCount;\n    //当前数组中的数据数量如果大于扩容阈值\n    if (++size > threshold)\n        //进行扩容操作\n        resize();\n    //空方法\n    afterNodeInsertion(evict);\n    //添加操作时 返回空值\n    return null;\n}\n```\nput的逻辑是：\n- 首先判断是不是没有进行初始化，如果是第一次加入，那么resize，这里的默认长度是16，阈值为16*0.75\n- 如果初始化了，看tab[(n - 1) & hash]是否有数据，如果没有，就直接放这里；如果有那么就进行后面的逻辑\n- 判断p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))看跟当前的这个是不是一样的，如果是一样的那就进行修改，如果不是，那就要进行链表或者红黑树的添加了\n- 如果是红黑树，那么就走红黑树的添加逻辑\n- 如果是链表，就遍历链表，每一个都进行判断p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))，如果是那就修改，如果遍历到最后了，那就添加到末尾\n- 边走边判断是不是要超过8个了，如果遍历到的节点到第七个了，那就要树化了\n- 最后遍历完了看是否超过扩容阈值了，如果要扩容还要扩\n> 关于这里链表的尾插法，后续还有相关知识点\n## HashMap的扩容\n```java\n//扩容、初始化数组\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n    \t//如果当前数组为null的时候，把oldCap老数组容量设置为0\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        //老的扩容阈值\n    \tint oldThr = threshold;\n        int newCap, newThr = 0;\n        //判断数组容量是否大于0，大于0说明数组已经初始化\n    \tif (oldCap > 0) {\n            //判断当前数组长度是否大于最大数组长度\n            if (oldCap >= MAXIMUM_CAPACITY) {\n                //如果是，将扩容阈值直接设置为int类型的最大数值并直接返回\n                /**\n                 * 如果都已经到最大限制了不能再多了，那么阈值就要变得最大以免还要进行扩容操作\n                 */\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            //如果在最大长度范围内，则需要扩容  OldCap << 1等价于oldCap*2\n            //运算过后判断是不是最大值并且oldCap需要大于16\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold  等价于oldThr*2\n        }\n    \t//如果oldCap<0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，       \t\t\t如果是首次初始化，它的临界值则为0\n        /**\n         * // 为什么这里的oldThr在未初始化数组的时候就有值呢？\n         // 这是因为HashMap有两个带参构造器，可以指定初始容量，\n         // 若你调用了这两个可以指定初始容量的构造器，\n         // 这两个构造器就会将阈值记录为第一个大于等于你指定容量，且满足2^n的数（可以看看这两个构造器）\n         */\n        else if (oldThr > 0) // initial capacity was placed in threshold\n            newCap = oldThr;\n        //数组未初始化的情况，将阈值和扩容因子都设置为默认值\n        //初始化走这个\n    \telse {               // zero initial threshold signifies using defaults\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n    \t//初始化容量小于16的时候，扩容阈值是没有赋值的\n        if (newThr == 0) {\n            //创建阈值\n            float ft = (float)newCap * loadFactor;\n            //判断新容量和新阈值是否大于最大容量\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n    \t//计算出来的阈值赋值\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        //根据上边计算得出的容量 创建新的数组       \n    \tNode<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    \t//赋值\n    \ttable = newTab;\n    \t//扩容操作，判断不为空证明不是初始化数组\n        if (oldTab != null) {\n            //遍历数组\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                //判断当前下标为j的数组如果不为空的话赋值个e，进行下一步操作\n                if ((e = oldTab[j]) != null) {\n                    //将数组位置置空\n                    oldTab[j] = null;\n                    //判断是否有下个节点\n                    if (e.next == null)\n                        //如果没有，就重新计算在新数组中的下标并放进去\n                        newTab[e.hash & (newCap - 1)] = e;\n                   \t//有下个节点的情况，并且判断是否已经树化\n                    else if (e instanceof TreeNode)\n                        //进行红黑树的操作\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    //有下个节点的情况，并且没有树化（链表形式）\n                    else {\n                        //比如老数组容量是16，那下标就为0-15\n                        //扩容操作*2，容量就变为32，下标为0-31\n                        //低位：0-15，高位16-31\n                        //定义了四个变量\n                        //        低位头          低位尾\n                        Node<K,V> loHead = null, loTail = null;\n                        //        高位头\t\t   高位尾\n                        Node<K,V> hiHead = null, hiTail = null;\n                        //下个节点\n                        Node<K,V> next;\n                        //循环遍历\n                        do {\n                            //取出next节点\n                            next = e.next;\n                            //通过 与操作 计算得出结果为0\n                            if ((e.hash & oldCap) == 0) {\n                                //如果低位尾为null，证明当前数组位置为空，没有任何数据\n                                if (loTail == null)\n                                    //将e值放入低位头\n                                    loHead = e;\n                                //低位尾不为null，证明已经有数据了\n                                else\n                                    //将数据放入next节点\n                                    loTail.next = e;\n                                //记录低位尾数据\n                                loTail = e;\n                            }\n                            //通过 与操作 计算得出结果不为0\n                            else {\n                                 //如果高位尾为null，证明当前数组位置为空，没有任何数据\n                                if (hiTail == null)\n                                    //将e值放入高位头\n                                    hiHead = e;\n                                //高位尾不为null，证明已经有数据了\n                                else\n                                    //将数据放入next节点\n                                    hiTail.next = e;\n                               //记录高位尾数据\n                               \thiTail = e;\n                            }\n                            \n                        } \n                        //如果e不为空，证明没有到链表尾部，继续执行循环\n                        while ((e = next) != null);\n                        //低位尾如果记录的有数据，是链表\n                        if (loTail != null) {\n                            //将下一个元素置空\n                            loTail.next = null;\n                            //将低位头放入新数组的原下标位置\n                            newTab[j] = loHead;\n                        }\n                        //高位尾如果记录的有数据，是链表\n                        if (hiTail != null) {\n                            //将下一个元素置空\n                            hiTail.next = null;\n                            //将高位头放入新数组的(原下标+原数组容量)位置\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n    \t//返回新的数组对象\n        return newTab;\n    }\n```\n  resize()的逻辑是：\n- 首先判断oldCap是否大于0，如果是大于0那么说明已经初始化了，如果是等于0但是有阈值，说明可能是通过remove光了，也可能是初始化的时候使用有参构造方法，最后是等于0但是也没有阈值，对应的是无参构造方法，这个时候还没有真正给hashmap空间\n- 大于0，那么就是扩展hashmap长度为原来两倍（这里是左移一位，也就是*2），那么阈值也跟着扩展，如果等于0但是有阈值，那么新的阈值也是原来的，如果是无参的初始化，那么就是默认的16，阈值16*0，75\n- 完成了新数组长度和新阈值的计算，接着就是移动数组了，新建一个新长度的数组\n- 在旧的数组里面遍历，如果不为空，说明要移动了，如果后续没有，那么直接进新数组，如果还有后续，先判断是否是红黑树的TreeNode节点，是的话就走红黑树的逻辑，如果不是那就说明是链表了\n- 链表的添加有两种，首先新建两个链表，一个是需要原封不动放在新链表对应节点的，另一组是放在$newTab[j + oldCap] = hiHead$中\n- 如何判断移动呢？进行$e.hash & oldCap$的判断，这个计算的结果是oldcap最高位的值，我们放在table数组里面的哈希碰撞都是通过取余操作，这个计算的是oldcap的最高位后面的位数，最高位被忽视了，比如101010 & 001111和111010 & 001111结果都是1010，放在10的位置，对于这个链表来说最高位10和11的效果是一样的，因此为了缩短链表，把这一部分进行分开是很有必要的，这样就可以有效缩短链表。\n- 然后通过判断遍历这个链表，按照上面的条件分别进入两个待移动链表。\n- 最后移动链表，完成扩容\n### 引申：为什么HashMap的数组是2的次幂\n回答这个问题可以看两个判断条件\n1. (n - 1) & hash，n为数组长度\n2. e.hash & oldCap，oldCap为数组长度\n参考回答：\n- 对于取余操作：计算索引的效率更高，如果是2的n次幂可以用位运算代替取模运算\n- 对于计算新索引，e.hash & oldCap可以计算高位，判断是否转移到新表下。\n## Java1.7的HashMap死循环问题\njdk7的的数据结构是：数组+链表\n\n在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环\n\n![image-20230428213115071](../img/Java/image-20230428213115071.png)\n\n- 变量e指向的是需要迁移的对象\n- 变量next指向的是下一个需要迁移的对象\n- Jdk1.7中的链表采用的头插法\n- 在数据迁移的过程中并没有新的对象产生，只是改变了对象的引用\n\n\n\n产生死循环的过程：\n\n线程1和线程2的变量e和next都引用了这个两个节点\n\n![image-20230428213533483](../img/Java/image-20230428213533483.png)\n\n线程2扩容后，由于头插法，链表顺序颠倒，但是线程1的临时变量e和next还引用了这两个节点\n\n![image-20230428214732877](../img/Java/image-20230428214732877.png)\n\n第一次循环\n\n由于线程2迁移的时候，已经把B的next执行了A\n\n![image-20230428214806072](../img/Java/image-20230428214806072.png)\n\n第二次循环\n\n![image-20230428214908652](../img/Java/image-20230428214908652.png)\n\n第三次循环\n\n![image-20230428214937231](../img/Java/image-20230428214937231.png)\n\n参考回答：\n\n在jdk1.7的hashmap中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环\n\n比如说，现在有两个线程\n\n线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入\n\n线程二：也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。\n\n线程一：继续执行的时候就会出现死循环的问题。\n\n线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，\n\n所以B->A->B,形成循环。\n\n当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），**尾插法**，就避免了jdk7中死循环的问题。\n\n\n# LinkedHashMap\nLinkedHashMap继承自HashMap，实现了Map接口，HashMap是不记录顺序的，有的时候我们需要记住插入的顺序，LinkedHashMap通过维护一个链表来记录顺序，可以想象成每插入一个到HashMap，链表也要插入一个保留顺序。\n```java\npublic class LinkedHashMap<K,V>\n    extends HashMap<K,V>\n    implements Map<K,V>\n```\n\n## 数据结构\n  在1.8维护了一个双向链表，定义头指针和尾指针，每一个Entry都会有前驱和后继\n  ![](../img/Java/img_4.png)\n> 这是新的 Entry的数据结构，继承自HashMap的Node，多了前驱和后继\n```java\n    /**\n     * LinkedHashMap中的node直接继承自HashMap中的Node。并且增加了双向的指针\n     */\n    static class Entry<K,V> extends HashMap.Node<K,V> {\n        Entry<K,V> before, after;\n        Entry(int hash, K key, V value, Node<K,V> next) {\n            super(hash, key, value, next);\n        }\n    }\n```\n> LinkedHashMap定义了头尾指针，accessOrder是一个重要变量，设置为真的话，get也会使元素移动到链表末尾，可以用这个变量实现**LRU**\n```java\n  /**\n     * 头指针，指向第一个node\n     */\n    transient LinkedHashMap.Entry<K,V> head;\n\n    /**\n     * 尾指针，指向最后一个node\n     */\n    transient LinkedHashMap.Entry<K,V> tail;\n\n    /**\n     * 一个条件变量，它控制了是否在get操作后需要将新的get的节点重新放到链表的尾部\n     * LinkedHashMap可以维持了插入的顺序，但是这个顺序不是不变的，可以被get操作打乱。\n     *\n     * @serial\n     */\n    final boolean accessOrder;\n\n```\n## 构造函数\n\n```java\n  /**\n     * Constructs an empty insertion-ordered <tt>LinkedHashMap</tt> instance\n     * with the specified initial capacity and load factor.\n     *\n     * @param  initialCapacity the initial capacity\n     * @param  loadFactor      the load factor\n     * @throws IllegalArgumentException if the initial capacity is negative\n     *         or the load factor is nonpositive\n     */\n    public LinkedHashMap(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor);\n        accessOrder = false;\n    }\n\n    /**\n     * 构造一个空的，按插入序（accessOrder = false）的LinkedHashMap，使用默认初始大小和负载因子0.75\n     */\n    public LinkedHashMap(int initialCapacity) {\n        super(initialCapacity);\n        accessOrder = false;\n    }\n\n    /**\n     * 默认的无参构造函数继承自HashMap的无参构造，那么也是刚开始懒加载\n     * 直到第一个元素进来才会有分配空间resize一次\n     * 默认也是accessOrder为假，也就是说不能get改变顺序\n     */\n    public LinkedHashMap() {\n        super();\n        accessOrder = false;\n    }\n    \n    public LinkedHashMap(Map<? extends K, ? extends V> m) {\n        super();\n        accessOrder = false;\n        putMapEntries(m, false);\n    }\n\n    /**\n     * 这个构造方法指定了accessOrder\n     * 注意细节，要配置accessOrder只能用容量和负载因子的有参构造方法\n     */\n    public LinkedHashMap(int initialCapacity,\n                         float loadFactor,\n                         boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        this.accessOrder = accessOrder;\n    }\n\n```\n## Java1.7和1.8LinkedHashMap的区别\n- 1.7版本的是用的双向循环链表，相比于HashMap多了两个变量，一个是头节点，因为是双向循环链表，head既可以是头也可以是尾。还有个顺序的变量，true是顺序，false是逆序，对于链表来说就是头插法和尾插法的区别，头插法就是逆序，尾插法就是顺序\n- 1.8用的是双向链表，接下来重点介绍\n## 1.8维护链表的操作\n> 对于数组的插入和扩容继承自HashMap，不在赘述。主要研究双向链表如何维护。\n### afterNodeRemoval\n顾名思义，在节点移除之后要做的事情\n```java\n    //在节点删除后，维护链表，传入删除的节点\n    void afterNodeRemoval(Node<K,V> e) { // unlink\n        //p指向待删除元素，b执行前驱，a执行后驱\n        LinkedHashMap.Entry<K,V> p =\n            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n        //这里执行双向链表删除p节点操作，很简单。\n        p.before = p.after = null;\n        //如果没有前面的节点，那这个就是第一个，这个时候全局的head指针要给当前节点的下一个作为头节点\n        if (b == null)\n            head = a;\n        //如果不是第一个节点，那就前面节点的后继为当前节点的后继\n        else\n            b.after = a;\n        //如果没有后继的节点，那么前面的节点就要接替成为尾节点\n        if (a == null)\n            tail = b;\n        //同理\n        else\n            a.before = b;\n    }\n\n```\n### afterNodeAccess\n根据accessOrder判断是否要在get之后进行调整\n```java\n  //在节点被访问后根据accessOrder判断是否需要调整链表顺序\n//将节点放在最后面\n    void afterNodeAccess(Node<K,V> e) { // move node to last\n        LinkedHashMap.Entry<K,V> last;\n        //如果accessOrder为false或者只有一个节点了，什么都不做\n        if (accessOrder && (last = tail) != e) {\n            //p指向待删除元素，b执行前驱，a执行后驱\n            LinkedHashMap.Entry<K,V> p =\n                (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n            //这里执行双向链表删除操作\n            p.after = null;\n            if (b == null)\n                head = a;\n            else\n                b.after = a;\n            if (a != null)\n                a.before = b;\n            else\n                last = b;\n            //这里执行将p放到尾部\n            if (last == null)\n                head = p;\n            else {\n                p.before = last;\n                last.after = p;\n            }\n            tail = p;\n            //保证并发读安全。\n            ++modCount;\n        }\n    }\n```\n### afterNodeInsertion\n这个方法是在添加之后的操作，可以想象成LRU，当容量超过阈值的时候可以重写removeEldestEntry方法返回true，就会删除最老的一个元素\n```java\nvoid afterNodeInsertion(boolean evict) { // possibly remove eldest\n    LinkedHashMap.Entry<K,V> first;\n    //removeEldestEntry(first)默认返回false，所以afterNodeInsertion这个方法其实并不会执行\n    if (evict && (first = head) != null && removeEldestEntry(first)) {\n        K key = first.key;\n        removeNode(hash(key), key, null, false, true);\n    }\n}\n\nprotected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n    return false;\n}\n\n```\n\n## get操作\n\n```java\n/**\n * 调用hashmap的getNode方法获取到值之后，维护链表\n * @param key\n * @return\n */\npublic V get(Object key) {\n    Node<K,V> e;\n    if ((e = getNode(hash(key), key)) == null)\n        return null;\n    //根据这个accessOrder来看是否要更新队伍\n    if (accessOrder)\n        afterNodeAccess(e);\n    return e.value;\n}\n\n```\n\n## put操作","tags":["Java"]},{"title":"Collections集合篇-List","url":"/2024/03/26/Collections集合篇-List/","content":"> 今天开始学习Java基础八股文，先从我用的最多的一个数据结构开始看起。虽然我学Java接触了这个概念快两三年了，但是不看源码还是不知道ArrayList的具体实现。\n\n# Collections\n\n集合分为两大类，Collection是单列集合，包含常用的Set，List，Queue等，其中Set里面使用HashSet比较多，List里面使用Arraylist比较多，Queue中有一个优先队列PriorityQueue的概念。\n\n- Set：HashSet，LinkedHashSet，SortedSet和继承其的TreeSet\n- List：ArrayList，LinkedList，Vector\n- Queue：PriorityQueue\n\n还有一类是双列集合Map，使用的比较多的有HashMap，LinkedHashMap，TreeMap，HashTable\n\n![](../img/Java/img.png)\n\n## List\n\n首先我们先复习一下顺序存储和链式存储的区别以及时间复杂度和空间复杂度。\n\n### 顺序存储：\n\n支持随机查找，空间连续，数据密度大（不像链表那样有额外的指针空间），删除和插入麻烦，不适合频繁在其中删除插入\n\n- 插入：如果在表尾就不需要移动元素为o(1)，如果是在内部，需要移动的期望为 (1+2+3+...+n)/(n+1) = n(n+1)/2(n+1) = n/2，时间复杂度为o(n)。\n- 删除：如果在表尾删除也不用移动，如果在内部，期望为 (1+2+...+n-1)/n = n(n-1)/2n = (n-1)/2 也是o(n)\n- 查找：平均查找期望 (1+2+..+n)/n = (n+1)/2 也为o(n)\n\n### 链式存储：\n\n不支持随机查找，但是相对于顺序的插入和删除效率还是高那么一点，空间不连续，数据的密度小，因为要存指针。\n\n- 插入：插入这个操作本身是o(1)的只需要改指针，但是要找到这个插入的位置是需要o(n)，删除同理。\n- 查找：不支持随机查找，每次找都需要从头开始找(双向链表可以解决这个问题)，也是o(n)\n\n### ArrayList\n\n> ArrayList和Vector是基于数组实现的，但是是动态的，每次添加之前都要判断是否下一个就要超过了，如果溢出就要重新开辟一个更长的数组。\n\n#### 成员变量\n\n```java\n/**\n * 默认的初始容量为10\n */\nprivate static final int DEFAULT_CAPACITY = 10;\n/**\n * 如果初始化为new ArrayList(n)，但是还没有在这个里面加东西的时候，elementData就是这个\n */\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\n/**\n * 如果初始化为new ArrayList()，但是还没有元素添加的时候，就是这个Default，为了和上面的区分开\n */\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n/**\n * 实际存储的数组结构\n */\ntransient Object[] elementData;\n\nprivate int size;\n```\n\n#### 构造方法\n>当initialCapacity给了是0或者没有提供的时候，不进行实例化，等到有元素进来了在进行扩容\n```java\n/**\n * 有参数的：只要有这个参数就是EMPTY_ELEMENTDATA，跟下面这个区分开\n * 可以按照指定容量初始化\n */\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    }\n}\n\n/**\n * 无参数构造方法：DEFAULTCAPACITY_EMPTY_ELEMENTDATA来区分\n */\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n\n\n```\n\n#### add添加方法流程\n\n```java\npublic boolean add(E e) {\n    //每一次加之前先检查size+1不会大于数组最大值\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n```\n\n```java\nprivate void ensureCapacityInternal(int minCapacity) {\n    //calculateCapacity(elementData, minCapacity)如果是无参的返回就是10\n    //如果不是返回的就是minCapacity\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n```\n\n\n```java\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    //如果是无参的初始化，那么就在当前这个容量和10之间选一个最大的\n    //但是一般来说第一个元素size肯定是0吧，这里传来的minCapacity估计是1\n    //所以第一次应该是初始化10个，对于无参构造方法而言\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n```\n\n\n```java\nprivate void ensureExplicitCapacity(int minCapacity) {\n    //操作次数，一个内部变量\n    modCount++;\n\n    // overflow-conscious code\n    //如果有增大的需求，即现在的需求已经比现长度大了\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n```\n\n```java\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    //1.5倍，oldCapacity右移一位代表/2，1+0.5\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    //只有第一次会这样minCapacity给的是10，这个肯定是<0\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    //然后拷贝一份这个数组\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n#### ArrayList的线程不安全问题\n\n> ArrayList不是线程安全的\n> \n> - 非同步操作： ArrayList 的方法并没有进行同步处理，因此在多线程环境下，多个线程可以同时访问和修改 ArrayList 的状态。\n> - 不保证操作的原子性： ArrayList 的操作（例如添加、删除、修改元素等）并不是原子操作，它们可能会分解成多个步骤。在多线程环境下，如果一个线程在执行操作的过程中被另一个线程中断，可能会导致数据不一致的情况发生\n> - 迭代器不支持并发修改： 在使用迭代器遍历 ArrayList 的过程中，如果其他线程对 ArrayList 进行了结构性修改（如添加或删除元素），则会抛出 ConcurrentModificationException 异常\n\n>举个例子，这里会报错，CopyOnWriteArrayList就不会\n```java\npublic static void main(String[] args) {\n    ArrayListTest arrayListTest = new ArrayListTest();\n    VectorTest vectorTest = new VectorTest();\n    for (int i = 0; i < 10; i++) {\n        new Thread(() -> {\n            for (int j = 0; j < 1000; j++) {\n                arrayListTest.insert(j);\n            }\n            System.out.println(arrayListTest.getSize());\n        }).start();\n    }\n\n    // 等待所有线程执行完毕\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n有几种解决方法\n\n- CopyOnWriteArrayList：使用 java.util.concurrent 包中提供的线程安全的集合类，例如 CopyOnWriteArrayList，它通过在写操作时复制整个数组来实现线程安全，适用于读多写少的场景。\n\n```java\nList<String> threadSafeList = new CopyOnWriteArrayList<>();\n\n```\n- 使用同步机制： 使用 Collections 工具类提供的 synchronizedList 方法，将 ArrayList 包装成一个同步的 List，这样可以保证在多线程环境下对 ArrayList 的操作是线程安全的，但性能可能会受到影响。\n```java\nList<String> synchronizedList = Collections.synchronizedList(new ArrayList<>());\n\n```\n\n### 几个面试题\n\n#### new ArrayList(10)grow了几次\n\n答：0次，因为这个在有参构造函数里面已经有了\n\n#### new ArrayList(0)和new ArrayList()在第一次扩容后都是多少\n\nnew ArrayList()和new ArrayList(0)执行完之后elementData都是空数组，但是这两个空数组的内存地址是不一样的。if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) 这一段代码在new(0)的时候是不会走的，因为比的是地址，所以返回值是1，最后结果也是1\n所以new ArrayList(0)第一次扩容是1，new ArrayList()第一次扩容是10\n\n#### 数组和list之间的转换？\n\n>数组->list:Arrays.asList()\n> \n>list->数组: list.toArray(n)\n\n- 数组转List ，使用JDK中java.util.Arrays工具类的asList方法\n\n- List转数组，使用List的toArray方法。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组\n\n#### 用Arrays.asList转List后，如果修改了数组内容，list受影响吗\n\nArrays.asList转换list之后，如果修改了数组的内容，list会受影响，\n因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，\n在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址\n\n#### List用toArray转数组后，如果修改了List内容，数组受影响吗\n\nlist用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响\n\n## LinkedList\n\n特点：\n- 基于双向链表实现\n- 也符合链式存储的一系列优缺点\n- 线程不安全，因为是链表，如何安全呢，跟上面的ArrayList一样使用Collections.synchronizedList(new ArrayList<>());\n\n## Vector\n\n特点：\n- 也是基于顺序存储（数组结构），但是增长的策略与ArrayList不同，而且每次增长2倍\n- 线程安全，这使其性能略逊于ArrayList\n- Stack是基于Vector的\n\n## 对比\n\n\n| 名称         | 基于数据结构 | 线程是否安全 |\n|------------|--------|--------|\n| ArrayList  | 数组     | 否      |\n| Vector     | 数组     | 是      |\n| LinkedList | 双向链表   | 否      |\n","tags":["Java"]},{"title":"leetcode-2024-3-26","url":"/2024/03/26/leetcode-2024-3-26/","content":"# 2642 设计可以求最短路径的图类（Hard）\n>题目太长了就换成图片了\n\n![](../img/2024_3_26_1.png)\n\n## 迪杰斯特拉\n> 我自己的做法是Dijkstra+邻接矩阵，还可以有Floyd，考虑到这个邻接矩阵都已经内存99%了，所以应该矩阵+Floyd是最佳方案\n\n> 就当是复习Dijkstra了\n```java\nclass Graph {\n\n    private int[][] matrix;\n    private int[] finalArr;\n    private int[] visited;\n    //用邻接矩阵表示图\n    public Graph(int n, int[][] edges) {\n        matrix = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i != j){\n                    matrix[i][j] = Integer.MAX_VALUE;\n                }\n            }\n        }\n        for (int i = 0; i < edges.length; i++) {\n            matrix[edges[i][0]][edges[i][1]] = edges[i][2];\n        }\n    }\n    //增加一条边就是再改一个值\n    public void addEdge(int[] edge) {\n        matrix[edge[0]][edge[1]] = edge[2];\n    }\n\n    /**\n     * Dijkstra，n次找到n个最短路径，所以需要一个visited矩阵保存已经找到最短路径的点\n     * finalArr存放最短路径，初始化为初始点的邻接数组，每次找到其中最小的\n     * 更新距离\n     * @param node1\n     * @param node2\n     * @return\n     */\n    public int shortestPath(int node1, int node2) {\n        finalArr = matrix[node1].clone();\n        visited = new int[matrix.length];\n        //System.out.println(Arrays.toString(finalArr));\n        int k = node1;\n        for (int i = 0; i < matrix.length-1; i++) {\n            visited[k] = 1;\n            int[] adj = getMin(finalArr);\n            k = adj[0];\n            int price = adj[1];\n            //如果这里返回-1说明找不到最小值，最小值都已经是正无穷了\n            //说明此时其他的都已经最优，直接跳出循环\n            if (k ==-1){\n                break;\n            }\n            for (int j = 0; j < matrix.length; j++) {\n                if (matrix[k][j] != Integer.MAX_VALUE&&price != Integer.MAX_VALUE && visited[j] == 0 && matrix[k][j]+price < finalArr[j]){\n                    finalArr[j] = matrix[k][j]+price;\n                }\n            }\n            //System.out.println(Arrays.toString(finalArr));\n        }\n        if (finalArr[node2] == Integer.MAX_VALUE){\n            return -1;\n        }else {\n            return finalArr[node2];\n        }\n    }\n    public int[] getMin(int[] arr){\n        int min = Integer.MAX_VALUE;\n        int vexNum = -1;\n        for (int i = 0; i < arr.length; i++) {\n            if (visited[i] ==0 && arr[i] != 0){\n                if (arr[i] <min){\n                    min = arr[i];\n                    vexNum = i;\n                }\n            }\n        }\n        return new int[]{vexNum,min};\n    }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = new\n * Graph(n, edges);\n * obj.addEdge(edge);\n * int param_2 = obj.shortestPath(node1,node2);\n */\n```\n\n# 矩阵置零（Medium）\n![](../img/2024_3_26_2.png)\n## 广度优先搜索\n>其实本来是想多源广度优先搜索的，后来发现好像不用这复杂。直接暴力每一行每一列都变成0就可以了\n```java\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        //存储在里面找到的0\n        List<int[]> points = new ArrayList<>();\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                if (matrix[i][j] == 0){\n                    points.add(new int[]{i,j});\n                }\n            }\n        }\n        //遍历每一个0，使其横竖都变为0\n        for(int[] point:points){\n            for (int i = 0; i < matrix.length; i++) {\n                matrix[i][point[1]] = 0;\n            }\n            for (int j = 0; j < matrix[0].length; j++) {\n                matrix[point[0]][j] = 0;\n            }\n        }\n    }\n}\n```\nrow为行，col为列\n\n时间复杂度：o(row*col)\n\n空间复杂度：o(row+col)\n\n# 130 被围绕的区域（Medium）\n![](../img/2024_3_26_3.png)\n## 深度优先搜索\n> 主要思路是，首先找到一个区域先把其全部变为X，用一个数组保存，如果这个区域里面包含在边界的块，那么这个数组用于后续再把他变为O\n```java\nclass Solution {\n    List<int[]> points = new ArrayList<>();\n    List<List<int[]>> list = new ArrayList<>();\n    public void solve(char[][] board) {\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                if (board[i][j] == 'O'){\n                    points = new ArrayList<>();\n                    //如果有链接到边界,随后把这些改回来\n                    if (!dfs(board,i,j)){\n                        list.add(points);\n                    }\n                }\n            }\n        }\n        for (List<int[]> points:list){\n            for (int[] point:points){\n                board[point[0]][point[1]] = 'O';\n            }\n        }\n        //System.out.println(Arrays.deepToString(board));\n    }\n    //一个区域块，首先全部变为X，返回真在后续把他变回O\n    public boolean dfs(char[][] board,int i,int j){\n        if (board[i][j] == 'O'){\n            boolean temp = true;\n            points.add(new int[]{i,j});\n            board[i][j] = 'X';\n            if (i == 0||j==0||i==board.length-1||j==board[0].length-1){\n                temp = false;\n            }\n            if (i+1<=board.length-1){\n                temp &= dfs(board,i+1,j);\n            }\n            if (i-1 >=0){\n                temp &= dfs(board,i-1,j);\n            }\n            if (j+1 <= board[0].length-1){\n                temp &= dfs(board,i,j+1);\n            }\n            if (j-1 >= 0){\n                temp &= dfs(board,i,j-1);\n            }\n            return temp;\n        }\n        else {\n            return true;\n        }\n    }\n}\n```\n时间复杂度：o(m*n)\n空间复杂度：o(m*n)\n\n## 还有两题太简单了我就当复习了\n### 排序链表\n### 快速排序\n```java\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        quickSort(nums,0,nums.length-1);\n    \n        return nums;\n    }\n    public void quickSort(int[] nums,int head,int rear){\n        if (head < rear){\n            int mid = partition(nums,head,rear);\n            quickSort(nums,head,mid-1);\n            quickSort(nums,mid+1,rear);\n        }\n    }\n    public int partition(int[] arr,int head,int rear){\n        int temp = arr[head];\n        while(head < rear){\n            //主要是要记得这里是每个都要带=，\n            while (head < rear && arr[rear] >= temp){\n                rear--;\n            }\n            arr[head] = arr[rear];\n            while (head < rear && arr[head] <= temp){\n                head++;\n            }\n            arr[rear] = arr[head];\n        }\n        arr[head] = temp;\n        //System.out.println(Arrays.toString(arr));\n        return head;\n    }\n}\n```","tags":["刷题笔记"]},{"title":"leetcode-2024-3-25","url":"/2024/03/25/leetcode-2024-3-25/","content":"# 518 零钱兑换2（Medium）\n给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。\n\n请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。\n\n假设每一种面额的硬币有无限个。\n\n题目数据保证结果符合 32 位带符号整数。\n\n\n\n示例 1：\n\n输入：amount = 5, coins = [1, 2, 5]\n\n输出：4\n\n解释：有四种方式可以凑成总金额：\n\n5=5\n\n5=2+2+1\n\n5=2+1+1+1\n\n5=1+1+1+1+1\n\n## 很愚蠢的暴力解：DFS（8/28）\n> 最搞笑的是我点了一个运行，然后吃完饭都没有算出结果来，我愿称之为最暴力的一集\n\n> 本意是深度优先搜索，然后将路径上的值保存进哈希表，哈希表记录的是硬币和个数，如果最后能全部找完，就把当前哈希表存到set里面（其实让我意想不到的是这样子set也可以去重）\n\n> 这种方法要重复计算太多次了，可以优化成右边的有向无环图，但是就这个题而言完全没必要这么复杂。\n\n![](../img/2024_3_25_1.png)\n```java\n//hashmap用来放具体找零\nprivate HashMap<Integer,Integer> hashMap = new HashMap<>();\n//set去重\nprivate Set<HashMap<Integer,Integer>> set = new HashSet<>();\npublic int change1(int amount, int[] coins) {\n    Arrays.sort(coins);\n    dfs(amount,coins);\n    return set.size();\n}\npublic void dfs(int amount,int[] coins){\n    //可以找完，放进set里面\n    if (amount == 0){\n        set.add(new HashMap<>(hashMap));\n        return;\n    }\n    //不能用已有的找零了，失败\n    if (amount < coins[0]){\n        return;\n    }\n    //递归遍历每一种情况\n    for (int i = 0; i < coins.length; i++) {\n        //先加入hashmap\n        if (!hashMap.containsKey(coins[i])){\n            hashMap.put(coins[i],1);\n        }\n        else {\n            Integer integer = hashMap.get(coins[i]);\n            hashMap.replace(coins[i],integer+1);\n        }\n\n        dfs(amount-coins[i],coins);\n        //后续递归再删除回到上一层，保证每个循环都是一样的\n        int temp = hashMap.get(coins[i]);\n        if (temp == 1){\n            hashMap.remove(coins[i]);\n        }\n        else {\n            hashMap.put(coins[i],temp-1);\n        }\n    }\n}\n```\n\n## 动态规划（其实就是跳房子游戏）\n\n> 问题一：我对这道题的主要纠结点在于，比如11，硬币有1，2，5，理应找dp[10],dp[9],dp[6],但是我们不知道这里面是不是可能造成重复，事实上dp[9]里面肯定也会只使用一个5，对于dp[6]的情况来说只是**改了顺序**\n\n> 如何解决？我们不再遍历11而遍历硬币，这样就能保证在遍历到当前硬币之前不会有这个路径出现。每一次遍历都是如何通过当前的这个硬币换到现在的钱，\n> 自然而然得到转移方程，dp[j] += dp[j-coins[i]];\n```java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount+1];\n        dp[0] = 1;\n        for (int i = 0; i < coins.length; i++) {\n            for (int j = coins[i]; j < dp.length; j++) {\n                dp[j] += dp[j-coins[i]];\n            }\n            \n        }\n\n        return dp[dp.length-1];\n    }\n}\n```\n>看完后其实是有恍然大雾的感觉，多看多学。\n\n# 合并K个有序链表（Hard）\n\n给你一个链表数组，每个链表都已经按升序排列。\n\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n\n>实在不明白这个题怎么会是hard，给我刷战绩的题\n\n>其实还不够快，如果用分治法可以logn\n\n## 队列\n> 两两合并然后入队，直到队里面只有一个，就是答案\n```java\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        //判断是否为空\n        if (lists.length == 0){\n            return null;\n        }\n        Queue<ListNode> queue = new ArrayDeque<>();\n        for (int i = 0; i < lists.length; i++) {\n            if (lists[i] != null){\n                queue.add(lists[i]);\n            }\n        }\n        //这里也被卡了一下，如果长度是0就不能进行下面的步骤\n        if (queue.isEmpty()){\n            return null;\n        }\n        while (queue.size() != 1){\n            ListNode listNode1 = queue.poll();\n            ListNode listNode2 = queue.poll();\n            if (listNode1 != null && listNode2 != null){\n                queue.add(merge(listNode1,listNode2));\n            }\n        }\n        return queue.poll();\n    }\n\n    /**\n     * 两个链表合并，基本方法\n     * @param listNode1\n     * @param listNode2\n     * @return\n     */\n    public ListNode merge(ListNode listNode1,ListNode listNode2){\n        //用了一个头节点方便保存\n        ListNode temp = new ListNode();\n        ListNode ans = temp;\n        while (listNode1!=null && listNode2!=null){\n            if (listNode1.val <= listNode2.val){\n                temp.next = listNode1;\n                listNode1 = listNode1.next;\n            }\n            else {\n                temp.next = listNode2;\n                listNode2 = listNode2.next;\n            }\n            temp = temp.next;\n        }\n        //接上没遍历到的\n        if (listNode1 != null){\n            temp.next = listNode1;\n        }\n        if (listNode2 != null){\n            temp.next = listNode2;\n        }\n        return ans.next;\n    }\n\n}\n```\n\n# 搜索二维矩阵2（Medium）\n\n编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：\n\n每行的元素从左到右升序排列。\n\n每列的元素从上到下升序排列。\n\n![](../img/2024_3_25_2.png)\n\n## 二维双指针\n>我们可以观察到，从下往上数每一行第一个元素，如果比目标大就可以删除了，同理每一列从后往前数第一个元素，如果大也可以删除了。\n> 这样就得到了一个新矩阵。\n\n>接着找新矩阵最后一行的元素，从前往后数如果比目标小也可以删除了，然后最后一列，从上到下比目标小的也可以删除。\n \n> 这样完成一次循环，减少了很大的搜索范围。一直收敛到只有一行或者一列。\n\n>这里用了***小技巧***，对于找不到的元素肯定是会**数组下标抛异常**的，catch到了肯定是没有的，返回假\n\n> 还有有一个小问题，当我们面对[[5,6,9],[9,10,11],[11,14,18]]这样的数组，有两个9，这时候我们就永远满足不了循环条件出不来了，为了解决需要看循环里面四个指针是否变化，如果没变就说明发生了这种情况。直接跳出循环。而出现这种情况的原因就是因为有两个一样的目标值，那肯定返回真。\n```java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int row_top = 0,row_bottom = matrix.length-1,col_left = 0,col_right = matrix[0].length-1;\n        boolean flag = false;\n\n        try {\n            while (row_top < row_bottom && col_left < col_right){\n                //判断是否指针有变化\n                int temp = 0;\n                while (matrix[row_bottom][col_left] > target){\n                    temp++;\n                    row_bottom--;\n                }\n                while (matrix[row_top][col_right] > target){\n                    temp++;\n                    col_right--;\n                }\n                while (matrix[row_bottom][col_left] < target){\n                    temp++;\n                    col_left++;\n                }\n                while (matrix[row_top][col_right] <target){\n                    temp++;\n                    row_top++;\n                }\n                if (temp == 0){\n                    flag = true;\n                    break;\n                }\n\n            }\n            //System.out.println(row_top+\"  \"+row_bottom+\"  \"+col_left+\"  \"+col_right);\n            if (row_top == row_bottom){\n                for (int i = col_left; i <=col_right; i++) {\n                    if (matrix[row_bottom][i] == target){\n                        flag = true;\n                        break;\n                    }\n                }\n            }\n            if (col_left == col_right){\n                for (int i = row_top; i <= row_bottom; i++) {\n                    if (matrix[i][col_right] == target){\n                        flag = true;\n                        break;\n                    }\n                }\n            }\n            return flag;\n        }\n        //小技巧\n        catch (ArrayIndexOutOfBoundsException e){\n            return false;\n        }\n    }\n}\n```\n\n这道题做出来其实有点侥幸，很多情况都是错了以后试验出来的。据他们所说这样还不如遍历整体找结果。\n\n# 54 螺旋矩阵（Medium）\n\n给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n\n![](../img/2024_3_25_3.png)\n\n> 非常好理解的一道题，根据上一题的思路很快就能写出，但是这里不用频繁维护四个指针，只用在循环末尾使用就可以。\n\n> 就跟洋葱一样，每次都剥掉最外一层\n\n## 双指针\n\n```java\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> ans = new ArrayList<>();\n        int row_top = 0,row_bottom = matrix.length-1,col_left = 0,col_right = matrix[0].length-1;\n        while (row_top < row_bottom && col_left < col_right){\n            for (int i = col_left; i < col_right; i++) {\n                ans.add(matrix[row_top][i]);\n            }\n            for (int i = row_top; i < row_bottom; i++) {\n                ans.add(matrix[i][col_right]);\n            }\n            for (int i = col_right; i > col_left ; i--) {\n                ans.add(matrix[row_bottom][i]);\n            }\n            for (int i = row_bottom; i > row_top; i--) {\n                ans.add(matrix[i][col_left]);\n            }\n            //换到内层\n            row_top++;\n            row_bottom--;\n            col_left++;\n            col_right--;\n        }\n        //特判。如果都相等，说明中间只有一个元素\n        if (row_top == row_bottom && col_left == col_right){\n            ans.add(matrix[row_top][col_right]);\n        }\n        else {\n            //一行\n            if (row_top == row_bottom){\n                for (int i = col_left; i <= col_right; i++) {\n                    ans.add(matrix[row_top][i]);\n                }\n            }\n            //一列\n            if (col_left == col_right){\n                for (int i = row_top; i <= row_bottom; i++) {\n                    ans.add(matrix[i][col_left]);\n                }\n            }\n        }\n\n        return ans;\n    }\n}\n```\n\n# 59 螺旋矩阵2（Medium）\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n\n![](../img/2024_3_25_4.png)\n> 这个比上面的更简单了，一个计数器，然后根据上面的逻辑转圈，每次都+1，就可以了，甚至没有中间是一行或者一列的情况，要不就是没有要不就只有一个。\n```java\nclass Solution {\n    public int[][] generateMatrix(int n) {\n        int[][] matrix = new int[n][n];\n        int count = 1;\n        int row_top = 0,row_bottom = matrix.length-1,col_left = 0,col_right = matrix[0].length-1;\n        while (row_top < row_bottom && col_left < col_right){\n            for (int i = col_left; i < col_right; i++) {\n                matrix[row_top][i] = count++;\n            }\n            for (int i = row_top; i < row_bottom; i++) {\n                matrix[i][col_right]= count++;\n            }\n            for (int i = col_right; i > col_left ; i--) {\n                matrix[row_bottom][i]= count++;\n            }\n            for (int i = row_bottom; i > row_top; i--) {\n                matrix[i][col_left]= count++;\n            }\n            row_top++;\n            row_bottom--;\n            col_left++;\n            col_right--;\n        }\n        if (row_top == row_bottom && col_left == col_right){\n            matrix[row_top][col_right]= count++;\n        }\n        else {\n            if (row_top == row_bottom){\n                for (int i = col_left; i <= col_right; i++) {\n                    matrix[row_top][i]= count++;\n                }\n            }\n            if (col_left == col_right){\n                for (int i = row_top; i <= row_bottom; i++) {\n                    matrix[i][col_left]= count++;\n                }\n            }\n        }\n        return matrix;\n    }\n}\n```","tags":["刷题笔记"]},{"title":"周赛2024-3-24","url":"/2024/03/24/周赛2024-3-24/","content":">陆陆续续这是第三次周赛，第一次是虚拟的我瞎写ac了两题，上一次也是ac两题因为起得太晚了。这次稍微一点点进步，ac两个半，第三题有思路但是暴力超时，是因为我没见过这种数据结构。\n\n> Hard就跳了吧\n\n# 第一题：每个字符最多出现两次的最长子字符串\n给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该 子字符串 的 最大 长度。\n\n示例 1：\n\n输入： s = \"bcbbbcba\"\n\n输出： 4\n\n解释：\n\n以下子字符串长度为 4，并且每个字符最多出现两次：\"bcbbbcba\"。\n>遍历每个字串，判断是否字符只出现两次\n```java\nclass Solution {\n    public int maximumLengthSubstring(String s) {\n        int max = 2;\n        for (int k = s.length(); k >=1; k--) {\n            for (int i = 0; i < s.length() - k; i++) {\n                String sub = s.substring(i,i+k+1);\n                //如果没有返回false\n                if (judge(sub)){\n                    max = Math.max(max,sub.length());\n                }\n            }\n        }\n        return max;\n    }\n    //判断字串是否只出现两次，用哈希表实现，如果哈希表超过2就返回false\n    public boolean judge(String s){\n        HashMap<Character,Integer> map = new HashMap<>();\n        boolean flag = true;\n        for (int i = 0; i < s.length(); i++) {\n            if (!map.containsKey(s.charAt(i))){\n                map.put(s.charAt(i),1);\n            }\n            else {\n                Integer integer = map.get(s.charAt(i));\n                if (integer >= 2){\n                    flag = false;\n                }\n                map.replace(s.charAt(i),integer+1);\n            }\n        }\n        return flag;\n    }\n\n}\n```\n# 第二题：执行操作使数据元素之和大于等于 K\n给你一个正整数 k 。最初，你有一个数组 nums = [1] 。\n\n你可以对数组执行以下 任意 操作 任意 次数（可能为零）：\n\n选择数组中的任何一个元素，然后将它的值 增加 1 。\n\n复制数组中的任何一个元素，然后将它附加到数组的末尾。\n\n返回使得最终数组元素之 和 大于或等于 k 所需的 最少 操作次数。\n\n\n\n示例 1：\n\n输入：k = 11\n\n输出：5\n\n解释：\n\n可以对数组 nums = [1] 执行以下操作：\n\n将元素的值增加 1 三次。结果数组为 nums = [4] 。\n复制元素两次。结果数组为 nums = [4,4,4] 。\n最终数组的和为 4 + 4 + 4 = 12 ，大于等于 k = 11 。\n执行的总操作次数为 3 + 2 = 5 。\n>数学题，假设+1的次数为x，复制的次数为y，要使得(y+1)*(x+1)>=n，而满足x+y最小\n\n>满足x+y+2最小其实也是满足x+y最小，那么就是开根号了，由基本不等式可得。\n \n>还有个问题就是这里的是整数，假如n=29开根号是5，这个时候用6 * 6=36就浪费了一次，只需要用5 * 6=30就可以，需要进行特殊判断\n\n>wa了一次，因为这里如果正好开根号，就直接返回x+y了，不需要-2\n```java\nclass Solution {\n    public int minOperations(int k) {\n        if (k ==1){\n            return 0;\n        }\n        int sqrt = (int) Math.sqrt(k);\n        if (k == sqrt*sqrt){\n            return sqrt*2-2;\n        }\n        else {\n            if (k <= sqrt *(sqrt+1)){\n                return sqrt+sqrt+1-2;\n            }\n            else {\n                return sqrt+1+sqrt+1-2;\n            }\n        }\n\n    }\n}\n```\n# 第三题：最高频率的 ID\n>高级的排序哈希集（TreeMap）不得不品\n> \n你需要在一个集合里动态记录 ID 的出现频率。给你两个长度都为 n 的整数数组 nums 和 freq ，nums 中每一个元素表示一个 ID ，对应的 freq 中的元素表示这个 ID 在集合中此次操作后需要增加或者减少的数目。\n\n增加 ID 的数目：如果 freq[i] 是正数，那么 freq[i] 个 ID 为 nums[i] 的元素在第 i 步操作后会添加到集合中。\n减少 ID 的数目：如果 freq[i] 是负数，那么 -freq[i] 个 ID 为 nums[i] 的元素在第 i 步操作后会从集合中删除。\n请你返回一个长度为 n 的数组 ans ，其中 ans[i] 表示第 i 步操作后出现频率最高的 ID 数目 ，如果在某次操作后集合为空，那么 ans[i] 为 0 。\n\n\n\n示例 1：\n\n输入：nums = [2,3,2,1], freq = [3,2,-3,1]\n\n输出：[3,3,2,2]\n\n解释：\n\n第 0 步操作后，有 3 个 ID 为 2 的元素，所以 ans[0] = 3 。\n第 1 步操作后，有 3 个 ID 为 2 的元素和 2 个 ID 为 3 的元素，所以 ans[1] = 3 。\n第 2 步操作后，有 2 个 ID 为 3 的元素，所以 ans[2] = 2 。\n第 3 步操作后，有 2 个 ID 为 3 的元素和 1 个 ID 为 1 的元素，所以 ans[3] = 2 。\n## 暴力超时\n>hashmap维护当前的频率，每次都对其进行最小值查找，时间复杂度o(n^2)\n```java\nclass Solution {\n    public long[] mostFrequentIDs(int[] nums, int[] freq) {\n        long[] ans = new long[nums.length];\n        HashMap<Integer,Long> hashMap = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (!hashMap.containsKey(nums[i])){\n                hashMap.put(nums[i], (long) freq[i]);\n            }\n            else {\n                long integer = hashMap.get(nums[i]);\n                hashMap.replace(nums[i],integer+freq[i]);\n            }\n            ans[i] = getMost(hashMap);\n        }\n        return ans;\n    }\n    //遍历哈希找最小值\n    public long getMost(HashMap<Integer,Long> hashMap){\n        long max = Long.MIN_VALUE;\n        for (Map.Entry<Integer,Long> entry : hashMap.entrySet()){\n            max = Math.max(max,entry.getValue());\n        }\n        return max;\n    }\n}\n```\n## TreeMap（重要）\n\n>TreeMap是索引为键的有序哈希表，从小到大排序，每次维护treemap只用从最后面找到就是最大值。\n\n>这里treemap存的是频率的频率，每当有更新的时候就对应频率的值-1，如果为0了就删除，然后在加上新的\n```java\nclass Solution {\n    public long[] mostFrequentIDs(int[] nums, int[] freq) {\n        long[] ans = new long[nums.length];\n        HashMap<Integer,Long> hashMap = new HashMap<>();\n        TreeMap<Long,Integer> treeMap = new TreeMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (!hashMap.containsKey(nums[i])){\n                hashMap.put(nums[i], (long) freq[i]);\n                //如果没有就默认为1，有就加上\n                treeMap.put((long) freq[i],treeMap.getOrDefault((long)freq[i],0)+1);\n            }\n            else {\n                long integer = hashMap.get(nums[i]);\n                if (treeMap.containsKey(integer)){\n                    int temp = treeMap.get(integer);\n                    if (temp == 1){\n                        //如果本来就只有1了，就移除\n                        treeMap.remove(integer);\n                    }\n                    else {\n                        //这里其实可以直接用put\n                        treeMap.replace(integer,temp-1);\n                    }\n                    treeMap.put(integer+freq[i],treeMap.getOrDefault(integer+freq[i],0)+1);\n                }\n                hashMap.replace(nums[i],integer+freq[i]);\n            }\n            ans[i] = treeMap.lastKey();\n        }\n        return ans;\n    }\n}\n```\n## [引申：前天的每日一题](./leetcode-2024-3-21.md)\n有一点相似\n","tags":["刷题笔记"]},{"title":"leetcode-2024-3-24","url":"/2024/03/24/leetcode-2024-3-24/","content":"# 323 零钱兑换(Medium)\n给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n\n计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。\n\n你可以认为每种硬币的数量是无限的。\n\n\n\n示例 1：\n\n输入：coins = [1, 2, 5], amount = 11\n\n输出：3\n\n解释：11 = 5 + 5 + 1\n>今天的每日一题在十天前做过，过一遍就不重新做了\n## 动态规划\n>dp数组存当前下标的钱可以用的最少兑换次数，如果用现在的零钱兑现不了，就为-1\n\n>dp[k] = min{dp[i]+dp[k-1-i]} 当且仅当dp[i]和dp[k-1-i]都不为-1\n> 但是如果这个本身就可以用零钱找开，就为1\n```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0){\n            return 0;\n        }\n        int[] dp = new int[amount+1];\n        for (int i = 0; i < coins.length; i++) {\n            if (coins[i] <= amount){\n                dp[coins[i]] = 1;\n            }\n        }\n        //System.out.println(Arrays.toString(dp));\n        for (int i = 1; i <= amount; i++) {\n            if (i != 1){\n                int head = 1;\n                int rear = i-1;\n                int min = Integer.MAX_VALUE;\n                //dp[k] = min{dp[i]+dp[k-1-i]} 当且仅当dp[i]和dp[k-1-i]都不为-1\n                while (head <= rear){\n                    if (dp[head] != -1 && dp[rear]!=-1 && dp[head] + dp[rear] < min){\n                        min = dp[head]+dp[rear];\n                    }\n                    //System.out.println(i+\":\"+dp[head] +\"  \"+ dp[rear]);\n                    head++;\n                    rear--;\n                }\n                //最小值没有改变，说明不能找的开\n                if (dp[i] == 0 && min == Integer.MAX_VALUE){\n                    dp[i] = -1;\n                }\n                //改变了就最小值\n                if (dp[i] == 0 && min != Integer.MAX_VALUE){\n                    dp[i] = min;\n                }\n                //如果这个本身就是1的话就不考虑，还是1\n            }\n            else {\n                if (dp[i] == 0){\n                    dp[i] = -1;\n                }\n            }\n        }\n        //System.out.println(Arrays.toString(dp));\n    \n        return dp[amount];\n    }\n}\n```\n\n# 238 除自身以外数组的乘积(Medium)\n给你一个整数数组 **nums**，返回 数组 **answer** ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。\n\n题目数据 **保证** 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。\n\n请 **不要使用除法**，且在 **O(n)** 时间复杂度内完成此题。\n\n## 偷懒方法（就是用了除法）\n>最简单方法，所有乘积起来，当前元素只要除掉这个就可以，遍历一次就可以。0的时候要特殊判断一下，这个时候还是傻方法，遍历其他的。\n\n```java\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int[] ans = new int[nums.length];\n        if (nums.length == 1){\n            return nums;\n        }\n        else if (nums.length > 1){\n            int sum = nums[0];\n            //乘起来\n            for (int i = 1; i < nums.length; i++) {\n                sum *=nums[i];\n            }\n            \n            for (int i = 0; i < nums.length; i++) {\n                if (nums[i] != 0){\n                    ans[i] = sum /nums[i];\n                }\n                //如果是0特判\n                else {\n                    int front = i-1;\n                    int next = i+1;\n                    int anss = 1;\n                    while (front >=0){\n                        anss*=nums[front];\n                        front--;\n                    }\n                    while (next <=nums.length-1){\n                        anss*=nums[next];\n                        next++;\n                    }\n                    ans[i] = anss;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n## 官方解：左右乘积列表\n>维护两个数组，L[i]是当前元素i左边的乘积，R[i]是i右边的乘积，返回的数组就是L[i]*R[i]，每次都是o（n）\n\n```java\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int[] L = new int[nums.length];\n        int[] R = new int[nums.length];\n        int[] ans = new int[nums.length];\n        L[0] = 1;\n        R[nums.length-1] = 1;\n        for (int i = 1; i < nums.length; i++) {\n            L[i] = L[i-1]*nums[i-1];\n        }\n        for (int j = nums.length-2; j >=0 ; j--) {\n            R[j] = R[j+1]*nums[j+1];\n        }\n        for (int i = 0; i < nums.length; i++) {\n            ans[i] = L[i] * R[i];\n        }\n        return ans;\n    }\n}\n```\n# 11 盛最多水的容器(Medium)\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n返回容器可以储存的最大水量。\n![](../img/2024_3_24_1.png)\n## 暴力超时\n>遍历找最小\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        int max = Integer.MIN_VALUE;\n        for (int i = 0; i < height.length-1; i++) {\n            for (int j = i+1; j < height.length; j++) {\n                max = Math.max(max,(j-i)*Math.min(height[j],height[i]));\n            }\n        }\n        return max;\n    }\n}\n```\n## 官方解：双指针\n>感觉证明有待考察，初始左右指针一个在左边一个在右边，每次移动比较小的就可以找到。\n\n![](../img/2024_3_24_2.png)\n![](../img/2024_3_24_3.png)\n>简单理解为什么移动小的，因为本来就是取较小的，移动大的话铁定没之前大，因为距离缩短了1，移动小的还可能碰到大的使原来的变大。\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        int head = 0;\n        int rear = height.length-1;\n        int max = Integer.MIN_VALUE;\n        while (head < rear){\n            int length = rear-head;\n            max = Math.max(max,length*Math.min(height[head],height[rear]));\n            if (height[head]<height[rear]){\n                head++;\n            }\n            else if (height[head]>height[rear]){\n                rear--;\n            }\n            else {\n                head++;\n            }\n        }\n        return max;\n    }\n}\n```","tags":["刷题笔记"]},{"title":"短期的小目标吧","url":"/2024/03/23/短期的小目标吧/","content":"这几天晚上睡不好，总在想自己保研了但是感觉也不是很开心。同专业的同学们陆陆续续出成绩，一看考本校的寥寥无几，顿时觉得自己保研好像也没什么了不起的。\n\n总不可能一直麻痹自己，说我这两个月去做了什么事情都没干的实习，说去给学校打工赚了一些小钱。如何将这些东西变现才是最重要的，要不然我会一直不平衡。\n\n我打算先把黑马头条那个项目狠狠重新搞一下，南方电网的也好好包装一下。\n\n说实话，我对Redis和MongoDB和Kafka都挺感兴趣的，每天保持刷题的同时我也想多看看这方面的八股文。\n\n暑假可以先去试试水，没有就好好安心搞12306那个微服务项目。\n\n![](../img/IMG_8928.JPG)","tags":["闲谈"]},{"title":"leetcode-2024-3-23","url":"/2024/03/23/leetcode-2024-3-23/","content":"# 2549 统计桌面上的不同数字(Easy)\n给你一个正整数 n ，开始时，它放在桌面上。在 10^9 天内，每天都要执行下述步骤：\n\n对于出现在桌面上的每个数字 x ，找出符合 1 <= i <= n 且满足 x % i == 1 的所有数字 i 。\n然后，将这些数字放在桌面上。\n返回在 10^9 天之后，出现在桌面上的 不同 整数的数目。\n\n>简单题重拳出击\n\n## 正常解\n\n>发现可以进行递归，假设n=7，那么第一次递归就是6和3，因为7%3=1，7%6=1，那么怎么样解决重复的问题呢，用一个set就好了。\n\n```java\n//去重\nHashSet<Integer> hashSet = new HashSet<>();\npublic int distinctIntegers(int n) {\n    dp(n);\n    //最后返回唯一集合的长度就行\n    return hashSet.size();\n}\npublic void dp(int n){\n    hashSet.add(n);\n    for (int i = n-1; i >=1; i--) {\n        //遍历进行递归\n        if (n % i ==1){\n            distinctIntegers(i);\n        }\n    }\n}\n```\n\n那是比不上最快点方法的，其实找规律直接出来就是n-1，我这个方法还算是有点编程的，自然速度快不过那些n-1的\n\n# 146 LRU缓存（Medium）非常重要这道题\n\n实现LRU算法，**关键是要时间复杂度和空间都是o（1）**\n\n>虽然从前在os上还是手搓过这个算法的，但是这里要用常数的复杂度。\n\n>那必然是要哈希，但是哈希还不够，在搜寻在队列里面的时候必然还是要遍历，这个时候就要想到另一种数据结构，链表\n> 这里为什么用双向链表，因为前驱还是要找的，总不能每次都去遍历吧，那还是浪费一点空间吧。\n## 哈希表+双向链表\n```java\nclass LRUCache{\n    //双向链表数据结构\n    class LinkNode{\n        int key;\n        int value;\n        //前驱\n        LinkNode front = null;\n        //后继\n        LinkNode behind = null;\n        LinkNode(int key,int value){\n            this.key = key;\n            this.value = value;\n        }\n        LinkNode(){}\n    }\n    //容量\n    private int capacity;\n    //维护首尾指针\n    private LinkNode head,tail;\n    //记录链表长度\n    private int linkSize = 0;\n    //哈希表来根据键找到链表的具体位置\n    private HashMap<Integer,LinkNode> hashMap = new HashMap<>();\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        head = new LinkNode();\n        tail = new LinkNode();\n    }\n    \n    public int get(int key) {\n        if (hashMap.containsKey(key)){\n            LinkNode linkNode = hashMap.get(key);\n            moveToHead(linkNode);\n            return linkNode.value;\n        }\n        else {\n            return -1;\n        }\n    }\n    \n    public void put(int key, int value) {\n        //如果没到容量，就不涉及释放位置\n        if (linkSize < capacity){\n            //如果map没有\n            if (!hashMap.containsKey(key)){\n                LinkNode linkNode = new LinkNode(key,value);\n                //头插法\n                handleInsert(linkNode);\n                linkSize++;\n                //保存这个节点\n                hashMap.put(key,linkNode);\n            }\n            else {\n                LinkNode linkNode = hashMap.get(key);\n                linkNode.value = value;\n                moveToHead(linkNode);\n                hashMap.replace(key,linkNode);\n            }\n        }\n        else {\n            if (!hashMap.containsKey(key)){\n                int removeKey = handleRemove();\n                hashMap.remove(removeKey);\n                LinkNode linkNode = new LinkNode(key,value);\n                handleInsert(linkNode);\n                hashMap.put(key,linkNode);\n            }\n            else {\n                LinkNode linkNode = hashMap.get(key);\n                linkNode.value = value;\n                moveToHead(linkNode);\n                hashMap.replace(key,linkNode);\n            }\n        }\n    }\n\n    /**\n     * 头插法\n     * @param linkNode 插入的节点\n     */\n    public void handleInsert(LinkNode linkNode){\n        LinkNode temp = head.behind;\n        //如果这是第一个节点，尾指针一直挂在这个元素上，直到被提起来rear再变\n        if (temp != null){\n            linkNode.behind = temp;\n            head.behind = linkNode;\n            temp.front = linkNode;\n            linkNode.front = head;\n        }\n        //如果不是第一个，那就头插法\n        else {\n            head.behind = linkNode;\n            linkNode.front = head;\n            tail = linkNode;\n        }\n    }\n\n    /**\n     * 出队，移动尾指针即可\n     * @return 返回尾元素的键\n     */\n    public int handleRemove(){\n        int ans = tail.key;\n        tail = tail.front;\n        tail.behind = null;\n        return ans;\n    }\n\n    /**\n     * 更新在队首\n     * @param linkNode\n     */\n    public void moveToHead(LinkNode linkNode){\n        //也就是在末尾的时候\n        if (linkNode.behind == null){\n            tail = linkNode.front;\n            linkNode.front.behind = null;\n            linkNode.front = null;\n            handleInsert(linkNode);\n\n        }\n        else {\n            LinkNode left = linkNode.front;\n            LinkNode right = linkNode.behind;\n            left.behind = right;\n            right.front = left;\n            linkNode.front = null;\n            linkNode.behind = null;\n            handleInsert(linkNode);\n        }\n    }\n}\n\n```\n\n大同小异这些答案，主要还是哈希+双向\n\n# 283 移动零(Easy)\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n\n示例 1:\n\n输入: nums = [0,1,0,3,12]\n\n输出: [1,3,12,0,0]\n\n>没什么好说的这个题\n\n## 直接插入排序思想\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        for (int i = nums.length-2; i >=0; i--) {\n            if (nums[i] == 0){\n                int j=i+1;\n                while (j <= nums.length-1&&nums[j] != 0  ){\n                    nums[j-1] = nums[j];\n                    j++;\n                }\n                nums[j-1] = 0;\n            }\n        }\n    }\n}\n```\n\n# 236.二叉树的最近公共祖先(Medium)\n题目意思就是字面意思\n>这个题居然还没有考研那段时间做得好，这里思路就是找到这两个节点的路径序列，然后找到最近的那个重复元素就完事。\n## 2024.3.23\n```java\nclass Solution {\n    List<TreeNode> list1 = new ArrayList<>();\n    List<List<TreeNode>> list = new ArrayList<>();\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        hxbl(root,p);\n        hxbl(root,q);\n        \n        return findSame(list.get(0),list.get(1));\n    }\n\n    /**\n     * 标准的（+left+{}+right+)结构\n     * @param root\n     * @param target\n     */\n    public void hxbl(TreeNode root,TreeNode target){\n    \n        list1.add(root);\n        if (root.val == target.val){\n        \n            list.add(new ArrayList<>(list1));\n        }\n    \n        if (root.left != null){\n            hxbl(root.left,target);\n        }\n        if (root.right != null){\n            hxbl(root.right,target);\n        }\n        list1.remove(list1.size()-1);\n\n    }\n\n    /**\n     * 找到这两个序列的最近元素，要从后往前，碰到了就break\n     * @param list1\n     * @param list2\n     * @return\n     */\n    public TreeNode findSame(List<TreeNode> list1, List<TreeNode> list2){\n        for (int i = list1.size()-1; i >=0; i--) {\n            for (int j = list2.size()-1; j >=0; j--) {\n                if (list1.get(i).val == list2.get(j).val){\n                    return list1.get(i);\n                }\n            }\n        }\n        return null;\n    }\n    \n}\n```\n\n## 2023.8.3\n\n```java\nclass Solution {\n    List<TreeNode> treeList = new ArrayList<>();\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        find(root,p);\n        List<TreeNode> treeList1 = new ArrayList<>(treeList);\n        treeList = new ArrayList<>();\n        find(root,q);\n        List<TreeNode> treeList2 = new ArrayList<>(treeList);\n        boolean flag = true;\n        if (treeList1.size()>treeList2.size()){\n            flag = false;\n        }\n        for (int i = 0;i<Math.max(treeList1.size(),treeList2.size());i++){\n            if (!flag && treeList2.contains(treeList1.get(i))){\n                return treeList1.get(i);\n            }\n            if (flag && treeList1.contains(treeList2.get(i))){\n                return treeList2.get(i);\n            }\n        }\n        return null;\n    }\n    \n    public boolean find(TreeNode root,TreeNode p){\n          if (root!=null){\n              boolean left = find(root.left,p);\n              boolean right = find(root.right,p);\n              if (root == p||left||right){\n                  treeList.add(root);\n                  return true;\n              }\n              else return false;\n          }\n          else {\n              return false;\n          }\n    }\n}\n```","tags":["刷题笔记"]},{"title":"leetcode-2024-3-21","url":"/2024/03/21/leetcode-2024-3-21/","content":"# 2671 频率跟踪器(Medium)\n请你设计并实现一个能够对其中的值进行跟踪的数据结构，并支持对频率相关查询进行应答。\n\n实现 FrequencyTracker 类：\n\nFrequencyTracker()：使用一个空数组初始化 FrequencyTracker 对象。\n\nvoid add(int number)：添加一个 number 到数据结构中。\n\nvoid deleteOne(int number)：从数据结构中删除一个 number 。数据结构 可能不包含 number ，在这种情况下不删除任何内容。\n\nbool hasFrequency(int frequency): 如果数据结构中存在出现 frequency 次的数字，则返回 true，否则返回 false。\n\n\n示例 1：\n\n输入\n\n[\"FrequencyTracker\", \"add\", \"add\", \"hasFrequency\"]\n\n[[], [3], [3], [2]]\n\n输出\n\n[null, null, null, true]\n\n解释\n\nFrequencyTracker frequencyTracker = new FrequencyTracker();\n\nfrequencyTracker.add(3); // 数据结构现在包含 [3]\n\nfrequencyTracker.add(3); // 数据结构现在包含 [3, 3]\n\nfrequencyTracker.hasFrequency(2); // 返回 true ，因为 3 出现 2 次\n\n## 双哈希\n>一个用来存频率，一个用来存频率的频率\n```java\npublic class FrequencyTracker {\n    private HashMap<Integer,Integer> hashMap;\n    private TreeMap<Integer,Integer> treeMap;\n\n    public FrequencyTracker() {\n        hashMap = new HashMap<>();\n        treeMap = new TreeMap<>();\n    }\n\n    public void add(int number) {\n        if (!hashMap.containsKey(number)){\n            hashMap.put(number,1);\n            treeMap.put(1,treeMap.getOrDefault(1,0)+1);\n        }\n        else {\n            Integer integer = hashMap.get(number);\n            hashMap.put(number,integer+1);\n            if (treeMap.containsKey(integer)){\n                int count = treeMap.get(integer);\n                if (count == 1){\n                    treeMap.remove(integer);\n                }\n                else{\n                    treeMap.replace(integer,count-1);\n                }\n                treeMap.put(integer+1,treeMap.getOrDefault(integer+1,0)+1);\n            }\n        }\n    }\n\n    public void deleteOne(int number) {\n\n        if (hashMap.containsKey(number)){\n            int i1 = hashMap.get(number);\n            int temp = treeMap.get(i1);\n            if (temp == 1){\n                treeMap.remove(i1);\n            }\n            else {\n                treeMap.replace(i1,temp-1);\n            }\n            if (i1-1 !=0){\n                if (treeMap.containsKey(i1-1)){\n                    treeMap.put(i1-1,treeMap.get(i1-1)+1);\n                }\n                else {\n                    treeMap.put(i1-1,1);\n                }\n            }\n\n            if (i1 == 1){\n                hashMap.remove(number);\n            }\n            else {\n                hashMap.put(number,i1-1);\n            }\n\n        }\n    }\n\n    public boolean hasFrequency(int frequency) {\n\n        if (treeMap.containsKey(frequency)){\n            int temp = treeMap.get(frequency);\n            if (temp > 0){\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        FrequencyTracker frequencyTracker = new FrequencyTracker();\n\n        frequencyTracker.add(2);\n\n        frequencyTracker.add(7);\n\n        frequencyTracker.add(7);\n        frequencyTracker.add(3);\n        frequencyTracker.add(3);\n\n        frequencyTracker.deleteOne(7);\n        frequencyTracker.deleteOne(7);\n        System.out.println(frequencyTracker.hasFrequency(2));\n        System.out.println(frequencyTracker.hasFrequency(1));\n    }\n\n}\n\n```","tags":["刷题笔记"]},{"title":"redis实现分布式锁-初见分布式锁","url":"/2024/03/20/redis实现分布式锁-初见分布式锁/","content":"# 什么是分布式锁\n\n分布式锁是控制分布式系统之间同步访问共享资源的一种方式，通过互斥来保持一致性。\n\n了解分布式锁之前先了解下线程锁和进程锁：\n\n**线程锁**：主要用来给方法、代码块加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，比如Synchronized、Lock等\n\n**进程锁**：控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁\n\n比如Golang语言中的sync包就提供了基本的同步基元，如互斥锁\n\n但是以上两种适合在单体架构应用，但是分布式系统中多个服务节点，多个进程分散部署在不同节点机器中，此时对于资源的竞争，上诉两种对节点本地资源的锁就无效了。\n\n这个时候就需要分布式锁来对分布式系统多进程访问资源进行控制，因此分布式锁是为了解决分布式互斥问题！\n\n![img.png](../img/2024_3_20_2.png)\n","tags":["Redis"]},{"title":"leetcode-2024-3-20","url":"/2024/03/20/leetcode-2024-3-20/","content":"# 1969.数组元素的最小非零乘积（Medium）\n给你一个正整数 **p** 。你有一个下标从 **1** 开始的数组 **nums** ，这个数组包含范围 [1, 2p - 1] 内所有整数的二进制形式（两端都 **包含**）。你可以进行以下操作 **任意** 次：\n\n从 nums 中选择两个元素 x 和 y  。\n选择 x 中的一位与 y 对应位置的位交换。对应位置指的是两个整数 相同位置 的二进制位。\n比方说，如果 x = 11**0**1 且 y = 00**1**1 ，交换右边数起第 2 位后，我们得到 x = 11**1**1 和 y = 00**0**1 。\n\n请你算出进行以上操作 **任意次** 以后，nums 能得到的 **最小非零** 乘积。将乘积对 109 + 7 取余 后返回。\n\n注意：答案应为取余 **之前** 的最小值。\n\n> ~~自己没想出来~~，其实有思路了就是总感觉不对劲，看了答案如果继续想应该能想出来，但是问题是这个取余肯定也会困扰我很久，还有我肯定只会暴力求幂，这里的**快速幂**其实是很值得学习一下的\n\n## 官方解：贪心+快速幂\n\n>   x * y肯定是要比(x-1) * (y+1)大的，那么什么时候会有最小值呢，就是当x=1，y变得最大的时候，对于都是二进制来说，能通过交换位来变大只能是x=1,y=2^(p-1)-2了，比如3位的时候，最小就是1，最大就是6，要保持x和y互为**反码**\n\n>那这道题就是一个纯数学问题了，每次取两个互为**反码**的数都能将其变成x=1，y=2^p-2，那么一共有多少对这样的反码对呢。\n>n=(2^p-2)/2，除了最后面那个数其他都可以凑对，就有2^(p-1)-1对。\n> p=3的时候，就有3对，p=4时，就有7对\n \n>也就是说，我们的最终答案是**最后一个元素*（最后一个元素-1）^(2^(p-1)-1)**\n> 即：![](../img/2024-3-20-1.png)\n\n>**快速幂**：通过观察 ***p=3的时候，就有3对，p=4时，就有7对***，可以发现3就是11，7就是111，根据幂的公式x^(111)=x^(100)*x^(010)*x^(001),\n> 答案里巧妙地用快速幂解决，也就是说，不再是暴力连乘，而是x也自己进行幂运算，就可以将复杂度降为o(log)\n\n```java\nprivate static final int MOD = 1_000_000_007;\n//这里的p就是已经log后的，一共有几位，每一位都循环一次\nprivate long pow(long x, int p) {\n    x %= MOD;\n    long res = 1;\n    while (p-- > 0) {\n        res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\npublic int minNonZeroProduct(int p) {\n    //移位，1L是long单位下的1，将其像左边移动p位\n    //得到的k就是最后一个元素\n    long k = (1L << p) - 1;\n    //最后一个元素*（最后一个元素-1）^(2^(p-1)-1)\n    return (int) (k % MOD * pow(k - 1, p - 1) % MOD);\n}\n```\n\n没想出来这种方法，贪心还是练习少了\n\n# 49.字母异位词分组（Medium）\n\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n\n示例 1:\n\n输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\n## 自己解（也是官方解）：哈希表+排序\n\n>遍历每个字符串，然后在对其排序，如果哈希表没有就加进去，list把这个排序之前的字符串放进去，有就在哈希表已有的键里面添加这个字符串。\n\n```java\npublic List<List<String>> groupAnagrams(String[] strs) {\n    HashMap<String,List<String>> hashMap = new HashMap<>();\n    List<List<String>> ans = new ArrayList<>();\n    for (String s:strs){\n        String temp = getAllStr(s);\n        //如果表里没有就新增键值对\n        if (!hashMap.containsKey(temp)){\n            List<String> list = new ArrayList<>();\n            list.add(s);\n            hashMap.put(temp,list);\n        }\n        //有就在末尾添加\n        else {\n            List<String> list = hashMap.get(temp);\n            list.add(s);\n            hashMap.replace(temp,list);\n        }\n    }\n    //遍历map存在list中\n    for (Map.Entry<String,List<String>> entry : hashMap.entrySet()){\n        ans.add(entry.getValue());\n    }\n    return ans;\n}\n//字符串变成char数组，排序，这样就能得到唯一\npublic String getAllStr(String s){\n    char[] temp = s.toCharArray();\n    Arrays.sort(temp);\n    return Arrays.toString(temp);\n}\n```\n\n比较简单\n\n# 128.最长连续序列（Medium）\n\n给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n\n请你设计并实现时间复杂度为 **(n)** 的算法解决此问题。\n\n示例 1：\n\n输入：nums = [100,4,200,1,3,2]\n\n输出：4\n\n解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n\n## 暴力解：（其实是超时的，因为复杂度为o(nlogn)）\n\n> 最傻逼的一集，这里**Arrays.sort**就已经超出复杂度了，但是居然也没超时，甚至比超过90%，感觉有点。\n\n> 最简单的思路，排序然后指针，从小到大如果一直递增就计数器一直加，如果相等那就计数器不动，如果不是，那就计数器重新变为1 \n```java\npublic int longestConsecutive(int[] nums) {\n    if (nums == null){\n        return 0;\n    }\n    //搞笑的排序\n    Arrays.sort(nums);\n    int count = 1;\n    int max = 1;\n    for (int i = 1; i < nums.length; i++) {\n        //当且仅当当前元素是之前元素的多1\n        if (nums[i]==nums[i-1]+1){\n            count++;\n        }\n        //如果相等计数器空过\n        else if (nums[i] == nums[i-1]) {\n\n        }\n        //如果不是这样的情况就不是连续，计数器变成1\n        else {\n            count = 1;\n        }\n        max = Math.max(max,count);\n        System.out.println(count);\n    }\n\n    return max;\n}\n```\n\n## 官方解：哈希表\n\n>我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 x+1,x+2... 是否存在，假设最长匹配到了 x+y，那么以 x 为起点的最长连续序列即为 x,x+1,x+2,x+y，其长度为 y+1，我们不断枚举并更新答案即可。\n\n>对于匹配的过程，暴力的方法是 O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。\n\n>仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n2)\n即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x,x+1,x+2,⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。\n\n>那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。\n\n```java\npublic int longestConsecutive(int[] nums) {\n    Set<Integer> num_set = new HashSet<Integer>();\n    //先去重，用集合\n    for (int num : nums) {\n        num_set.add(num);\n    }\n\n    int longestStreak = 0;\n    //有下一个值的时候就跳掉，一定要没有下一个，这样遍历才是o(n)\n    for (int num : num_set) {\n        if (!num_set.contains(num - 1)) {\n            int currentNum = num;\n            int currentStreak = 1;\n            //然后比较一下\n            while (num_set.contains(currentNum + 1)) {\n                currentNum += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\n```\n\n非常巧妙的o(n),这里set查询是o(1)，需要好好学习一下，多用用哈希","tags":["刷题笔记"]},{"title":"leetcode-2024-3-19","url":"/2024/03/19/leetcode-2024-3-19/","content":"# 1793.好子数组的最大分数（Hard）\n\n给你一个整数数组 nums （下标从 0 开始）和一个整数 k 。\n\n一个子数组 (i, j) 的 **分数** 定义为 min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1) 。一个 好 子数组的两个端点下标需要满足 i <= k <= j 。\n\n请你返回 **好** 子数组的最大可能 **分数** 。\n\n## 暴力解：超出内存限制\n\n> 思路：用一个二维数组，dp[i][j]表示num[i]到num[j]的最小值，起始dp[i][i]都为num[i],状态转移方程为：dp[i][j] = min{dp[i][j-1],num[i]},\n> 其实是可以做出来的。但是这是hard，空间复杂度要求有点高，就会超内存。我的评价是动态规划很好，下次别用了\n\n```java\npublic int maximumScore(int[] nums, int k) {\n    //二维动态规划\n    int[][] dp = new int[nums.length][nums.length];\n    //初始对角线都为自身，自己肯定是最小值\n    for (int i = 0; i < nums.length; i++) {\n        dp[i][i] = nums[i];\n    }\n    for (int i = 0; i < nums.length-1; i++) {\n        for (int j = i+1; j < nums.length; j++) {\n            //动态转移方程\n            dp[i][j] = Math.min(nums[j], dp[i][j - 1]);\n        }\n    }\n    //k要在中间，那么就是矩阵的右上角那块，i<=k<=j\n    int max = Integer.MIN_VALUE;\n    for (int i = 0; i <= k; i++) {\n        for (int j = k; j < nums.length; j++) {\n            int length = j-i+1;\n            max = Math.max(max,length*dp[i][j]);\n        }\n    }\n    //返回在右上角的最大值\n    return max;\n}\n```\n## 官方解 ：双指针\n> 以k为原点，head=k-1，rear=k+1，左开右开区间，数据长度rear-head+1，初始时长度只有1即为nums[k]本身，也为最小值。\n> 那么怎么样找包含他的最小值呢，只要找左右两边比他大的，整体的最小值就是不变的，那么长度*最小值就会有效变大，直到双指针遇到比当前最小值还要小的元素\n> 那么由于初始最小值就是本身，那么只要循环本身这个值不断递减就可以了。\n```java\npublic int maximumScore(int[] nums, int k) {\n    int length = nums.length;\n    int head = k-1,rear = k+1;\n    int max = Integer.MIN_VALUE;\n    for (int i = nums[k];;i--){\n        while (head >=0 && nums[head] >= i){\n            head--;\n        }\n        while (rear < nums.length && nums[rear] >= i){\n            rear++;\n        }\n        max = Math.max(max,(rear-head-1)*i);\n        if (head == -1 && rear == length){\n            break;\n        }\n    }\n    return max;\n}\n```\n复杂度分析\n\n时间复杂度：O(n+C)，其中 n 是数组nums 的长度，C 是数组 nums 中元素的范围。\n\n空间复杂度：O(1)。明显比我自己写的暴力解好\n\n","tags":["刷题笔记"]},{"title":"我的第一篇blog","url":"/2024/03/19/我的第一篇blog/","content":"  做这个博客的目的是为了能激励自己，不要看了一遍就觉得自己会了。好记性不如烂笔头，刷题的思路尽量多写，很难说下次碰到一样的题目会不会忘掉。\n\n  还有25天蓝桥杯，让我这个大四老狗随便得个奖吧~~\n\n  ![上海外国语大学校花](../img/2024_3_19_1.JPG)\n","tags":["闲谈"]}]