[{"title":"leetcode-2024-3-28","url":"/2024/03/28/leetcode-2024-3-28/","content":"> 今天斗胆试了一下蓝桥杯的题，实在是感觉太难了，不暴力根本不会做，以后有机会再写题解吧。\n> \n> 我觉得这种程序设计竞赛还是得好好研究算法才行，我这种野路子还有很长一段路要走\n# 1997 访问完所有房间的第一天（Medium）\n你需要访问 n 个房间，房间从 0 到 n - 1 编号。同时，每一天都有一个日期编号，从 0 开始，依天数递增。你每天都会访问一个房间。\n\n最开始的第 0 天，你访问 0 号房间。给你一个长度为 n 且 下标从 0 开始 的数组 nextVisit 。在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定：\n\n- 假设某一天，你访问 i 号房间。\n- 如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间，其中 0 <= nextVisit[i] <= i 。\n- 如果算上本次访问，访问 i 号房间的次数为 偶数 ，那么 第二天 需要访问 (i + 1) mod n 号房间。\n\n请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 109 + 7 取余后的结果\n## 暴力超时：简陋的动态规划\n> 虽然超时了但是思路跟答案是一样的。\n>\n> 分析题意发现 nextVisited[i]的范围属于 [0,i]，意味着当你首次到达房间 i 时会回退到房间 nextVisited[i]。而只有访问过该房间偶数次时才会到达下一个房间，进而推断出到达 i 时，[0,i)的房间已经被访问过偶数次。\n\n>定义 f[i] 表示从奇数次到房间 i，到奇数次到达房间 i+1 所需要的天数。以下用 to 代表 nextVisited[i]，回退到房间 to 时是奇数次访问，又需要花费 f[to] 才会到达房间 to+1。从 iii 访问 to 和 i+1 又分别需要花费一天，所以有转移方程:\n\n$$\nf[i] = \\sum\\limits_{j=to}^{i-1}f[j]+2\n$$\n![](../img/2024_3_28_1.PNG)\n```java\nclass Solution {\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\n        int[] dp = new int[nextVisit.length];\n        int MOD = 1000000007;\n        for (int i = 0; i < nextVisit.length; i++) {\n            //第一次进来然后去nextVisited[i]，第二次回来才变成偶数\n            int temp = 2;\n            //访问到nextVisited[i]，把之后所有的都会再访问一遍，全部都加起来\n            for (int j = nextVisit[i]; j < i; j++) {\n                temp = (dp[j]+temp)%MOD;\n            }\n            dp[i] = temp;\n        }\n        int ans = 0;\n        //dp存放的只是这个节点的次数，要总体的还要全部加起来\n        for (int i = 0; i < nextVisit.length-1; i++) {\n            ans=(dp[i]+ans)%MOD;\n        }\n        return ans;\n    }\n\n}\n```\n时间复杂度o(n^2)，那肯定暴力超时\n## 优化版：前缀和\n定义前缀和\n$$\ns[0]=0,s[i+1] = \\sum\\limits_{j=0}^{i}f[i]\n$$\n\n对于\n$$\nf[i] = \\sum\\limits_{j=to}^{i-1}f[j]+2\n$$\n可以化简为\n$$\nf[i] = 2+s[i]-s[j]\n$$\n对于前缀和 s，有如下递推式\n$$\ns[i+1] = 2*s[i]-s[j]+2\n$$\n这样我们就不用计算原先的dp数组，通过前缀和就得到答案。\n\n```java\nclass Solution {\n    public int firstDayBeenInAllRooms(int[] nextVisit) {\n        final long MOD = 1_000_000_007;\n        int n = nextVisit.length;\n        long[] s = new long[n];\n        for (int i = 0; i < n - 1; i++) {\n            int j = nextVisit[i];\n            s[i + 1] = (s[i] * 2 - s[j] + 2 + MOD) % MOD; // + MOD 避免算出负数\n        }\n        return (int) s[n - 1];\n    }\n}\n```\n\n# 221 最大正方形（Medium）\n\n在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。\n![](../img/2024_3_28_3.png)\n> 由于是在上课的时候看的，没有自己动手写，直接看的答案。我估计自己写也是智能暴力解法\n## 二维动态规划\n> 有点像“编辑距离”和某一天的那个截木块的每日一题，$dp[i][j]$表示以这个点为右下角的最大正方形的边长，那么如果$matrix[i][j]=0$，那dp肯定也为0，我们考虑为1的情况。\n> \n> 这里的状态转移方程是\n> $$\n> dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1\n> $$\n> ![](../img/2024_3_28_2.png)\n\n```java\nclass Solution {\n    public int maximalSquare(char[][] matrix) {\n        int[][] dp = new int[matrix.length][matrix[0].length];\n        int ans = 0;\n        for (int i = 0; i < dp.length; i++) {\n            for (int j = 0; j < dp[0].length; j++) {\n                if (i != 0 || j !=0){\n                    if (matrix[i][j] == '1'){\n                        int left = 0,up = 0,up_left = 0;\n                        if (i-1 >= 0){\n                            up = dp[i-1][j];\n                        }\n                        if (j-1 >=0){\n                            left = dp[i][j-1];\n                        }\n                        if (i-1 >=0 && j-1>=0){\n                            up_left = dp[i-1][j-1];\n                        }\n                        dp[i][j] = Math.min(Math.min(left,up),up_left)+1;\n                        ans = Math.max(ans,dp[i][j]);\n                    }\n                }\n                else {\n                    if (matrix[i][j] == '1'){\n                        dp[i][j] = 1;\n                        ans = Math.max(ans,dp[i][j]);\n                    }\n                    else {\n                        dp[i][j] = 0;\n                    }\n                }\n\n            }\n        }\n        //System.out.println(Arrays.deepToString(dp));\n        return ans*ans;\n    }\n}\n```\n","tags":["刷题笔记"]},{"title":"leetcode-2024-3-27","url":"/2024/03/27/leetcode-2024-3-27/","content":"# 2580 统计将重叠区间合并成组的方案数（Medium）\n\n给你一个二维整数数组 ranges ，其中 ranges[i] = [starti, endi] 表示 starti 到 endi 之间（包括二者）的所有整数都包含在第 i 个区间中。\n\n你需要将 ranges 分成 两个 组（可以为空），满足：\n\n每个区间只属于一个组。\n两个有 交集 的区间必须在 同一个 组内。\n如果两个区间有至少 一个 公共整数，那么这两个区间是 有交集 的。\n\n比方说，区间 [1, 3] 和 [2, 5] 有交集，因为 2 和 3 在两个区间中都被包含。\n请你返回将 ranges 划分成两个组的 总方案数 。由于答案可能很大，将它对 109 + 7 取余 后返回。\n\n\n\n示例 1：\n\n输入：ranges = [[6,10],[5,15]]\n输出：2\n解释：\n两个区间有交集，所以它们必须在同一个组内。\n所以有两种方案：\n- 将两个区间都放在第 1 个组中。\n- 将两个区间都放在第 2 个组中。\n\n## 区间合并+组合数\n> 思路是将里面的区间先合并，得到长度。然后就相当于两个桶子，最终的结果为组合数相加，也就是一个杨辉三角，那么一行的总数就是2^n\n\n![](../img/2024_3_27_1.png)\n\n> 区间合并：设置一个动态数组，首先按照左括号排序，接着从后往前遍历，如果两个区间存在重合，就把后面的删除，前面的改成合并以后的新区间。\n>\n> 这样主要是可以避免下标的影响，从前面遍历删除会乱序号\n> \n> 但是这样还不够，比如这个例子[[2,3],[4,5],[6,7],[8,9],[1,10]]，排序以后[[1,10],[2,3],[4,5],[6,7],[8,9]]，这样以来排序也没用，结果是[[1,10],[4,5],[6,7],[8,9]]，面对这种情况需要多循环几次，每次减少1个，当长度不再变化的时候就停止\n```java\nclass Solution {\n    public int countWays(int[][] ranges) {\n        int MOD = 1000000007;\n        int length = merge(ranges).length;\n        int ans = 1;\n        for (int i = 0; i < length; i++) {\n            ans = ans *2%MOD;\n        }\n        return ans;\n    }\n\n    /**\n     * 合并区间的代码\n     * @param intervals\n     * @return\n     */\n    public int[][] merge(int[][] intervals){\n        int[][] temp1 = mergeTemp(intervals);\n        int[][] temp2 = mergeTemp(temp1);\n        while (temp1.length != temp2.length){\n            temp1 = mergeTemp(temp2);\n            temp2 = mergeTemp(temp1);\n        }\n        return temp1;\n    }\n    public int[][] mergeTemp(int[][] intervals) {\n        //先排序\n        Arrays.sort(intervals, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if(o1[0]==o2[0]){\n                    return o1[1] - o2[1];\n                }\n                return o1[0] - o2[0];\n            }\n        });\n        List<int[]> arrList = new ArrayList<>();\n        int rear = intervals.length-1;\n        for (int[] interval : intervals) {\n            arrList.add(interval);\n        }\n        while (rear > 0){\n            int[] front = arrList.get(rear-1);\n            int[] behind = arrList.get(rear);\n            int temp;\n            if (front[1] >= behind[0]){\n                temp = Math.max(front[1],behind[1]);\n                arrList.set(rear-1,new int[]{\n                        arrList.get(rear-1)[0],temp\n                });\n                arrList.remove(rear);\n                rear--;\n            }\n            else rear--;\n        }\n        int[][] ans = new int[arrList.size()][2];\n        for (int i = 0; i < arrList.size(); i++) {\n            ans[i] = arrList.get(i);\n        }\n        return ans;\n    }\n}\n```\n\n> 当初在做合并区间的时候就有点侥幸了，这个题后续还要多看\n\n# 25 K个一组翻转链表(Hard)\n\n给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。\n\nk 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n\n你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换\n\n![](../img/2024_3_27_2.png)\n\n>其实也没那么Hard，就是麻烦了一点\n\n## 模拟\n```java\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        //如果间隔是1，那么就不进行下面的逻辑直接返回\n        if (k==1){\n            return head;\n        }\n        ListNode p = head;\n        //首先遍历统计节点数\n        int count = 0;\n        while (p!=null){\n            count++;\n            p = p.next;\n        }\n        p = head;\n        ListNode pre = head;\n        List<ListNode> listNodes = new ArrayList<>();\n        //对于每一个完整的组，不完整的直接接在尾部就行\n        for (int i = 1; i <= count / k; i++) {\n            //pre找的是下一个的完整组的头节点，也就是下个p\n            pre = getNext(pre,k);\n            //将反转后的头节点放进数组保存\n            listNodes.add(reverse(p,k));\n            p = pre;\n        }\n        //遍历数组，一段一段接起来\n        ListNode temp = listNodes.get(0);\n        for (int i = 0; i < listNodes.size()-1; i++) {\n            temp= listNodes.get(i);\n            while (temp.next != null){\n                temp = temp.next;\n            }\n            temp.next = listNodes.get(i+1);\n        }\n        //这里最后一段还没遍历，为了找到尾指针接上落单的那几个节点\n        while (temp.next != null){\n            temp = temp.next;\n        }\n        //接上落单的几个节点\n        temp.next = pre;\n        //返回最终的头节点\n        ListNode ans = listNodes.get(0);\n        \n        return listNodes.get(0);\n\n    }\n\n    /**\n     * 返回下一段的头节点\n     * @param p\n     * @param k\n     * @return\n     */\n    public ListNode getNext(ListNode p,int k){\n        for (int i = 0; i < k; i++) {\n            p = p.next;\n        }\n        return p;\n    }\n\n    /**\n     * 反转当前段\n     * @param head 原顺序的第一个节点\n     * @param k 本段长多少\n     * @return 返回这一段反转完的头节点\n     */\n    public ListNode reverse(ListNode head,int k){\n        //首先返回的头节点肯定是动过的，头节点是最末尾那个，在这里是k-1次循环后的那个节点\n        ListNode ans = head;\n        for (int i = 0; i < k - 1; i++) {\n            ans = ans.next;\n        }\n        //执行倒序逻辑\n        ListNode pre =null,p = head,pa;\n        for (int i = 0; i < k; i++) {\n            pa = p.next;\n            p.next = pre;\n            pre = p;\n            p = pa;\n        }\n        return ans;\n    }\n}\n```\n\n# 136 只出现一次的数字（Easy）\n\n给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n\n示例 1 ：\n\n输入：nums = [2,2,1]\n\n输出：1\n\n## 哈希表\n\n> 这里我的思路是遍历一次然后加入哈希表进行统计，再遍历一次哈希表找出其中为1的，这样时间空间复杂度肯定都0(n)了\n\n## 技巧-位运算\n\n> 通过异或，因为只有两个两个的，两个相同的异或结果就是0，0和任何异或都是自身，那么所有进行异或得到的就是落单的\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int single = 0;\n        for (int num : nums) {\n            single ^= num;\n        }\n        return single;\n    }\n}\n\n``` \n\n","tags":["刷题笔记"]},{"title":"Collections集合篇-Map","url":"/2024/03/26/Collections集合篇-Map/","content":"# HashMap\n> 最常用的Map结构，使用的是拉链法\n\n## 数据结构\nHashMap采用Entry数组来存储key-value,Entry有四个属性，Key，value，哈希值和下一个的指针\n![](../img/Java/img_2.png)\n> 这里是1.8的版本，Node是Entry的一种实现\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n}\n```\n表的数据结构就是一个个的Entry\n```java\ntransient Node<K,V>[] table;\n```\n## 属性\n```java\n/**\n * 初始的大小\n */\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n/**\n * 为什么这里是2^31呢，因为hashCode是int类型的值，\n * 对于数组下标而言不能有负数，整数的范围就是0-2^31-1\n */\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n\n/**\n * 阈值的计算参数，太多了可能会造成链表变长而降低查找效率\n * 太低了可能频繁扩容也会影响效率\n * 这个值是通过泊松分布计算出来的\n */\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n/**\n * 意味着如果链表的长度大于8就要转化为红黑树\n */\nstatic final int TREEIFY_THRESHOLD = 8;\n\n/**\n * 相反的，如果当前树节点小于6个就要将其转化为链表\n */\nstatic final int UNTREEIFY_THRESHOLD = 6;\n\n/**\n * 链表的长度大于8且数组长度大于64转化为红黑树\n */\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n\n```\n## hashCode()和equals()方法\n首先看Object的hashCode方法：\n\n作用：返回对象的哈希码值，用于在哈希表等数据结构中快速定位对象，提高哈希表的性能。\n\n默认实现：Object类中的hashCode()方法默认返回对象的内存地址的哈希码值。\n\n> 这个默认的方法是根据地址计算出来的，\n> 如果两个对象的hashCode()返回值相同，不一定表示这两个对象相等(一般情况下是可以说明两个对象相等)，因为可能存在哈希冲突。\n> \n> **哈希值不能等价于地址，因为Java是在JVM中执行的，并不是真正的地址。**\n```java\npublic class Hashcode {\n    public static void main(String[] args) {\n        A a = new A();\n        A a1 = new A();\n        A a2 = a1;\n        System.out.println(a.hashCode());//460141958\n        System.out.println(a1.hashCode());//1163157884\n        System.out.println(a2.hashCode());//1163157884\n    }\n}\n \nclass A{\n}\n```\n\n我们再看HashMap重写的hashCode\n> 这里选择高十六位和第十六位进行异或运算，是为了尽量提取全部位的特征参与哈希计算，使得其更加分散\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n1. int h;：定义一个整型变量 h，用于存储计算出的哈希值。\n2. (key == null) ? 0 : (h = key.hashCode())：这是一个三元运算符，用于判断给定的键是否为 null。如果键为 null，则将哈希值 h 设为 0；否则，调用键的 hashCode() 方法获取其哈希码，并将结果赋给变量 h。\n3. (h >>> 16)：这是一个无符号右移运算，将变量 h 的二进制表示向右移动 16 位。这么做的目的是为了增加哈希值的随机性，使得哈希值的高位和低位都参与了哈希码的计算。\n4. (h = key.hashCode()) ^ (h >>> 16)：这是一个按位异或运算，将哈希值 h 和右移后的哈希值进行异或运算。按位异或运算是一种常用的混合哈希函数，用于将高位的信息与低位的信息混合在一起，增加哈希值的随机性。\n5. return：将计算出的哈希值返回。\n\n> 在put操作里面是这样判断hashcode和equals的\n```\np.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))\n```\n- 首先判断两个的哈希是否相等，如果哈希不相等那么肯定不存在冲突\n- 如果哈希相等，可能是哈希碰撞，也可能是真的就是一样的元素，需要对具体的k进行判断\n- p.key == key判断的是**引用是否相等**，也就是指针，有的时候两个类的指针指向的是同一块空间，那么这个时候就肯定是相等的\n- key.equals(k)判断的是**内容是否相等**，有的时候两个指针指得确实是不一样的，但是他们包含的内容是一样的，那么肯定也不能放进哈希表，new Student(\"yyf\")和new Student(\"xxy\")指针肯定是不同的，因为指向不同的内存空间，但是内容不一样。这个检测就需要equal来检测了\n\n> 看源码这一段判断，书里的长篇大论都可以不看了：\n> \n> hashcode一致，内容不一样的两个肯定是能进哈希表的，这就是哈希碰撞\n> \n> hashcode一致，equals返回true那肯定是不能进的，这里逻辑是或，就是内容或者引用满足一个相等就不能放了\n> \n> 重写了hashcode，但是equals返回true是可以放进去的，因为逻辑是与\n\n## put操作\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n```\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n> 这里主要有几点注意：\n> - (n - 1) & hash是怎么来的，其实这就是一个取余的操作，因为n为2的整数倍，那么n-1肯定是末尾全为1前面全为0的，用位运算会比%快\n> - p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))在前面已经讲过了\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    //判断数组是否未初始化,这里table已经赋值给tab了，n也同理\n    if ((tab = table) == null || (n = tab.length) == 0)\n        //如果未初始化，调用resize方法 进行初始化\n        n = (tab = resize()).length;\n    //通过 & 运算求出该数据（key）的数组下标并判断该下标位置是否有数据\n    /**\n     * 这里是取余操作，位运算更快\n     * 由于n必然是2的倍数，那么-1就是除了最高位其他都为1，这个时候就相当于掩码，与hash进行与运算\n     * 就可以得到余数，非常神奇\n     */\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        //如果没有，直接将数据放在该下标位置\n        tab[i] = newNode(hash, key, value, null);\n    //该数组下标有数据的情况\n    else {\n        Node<K,V> e; K k;\n        //判断该位置数据的key和新来的数据是否一样\n        if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))\n            //如果一样，证明为修改操作，该节点的数据赋值给e,后边会用到\n            e = p;\n        //判断是不是红黑树\n        else if (p instanceof TreeNode)\n            //如果是红黑树的话，进行红黑树的操作\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        //新数据和当前数组既不相同，也不是红黑树节点，证明是链表\n        else {\n            //遍历链表\n            for (int binCount = 0; ; ++binCount) {\n                //判断next节点，如果为空的话，证明遍历到链表尾部了\n                if ((e = p.next) == null) {\n                    //把新值放入链表尾部\n                    p.next = newNode(hash, key, value, null);\n                    //因为新插入了一条数据，所以判断链表长度是不是大于等于8\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        //如果是，进行转换红黑树操作\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                //判断链表当中有数据相同的值，如果一样，证明为修改操作\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                //把下一个节点赋值为当前节点\n                p = e;\n            }\n        }\n        //判断e是否为空（e值为修改操作存放原数据的变量）\n        if (e != null) { // existing mapping for key\n            //不为空的话证明是修改操作，取出老值\n            V oldValue = e.value;\n            //一定会执行  onlyIfAbsent传进来的是false\n            if (!onlyIfAbsent || oldValue == null)\n                //将新值赋值当前节点\n                e.value = value;\n            afterNodeAccess(e);\n            //返回老值\n            return oldValue;\n        }\n    }\n    //计数器，计算当前节点的修改次数\n    ++modCount;\n    //当前数组中的数据数量如果大于扩容阈值\n    if (++size > threshold)\n        //进行扩容操作\n        resize();\n    //空方法\n    afterNodeInsertion(evict);\n    //添加操作时 返回空值\n    return null;\n}\n```\nput的逻辑是：\n- 首先判断是不是没有进行初始化，如果是第一次加入，那么resize，这里的默认长度是16，阈值为16*0.75\n- 如果初始化了，看tab[(n - 1) & hash]是否有数据，如果没有，就直接放这里；如果有那么就进行后面的逻辑\n- 判断p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))看跟当前的这个是不是一样的，如果是一样的那就进行修改，如果不是，那就要进行链表或者红黑树的添加了\n- 如果是红黑树，那么就走红黑树的添加逻辑\n- 如果是链表，就遍历链表，每一个都进行判断p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))，如果是那就修改，如果遍历到最后了，那就添加到末尾\n- 边走边判断是不是要超过8个了，如果遍历到的节点到第七个了，那就要树化了\n- 最后遍历完了看是否超过扩容阈值了，如果要扩容还要扩\n> 关于这里链表的尾插法，后续还有相关知识点\n## Java1.7的HashMap死循环问题\njdk7的的数据结构是：数组+链表\n\n在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环\n\n![image-20230428213115071](../img/Java/image-20230428213115071.png)\n\n- 变量e指向的是需要迁移的对象\n- 变量next指向的是下一个需要迁移的对象\n- Jdk1.7中的链表采用的头插法\n- 在数据迁移的过程中并没有新的对象产生，只是改变了对象的引用\n\n\n\n产生死循环的过程：\n\n线程1和线程2的变量e和next都引用了这个两个节点\n\n![image-20230428213533483](../img/Java/image-20230428213533483.png)\n\n线程2扩容后，由于头插法，链表顺序颠倒，但是线程1的临时变量e和next还引用了这两个节点\n\n![image-20230428214732877](../img/Java/image-20230428214732877.png)\n\n第一次循环\n\n由于线程2迁移的时候，已经把B的next执行了A\n\n![image-20230428214806072](../img/Java/image-20230428214806072.png)\n\n第二次循环\n\n![image-20230428214908652](../img/Java/image-20230428214908652.png)\n\n第三次循环\n\n![image-20230428214937231](../img/Java/image-20230428214937231.png)\n\n参考回答：\n\n在jdk1.7的hashmap中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环\n\n比如说，现在有两个线程\n\n线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入\n\n线程二：也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。\n\n线程一：继续执行的时候就会出现死循环的问题。\n\n线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，\n\n所以B->A->B,形成循环。\n\n当然，JDK 8 将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），**尾插法**，就避免了jdk7中死循环的问题。\n","tags":["Java"]},{"title":"Collections集合篇-List","url":"/2024/03/26/Collections集合篇-List/","content":"> 今天开始学习Java基础八股文，先从我用的最多的一个数据结构开始看起。虽然我学Java接触了这个概念快两三年了，但是不看源码还是不知道ArrayList的具体实现。\n\n# Collections\n\n集合分为两大类，Collection是单列集合，包含常用的Set，List，Queue等，其中Set里面使用HashSet比较多，List里面使用Arraylist比较多，Queue中有一个优先队列PriorityQueue的概念。\n\n- Set：HashSet，LinkedHashSet，SortedSet和继承其的TreeSet\n- List：ArrayList，LinkedList，Vector\n- Queue：PriorityQueue\n\n还有一类是双列集合Map，使用的比较多的有HashMap，LinkedHashMap，TreeMap，HashTable\n\n![](../img/Java/img.png)\n\n## List\n\n首先我们先复习一下顺序存储和链式存储的区别以及时间复杂度和空间复杂度。\n\n### 顺序存储：\n\n支持随机查找，空间连续，数据密度大（不像链表那样有额外的指针空间），删除和插入麻烦，不适合频繁在其中删除插入\n\n- 插入：如果在表尾就不需要移动元素为o(1)，如果是在内部，需要移动的期望为 (1+2+3+...+n)/(n+1) = n(n+1)/2(n+1) = n/2，时间复杂度为o(n)。\n- 删除：如果在表尾删除也不用移动，如果在内部，期望为 (1+2+...+n-1)/n = n(n-1)/2n = (n-1)/2 也是o(n)\n- 查找：平均查找期望 (1+2+..+n)/n = (n+1)/2 也为o(n)\n\n### 链式存储：\n\n不支持随机查找，但是相对于顺序的插入和删除效率还是高那么一点，空间不连续，数据的密度小，因为要存指针。\n\n- 插入：插入这个操作本身是o(1)的只需要改指针，但是要找到这个插入的位置是需要o(n)，删除同理。\n- 查找：不支持随机查找，每次找都需要从头开始找(双向链表可以解决这个问题)，也是o(n)\n\n### ArrayList\n\n> ArrayList和Vector是基于数组实现的，但是是动态的，每次添加之前都要判断是否下一个就要超过了，如果溢出就要重新开辟一个更长的数组。\n\n#### 成员变量\n\n```java\n/**\n * 默认的初始容量为10\n */\nprivate static final int DEFAULT_CAPACITY = 10;\n/**\n * 如果初始化为new ArrayList(n)，但是还没有在这个里面加东西的时候，elementData就是这个\n */\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\n/**\n * 如果初始化为new ArrayList()，但是还没有元素添加的时候，就是这个Default，为了和上面的区分开\n */\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n/**\n * 实际存储的数组结构\n */\ntransient Object[] elementData;\n\nprivate int size;\n```\n\n#### 构造方法\n>当initialCapacity给了是0或者没有提供的时候，不进行实例化，等到有元素进来了在进行扩容\n```java\n/**\n * 有参数的：只要有这个参数就是EMPTY_ELEMENTDATA，跟下面这个区分开\n * 可以按照指定容量初始化\n */\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    }\n}\n\n/**\n * 无参数构造方法：DEFAULTCAPACITY_EMPTY_ELEMENTDATA来区分\n */\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n\n\n```\n\n#### add添加方法流程\n\n```java\npublic boolean add(E e) {\n    //每一次加之前先检查size+1不会大于数组最大值\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n```\n\n```java\nprivate void ensureCapacityInternal(int minCapacity) {\n    //calculateCapacity(elementData, minCapacity)如果是无参的返回就是10\n    //如果不是返回的就是minCapacity\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n```\n\n\n```java\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    //如果是无参的初始化，那么就在当前这个容量和10之间选一个最大的\n    //但是一般来说第一个元素size肯定是0吧，这里传来的minCapacity估计是1\n    //所以第一次应该是初始化10个，对于无参构造方法而言\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n```\n\n\n```java\nprivate void ensureExplicitCapacity(int minCapacity) {\n    //操作次数，一个内部变量\n    modCount++;\n\n    // overflow-conscious code\n    //如果有增大的需求，即现在的需求已经比现长度大了\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n```\n\n```java\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    //1.5倍，oldCapacity右移一位代表/2，1+0.5\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    //只有第一次会这样minCapacity给的是10，这个肯定是<0\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    //然后拷贝一份这个数组\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n#### ArrayList的线程不安全问题\n\n> ArrayList不是线程安全的\n> \n> - 非同步操作： ArrayList 的方法并没有进行同步处理，因此在多线程环境下，多个线程可以同时访问和修改 ArrayList 的状态。\n> - 不保证操作的原子性： ArrayList 的操作（例如添加、删除、修改元素等）并不是原子操作，它们可能会分解成多个步骤。在多线程环境下，如果一个线程在执行操作的过程中被另一个线程中断，可能会导致数据不一致的情况发生\n> - 迭代器不支持并发修改： 在使用迭代器遍历 ArrayList 的过程中，如果其他线程对 ArrayList 进行了结构性修改（如添加或删除元素），则会抛出 ConcurrentModificationException 异常\n\n>举个例子，这里会报错，CopyOnWriteArrayList就不会\n```java\npublic static void main(String[] args) {\n    ArrayListTest arrayListTest = new ArrayListTest();\n    VectorTest vectorTest = new VectorTest();\n    for (int i = 0; i < 10; i++) {\n        new Thread(() -> {\n            for (int j = 0; j < 1000; j++) {\n                arrayListTest.insert(j);\n            }\n            System.out.println(arrayListTest.getSize());\n        }).start();\n    }\n\n    // 等待所有线程执行完毕\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n有几种解决方法\n\n- CopyOnWriteArrayList：使用 java.util.concurrent 包中提供的线程安全的集合类，例如 CopyOnWriteArrayList，它通过在写操作时复制整个数组来实现线程安全，适用于读多写少的场景。\n\n```java\nList<String> threadSafeList = new CopyOnWriteArrayList<>();\n\n```\n- 使用同步机制： 使用 Collections 工具类提供的 synchronizedList 方法，将 ArrayList 包装成一个同步的 List，这样可以保证在多线程环境下对 ArrayList 的操作是线程安全的，但性能可能会受到影响。\n```java\nList<String> synchronizedList = Collections.synchronizedList(new ArrayList<>());\n\n```\n\n### 几个面试题\n\n#### new ArrayList(10)grow了几次\n\n答：0次，因为这个在有参构造函数里面已经有了\n\n#### new ArrayList(0)和new ArrayList()在第一次扩容后都是多少\n\nnew ArrayList()和new ArrayList(0)执行完之后elementData都是空数组，但是这两个空数组的内存地址是不一样的。if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) 这一段代码在new(0)的时候是不会走的，因为比的是地址，所以返回值是1，最后结果也是1\n所以new ArrayList(0)第一次扩容是1，new ArrayList()第一次扩容是10\n\n#### 数组和list之间的转换？\n\n>数组->list:Arrays.asList()\n> \n>list->数组: list.toArray(n)\n\n- 数组转List ，使用JDK中java.util.Arrays工具类的asList方法\n\n- List转数组，使用List的toArray方法。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组\n\n#### 用Arrays.asList转List后，如果修改了数组内容，list受影响吗\n\nArrays.asList转换list之后，如果修改了数组的内容，list会受影响，\n因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，\n在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址\n\n#### List用toArray转数组后，如果修改了List内容，数组受影响吗\n\nlist用了toArray转数组后，如果修改了list内容，数组不会影响，当调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响\n\n## LinkedList\n\n特点：\n- 基于双向链表实现\n- 也符合链式存储的一系列优缺点\n- 线程不安全，因为是链表，如何安全呢，跟上面的ArrayList一样使用Collections.synchronizedList(new ArrayList<>());\n\n## Vector\n\n特点：\n- 也是基于顺序存储（数组结构），但是增长的策略与ArrayList不同，而且每次增长2倍\n- 线程安全，这使其性能略逊于ArrayList\n- Stack是基于Vector的\n\n## 对比\n\n\n| 名称         | 基于数据结构 | 线程是否安全 |\n|------------|--------|--------|\n| ArrayList  | 数组     | 否      |\n| Vector     | 数组     | 是      |\n| LinkedList | 双向链表   | 否      |\n","tags":["Java"]},{"title":"leetcode-2024-3-26","url":"/2024/03/26/leetcode-2024-3-26/","content":"# 2642 设计可以求最短路径的图类（Hard）\n>题目太长了就换成图片了\n\n![](../img/2024_3_26_1.png)\n\n## 迪杰斯特拉\n> 我自己的做法是Dijkstra+邻接矩阵，还可以有Floyd，考虑到这个邻接矩阵都已经内存99%了，所以应该矩阵+Floyd是最佳方案\n\n> 就当是复习Dijkstra了\n```java\nclass Graph {\n\n    private int[][] matrix;\n    private int[] finalArr;\n    private int[] visited;\n    //用邻接矩阵表示图\n    public Graph(int n, int[][] edges) {\n        matrix = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i != j){\n                    matrix[i][j] = Integer.MAX_VALUE;\n                }\n            }\n        }\n        for (int i = 0; i < edges.length; i++) {\n            matrix[edges[i][0]][edges[i][1]] = edges[i][2];\n        }\n    }\n    //增加一条边就是再改一个值\n    public void addEdge(int[] edge) {\n        matrix[edge[0]][edge[1]] = edge[2];\n    }\n\n    /**\n     * Dijkstra，n次找到n个最短路径，所以需要一个visited矩阵保存已经找到最短路径的点\n     * finalArr存放最短路径，初始化为初始点的邻接数组，每次找到其中最小的\n     * 更新距离\n     * @param node1\n     * @param node2\n     * @return\n     */\n    public int shortestPath(int node1, int node2) {\n        finalArr = matrix[node1].clone();\n        visited = new int[matrix.length];\n        //System.out.println(Arrays.toString(finalArr));\n        int k = node1;\n        for (int i = 0; i < matrix.length-1; i++) {\n            visited[k] = 1;\n            int[] adj = getMin(finalArr);\n            k = adj[0];\n            int price = adj[1];\n            //如果这里返回-1说明找不到最小值，最小值都已经是正无穷了\n            //说明此时其他的都已经最优，直接跳出循环\n            if (k ==-1){\n                break;\n            }\n            for (int j = 0; j < matrix.length; j++) {\n                if (matrix[k][j] != Integer.MAX_VALUE&&price != Integer.MAX_VALUE && visited[j] == 0 && matrix[k][j]+price < finalArr[j]){\n                    finalArr[j] = matrix[k][j]+price;\n                }\n            }\n            //System.out.println(Arrays.toString(finalArr));\n        }\n        if (finalArr[node2] == Integer.MAX_VALUE){\n            return -1;\n        }else {\n            return finalArr[node2];\n        }\n    }\n    public int[] getMin(int[] arr){\n        int min = Integer.MAX_VALUE;\n        int vexNum = -1;\n        for (int i = 0; i < arr.length; i++) {\n            if (visited[i] ==0 && arr[i] != 0){\n                if (arr[i] <min){\n                    min = arr[i];\n                    vexNum = i;\n                }\n            }\n        }\n        return new int[]{vexNum,min};\n    }\n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = new\n * Graph(n, edges);\n * obj.addEdge(edge);\n * int param_2 = obj.shortestPath(node1,node2);\n */\n```\n\n# 矩阵置零（Medium）\n![](../img/2024_3_26_2.png)\n## 广度优先搜索\n>其实本来是想多源广度优先搜索的，后来发现好像不用这复杂。直接暴力每一行每一列都变成0就可以了\n```java\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        //存储在里面找到的0\n        List<int[]> points = new ArrayList<>();\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                if (matrix[i][j] == 0){\n                    points.add(new int[]{i,j});\n                }\n            }\n        }\n        //遍历每一个0，使其横竖都变为0\n        for(int[] point:points){\n            for (int i = 0; i < matrix.length; i++) {\n                matrix[i][point[1]] = 0;\n            }\n            for (int j = 0; j < matrix[0].length; j++) {\n                matrix[point[0]][j] = 0;\n            }\n        }\n    }\n}\n```\nrow为行，col为列\n\n时间复杂度：o(row*col)\n\n空间复杂度：o(row+col)\n\n# 130 被围绕的区域（Medium）\n![](../img/2024_3_26_3.png)\n## 深度优先搜索\n> 主要思路是，首先找到一个区域先把其全部变为X，用一个数组保存，如果这个区域里面包含在边界的块，那么这个数组用于后续再把他变为O\n```java\nclass Solution {\n    List<int[]> points = new ArrayList<>();\n    List<List<int[]>> list = new ArrayList<>();\n    public void solve(char[][] board) {\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                if (board[i][j] == 'O'){\n                    points = new ArrayList<>();\n                    //如果有链接到边界,随后把这些改回来\n                    if (!dfs(board,i,j)){\n                        list.add(points);\n                    }\n                }\n            }\n        }\n        for (List<int[]> points:list){\n            for (int[] point:points){\n                board[point[0]][point[1]] = 'O';\n            }\n        }\n        //System.out.println(Arrays.deepToString(board));\n    }\n    //一个区域块，首先全部变为X，返回真在后续把他变回O\n    public boolean dfs(char[][] board,int i,int j){\n        if (board[i][j] == 'O'){\n            boolean temp = true;\n            points.add(new int[]{i,j});\n            board[i][j] = 'X';\n            if (i == 0||j==0||i==board.length-1||j==board[0].length-1){\n                temp = false;\n            }\n            if (i+1<=board.length-1){\n                temp &= dfs(board,i+1,j);\n            }\n            if (i-1 >=0){\n                temp &= dfs(board,i-1,j);\n            }\n            if (j+1 <= board[0].length-1){\n                temp &= dfs(board,i,j+1);\n            }\n            if (j-1 >= 0){\n                temp &= dfs(board,i,j-1);\n            }\n            return temp;\n        }\n        else {\n            return true;\n        }\n    }\n}\n```\n时间复杂度：o(m*n)\n空间复杂度：o(m*n)\n\n## 还有两题太简单了我就当复习了\n### 排序链表\n### 快速排序\n```java\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        quickSort(nums,0,nums.length-1);\n    \n        return nums;\n    }\n    public void quickSort(int[] nums,int head,int rear){\n        if (head < rear){\n            int mid = partition(nums,head,rear);\n            quickSort(nums,head,mid-1);\n            quickSort(nums,mid+1,rear);\n        }\n    }\n    public int partition(int[] arr,int head,int rear){\n        int temp = arr[head];\n        while(head < rear){\n            //主要是要记得这里是每个都要带=，\n            while (head < rear && arr[rear] >= temp){\n                rear--;\n            }\n            arr[head] = arr[rear];\n            while (head < rear && arr[head] <= temp){\n                head++;\n            }\n            arr[rear] = arr[head];\n        }\n        arr[head] = temp;\n        //System.out.println(Arrays.toString(arr));\n        return head;\n    }\n}\n```","tags":["刷题笔记"]},{"title":"leetcode-2024-3-25","url":"/2024/03/25/leetcode-2024-3-25/","content":"# 518 零钱兑换2（Medium）\n给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。\n\n请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。\n\n假设每一种面额的硬币有无限个。\n\n题目数据保证结果符合 32 位带符号整数。\n\n\n\n示例 1：\n\n输入：amount = 5, coins = [1, 2, 5]\n\n输出：4\n\n解释：有四种方式可以凑成总金额：\n\n5=5\n\n5=2+2+1\n\n5=2+1+1+1\n\n5=1+1+1+1+1\n\n## 很愚蠢的暴力解：DFS（8/28）\n> 最搞笑的是我点了一个运行，然后吃完饭都没有算出结果来，我愿称之为最暴力的一集\n\n> 本意是深度优先搜索，然后将路径上的值保存进哈希表，哈希表记录的是硬币和个数，如果最后能全部找完，就把当前哈希表存到set里面（其实让我意想不到的是这样子set也可以去重）\n\n> 这种方法要重复计算太多次了，可以优化成右边的有向无环图，但是就这个题而言完全没必要这么复杂。\n\n![](../img/2024_3_25_1.png)\n```java\n//hashmap用来放具体找零\nprivate HashMap<Integer,Integer> hashMap = new HashMap<>();\n//set去重\nprivate Set<HashMap<Integer,Integer>> set = new HashSet<>();\npublic int change1(int amount, int[] coins) {\n    Arrays.sort(coins);\n    dfs(amount,coins);\n    return set.size();\n}\npublic void dfs(int amount,int[] coins){\n    //可以找完，放进set里面\n    if (amount == 0){\n        set.add(new HashMap<>(hashMap));\n        return;\n    }\n    //不能用已有的找零了，失败\n    if (amount < coins[0]){\n        return;\n    }\n    //递归遍历每一种情况\n    for (int i = 0; i < coins.length; i++) {\n        //先加入hashmap\n        if (!hashMap.containsKey(coins[i])){\n            hashMap.put(coins[i],1);\n        }\n        else {\n            Integer integer = hashMap.get(coins[i]);\n            hashMap.replace(coins[i],integer+1);\n        }\n\n        dfs(amount-coins[i],coins);\n        //后续递归再删除回到上一层，保证每个循环都是一样的\n        int temp = hashMap.get(coins[i]);\n        if (temp == 1){\n            hashMap.remove(coins[i]);\n        }\n        else {\n            hashMap.put(coins[i],temp-1);\n        }\n    }\n}\n```\n\n## 动态规划（其实就是跳房子游戏）\n\n> 问题一：我对这道题的主要纠结点在于，比如11，硬币有1，2，5，理应找dp[10],dp[9],dp[6],但是我们不知道这里面是不是可能造成重复，事实上dp[9]里面肯定也会只使用一个5，对于dp[6]的情况来说只是**改了顺序**\n\n> 如何解决？我们不再遍历11而遍历硬币，这样就能保证在遍历到当前硬币之前不会有这个路径出现。每一次遍历都是如何通过当前的这个硬币换到现在的钱，\n> 自然而然得到转移方程，dp[j] += dp[j-coins[i]];\n```java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount+1];\n        dp[0] = 1;\n        for (int i = 0; i < coins.length; i++) {\n            for (int j = coins[i]; j < dp.length; j++) {\n                dp[j] += dp[j-coins[i]];\n            }\n            \n        }\n\n        return dp[dp.length-1];\n    }\n}\n```\n>看完后其实是有恍然大雾的感觉，多看多学。\n\n# 合并K个有序链表（Hard）\n\n给你一个链表数组，每个链表都已经按升序排列。\n\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n\n>实在不明白这个题怎么会是hard，给我刷战绩的题\n\n>其实还不够快，如果用分治法可以logn\n\n## 队列\n> 两两合并然后入队，直到队里面只有一个，就是答案\n```java\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        //判断是否为空\n        if (lists.length == 0){\n            return null;\n        }\n        Queue<ListNode> queue = new ArrayDeque<>();\n        for (int i = 0; i < lists.length; i++) {\n            if (lists[i] != null){\n                queue.add(lists[i]);\n            }\n        }\n        //这里也被卡了一下，如果长度是0就不能进行下面的步骤\n        if (queue.isEmpty()){\n            return null;\n        }\n        while (queue.size() != 1){\n            ListNode listNode1 = queue.poll();\n            ListNode listNode2 = queue.poll();\n            if (listNode1 != null && listNode2 != null){\n                queue.add(merge(listNode1,listNode2));\n            }\n        }\n        return queue.poll();\n    }\n\n    /**\n     * 两个链表合并，基本方法\n     * @param listNode1\n     * @param listNode2\n     * @return\n     */\n    public ListNode merge(ListNode listNode1,ListNode listNode2){\n        //用了一个头节点方便保存\n        ListNode temp = new ListNode();\n        ListNode ans = temp;\n        while (listNode1!=null && listNode2!=null){\n            if (listNode1.val <= listNode2.val){\n                temp.next = listNode1;\n                listNode1 = listNode1.next;\n            }\n            else {\n                temp.next = listNode2;\n                listNode2 = listNode2.next;\n            }\n            temp = temp.next;\n        }\n        //接上没遍历到的\n        if (listNode1 != null){\n            temp.next = listNode1;\n        }\n        if (listNode2 != null){\n            temp.next = listNode2;\n        }\n        return ans.next;\n    }\n\n}\n```\n\n# 搜索二维矩阵2（Medium）\n\n编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：\n\n每行的元素从左到右升序排列。\n\n每列的元素从上到下升序排列。\n\n![](../img/2024_3_25_2.png)\n\n## 二维双指针\n>我们可以观察到，从下往上数每一行第一个元素，如果比目标大就可以删除了，同理每一列从后往前数第一个元素，如果大也可以删除了。\n> 这样就得到了一个新矩阵。\n\n>接着找新矩阵最后一行的元素，从前往后数如果比目标小也可以删除了，然后最后一列，从上到下比目标小的也可以删除。\n \n> 这样完成一次循环，减少了很大的搜索范围。一直收敛到只有一行或者一列。\n\n>这里用了***小技巧***，对于找不到的元素肯定是会**数组下标抛异常**的，catch到了肯定是没有的，返回假\n\n> 还有有一个小问题，当我们面对[[5,6,9],[9,10,11],[11,14,18]]这样的数组，有两个9，这时候我们就永远满足不了循环条件出不来了，为了解决需要看循环里面四个指针是否变化，如果没变就说明发生了这种情况。直接跳出循环。而出现这种情况的原因就是因为有两个一样的目标值，那肯定返回真。\n```java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int row_top = 0,row_bottom = matrix.length-1,col_left = 0,col_right = matrix[0].length-1;\n        boolean flag = false;\n\n        try {\n            while (row_top < row_bottom && col_left < col_right){\n                //判断是否指针有变化\n                int temp = 0;\n                while (matrix[row_bottom][col_left] > target){\n                    temp++;\n                    row_bottom--;\n                }\n                while (matrix[row_top][col_right] > target){\n                    temp++;\n                    col_right--;\n                }\n                while (matrix[row_bottom][col_left] < target){\n                    temp++;\n                    col_left++;\n                }\n                while (matrix[row_top][col_right] <target){\n                    temp++;\n                    row_top++;\n                }\n                if (temp == 0){\n                    flag = true;\n                    break;\n                }\n\n            }\n            //System.out.println(row_top+\"  \"+row_bottom+\"  \"+col_left+\"  \"+col_right);\n            if (row_top == row_bottom){\n                for (int i = col_left; i <=col_right; i++) {\n                    if (matrix[row_bottom][i] == target){\n                        flag = true;\n                        break;\n                    }\n                }\n            }\n            if (col_left == col_right){\n                for (int i = row_top; i <= row_bottom; i++) {\n                    if (matrix[i][col_right] == target){\n                        flag = true;\n                        break;\n                    }\n                }\n            }\n            return flag;\n        }\n        //小技巧\n        catch (ArrayIndexOutOfBoundsException e){\n            return false;\n        }\n    }\n}\n```\n\n这道题做出来其实有点侥幸，很多情况都是错了以后试验出来的。据他们所说这样还不如遍历整体找结果。\n\n# 54 螺旋矩阵（Medium）\n\n给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n\n![](../img/2024_3_25_3.png)\n\n> 非常好理解的一道题，根据上一题的思路很快就能写出，但是这里不用频繁维护四个指针，只用在循环末尾使用就可以。\n\n> 就跟洋葱一样，每次都剥掉最外一层\n\n## 双指针\n\n```java\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> ans = new ArrayList<>();\n        int row_top = 0,row_bottom = matrix.length-1,col_left = 0,col_right = matrix[0].length-1;\n        while (row_top < row_bottom && col_left < col_right){\n            for (int i = col_left; i < col_right; i++) {\n                ans.add(matrix[row_top][i]);\n            }\n            for (int i = row_top; i < row_bottom; i++) {\n                ans.add(matrix[i][col_right]);\n            }\n            for (int i = col_right; i > col_left ; i--) {\n                ans.add(matrix[row_bottom][i]);\n            }\n            for (int i = row_bottom; i > row_top; i--) {\n                ans.add(matrix[i][col_left]);\n            }\n            //换到内层\n            row_top++;\n            row_bottom--;\n            col_left++;\n            col_right--;\n        }\n        //特判。如果都相等，说明中间只有一个元素\n        if (row_top == row_bottom && col_left == col_right){\n            ans.add(matrix[row_top][col_right]);\n        }\n        else {\n            //一行\n            if (row_top == row_bottom){\n                for (int i = col_left; i <= col_right; i++) {\n                    ans.add(matrix[row_top][i]);\n                }\n            }\n            //一列\n            if (col_left == col_right){\n                for (int i = row_top; i <= row_bottom; i++) {\n                    ans.add(matrix[i][col_left]);\n                }\n            }\n        }\n\n        return ans;\n    }\n}\n```\n\n# 59 螺旋矩阵2（Medium）\n给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n\n![](../img/2024_3_25_4.png)\n> 这个比上面的更简单了，一个计数器，然后根据上面的逻辑转圈，每次都+1，就可以了，甚至没有中间是一行或者一列的情况，要不就是没有要不就只有一个。\n```java\nclass Solution {\n    public int[][] generateMatrix(int n) {\n        int[][] matrix = new int[n][n];\n        int count = 1;\n        int row_top = 0,row_bottom = matrix.length-1,col_left = 0,col_right = matrix[0].length-1;\n        while (row_top < row_bottom && col_left < col_right){\n            for (int i = col_left; i < col_right; i++) {\n                matrix[row_top][i] = count++;\n            }\n            for (int i = row_top; i < row_bottom; i++) {\n                matrix[i][col_right]= count++;\n            }\n            for (int i = col_right; i > col_left ; i--) {\n                matrix[row_bottom][i]= count++;\n            }\n            for (int i = row_bottom; i > row_top; i--) {\n                matrix[i][col_left]= count++;\n            }\n            row_top++;\n            row_bottom--;\n            col_left++;\n            col_right--;\n        }\n        if (row_top == row_bottom && col_left == col_right){\n            matrix[row_top][col_right]= count++;\n        }\n        else {\n            if (row_top == row_bottom){\n                for (int i = col_left; i <= col_right; i++) {\n                    matrix[row_top][i]= count++;\n                }\n            }\n            if (col_left == col_right){\n                for (int i = row_top; i <= row_bottom; i++) {\n                    matrix[i][col_left]= count++;\n                }\n            }\n        }\n        return matrix;\n    }\n}\n```","tags":["刷题笔记"]},{"title":"周赛2024-3-24","url":"/2024/03/24/周赛2024-3-24/","content":">陆陆续续这是第三次周赛，第一次是虚拟的我瞎写ac了两题，上一次也是ac两题因为起得太晚了。这次稍微一点点进步，ac两个半，第三题有思路但是暴力超时，是因为我没见过这种数据结构。\n\n> Hard就跳了吧\n\n# 第一题：每个字符最多出现两次的最长子字符串\n给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该 子字符串 的 最大 长度。\n\n示例 1：\n\n输入： s = \"bcbbbcba\"\n\n输出： 4\n\n解释：\n\n以下子字符串长度为 4，并且每个字符最多出现两次：\"bcbbbcba\"。\n>遍历每个字串，判断是否字符只出现两次\n```java\nclass Solution {\n    public int maximumLengthSubstring(String s) {\n        int max = 2;\n        for (int k = s.length(); k >=1; k--) {\n            for (int i = 0; i < s.length() - k; i++) {\n                String sub = s.substring(i,i+k+1);\n                //如果没有返回false\n                if (judge(sub)){\n                    max = Math.max(max,sub.length());\n                }\n            }\n        }\n        return max;\n    }\n    //判断字串是否只出现两次，用哈希表实现，如果哈希表超过2就返回false\n    public boolean judge(String s){\n        HashMap<Character,Integer> map = new HashMap<>();\n        boolean flag = true;\n        for (int i = 0; i < s.length(); i++) {\n            if (!map.containsKey(s.charAt(i))){\n                map.put(s.charAt(i),1);\n            }\n            else {\n                Integer integer = map.get(s.charAt(i));\n                if (integer >= 2){\n                    flag = false;\n                }\n                map.replace(s.charAt(i),integer+1);\n            }\n        }\n        return flag;\n    }\n\n}\n```\n# 第二题：执行操作使数据元素之和大于等于 K\n给你一个正整数 k 。最初，你有一个数组 nums = [1] 。\n\n你可以对数组执行以下 任意 操作 任意 次数（可能为零）：\n\n选择数组中的任何一个元素，然后将它的值 增加 1 。\n\n复制数组中的任何一个元素，然后将它附加到数组的末尾。\n\n返回使得最终数组元素之 和 大于或等于 k 所需的 最少 操作次数。\n\n\n\n示例 1：\n\n输入：k = 11\n\n输出：5\n\n解释：\n\n可以对数组 nums = [1] 执行以下操作：\n\n将元素的值增加 1 三次。结果数组为 nums = [4] 。\n复制元素两次。结果数组为 nums = [4,4,4] 。\n最终数组的和为 4 + 4 + 4 = 12 ，大于等于 k = 11 。\n执行的总操作次数为 3 + 2 = 5 。\n>数学题，假设+1的次数为x，复制的次数为y，要使得(y+1)*(x+1)>=n，而满足x+y最小\n\n>满足x+y+2最小其实也是满足x+y最小，那么就是开根号了，由基本不等式可得。\n \n>还有个问题就是这里的是整数，假如n=29开根号是5，这个时候用6 * 6=36就浪费了一次，只需要用5 * 6=30就可以，需要进行特殊判断\n\n>wa了一次，因为这里如果正好开根号，就直接返回x+y了，不需要-2\n```java\nclass Solution {\n    public int minOperations(int k) {\n        if (k ==1){\n            return 0;\n        }\n        int sqrt = (int) Math.sqrt(k);\n        if (k == sqrt*sqrt){\n            return sqrt*2-2;\n        }\n        else {\n            if (k <= sqrt *(sqrt+1)){\n                return sqrt+sqrt+1-2;\n            }\n            else {\n                return sqrt+1+sqrt+1-2;\n            }\n        }\n\n    }\n}\n```\n# 第三题：最高频率的 ID\n>高级的排序哈希集（TreeMap）不得不品\n> \n你需要在一个集合里动态记录 ID 的出现频率。给你两个长度都为 n 的整数数组 nums 和 freq ，nums 中每一个元素表示一个 ID ，对应的 freq 中的元素表示这个 ID 在集合中此次操作后需要增加或者减少的数目。\n\n增加 ID 的数目：如果 freq[i] 是正数，那么 freq[i] 个 ID 为 nums[i] 的元素在第 i 步操作后会添加到集合中。\n减少 ID 的数目：如果 freq[i] 是负数，那么 -freq[i] 个 ID 为 nums[i] 的元素在第 i 步操作后会从集合中删除。\n请你返回一个长度为 n 的数组 ans ，其中 ans[i] 表示第 i 步操作后出现频率最高的 ID 数目 ，如果在某次操作后集合为空，那么 ans[i] 为 0 。\n\n\n\n示例 1：\n\n输入：nums = [2,3,2,1], freq = [3,2,-3,1]\n\n输出：[3,3,2,2]\n\n解释：\n\n第 0 步操作后，有 3 个 ID 为 2 的元素，所以 ans[0] = 3 。\n第 1 步操作后，有 3 个 ID 为 2 的元素和 2 个 ID 为 3 的元素，所以 ans[1] = 3 。\n第 2 步操作后，有 2 个 ID 为 3 的元素，所以 ans[2] = 2 。\n第 3 步操作后，有 2 个 ID 为 3 的元素和 1 个 ID 为 1 的元素，所以 ans[3] = 2 。\n## 暴力超时\n>hashmap维护当前的频率，每次都对其进行最小值查找，时间复杂度o(n^2)\n```java\nclass Solution {\n    public long[] mostFrequentIDs(int[] nums, int[] freq) {\n        long[] ans = new long[nums.length];\n        HashMap<Integer,Long> hashMap = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (!hashMap.containsKey(nums[i])){\n                hashMap.put(nums[i], (long) freq[i]);\n            }\n            else {\n                long integer = hashMap.get(nums[i]);\n                hashMap.replace(nums[i],integer+freq[i]);\n            }\n            ans[i] = getMost(hashMap);\n        }\n        return ans;\n    }\n    //遍历哈希找最小值\n    public long getMost(HashMap<Integer,Long> hashMap){\n        long max = Long.MIN_VALUE;\n        for (Map.Entry<Integer,Long> entry : hashMap.entrySet()){\n            max = Math.max(max,entry.getValue());\n        }\n        return max;\n    }\n}\n```\n## TreeMap（重要）\n\n>TreeMap是索引为键的有序哈希表，从小到大排序，每次维护treemap只用从最后面找到就是最大值。\n\n>这里treemap存的是频率的频率，每当有更新的时候就对应频率的值-1，如果为0了就删除，然后在加上新的\n```java\nclass Solution {\n    public long[] mostFrequentIDs(int[] nums, int[] freq) {\n        long[] ans = new long[nums.length];\n        HashMap<Integer,Long> hashMap = new HashMap<>();\n        TreeMap<Long,Integer> treeMap = new TreeMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (!hashMap.containsKey(nums[i])){\n                hashMap.put(nums[i], (long) freq[i]);\n                //如果没有就默认为1，有就加上\n                treeMap.put((long) freq[i],treeMap.getOrDefault((long)freq[i],0)+1);\n            }\n            else {\n                long integer = hashMap.get(nums[i]);\n                if (treeMap.containsKey(integer)){\n                    int temp = treeMap.get(integer);\n                    if (temp == 1){\n                        //如果本来就只有1了，就移除\n                        treeMap.remove(integer);\n                    }\n                    else {\n                        //这里其实可以直接用put\n                        treeMap.replace(integer,temp-1);\n                    }\n                    treeMap.put(integer+freq[i],treeMap.getOrDefault(integer+freq[i],0)+1);\n                }\n                hashMap.replace(nums[i],integer+freq[i]);\n            }\n            ans[i] = treeMap.lastKey();\n        }\n        return ans;\n    }\n}\n```\n## [引申：前天的每日一题](./leetcode-2024-3-21.md)\n有一点相似\n","tags":["刷题笔记"]},{"title":"leetcode-2024-3-24","url":"/2024/03/24/leetcode-2024-3-24/","content":"# 323 零钱兑换(Medium)\n给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n\n计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。\n\n你可以认为每种硬币的数量是无限的。\n\n\n\n示例 1：\n\n输入：coins = [1, 2, 5], amount = 11\n\n输出：3\n\n解释：11 = 5 + 5 + 1\n>今天的每日一题在十天前做过，过一遍就不重新做了\n## 动态规划\n>dp数组存当前下标的钱可以用的最少兑换次数，如果用现在的零钱兑现不了，就为-1\n\n>dp[k] = min{dp[i]+dp[k-1-i]} 当且仅当dp[i]和dp[k-1-i]都不为-1\n> 但是如果这个本身就可以用零钱找开，就为1\n```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0){\n            return 0;\n        }\n        int[] dp = new int[amount+1];\n        for (int i = 0; i < coins.length; i++) {\n            if (coins[i] <= amount){\n                dp[coins[i]] = 1;\n            }\n        }\n        //System.out.println(Arrays.toString(dp));\n        for (int i = 1; i <= amount; i++) {\n            if (i != 1){\n                int head = 1;\n                int rear = i-1;\n                int min = Integer.MAX_VALUE;\n                //dp[k] = min{dp[i]+dp[k-1-i]} 当且仅当dp[i]和dp[k-1-i]都不为-1\n                while (head <= rear){\n                    if (dp[head] != -1 && dp[rear]!=-1 && dp[head] + dp[rear] < min){\n                        min = dp[head]+dp[rear];\n                    }\n                    //System.out.println(i+\":\"+dp[head] +\"  \"+ dp[rear]);\n                    head++;\n                    rear--;\n                }\n                //最小值没有改变，说明不能找的开\n                if (dp[i] == 0 && min == Integer.MAX_VALUE){\n                    dp[i] = -1;\n                }\n                //改变了就最小值\n                if (dp[i] == 0 && min != Integer.MAX_VALUE){\n                    dp[i] = min;\n                }\n                //如果这个本身就是1的话就不考虑，还是1\n            }\n            else {\n                if (dp[i] == 0){\n                    dp[i] = -1;\n                }\n            }\n        }\n        //System.out.println(Arrays.toString(dp));\n    \n        return dp[amount];\n    }\n}\n```\n\n# 238 除自身以外数组的乘积(Medium)\n给你一个整数数组 **nums**，返回 数组 **answer** ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。\n\n题目数据 **保证** 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。\n\n请 **不要使用除法**，且在 **O(n)** 时间复杂度内完成此题。\n\n## 偷懒方法（就是用了除法）\n>最简单方法，所有乘积起来，当前元素只要除掉这个就可以，遍历一次就可以。0的时候要特殊判断一下，这个时候还是傻方法，遍历其他的。\n\n```java\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int[] ans = new int[nums.length];\n        if (nums.length == 1){\n            return nums;\n        }\n        else if (nums.length > 1){\n            int sum = nums[0];\n            //乘起来\n            for (int i = 1; i < nums.length; i++) {\n                sum *=nums[i];\n            }\n            \n            for (int i = 0; i < nums.length; i++) {\n                if (nums[i] != 0){\n                    ans[i] = sum /nums[i];\n                }\n                //如果是0特判\n                else {\n                    int front = i-1;\n                    int next = i+1;\n                    int anss = 1;\n                    while (front >=0){\n                        anss*=nums[front];\n                        front--;\n                    }\n                    while (next <=nums.length-1){\n                        anss*=nums[next];\n                        next++;\n                    }\n                    ans[i] = anss;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n## 官方解：左右乘积列表\n>维护两个数组，L[i]是当前元素i左边的乘积，R[i]是i右边的乘积，返回的数组就是L[i]*R[i]，每次都是o（n）\n\n```java\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int[] L = new int[nums.length];\n        int[] R = new int[nums.length];\n        int[] ans = new int[nums.length];\n        L[0] = 1;\n        R[nums.length-1] = 1;\n        for (int i = 1; i < nums.length; i++) {\n            L[i] = L[i-1]*nums[i-1];\n        }\n        for (int j = nums.length-2; j >=0 ; j--) {\n            R[j] = R[j+1]*nums[j+1];\n        }\n        for (int i = 0; i < nums.length; i++) {\n            ans[i] = L[i] * R[i];\n        }\n        return ans;\n    }\n}\n```\n# 11 盛最多水的容器(Medium)\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n返回容器可以储存的最大水量。\n![](../img/2024_3_24_1.png)\n## 暴力超时\n>遍历找最小\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        int max = Integer.MIN_VALUE;\n        for (int i = 0; i < height.length-1; i++) {\n            for (int j = i+1; j < height.length; j++) {\n                max = Math.max(max,(j-i)*Math.min(height[j],height[i]));\n            }\n        }\n        return max;\n    }\n}\n```\n## 官方解：双指针\n>感觉证明有待考察，初始左右指针一个在左边一个在右边，每次移动比较小的就可以找到。\n\n![](../img/2024_3_24_2.png)\n![](../img/2024_3_24_3.png)\n>简单理解为什么移动小的，因为本来就是取较小的，移动大的话铁定没之前大，因为距离缩短了1，移动小的还可能碰到大的使原来的变大。\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        int head = 0;\n        int rear = height.length-1;\n        int max = Integer.MIN_VALUE;\n        while (head < rear){\n            int length = rear-head;\n            max = Math.max(max,length*Math.min(height[head],height[rear]));\n            if (height[head]<height[rear]){\n                head++;\n            }\n            else if (height[head]>height[rear]){\n                rear--;\n            }\n            else {\n                head++;\n            }\n        }\n        return max;\n    }\n}\n```","tags":["刷题笔记"]},{"title":"短期的小目标吧","url":"/2024/03/23/短期的小目标吧/","content":"这几天晚上睡不好，总在想自己保研了但是感觉也不是很开心。同专业的同学们陆陆续续出成绩，一看考本校的寥寥无几，顿时觉得自己保研好像也没什么了不起的。\n\n总不可能一直麻痹自己，说我这两个月去做了什么事情都没干的实习，说去给学校打工赚了一些小钱。如何将这些东西变现才是最重要的，要不然我会一直不平衡。\n\n我打算先把黑马头条那个项目狠狠重新搞一下，南方电网的也好好包装一下。\n\n说实话，我对Redis和MongoDB和Kafka都挺感兴趣的，每天保持刷题的同时我也想多看看这方面的八股文。\n\n暑假可以先去试试水，没有就好好安心搞12306那个微服务项目。\n\n![](../img/IMG_8928.JPG)","tags":["闲谈"]},{"title":"leetcode-2024-3-23","url":"/2024/03/23/leetcode-2024-3-23/","content":"# 2549 统计桌面上的不同数字(Easy)\n给你一个正整数 n ，开始时，它放在桌面上。在 10^9 天内，每天都要执行下述步骤：\n\n对于出现在桌面上的每个数字 x ，找出符合 1 <= i <= n 且满足 x % i == 1 的所有数字 i 。\n然后，将这些数字放在桌面上。\n返回在 10^9 天之后，出现在桌面上的 不同 整数的数目。\n\n>简单题重拳出击\n\n## 正常解\n\n>发现可以进行递归，假设n=7，那么第一次递归就是6和3，因为7%3=1，7%6=1，那么怎么样解决重复的问题呢，用一个set就好了。\n\n```java\n//去重\nHashSet<Integer> hashSet = new HashSet<>();\npublic int distinctIntegers(int n) {\n    dp(n);\n    //最后返回唯一集合的长度就行\n    return hashSet.size();\n}\npublic void dp(int n){\n    hashSet.add(n);\n    for (int i = n-1; i >=1; i--) {\n        //遍历进行递归\n        if (n % i ==1){\n            distinctIntegers(i);\n        }\n    }\n}\n```\n\n那是比不上最快点方法的，其实找规律直接出来就是n-1，我这个方法还算是有点编程的，自然速度快不过那些n-1的\n\n# 146 LRU缓存（Medium）非常重要这道题\n\n实现LRU算法，**关键是要时间复杂度和空间都是o（1）**\n\n>虽然从前在os上还是手搓过这个算法的，但是这里要用常数的复杂度。\n\n>那必然是要哈希，但是哈希还不够，在搜寻在队列里面的时候必然还是要遍历，这个时候就要想到另一种数据结构，链表\n> 这里为什么用双向链表，因为前驱还是要找的，总不能每次都去遍历吧，那还是浪费一点空间吧。\n## 哈希表+双向链表\n```java\nclass LRUCache{\n    //双向链表数据结构\n    class LinkNode{\n        int key;\n        int value;\n        //前驱\n        LinkNode front = null;\n        //后继\n        LinkNode behind = null;\n        LinkNode(int key,int value){\n            this.key = key;\n            this.value = value;\n        }\n        LinkNode(){}\n    }\n    //容量\n    private int capacity;\n    //维护首尾指针\n    private LinkNode head,tail;\n    //记录链表长度\n    private int linkSize = 0;\n    //哈希表来根据键找到链表的具体位置\n    private HashMap<Integer,LinkNode> hashMap = new HashMap<>();\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        head = new LinkNode();\n        tail = new LinkNode();\n    }\n    \n    public int get(int key) {\n        if (hashMap.containsKey(key)){\n            LinkNode linkNode = hashMap.get(key);\n            moveToHead(linkNode);\n            return linkNode.value;\n        }\n        else {\n            return -1;\n        }\n    }\n    \n    public void put(int key, int value) {\n        //如果没到容量，就不涉及释放位置\n        if (linkSize < capacity){\n            //如果map没有\n            if (!hashMap.containsKey(key)){\n                LinkNode linkNode = new LinkNode(key,value);\n                //头插法\n                handleInsert(linkNode);\n                linkSize++;\n                //保存这个节点\n                hashMap.put(key,linkNode);\n            }\n            else {\n                LinkNode linkNode = hashMap.get(key);\n                linkNode.value = value;\n                moveToHead(linkNode);\n                hashMap.replace(key,linkNode);\n            }\n        }\n        else {\n            if (!hashMap.containsKey(key)){\n                int removeKey = handleRemove();\n                hashMap.remove(removeKey);\n                LinkNode linkNode = new LinkNode(key,value);\n                handleInsert(linkNode);\n                hashMap.put(key,linkNode);\n            }\n            else {\n                LinkNode linkNode = hashMap.get(key);\n                linkNode.value = value;\n                moveToHead(linkNode);\n                hashMap.replace(key,linkNode);\n            }\n        }\n    }\n\n    /**\n     * 头插法\n     * @param linkNode 插入的节点\n     */\n    public void handleInsert(LinkNode linkNode){\n        LinkNode temp = head.behind;\n        //如果这是第一个节点，尾指针一直挂在这个元素上，直到被提起来rear再变\n        if (temp != null){\n            linkNode.behind = temp;\n            head.behind = linkNode;\n            temp.front = linkNode;\n            linkNode.front = head;\n        }\n        //如果不是第一个，那就头插法\n        else {\n            head.behind = linkNode;\n            linkNode.front = head;\n            tail = linkNode;\n        }\n    }\n\n    /**\n     * 出队，移动尾指针即可\n     * @return 返回尾元素的键\n     */\n    public int handleRemove(){\n        int ans = tail.key;\n        tail = tail.front;\n        tail.behind = null;\n        return ans;\n    }\n\n    /**\n     * 更新在队首\n     * @param linkNode\n     */\n    public void moveToHead(LinkNode linkNode){\n        //也就是在末尾的时候\n        if (linkNode.behind == null){\n            tail = linkNode.front;\n            linkNode.front.behind = null;\n            linkNode.front = null;\n            handleInsert(linkNode);\n\n        }\n        else {\n            LinkNode left = linkNode.front;\n            LinkNode right = linkNode.behind;\n            left.behind = right;\n            right.front = left;\n            linkNode.front = null;\n            linkNode.behind = null;\n            handleInsert(linkNode);\n        }\n    }\n}\n\n```\n\n大同小异这些答案，主要还是哈希+双向\n\n# 283 移动零(Easy)\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n\n示例 1:\n\n输入: nums = [0,1,0,3,12]\n\n输出: [1,3,12,0,0]\n\n>没什么好说的这个题\n\n## 直接插入排序思想\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        for (int i = nums.length-2; i >=0; i--) {\n            if (nums[i] == 0){\n                int j=i+1;\n                while (j <= nums.length-1&&nums[j] != 0  ){\n                    nums[j-1] = nums[j];\n                    j++;\n                }\n                nums[j-1] = 0;\n            }\n        }\n    }\n}\n```\n\n# 236.二叉树的最近公共祖先(Medium)\n题目意思就是字面意思\n>这个题居然还没有考研那段时间做得好，这里思路就是找到这两个节点的路径序列，然后找到最近的那个重复元素就完事。\n## 2024.3.23\n```java\nclass Solution {\n    List<TreeNode> list1 = new ArrayList<>();\n    List<List<TreeNode>> list = new ArrayList<>();\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        hxbl(root,p);\n        hxbl(root,q);\n        \n        return findSame(list.get(0),list.get(1));\n    }\n\n    /**\n     * 标准的（+left+{}+right+)结构\n     * @param root\n     * @param target\n     */\n    public void hxbl(TreeNode root,TreeNode target){\n    \n        list1.add(root);\n        if (root.val == target.val){\n        \n            list.add(new ArrayList<>(list1));\n        }\n    \n        if (root.left != null){\n            hxbl(root.left,target);\n        }\n        if (root.right != null){\n            hxbl(root.right,target);\n        }\n        list1.remove(list1.size()-1);\n\n    }\n\n    /**\n     * 找到这两个序列的最近元素，要从后往前，碰到了就break\n     * @param list1\n     * @param list2\n     * @return\n     */\n    public TreeNode findSame(List<TreeNode> list1, List<TreeNode> list2){\n        for (int i = list1.size()-1; i >=0; i--) {\n            for (int j = list2.size()-1; j >=0; j--) {\n                if (list1.get(i).val == list2.get(j).val){\n                    return list1.get(i);\n                }\n            }\n        }\n        return null;\n    }\n    \n}\n```\n\n## 2023.8.3\n\n```java\nclass Solution {\n    List<TreeNode> treeList = new ArrayList<>();\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        find(root,p);\n        List<TreeNode> treeList1 = new ArrayList<>(treeList);\n        treeList = new ArrayList<>();\n        find(root,q);\n        List<TreeNode> treeList2 = new ArrayList<>(treeList);\n        boolean flag = true;\n        if (treeList1.size()>treeList2.size()){\n            flag = false;\n        }\n        for (int i = 0;i<Math.max(treeList1.size(),treeList2.size());i++){\n            if (!flag && treeList2.contains(treeList1.get(i))){\n                return treeList1.get(i);\n            }\n            if (flag && treeList1.contains(treeList2.get(i))){\n                return treeList2.get(i);\n            }\n        }\n        return null;\n    }\n    \n    public boolean find(TreeNode root,TreeNode p){\n          if (root!=null){\n              boolean left = find(root.left,p);\n              boolean right = find(root.right,p);\n              if (root == p||left||right){\n                  treeList.add(root);\n                  return true;\n              }\n              else return false;\n          }\n          else {\n              return false;\n          }\n    }\n}\n```","tags":["刷题笔记"]},{"title":"leetcode-2024-3-21","url":"/2024/03/21/leetcode-2024-3-21/","content":"# 2671 频率跟踪器(Medium)\n请你设计并实现一个能够对其中的值进行跟踪的数据结构，并支持对频率相关查询进行应答。\n\n实现 FrequencyTracker 类：\n\nFrequencyTracker()：使用一个空数组初始化 FrequencyTracker 对象。\n\nvoid add(int number)：添加一个 number 到数据结构中。\n\nvoid deleteOne(int number)：从数据结构中删除一个 number 。数据结构 可能不包含 number ，在这种情况下不删除任何内容。\n\nbool hasFrequency(int frequency): 如果数据结构中存在出现 frequency 次的数字，则返回 true，否则返回 false。\n\n\n示例 1：\n\n输入\n\n[\"FrequencyTracker\", \"add\", \"add\", \"hasFrequency\"]\n\n[[], [3], [3], [2]]\n\n输出\n\n[null, null, null, true]\n\n解释\n\nFrequencyTracker frequencyTracker = new FrequencyTracker();\n\nfrequencyTracker.add(3); // 数据结构现在包含 [3]\n\nfrequencyTracker.add(3); // 数据结构现在包含 [3, 3]\n\nfrequencyTracker.hasFrequency(2); // 返回 true ，因为 3 出现 2 次\n\n## 双哈希\n>一个用来存频率，一个用来存频率的频率\n```java\npublic class FrequencyTracker {\n    private HashMap<Integer,Integer> hashMap;\n    private TreeMap<Integer,Integer> treeMap;\n\n    public FrequencyTracker() {\n        hashMap = new HashMap<>();\n        treeMap = new TreeMap<>();\n    }\n\n    public void add(int number) {\n        if (!hashMap.containsKey(number)){\n            hashMap.put(number,1);\n            treeMap.put(1,treeMap.getOrDefault(1,0)+1);\n        }\n        else {\n            Integer integer = hashMap.get(number);\n            hashMap.put(number,integer+1);\n            if (treeMap.containsKey(integer)){\n                int count = treeMap.get(integer);\n                if (count == 1){\n                    treeMap.remove(integer);\n                }\n                else{\n                    treeMap.replace(integer,count-1);\n                }\n                treeMap.put(integer+1,treeMap.getOrDefault(integer+1,0)+1);\n            }\n        }\n    }\n\n    public void deleteOne(int number) {\n\n        if (hashMap.containsKey(number)){\n            int i1 = hashMap.get(number);\n            int temp = treeMap.get(i1);\n            if (temp == 1){\n                treeMap.remove(i1);\n            }\n            else {\n                treeMap.replace(i1,temp-1);\n            }\n            if (i1-1 !=0){\n                if (treeMap.containsKey(i1-1)){\n                    treeMap.put(i1-1,treeMap.get(i1-1)+1);\n                }\n                else {\n                    treeMap.put(i1-1,1);\n                }\n            }\n\n            if (i1 == 1){\n                hashMap.remove(number);\n            }\n            else {\n                hashMap.put(number,i1-1);\n            }\n\n        }\n    }\n\n    public boolean hasFrequency(int frequency) {\n\n        if (treeMap.containsKey(frequency)){\n            int temp = treeMap.get(frequency);\n            if (temp > 0){\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        FrequencyTracker frequencyTracker = new FrequencyTracker();\n\n        frequencyTracker.add(2);\n\n        frequencyTracker.add(7);\n\n        frequencyTracker.add(7);\n        frequencyTracker.add(3);\n        frequencyTracker.add(3);\n\n        frequencyTracker.deleteOne(7);\n        frequencyTracker.deleteOne(7);\n        System.out.println(frequencyTracker.hasFrequency(2));\n        System.out.println(frequencyTracker.hasFrequency(1));\n    }\n\n}\n\n```","tags":["刷题笔记"]},{"title":"redis实现分布式锁-初见分布式锁","url":"/2024/03/20/redis实现分布式锁-初见分布式锁/","content":"# 什么是分布式锁\n\n分布式锁是控制分布式系统之间同步访问共享资源的一种方式，通过互斥来保持一致性。\n\n了解分布式锁之前先了解下线程锁和进程锁：\n\n**线程锁**：主要用来给方法、代码块加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，比如Synchronized、Lock等\n\n**进程锁**：控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁\n\n比如Golang语言中的sync包就提供了基本的同步基元，如互斥锁\n\n但是以上两种适合在单体架构应用，但是分布式系统中多个服务节点，多个进程分散部署在不同节点机器中，此时对于资源的竞争，上诉两种对节点本地资源的锁就无效了。\n\n这个时候就需要分布式锁来对分布式系统多进程访问资源进行控制，因此分布式锁是为了解决分布式互斥问题！\n\n![img.png](../img/2024_3_20_2.png)\n","tags":["Redis"]},{"title":"leetcode-2024-3-20","url":"/2024/03/20/leetcode-2024-3-20/","content":"# 1969.数组元素的最小非零乘积（Medium）\n给你一个正整数 **p** 。你有一个下标从 **1** 开始的数组 **nums** ，这个数组包含范围 [1, 2p - 1] 内所有整数的二进制形式（两端都 **包含**）。你可以进行以下操作 **任意** 次：\n\n从 nums 中选择两个元素 x 和 y  。\n选择 x 中的一位与 y 对应位置的位交换。对应位置指的是两个整数 相同位置 的二进制位。\n比方说，如果 x = 11**0**1 且 y = 00**1**1 ，交换右边数起第 2 位后，我们得到 x = 11**1**1 和 y = 00**0**1 。\n\n请你算出进行以上操作 **任意次** 以后，nums 能得到的 **最小非零** 乘积。将乘积对 109 + 7 取余 后返回。\n\n注意：答案应为取余 **之前** 的最小值。\n\n> ~~自己没想出来~~，其实有思路了就是总感觉不对劲，看了答案如果继续想应该能想出来，但是问题是这个取余肯定也会困扰我很久，还有我肯定只会暴力求幂，这里的**快速幂**其实是很值得学习一下的\n\n## 官方解：贪心+快速幂\n\n>   x * y肯定是要比(x-1) * (y+1)大的，那么什么时候会有最小值呢，就是当x=1，y变得最大的时候，对于都是二进制来说，能通过交换位来变大只能是x=1,y=2^(p-1)-2了，比如3位的时候，最小就是1，最大就是6，要保持x和y互为**反码**\n\n>那这道题就是一个纯数学问题了，每次取两个互为**反码**的数都能将其变成x=1，y=2^p-2，那么一共有多少对这样的反码对呢。\n>n=(2^p-2)/2，除了最后面那个数其他都可以凑对，就有2^(p-1)-1对。\n> p=3的时候，就有3对，p=4时，就有7对\n \n>也就是说，我们的最终答案是**最后一个元素*（最后一个元素-1）^(2^(p-1)-1)**\n> 即：![](../img/2024-3-20-1.png)\n\n>**快速幂**：通过观察 ***p=3的时候，就有3对，p=4时，就有7对***，可以发现3就是11，7就是111，根据幂的公式x^(111)=x^(100)*x^(010)*x^(001),\n> 答案里巧妙地用快速幂解决，也就是说，不再是暴力连乘，而是x也自己进行幂运算，就可以将复杂度降为o(log)\n\n```java\nprivate static final int MOD = 1_000_000_007;\n//这里的p就是已经log后的，一共有几位，每一位都循环一次\nprivate long pow(long x, int p) {\n    x %= MOD;\n    long res = 1;\n    while (p-- > 0) {\n        res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\npublic int minNonZeroProduct(int p) {\n    //移位，1L是long单位下的1，将其像左边移动p位\n    //得到的k就是最后一个元素\n    long k = (1L << p) - 1;\n    //最后一个元素*（最后一个元素-1）^(2^(p-1)-1)\n    return (int) (k % MOD * pow(k - 1, p - 1) % MOD);\n}\n```\n\n没想出来这种方法，贪心还是练习少了\n\n# 49.字母异位词分组（Medium）\n\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n\n示例 1:\n\n输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\n## 自己解（也是官方解）：哈希表+排序\n\n>遍历每个字符串，然后在对其排序，如果哈希表没有就加进去，list把这个排序之前的字符串放进去，有就在哈希表已有的键里面添加这个字符串。\n\n```java\npublic List<List<String>> groupAnagrams(String[] strs) {\n    HashMap<String,List<String>> hashMap = new HashMap<>();\n    List<List<String>> ans = new ArrayList<>();\n    for (String s:strs){\n        String temp = getAllStr(s);\n        //如果表里没有就新增键值对\n        if (!hashMap.containsKey(temp)){\n            List<String> list = new ArrayList<>();\n            list.add(s);\n            hashMap.put(temp,list);\n        }\n        //有就在末尾添加\n        else {\n            List<String> list = hashMap.get(temp);\n            list.add(s);\n            hashMap.replace(temp,list);\n        }\n    }\n    //遍历map存在list中\n    for (Map.Entry<String,List<String>> entry : hashMap.entrySet()){\n        ans.add(entry.getValue());\n    }\n    return ans;\n}\n//字符串变成char数组，排序，这样就能得到唯一\npublic String getAllStr(String s){\n    char[] temp = s.toCharArray();\n    Arrays.sort(temp);\n    return Arrays.toString(temp);\n}\n```\n\n比较简单\n\n# 128.最长连续序列（Medium）\n\n给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n\n请你设计并实现时间复杂度为 **(n)** 的算法解决此问题。\n\n示例 1：\n\n输入：nums = [100,4,200,1,3,2]\n\n输出：4\n\n解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n\n## 暴力解：（其实是超时的，因为复杂度为o(nlogn)）\n\n> 最傻逼的一集，这里**Arrays.sort**就已经超出复杂度了，但是居然也没超时，甚至比超过90%，感觉有点。\n\n> 最简单的思路，排序然后指针，从小到大如果一直递增就计数器一直加，如果相等那就计数器不动，如果不是，那就计数器重新变为1 \n```java\npublic int longestConsecutive(int[] nums) {\n    if (nums == null){\n        return 0;\n    }\n    //搞笑的排序\n    Arrays.sort(nums);\n    int count = 1;\n    int max = 1;\n    for (int i = 1; i < nums.length; i++) {\n        //当且仅当当前元素是之前元素的多1\n        if (nums[i]==nums[i-1]+1){\n            count++;\n        }\n        //如果相等计数器空过\n        else if (nums[i] == nums[i-1]) {\n\n        }\n        //如果不是这样的情况就不是连续，计数器变成1\n        else {\n            count = 1;\n        }\n        max = Math.max(max,count);\n        System.out.println(count);\n    }\n\n    return max;\n}\n```\n\n## 官方解：哈希表\n\n>我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 x+1,x+2... 是否存在，假设最长匹配到了 x+y，那么以 x 为起点的最长连续序列即为 x,x+1,x+2,x+y，其长度为 y+1，我们不断枚举并更新答案即可。\n\n>对于匹配的过程，暴力的方法是 O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。\n\n>仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 O(n2)\n即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 x,x+1,x+2,⋯,x+y 的连续序列，而我们却重新从 x+1，x+2 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。\n\n>那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x−1 开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。\n\n```java\npublic int longestConsecutive(int[] nums) {\n    Set<Integer> num_set = new HashSet<Integer>();\n    //先去重，用集合\n    for (int num : nums) {\n        num_set.add(num);\n    }\n\n    int longestStreak = 0;\n    //有下一个值的时候就跳掉，一定要没有下一个，这样遍历才是o(n)\n    for (int num : num_set) {\n        if (!num_set.contains(num - 1)) {\n            int currentNum = num;\n            int currentStreak = 1;\n            //然后比较一下\n            while (num_set.contains(currentNum + 1)) {\n                currentNum += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\n```\n\n非常巧妙的o(n),这里set查询是o(1)，需要好好学习一下，多用用哈希","tags":["刷题笔记"]},{"title":"leetcode-2024-3-19","url":"/2024/03/19/leetcode-2024-3-19/","content":"# 1793.好子数组的最大分数（Hard）\n\n给你一个整数数组 nums （下标从 0 开始）和一个整数 k 。\n\n一个子数组 (i, j) 的 **分数** 定义为 min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1) 。一个 好 子数组的两个端点下标需要满足 i <= k <= j 。\n\n请你返回 **好** 子数组的最大可能 **分数** 。\n\n## 暴力解：超出内存限制\n\n> 思路：用一个二维数组，dp[i][j]表示num[i]到num[j]的最小值，起始dp[i][i]都为num[i],状态转移方程为：dp[i][j] = min{dp[i][j-1],num[i]},\n> 其实是可以做出来的。但是这是hard，空间复杂度要求有点高，就会超内存。我的评价是动态规划很好，下次别用了\n\n```java\npublic int maximumScore(int[] nums, int k) {\n    //二维动态规划\n    int[][] dp = new int[nums.length][nums.length];\n    //初始对角线都为自身，自己肯定是最小值\n    for (int i = 0; i < nums.length; i++) {\n        dp[i][i] = nums[i];\n    }\n    for (int i = 0; i < nums.length-1; i++) {\n        for (int j = i+1; j < nums.length; j++) {\n            //动态转移方程\n            dp[i][j] = Math.min(nums[j], dp[i][j - 1]);\n        }\n    }\n    //k要在中间，那么就是矩阵的右上角那块，i<=k<=j\n    int max = Integer.MIN_VALUE;\n    for (int i = 0; i <= k; i++) {\n        for (int j = k; j < nums.length; j++) {\n            int length = j-i+1;\n            max = Math.max(max,length*dp[i][j]);\n        }\n    }\n    //返回在右上角的最大值\n    return max;\n}\n```\n## 官方解 ：双指针\n> 以k为原点，head=k-1，rear=k+1，左开右开区间，数据长度rear-head+1，初始时长度只有1即为nums[k]本身，也为最小值。\n> 那么怎么样找包含他的最小值呢，只要找左右两边比他大的，整体的最小值就是不变的，那么长度*最小值就会有效变大，直到双指针遇到比当前最小值还要小的元素\n> 那么由于初始最小值就是本身，那么只要循环本身这个值不断递减就可以了。\n```java\npublic int maximumScore(int[] nums, int k) {\n    int length = nums.length;\n    int head = k-1,rear = k+1;\n    int max = Integer.MIN_VALUE;\n    for (int i = nums[k];;i--){\n        while (head >=0 && nums[head] >= i){\n            head--;\n        }\n        while (rear < nums.length && nums[rear] >= i){\n            rear++;\n        }\n        max = Math.max(max,(rear-head-1)*i);\n        if (head == -1 && rear == length){\n            break;\n        }\n    }\n    return max;\n}\n```\n复杂度分析\n\n时间复杂度：O(n+C)，其中 n 是数组nums 的长度，C 是数组 nums 中元素的范围。\n\n空间复杂度：O(1)。明显比我自己写的暴力解好\n\n","tags":["刷题笔记"]},{"title":"我的第一篇blog","url":"/2024/03/19/我的第一篇blog/","content":"  做这个博客的目的是为了能激励自己，不要看了一遍就觉得自己会了。好记性不如烂笔头，刷题的思路尽量多写，很难说下次碰到一样的题目会不会忘掉。\n\n  还有25天蓝桥杯，让我这个大四老狗随便得个奖吧~~\n\n  ![上海外国语大学校花](../img/2024_3_19_1.JPG)\n","tags":["闲谈"]}]