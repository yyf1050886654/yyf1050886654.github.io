<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/default" title="YYF's Blog" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://yyf1050886654.github.io/page/4/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>YYF&#39;s Blog</title>

<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">YYF&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/collect/">
      <li class="mobile-menu-item">
        
        
        收藏              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">YYF's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/collect/">  
              
              
              收藏  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <section id="posts" class="posts">
  
  
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/14/Java%E5%9F%BA%E7%A1%80%E7%AF%87/">Java基础篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-14
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h2><p>分为异常Exception和错误Error，异常是可以用try&#x2F;catch来解决的，但是error就很严重了，会直接导致线程终止。他们都继承自ThrowAble接口。</p>
<p>其中exception分为可以检查到的异常（checked exception），表示能够在编译阶段就发现并且抛出错误的异常，比如sqlexception或者ioexception；编译时无法检测出的异常（unchecked exception），指的就是运行时异常（runtimeException）例如数组越界，空指针这种。 runtimeException都是无法检测出的异常，其余的都是可以在编译阶段检测出来的。</p>
<p>error是比较严重的错误，例如oom或者stackoverflow，还有虚拟机内部的一些问题，这些error会导致线程直接终止，<del>并不能用try&#x2F;catch</del></p>
<blockquote>
<p>gpt了一下，其实error也可以用catch，因为都是继承自throwable接口，throwable满足这个语法糖。但是出现了error就算catch了程序还是出现了严重错误，捕获这些问题并不能修复，继续运行可能导致更加严重的问题。</p>
</blockquote>
<h2 id="finally方法块"><a href="#finally方法块" class="headerlink" title="finally方法块"></a>finally方法块</h2><ul>
<li>finally并不一定会执行：如果出现了电源掉电或者cpu卡死就不会（<del>这有点幽默了</del>）</li>
<li>不建议在finally里面写返回：try&#x2F;catch&#x2F;finally方法块的逻辑是，即使在try中已经返回了，也会执行finally里面的语句，try的返回值保存起来，同时如果finally里面也有return，就会覆盖try的返回值。</li>
</ul>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>Java数据的传输是通过字节流的，也就是一个byte[]数组，如何将Java转化为这个数组就是序列化要干的事情，原生提供的序列化可以提供实现serialization接口并且指定serialVersionUID完成序列化，这个serialVersionUID会为反序列化提供一个校验，如果id与当前要强制类型转换的类是一样的，那就可以转换，否则就会抛出异常。</p>
<p>比如下面这个代码，文件模拟的是传输的数据流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 显式定义版本号</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.ser&quot;</span>));</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line">            out.writeObject(person);</span><br><span class="line">            out.close();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 模拟反序列化后类发生变化</span></span><br><span class="line">            <span class="comment">// 修改 serialVersionUID 为 2L，模拟版本不匹配</span></span><br><span class="line">            <span class="comment">// private static final long serialVersionUID = 2L;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反序列化</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.ser&quot;</span>));</span><br><span class="line">            <span class="type">Person</span> <span class="variable">deserializedPerson</span> <span class="operator">=</span> (Person) in.readObject();  <span class="comment">// 读取对象</span></span><br><span class="line">            in.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Deserialized Person: &quot;</span> + deserializedPerson.name + <span class="string">&quot;, &quot;</span> + deserializedPerson.age);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();  <span class="comment">// 如果 serialVersionUID 不匹配，这里会抛出 InvalidClassException</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意几点：</p>
<ol>
<li>序列化转化的是对象，也就是说static修饰的字段是不会被序列化的，反正最终反序列化变成了一个对象之后类的静态属性又不会有变化，</li>
<li>不想序列化的变量用transient修饰，例如下面这个代码</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// static 字段</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">transientField</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// transient 字段</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">instanceField</span> <span class="operator">=</span> <span class="number">30</span>; <span class="comment">// 实例字段</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 序列化对象</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;example.ser&quot;</span>));</span><br><span class="line">            out.writeObject(example);</span><br><span class="line">            out.close();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 修改 staticField 值以查看序列化和反序列化的影响</span></span><br><span class="line">            Example.staticField = <span class="number">100</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 反序列化对象</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;example.ser&quot;</span>));</span><br><span class="line">            <span class="type">Example</span> <span class="variable">deserializedExample</span> <span class="operator">=</span> (Example) in.readObject();</span><br><span class="line">            in.close();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 打印结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Deserialized Example:&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Static Field: &quot;</span> + Example.staticField); <span class="comment">// staticField 仍然是 100</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Instance Field: &quot;</span> + deserializedExample.instanceField); <span class="comment">// instanceField 是 30</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Transient Field: &quot;</span> + deserializedExample.transientField); <span class="comment">// transientField 是 0</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>但是Java默认的这个序列化并不好，至少我在开发的时候都用的是Json，为什么呢？</p>
<ol>
<li>不支持跨平台，java序列化得到的字节流只能java反序列化出来，json不一样，java转化为的json可以用python再反序列化回来</li>
<li>性能较差，转化后的字节数组大</li>
<li>安全性</li>
</ol>
<h2 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String,StringBuffer,StringBuilder"></a>String,StringBuffer,StringBuilder</h2><ul>
<li>string是被final修饰的，同时内部的实现数组（char[]或者byte[]）是private，无法通过外界修改。因此字符串的拼接是需要新生成对象的。</li>
<li>stringbuffer：方法由synchronized修饰，是线程安全的，其拼接字符串不会创建一个新的stringbuffer类，效率比string不知道高到哪里去了</li>
<li>stringbuilder：在大部分情况下string的操作都不太需要线程同步，这个类就取消了同步操作，效率比上一个高。</li>
</ul>
<p><strong>字符串的拼接</strong></p>
<p>java是没有运算符重载的，但是唯一为了string的拼接修改了+和+&#x3D;，使得string可以通过+和+&#x3D;操作</p>
<p>查看字节码我们可以知道，其实string的+和+&#x3D;是基于stringbuilder调用append方法，最后再使用tostring赋值给String，但是每次进行这样一个拼接操作就需要new一个stringbuilder，对于循环来说，这样的开销就非常大了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    s += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>如果直接使用append来拼接，就不会有这个问题了。所以在大量字符串操作的时候用buffer或者builder比较好。</p>
<h2 id="字符串常量池和String对象"><a href="#字符串常量池和String对象" class="headerlink" title="字符串常量池和String对象"></a>字符串常量池和String对象</h2><p><strong>字符串常量池</strong><br>首先做个区分，java程序在编译成了class文件之后会有一个常量池，也叫做静态常量池。当在被类加载器加载进内存时会将其分为字符串常量池和运行时常量池。</p>
<ul>
<li>运行时常量池是一直跟着方法区的，方法区在哪里它在哪里。在jdk1.7的时候方法区叫做永久代，放在运行时数据区，也就是和堆栈在一起的区域，为了减少oom的可能和内存的压力，在jdk1.8以后被搬到了直接内存中，由操作系统管理不由jvm虚拟机管理，从而减少了jvm的内存压力。但是虚拟机参数可以配置元空间的大小，并不是可以无限扩大的，也会有oom：metaspace的报错。说回运行时常量池，包含了class文件里静态常量池里的字面量和符号引用，但唯独没有字符串。<strong>也就是说除字符串以外的字面量比如整形和浮点，符号引用的类与接口全限定名，方法和字段的名称和描述符，都还在运行时常量池；维度字符串排除出去了</strong></li>
<li>字符串常量池：在jdk1.6的时候是没有与运行时常量池分开来的，也是跟着方法区的，到了1.7被分到堆内存去了。原因是本来方法区进行垃圾回收的机会就很少，除了fullgc基本到不了这里，字符串又是一个很容易产生大量对象的地方。所以就放到heap中了，可以进行垃圾回收，这里创建出的也被称之为字符串对象。实际上String的引用都是在字符串常量池里的地址。</li>
</ul>
<p><strong>new String(“abc”)的问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>我们假设前面都没有关于abc这个字符串的创建，这个操作会创建两个对象：</p>
<ul>
<li>首先会在字符串常量池上创建abc这个对象</li>
<li>由于new了一个String对象，会在堆上创建一个新的对象</li>
</ul>
<p>但是如果前面有String s2&#x3D;”abc”，也就是前面已经有在字符串常量池里面创建对象了，前面这个new的代码只会创建一个对象，即堆内存上的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);  <span class="comment">// true，因为 s1 和 s2 都引用常量池中的同一个对象</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;              <span class="comment">// 常量池中的 &quot;abc&quot; 对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 堆中的新对象</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);   <span class="comment">// false，s1 和 s2 是不同的对象，s1 是常量池中的，s2 是堆中的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>那我在new了一个String以后，我怎么找到字符串常量池里面的对象？<br>intern可以直接找，返回的是在字符串常量池里的地址，这样就保证了字符串内容是一致的情况下，地址也完全一样，在某些要用锁的场合下，使用intern可以保证锁的对象是唯一的。<br>例如在黑马点评这个锁代码块里面：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span>  Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">	<span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里面每一个id的toString都会创建一个新的对象，为了保证锁对象的唯一性，需要用intern直接取出常量池的地址</p>
</blockquote>
<p>为什么要有这种设计？字符串常量池本身就是为了可重复才扩展的，有的时候不想要与字符串的常量池共享，就需要创建一个新的字符串。</p>
<h2 id="Double和BigDecimal的区别"><a href="#Double和BigDecimal的区别" class="headerlink" title="Double和BigDecimal的区别"></a>Double和BigDecimal的区别</h2><ul>
<li>double是基本数据类型，bigDecimal是类</li>
<li>double双精度浮点型可能会有数据溢出的情况，bigdecimal是用字符串做运算的，精度有保障，由于是字符串，会频繁创建对象，开销较大</li>
<li>精度要求特别高比如在金融领域需要用big</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>类加载器加载字节码文件分为三部分：通过类的全限定名获取字节码文件，将字节码文件生成一个InstanceKlass文件在方法区，保存了类的元数据包括字段，方法，虚方法表登；同时会在堆中生成一个Class对象，作为访问这个InstanceKlass对象的接口。 正是这个Class对象为Java反射提供了基础。</p>
<p>获取Class对象有以下四种方式：</p>
<ol>
<li>Class.forName传入路径</li>
<li>通过对象获取class（instance.getClass()）</li>
<li>通过类加载器传入loadClass路径获取（走的就是双亲委派机制那一套了，估计findClass是根据路径改造成全限定名然后找，但是这里仅仅是加载类，没有连接过程，所有静态代码块不会执行）</li>
<li>可以直接.class获取</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 获取Class对象</span></span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 获取构造器并创建对象</span></span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 获取并调用方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">sayHello</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">            sayHello.invoke(person);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 获取并修改字段</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">            ageField.setAccessible(<span class="literal">true</span>); <span class="comment">// 如果字段是private的，需要设置可访问</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> (<span class="type">int</span>) ageField.get(person);</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄: &quot;</span> + age);</span><br><span class="line">            ageField.set(person, <span class="number">30</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;修改后的年龄: &quot;</span> + ageField.get(person));</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设存在如下Person类</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好，我是&quot;</span> + name + <span class="string">&quot;，今年&quot;</span> + age + <span class="string">&quot;岁。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何获得私有变量&#x2F;方法：setAccessible</p>
</blockquote>
<p><strong>反射的优缺点</strong></p>
<ul>
<li>优点：灵活度高，多种框架都是基于反射的，能够在运行时动态操作类和对象</li>
<li>缺点：安全性，private字段可以访问，性能开销</li>
</ul>
<blockquote>
<p>总结：为什么反射的效率低？<br>反射效率低的原因可以归结为以下几点：</p>
<ul>
<li>需要进行动态的类型解析，耗费额外时间。 </li>
<li>反射的调用绕过了编译时的优化。 </li>
<li>反射需要执行额外的安全性检查。 </li>
<li>方法调用的间接性导致了额外的步骤和开销。 </li>
<li>缺乏JIT对反射的优化支持。 </li>
<li>频繁使用时，开销会明显累积。 </li>
<li>反射可能会引发对象包装和拆箱操作，进一步降低效率。</li>
</ul>
</blockquote>
<h2 id="switch能否用String当作case"><a href="#switch能否用String当作case" class="headerlink" title="switch能否用String当作case"></a>switch能否用String当作case</h2><p>在jdk1.7以后有了这个语法糖。在底层原理中switch仅支持int，char等基本数据类型。switch中string是通过case哈希值，然后在equals内容得到的。哈希值是一个int类型的，由于也可能产生哈希碰撞，所以还得再检查字符串内容是否相同。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的Class类对象。比如并不存在List<String>.class或是List<Integer>.class，而只有List.class。</p>
<p>也就是说泛型仅仅是在编译的时候做检查，而不会真正落到jvm里</p>
<h2 id="Object有哪些方法"><a href="#Object有哪些方法" class="headerlink" title="Object有哪些方法"></a>Object有哪些方法</h2><ul>
<li>wait和notify以及notifyAll：wait方法是放弃当前监视器锁，进入waitSet，状态变为WAIT。notify和notifyAll是唤醒当前监视器锁下面wait的线程，在hotspot中是分别是随机唤醒一个和全部唤醒。这个方法仅能在synchronized方法块中使用</li>
<li>hashCode和equals：下面讲</li>
<li>getClass：获取Class对象，与类.class方法是一样的，一共有四种方法获取Class对象（getClass，.class，类加载器loadClass,Class.forName）</li>
</ul>
<h2 id="hashCode和equals"><a href="#hashCode和equals" class="headerlink" title="hashCode和equals"></a>hashCode和equals</h2><p>说这两个就离不开集合，例如hashMap存储是按照hashCode散列找Entry，如果hashCode相同则在一个Entry下，但是有可能是哈希碰撞，所以还要比较equals，当且仅当hashCode相等并且equals返回为真的时候才会被认为是一个。在Object中默认hashCode是两个对象的内存散列，equals是比较内存地址是否相同。</p>
<p><strong>String重写的hashCode和equals</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s.hashCode()+<span class="string">&quot;  &quot;</span>+s1.hashCode());</span><br><span class="line">System.out.println(s.equals(s1));</span><br></pre></td></tr></table></figure>

<p>按道理来说s和s1是两个不同的对象，由于之前说的s应该是在字符串常量池，而s1是在堆中，hashCode按照Object默认的比较地址肯定是不相同的。但是String重写了hashCode，通过字符累加的方式计算哈希码，在保证了分散的同时使得相同字符串的哈希码相等。也重写了equals，比较字符串内容而不是比较地址。</p>
<p><strong>为什么重写了equals就必须重写hashCode</strong></p>
<p>如果两个对象内容相同就是一个对象的话，在set里面不能重复。需要重写equals，但是不重写hashCode可能会分配到不同的Entry，这样两个对象同时会被存储。所以保证equals为真的同时hashCode也要相同。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/">多线程总结</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-10
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ol>
<li>资源分配的角度来看：进程是资源分配的最小单位，线程的切换仅仅保存了较少的寄存器，线程不是资源分配的最小单位</li>
<li>调度的角度：没有引入线程的时候，进程是调度的最小单位，有了线程之后操作系统调度的就是线程了。</li>
<li>切换开销来看：线程的切换开销较小，只用保存较少的寄存器，进程切换的开销较大</li>
<li>并发的角度来看：同一个进程的线程可以并发，不同进程的线程之间也可以并发</li>
</ol>
<h2 id="Java的线程和操作系统的线程有什么区别"><a href="#Java的线程和操作系统的线程有什么区别" class="headerlink" title="Java的线程和操作系统的线程有什么区别"></a>Java的线程和操作系统的线程有什么区别</h2><p>在jdk1.2以前，java的线程是用户级线程，也就是一对多模型，向下操作系统申请一个线程，这个线程来轮询java的操作，在用户层面看上去是有多线程，但这样效率并没有提升</p>
<p>在此之后java的线程可以直接用内核级线程，也就是java创建的线程就是操作系统认可的一个线程。</p>
<h2 id="创建线程的方法"><a href="#创建线程的方法" class="headerlink" title="创建线程的方法"></a>创建线程的方法</h2><p>网上都说有四五种方法，但是其实只用一种就是thread.start()方法，但是为了完整性还是说一下这四种方法：</p>
<ol>
<li>继承Thread</li>
<li>实现Runnable接口:run方法不允许有返回值，也不能抛出异常</li>
<li>实现Callable接口：call可以有返回值，可以抛出异常</li>
<li>线程池</li>
</ol>
<blockquote>
<p>什么时候实现runnable接口什么时候继承thread：由于java是单继承的，如果有继承别的类就不能继承Thread了，此时就要使用Runnable接口<br>runnable和callable只是两个接口而已，直接运行对应的run和call是不能成为一个线程的，start是Thread类才有的方法，所以要真正运行起来线程需要new Thread(),这里面传入的是一个Runnable参数，Callable不行，需要用futureTask包装</p>
</blockquote>
<blockquote>
<p>callable怎么用？</p>
<ol>
<li>callable和futureTask:由于new Thread要传一个Runnable参数，Callable不是；所以要用futureTask包装</li>
<li>callable和线程池：submit给线程池返回一个future对象</li>
</ol>
</blockquote>
<h2 id="Future和FutureTask"><a href="#Future和FutureTask" class="headerlink" title="Future和FutureTask"></a>Future和FutureTask</h2><p>future是异步编程的一个体现，当前线程正在执行，我需要取到程序运行结束的结果，也就是未来的结果。具有取消任务，查看任务执行情况，获取任务执行结果等功能。而futureTask是其的一个实现类，同时实现了future和runnable接口，由于new Thread只能传Runnable接口，futureTask正式为了搭配Callable接口，使用的时候new Thread(new FutureTask(new Callable))</p>
<h2 id="线程池的submit和execute什么区别"><a href="#线程池的submit和execute什么区别" class="headerlink" title="线程池的submit和execute什么区别"></a>线程池的submit和execute什么区别</h2><ol>
<li>submit返回值为Future，可以执行Callable和Runnable任务，但是如果是runnable那future.get返回就是null，也可以抛出异常</li>
<li>execute返回值为空，只能执行Runnable任务</li>
</ol>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>类似原来408学的线程状态，但是在java中这些状态略有不同，相比于底层操作系统，这些状态更加高层次，因为不涉及到io操作阻塞进程：</p>
<ul>
<li>NEW:初始状态，一般是new Thread()，创建出来但是还没有执行start方法</li>
<li>RUNNABLE:运行状态，执行了start方法</li>
<li>BLOCKED:被synchronized方法阻塞了，没有抢到锁就进入这个状态，等到锁释放就变为RUNNABLE</li>
<li>WAITING:一般是线程之间通讯，调用了wait方法变成waiting状态，而等到notify或者notifyAll变为运行态</li>
<li>TIME_WAITING:具有具体时间的等待状态</li>
<li>TERMINATED:线程终止</li>
</ul>
<p><strong>BLOCKED和WAITING的区别</strong></p>
<ul>
<li>触发条件：线程没有获取到监视器锁（synchronized）就BLOCKING，WAITING是获取到了synchronized锁但是锁对象wait了，也就是释放了锁，主要用于线程通讯</li>
<li>唤醒条件：获取到锁了之后会解除BLOCKING，而别的线程对锁对象.notify或者notifyAll之后会唤醒waiting线程，但是要继续执行还是要获取锁</li>
</ul>
<p><strong>notify和notifyAll的区别</strong></p>
<ul>
<li>notify随机唤醒一个（这个是hotspot的机制，可能别的虚拟机是指定的）</li>
<li>notifyAll，当前锁对象下所有的WAITING线程，共同争抢。唤醒的线程在被 notify() 或 notifyAll() 唤醒后，仍然需要重新争抢对象的锁。它会从 WAITING 状态转换到 BLOCKED 状态，等待对象的锁释放。</li>
</ul>
<p><strong>wait和sleep方法的区别</strong></p>
<ul>
<li>wait是Object的方法，sleep是Thread的方法</li>
<li>wait释放锁，sleep不释放锁</li>
<li>wait需要notify唤醒而sleep到时间就唤醒了</li>
<li>wait主要用于进程同步，sleep延时</li>
</ul>
<blockquote>
<p>为什么wait定义在object里面而sleep定义在Thread里面：<br>与他们使用的场合有关，wait需要在synchronized方法中运用，而代码块的锁正是object，操作的并不是线程<br>而sleep的作用是让线程睡眠一段时间，这显然跟锁没什么关系，就定义在线程中</p>
</blockquote>
<h2 id="死锁的四个条件，通过什么方法解决"><a href="#死锁的四个条件，通过什么方法解决" class="headerlink" title="死锁的四个条件，通过什么方法解决"></a>死锁的四个条件，通过什么方法解决</h2><ul>
<li>互斥条件：一个资源同时刻只能有一个线程访问</li>
<li>不剥夺条件：一个线程的资源不可以被别的线程剥夺</li>
<li>占有且等待条件：一个线程获取不到更多的资源，原来持有的资源也不会释放</li>
<li>循环等待条件：资源的请求变成了一个环，大家都拿不到对应的资源</li>
</ul>
<blockquote>
<p>破坏这四个条件是<strong>死锁预防</strong>要做的事情。此外还有死锁避免（银行家算法），死锁检测和恢复（有向图检测方法）。这三个大的方法性能由低到高，对死锁的控制由严格到松。</p>
</blockquote>
<ul>
<li>破坏互斥条件：多增加临界资源的数量（虚拟化）</li>
<li>破坏不剥夺条件：抢占式调度（还有一种是协同式调度，是等到当前线程结束才进行线程调度），得不到资源就释放</li>
<li>破坏占有等待条件：可以先申请，检查当前系统剩余资源是否能够让线程运行，一次性全拿而不是一次拿一点</li>
<li>循环等待条件：编号，类似TCP的同步号</li>
</ul>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><ol>
<li>在多线程环境中，每个线程都有自己的 CPU 缓存，线程在读写变量时可能会先将变量的值缓存在自己的工作内存中，而不是直接从主内存中读取或写入。使用volatile关键字就告诉程序这个变量是不稳定的，禁用cpu缓存，每次找这个变量都需要去主存取，</li>
<li>在jvm的执行优化中可能出现指令重排序，也就是123条指令，可能实际变成132，volatile关键字能够在其中加上内存屏障，禁止指令重排序（主要用在双校验单例模式）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>能保证可见性，但不能保证原子性，例如再出现i++这种操作的时候，即使volatile i，还是会有线程安全问题。因为i++其实是三个操作，从内存取出i，对这个副本+1，再把其写回内存。此时两个线程来操作就会少一次+1。（可以加锁synchronized,reentrantlock或者用AtomicInteger的cas操作）</li>
</ol>
<blockquote>
<p>内存屏障：</p>
<ul>
<li>写 volatile 变量时： 当一个线程写入 volatile 变量时，JVM 会在写操作后插入一个写内存屏障（Store Memory Barrier），确保所有在 volatile 变量写操作之前的内存操作都已经完成，并且这些操作的结果对其他线程可见。 在 Java 内存模型中，写 volatile 变量时会确保该写入操作之前的所有变量修改都被刷新到主内存中，然后将 volatile 变量的值写入主内存。 </li>
<li>读 volatile 变量时：当一个线程读取 volatile 变量时，JVM 会在读操作前插入一个读内存屏障（Load Memory Barrier），确保所有在 volatile 变量读操作之后的内存操作都不会被重排序到它之前。 在 Java 内存模型中，读 volatile 变量时，会确保在读取这个 volatile 变量之后，线程能够看到所有其他线程在写入该 volatile 变量之前对其他变量的修改。</li>
</ul>
</blockquote>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ol>
<li>可以修饰实例方法，锁住当前对象</li>
<li>修饰静态方法，锁住当前类。这里就会有个有意思的事情，修饰在静态方法上的synchronized和实例方法上的<strong>不互斥</strong>，因为静态方法锁住的是当前类，实例方法锁住的是对象</li>
<li>修饰代码块，这个比较灵活<blockquote>
<p>注意这里不能修饰构造函数，构造函数本身就是线程安全的</p>
</blockquote>
</li>
</ol>
<p><strong>原理</strong><br>基于jvm的monitor，在代码块进入前加上monitorenter，退出的时候加上monitorexit，也是可重入的，底层是监视器维护了一个state字段，有锁进来就+1，重入多次就+n，退出-1，同时也会有维护一个队列存放未获取锁的对象，等到释放了就会唤醒（BLOCKED）</p>
<p>两个队列entryList和waitList:</p>
<ul>
<li>entryList是进入锁代码块的所有线程，当锁释放了之后其中的一个线程会给monitor上锁，同时+1（队列里的状态为BLOCKED），注意这里是队列里所有线程都进行竞争，所以synchronized是非公平锁</li>
<li>waitList是调用了wait方法的线程，等待notify或者notifyAll进行唤醒，唤醒之后还需要重新获得锁，也就是要进入entryList里（状态为WAITING）</li>
</ul>
<p><img src="/../img/Java/img_9.png"></p>
<p><strong>锁升级</strong></p>
<ul>
<li>不加锁：</li>
<li>偏向锁：当第一个线程进入之后会给其加上偏向锁，使得这个资源偏向。</li>
<li>轻度锁：使用cas操作</li>
<li>重度锁：</li>
</ul>
<blockquote>
<p>为什么会有偏向锁这个过程：<br>对于竞争不激烈但是还有加了synchronized关键字的，如果是单线程就没有必要进行锁和上下文切换，偏向锁的初衷正是为了减小上下文切换的开销。如果一个线程反复进入和退出同步块，而没有其他线程争用这把锁，那么这些加锁解锁的开销是完全多余的。</p>
</blockquote>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>抽象队列同步器（AbstractQueuedSynchronizer）提供了一种同步机制，被应用于Reentrantlock，semaphore，cyclicBarrier等排他和共享锁结构中。</p>
<p>在说AQS之前先要讨论一下CHL锁，因为AQS是基于CHL的。CHL锁是一个队列结构，头节点是一个空节点，当线程进入后会对前驱节点的资源释放状态做cas，例如第一个线程进入之后就对表头节点的锁资源cas，获取到了就改变自己的值为false，后续另外一个线程进入之后就会轮询上一个节点的状态，拉成一个队列。</p>
<p>这种结构的好处是资源状态分布在每个节点上，但同时也增大了cpu的开销，因为每一个节点都需要轮询。</p>
<p>AQS正式基于这种思想，首先他把CHL的虚拟队列改造成了显式队列，保存了前驱和后继（为了满足一些对于公平锁和非公平锁的要求，使用了双向链表），全局维护一个state，当获取到锁之后state+1，可以实现锁重入。</p>
<h2 id="reentrantLock"><a href="#reentrantLock" class="headerlink" title="reentrantLock"></a>reentrantLock</h2><p>reentrantLock基于aqs，实现可重入，可中断，可以设置公平锁，可以有多个条件设置，可以设置超时时间。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/10/%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/">集合总结</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-10
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="数组与集合区别，用过哪些？"><a href="#数组与集合区别，用过哪些？" class="headerlink" title="数组与集合区别，用过哪些？"></a>数组与集合区别，用过哪些？</h2><ol>
<li>数组是定长的，集合不是定长的，例如ArrayList是动态数组</li>
<li>数组存储的是基本数据类型和对象，而集合只能存储对象（这里也可以引申出为什么要有包装类，为了统一集合的操作需要把基本数据类型包装成对象，int变成Integer，但是这样也会有自动拆箱导致的性能问题）</li>
<li>数组可以随机访问，集合需要通过迭代器或者其他方法访问（其实还是由于包装了）</li>
</ol>
<p>用过哪些：ArrayList,LinkedList,Vector,HashSet,TreeSet,BlockingQueue,HashMap.TreeMap,LinkedHashMap</p>
<h2 id="说说Java中的集合？"><a href="#说说Java中的集合？" class="headerlink" title="说说Java中的集合？"></a>说说Java中的集合？</h2><p>Java的集合类分为两个大类，Collection接口实现的List，Set和Queue，以及Map接口。Collection存储的是<strong>单一元素</strong>，而Map存储的是<strong>键值对</strong>。</p>
<p>在Collection接口下：</p>
<ol>
<li>List是顺序的，主要实现类是ArrayList，底层基于动态数组，LinkedList，底层基于双向链表，Vector，是加了重度锁的有线程安全的顺序数据结构，由于性能一般已经很少用了</li>
<li>Set是集合，存储的元素不能重复：HashSet基于HashMap（有待考究），TreeSet是基于红黑树，按照某种顺序有序的集合。</li>
<li>QUeue是队列，了解较少</li>
</ol>
<p>在Map接口下：</p>
<ol>
<li>HashMap：jkd1.7基于Entry+链表的形式，在1.8之后改成Node+链表+红黑树。线程不安全</li>
<li>TreeMap：基于红黑树，可以根据key的大小排序</li>
<li>LinkedHashMap：基于HashMap，但是内部维护了一个双向链表来指定顺序，1.7之前是循环链表，1.8以后是双向链表</li>
</ol>
<h2 id="Java中的线程安全的集合是什么？"><a href="#Java中的线程安全的集合是什么？" class="headerlink" title="Java中的线程安全的集合是什么？"></a>Java中的线程安全的集合是什么？</h2><p>在java.util包下的数据结构，也就是本身设计就是为了线程安全的：</p>
<ol>
<li>Vector：操作都用了synchronized方法，用copyOnWriteArrayList替代</li>
<li>HashTable：也是加了重度锁的哈希表，性能不如concurrentHashMap</li>
</ol>
<p>在1.8以后有Concurrent的包出现，带来了很多新的线程安全的集合</p>
<ol>
<li>ConcurrentHashMap：1.7之前是分段锁，把每个Segment都锁上，默认可以实现16个线程并发（前提是他们访问的这些数据都分布在16个不同的Segment上）。1.8以后是用了Node+链表+红黑树，锁的粒度变小了，只用synchronized锁住头节点，然后如果要添加到话用cas操作，大大减轻了锁的粒度，性能较好</li>
<li>CopyONWriteArrayList：写时复制COW，指的是在写操作的时候赋值一份副本在副本上进行操作，最后再用新数组替换旧的数组，如果期间原数组有操作，就记录下来最后进行变更</li>
</ol>
<h2 id="Collections和Collection的区别"><a href="#Collections和Collection的区别" class="headerlink" title="Collections和Collection的区别"></a>Collections和Collection的区别</h2><p>Collection是一个接口，如上面所述；Collections是一个工具类，提供了一系列静态方法来帮助完成集合的操作，比如sort</p>
<blockquote>
<p>Collections还有一个方法可以让HashMap变成线程安全的集合，这个方法是给所有HashMap的方法加上synchronized关键字，这样效率是很低的，所以能用还是用ConcurrentHashMap吧</p>
</blockquote>
<h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><ol>
<li>底层数据结构不同：ArrayList基于的是动态数组自动扩容，LinkedList基于的是双向链表，都不是线程安全的</li>
<li>增删改查的时间复杂度不一样，ArrayList可以支持随机查询，但是增删都需要平均一半的时间o(n&#x2F;2)，双向链表在头尾增删有比较高的效率，但是在中间添加也是有查询的时间复杂度（注意，这里ArrayList实现了RandomAccess接口，表示可以支持随机访问，但是这个接口是空的，仅仅作为一个标记）</li>
<li>空间占用，ArrayList是连续的数据结构，数据密度大，而LinkedList可以是离散的，由于要存储下一个数据的指针，需要额外的空间，数据密度不大</li>
</ol>
<h2 id="ArrayList的初始化"><a href="#ArrayList的初始化" class="headerlink" title="ArrayList的初始化"></a>ArrayList的初始化</h2><p>ArrayList有两种初始化方式（还有一种是输入集合的，考察的比较少）：</p>
<ol>
<li>无参构造方法，初始化为一个默认的DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空数组，并没有分配具体对象，到后面grow操作才会有对象</li>
<li>有参构造方法，如果输入的长度不为0，直接就new一个Object数组，如果输入的长度为0，初始化为另外一个EMPTY_ELEMENTDATA的空数组</li>
</ol>
<blockquote>
<p>为什么要有两个这个空数组呢，是因为需要区分是否为有参构造函数，在后续的扩容操作中只有DEFAULTCAPACITY_EMPTY_ELEMENTDATA才会分配默认值。这个在后续扩容操作有用处</p>
</blockquote>
<h2 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h2><blockquote>
<p>注意区分数组长度elementData.length和数据量size</p>
</blockquote>
<ol>
<li>再添加一个元素之前，先检查下一个位置是否存在，进行检查，传入参数是当前数据量+1；检查的目的是为了确定数组长度能否支持下一个数据的添加</li>
<li>在检查前针对无参构造方法有一个当前需要的最小长度的计算，由于初始化的时候长度没有确定，这个时候需要的最短长度就是默认的10；其余的方法容量计算的结果就是传入参数直接输出（即数据量+1）</li>
<li>进行检查，如果这个需要的最短长度大于了数组长度，就需要扩容了</li>
<li>扩容：非0情况下是1.5倍的原长度，如果原长度为0，则新长度为刚刚计算得到的最小长度。</li>
</ol>
<blockquote>
<p>引申问题1:new ArrayList()和new ArrayList(0)第一次扩容的长度是多少，由刚刚的分析可知，有参在最小长度计算得到的长度为0+1&#x3D;1，无参为10，所以说第一次扩容分别为10和1<br>引申问题2:new ArrayList(10)在添加一个元素的时候扩容了几次，没有扩容，因为在构造函数里面已经有分配空间，而且1&lt;10，不会触发grow</p>
</blockquote>
<h2 id="ArrayList是线程安全的吗？如果想用线程安全的List怎么操作"><a href="#ArrayList是线程安全的吗？如果想用线程安全的List怎么操作" class="headerlink" title="ArrayList是线程安全的吗？如果想用线程安全的List怎么操作"></a>ArrayList是线程安全的吗？如果想用线程安全的List怎么操作</h2><p>ArrayList不是线程安全的，主要是因为在加入数据的时候++操作不是原子性的，首先先说明加入数据的逻辑，总结为如下：</p>
<ol>
<li>先进行上面所述的校验和扩容</li>
<li>再在当前size的位置添加元素（引发线程安全）</li>
<li>最后将当前的size+1</li>
</ol>
<p>有以下三种情况会引发线程安全问题：</p>
<ol>
<li>出现null值，线程a添加2位置的元素，此时线程b也同时进来想要添加2位置的元素，线程a添加完成后没有立刻size++，线程b也存到当前位置，最后两个都size++，此时size为4，2的位置由于重复冲掉了一个数据，3的位置直接就是null。</li>
<li>出现溢出：当前长度为9，容量是10，两个线程同时在9的时候添加，就会出现溢出</li>
<li>size和put的次数不一样：这个出现的最多，也是因为size++</li>
</ol>
<p>如何使用线程安全的list：</p>
<ol>
<li>Collections.synchronizedList(arrayList)，相当于在方法上全部加上synchronized，效率低</li>
<li>CopyOnWriteArrayList：写操作用reentrantlock来保证不会出现<strong>上述1和3</strong>的线程安全问题，临界区内执行复制，不会影响读操作，存入完成后进行地址替换。虽然这种方法确实是线程安全的，但是每次写操作都要进行上锁和复制数组，在写多读少的情况下肯定是不好的。只适用于读多写少</li>
<li>Vector：效率更低，已经淘汰</li>
</ol>
<h2 id="LinkedList的机制"><a href="#LinkedList的机制" class="headerlink" title="LinkedList的机制"></a>LinkedList的机制</h2><p>双向链表，查询数据的复杂度为o(n)，在首尾添加数据的复杂度为o(1)</p>
<h2 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h2><p>HashMap的结构经历了大的改版，在jkd1.7HashMap是基于Entry数组的，哈希冲突用拉链法解决，就形成了Entry数组+链表的结构；在jkd1.8以后，拉链超过一定的数量转化成查询效率更高的红黑树，形成了Entry数组+链表+红黑树的结构</p>
<p>解决哈希冲突的方法（复习）：</p>
<ol>
<li>拉链法：把冲突的都还是放在原来的位置</li>
<li>开放选址法：线性探测法（顺序往后面找），二次探测（1，4，9这样找）</li>
<li>再散列法：把冲突的再进行散列</li>
<li>哈希桶扩容：减小碰撞的可能性</li>
</ol>
<h2 id="HashMap的put过程"><a href="#HashMap的put过程" class="headerlink" title="HashMap的put过程"></a>HashMap的put过程</h2><ol>
<li>首先会判断是否初始化，如果没有初始化（比如空参构造方法）就resize</li>
<li>按照hash方法计算哈希值，这个哈希值的计算是通过hashcode和高位的异或运算得出，融合了高位和低位信息的hash函数，效果会更好</li>
<li>与当前Entry数组进行取余操作，这里的取余是位运算，hash&amp;(n-1)，hashmap规定n必须是2的整数倍，也就是说n-1为最高位为0，其余都是1的二进制数，与hash进行与运算就能得到余数，位运算比%的效率高</li>
<li>得到了应该存储的Entry号，判断这个Entry上有没有别的元素，如果没有就直接写上去（这里还要判断是不是一个key，如果是一个key的话需要替换值）</li>
<li>如果有别的元素，首先判断是不是红黑树的节点，如果是红黑树的节点就走红黑树的添加逻辑</li>
<li>如果不是红黑树，是链表，在查找的过程中还需要看key是否重复，如果是重复的还需要覆盖v，如果没有重复的key就添加到表尾（尾插法，这也是1.8与1.7的一个区别，1.7的尾插会出现一些并发安全问题）</li>
<li>如果加入之后大于红黑树的阈值，还需要转换成红黑树</li>
<li>最后检查size，如果大了就需要resize</li>
</ol>
<p><img src="/../img/Java/img_6.png"></p>
<h2 id="HashMap如何检查重复"><a href="#HashMap如何检查重复" class="headerlink" title="HashMap如何检查重复"></a>HashMap如何检查重复</h2><p>主要是靠这一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))</span><br></pre></td></tr></table></figure>
<ol>
<li>首先判断两个的hash值，hash值相同说明碰撞了</li>
<li>再判断key的地址是不是一个，如果是基本数据类型那就是比较本身，如果是字符串或者是对象就比较地址</li>
<li>再比较内容，如果内容是一个那就是相同的，比如两个不同地址的字符串但是内容都是“abc”，再map这里也是一个</li>
</ol>
<h2 id="HashMap的resize机制"><a href="#HashMap的resize机制" class="headerlink" title="HashMap的resize机制"></a>HashMap的resize机制</h2><ol>
<li>首先进行新数组的长度和阈值的计算，如果当前数组有长度和阈值，那就都乘2，如果有阈值但是没有长度（或长度为0，这种情况可能是有参构造函数造成的，在构造函数中只有这个阈值的初始化）就把要最小数组长度设置为阈值（此阈值不是那个乘负载因子的阈值），最后就是无参构造函数的，直接设置最小数组长度为默认的16</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">     <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span></span><br><span class="line">     <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据最小数组长度和阈值进行扩容，进行新的哈希值计算</li>
<li>链表上的元素根据e.hash&amp;oldCap，得到高位是0或者1，如果是1就放在新加的数组后面：</li>
</ol>
<p><img src="/../img/Java/img_7.png"></p>
<p><img src="/../img/Java/img_8.png"></p>
<ol start="4">
<li>红黑树也根据哈希值按照上述方法进行分裂，小于6个点的退化为链表’</li>
</ol>
<h2 id="为什么HashMap要用2的整数倍"><a href="#为什么HashMap要用2的整数倍" class="headerlink" title="为什么HashMap要用2的整数倍"></a>为什么HashMap要用2的整数倍</h2><ol>
<li>位运算的取余操作</li>
<li>扩容机制巧妙将0，1分开</li>
</ol>
<h2 id="HashMap怎么样才能不扩容"><a href="#HashMap怎么样才能不扩容" class="headerlink" title="HashMap怎么样才能不扩容"></a>HashMap怎么样才能不扩容</h2><p>只要满足大于扩容阈值就行了，如果预计有100个数据要进入hashmap，那就做一个（100&#x2F;负载因子）+1这么大的数组，这样可以保证不会触发扩容，当然初始化的resize还是有的</p>
<h2 id="HashMap的线程安全问题"><a href="#HashMap的线程安全问题" class="headerlink" title="HashMap的线程安全问题"></a>HashMap的线程安全问题</h2><p>并不是安全的，主要会有以下几个问题：</p>
<ol>
<li>在jkd1.7，由于是头插法，在数据迁移的过程中可能会出现死循环的问题，有两个数据A-&gt;B，线程1和2同时操作当前快照，线程1已经操作了这两个节点变为B-&gt;A，线程2的当前节点为A，next为B，此时线程2进行操作，插入A节点，把当前节点换为B，B的next也是A，这样就循环了</li>
<li>此外还是会有跟ArrayList那种出现索引位置重复，比如当前某个Entry上没有元素，两个hash冲突的就可能会覆盖</li>
<li>还有size与put操作次数不一致的问题</li>
</ol>
<p>什么方法解决？</p>
<ol>
<li>concurrentHashMap：一种基于多段锁的Map</li>
<li>HashTable：直接锁整个表</li>
</ol>
<h2 id="concurrentHashMap和HashTable的区别"><a href="#concurrentHashMap和HashTable的区别" class="headerlink" title="concurrentHashMap和HashTable的区别"></a>concurrentHashMap和HashTable的区别</h2><p>concurrentHashMap在jdk1.7以前是segment+hashEntry+链表构成，给每个segment上锁，默认支持16的并发（前提是每一个线程访问的数据都不在一个segment上）；在jdk1.8以后通过synchronized+cas+node完成了并发控制，直接在hashmap进行锁操作，用synchronized锁住头节点，cas锁住添加操作。HashTable是方法全加synchronized的哈希表，效果肯定是不如cas的</p>
<blockquote>
<p>concurrentHashMap什么时候用synchronized什么时候用cas，当Entry是空节点的时候就用自旋锁，当不为空就不用</p>
</blockquote>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet是基于HashMap的，由于HashMap的特性会替换重复的key，HashSet直接把当前元素作为key，这样就可以达到去重的目的</p>
<h1 id="未完待续。。。。。"><a href="#未完待续。。。。。" class="headerlink" title="未完待续。。。。。"></a>未完待续。。。。。</h1>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/08/16/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/">jvm-类加载器和双亲委派机制</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-08-16
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>首先回顾一下类加载的过程。类的生命周期分为以下七个阶段：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载。其中加载是生命周期的第一个阶段，类加载器用不同的方式加载jar包，可以从classpath，动态代理和网络获取要加载的类。</p>
<p>类加载主要做了以下三件事：</p>
<ol>
<li>用类的全限定名找到类的class文件，也就是字节流</li>
<li>将字节流文件转化为方法区中运行时数据结构InstanceKlass，保存常量池，字段，方法等内容</li>
<li>在堆中创建相应Class对象，映射到方法区的数据结构，这部分是允许程序员操纵的</li>
</ol>
<blockquote>
<p>在 Java 的类加载阶段，<code>InstanceKlass</code> 和 <code>Class</code> 对象各自扮演了不同的角色。理解它们的作用有助于更好地理解 Java 类加载和运行时的内部机制。</p>
</blockquote>
<h3 id="1-InstanceKlass"><a href="#1-InstanceKlass" class="headerlink" title="1. InstanceKlass"></a>1. <strong><code>InstanceKlass</code></strong></h3><p><code>InstanceKlass</code> 是在某些 Java 虚拟机（JVM）实现中用于表示类的内部数据结构的一个术语（例如在 HotSpot JVM 中）。它是 JVM 内部的一个概念，主要用于存储和管理类的各种元数据。<code>InstanceKlass</code> 包含了类的实例字段、方法、常量池等信息，主要用于：</p>
<ul>
<li><strong>表示和管理类的元数据</strong>：包括类的字段、方法、常量池等。</li>
<li><strong>支持类的实例化和动态操作</strong>：在 JVM 内部用于实现类实例化、反射等操作。</li>
<li><strong>管理类的加载和初始化</strong>：确保类在加载、链接和初始化过程中能够正确地管理其结构和状态。</li>
</ul>
<p><code>InstanceKlass</code> 是 JVM 内部对类的表示，主要用于实现 JVM 的各种内部操作，通常不会被应用程序直接访问或操作。</p>
<h3 id="2-Class-对象"><a href="#2-Class-对象" class="headerlink" title="2. Class 对象"></a>2. <strong><code>Class</code> 对象</strong></h3><p><code>Class</code> 对象是 Java 语言层面提供的，用于表示和操作 Java 类的一个公共 API。每个 Java 类在运行时都有一个 <code>Class</code> 对象，用于提供对该类的元数据的访问。<code>Class</code> 对象的作用包括：</p>
<ul>
<li><strong>反射</strong>：提供了用于访问类的信息和操作类的方法（如获取类的字段、方法、构造函数等）。</li>
<li><strong>类型检查</strong>：在运行时进行类型检查和类型转换。</li>
<li><strong>动态实例化</strong>：允许在运行时创建类的实例（如 <code>Class.forName</code> 和 <code>newInstance</code>）。</li>
</ul>
<h3 id="类的加载阶段的角色和作用"><a href="#类的加载阶段的角色和作用" class="headerlink" title="类的加载阶段的角色和作用"></a>类的加载阶段的角色和作用</h3><ol>
<li><p><strong>加载（Loading）</strong>：</p>
<ul>
<li>在这个阶段，JVM 会根据类的全限定名找到类文件（<code>.class</code> 文件），并将其字节码读入内存。此时，<code>InstanceKlass</code> 对象可能在内部被创建来管理这个类的字节码和元数据。</li>
</ul>
</li>
<li><p><strong>链接（Linking）</strong>：</p>
<ul>
<li><strong>验证（Verification）</strong>：确保类文件的字节码符合 Java 虚拟机规范。</li>
<li><strong>准备（Preparation）</strong>：为类的静态变量分配内存并初始化。</li>
<li><strong>解析（Resolution）</strong>：将类中的符号引用解析为直接引用。</li>
</ul>
</li>
<li><p><strong>初始化（Initialization）</strong>：</p>
<ul>
<li>执行类的静态初始化代码（如静态块）。</li>
</ul>
</li>
</ol>
<h3 id="InstanceKlass-和-Class-对象的关系"><a href="#InstanceKlass-和-Class-对象的关系" class="headerlink" title="InstanceKlass 和 Class 对象的关系"></a><code>InstanceKlass</code> 和 <code>Class</code> 对象的关系</h3><ul>
<li>在内部，<code>InstanceKlass</code> 是 JVM 实现中的一个结构，用于存储和管理类的内部数据和状态。</li>
<li><code>Class</code> 对象是 Java 语言层面的一个公共 API，提供了对类信息的访问。</li>
</ul>
<p><strong>在类加载阶段，<code>InstanceKlass</code> 负责 JVM 内部的类数据结构管理和维护</strong>，而 <code>Class</code> 对象则提供了给应用程序使用的接口来访问和操作这些数据。它们各自作用于不同的层面，但在类加载和运行时的操作中是相辅相成的。</p>
<h3 id="关系总结"><a href="#关系总结" class="headerlink" title="关系总结"></a>关系总结</h3><ul>
<li>**<code>InstanceKlass</code>**：JVM 内部用于表示和管理类的元数据，是实现细节。</li>
<li><strong><code>Class</code> 对象</strong>：Java API 提供的类元数据的公共接口，让应用程序能够通过反射等机制与类进行交互。</li>
</ul>
<p><strong><code>InstanceKlass</code> 和 <code>Class</code> 对象</strong> 在类加载过程中相互协作，使得类的内部管理与外部访问得以实现。</p>
<blockquote>
<p>补充知识点：反射</p>
<p>反射是通过操作Class文件，在类的运行过程中动态的获取一些信息，比如当前时刻的字段和方法。首先在某个类的加载阶段，会在jvm的方法区生成一个InstanceKlass文件，这是由c++实现的，同时也会在堆中生成一个Class对象，该对象有反射的功能。<br>在需要使用反射的时候，利用Class.forName(全限定名)，可以在堆中取出该Class对象，完成反射调用。</p>
</blockquote>
<h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p>一般来说，自上而下可以分为四个类加载器：</p>
<h3 id="启动类加载器-BootStrapClassLoader"><a href="#启动类加载器-BootStrapClassLoader" class="headerlink" title="启动类加载器(BootStrapClassLoader)"></a>启动类加载器(BootStrapClassLoader)</h3><p>由jvm提供c++编写，对于java程序员不可见，当打印类加载器名为null的时候即为启动类加载器。一般用于加载java核心类（rt）</p>
<h3 id="扩展类加载器-ExtensionClassLoader"><a href="#扩展类加载器-ExtensionClassLoader" class="headerlink" title="扩展类加载器(ExtensionClassLoader)"></a>扩展类加载器(ExtensionClassLoader)</h3><p>加载一些拓展jar包，比如applet等一系列非java核心功能，但是有时候有需要用到的官方包</p>
<h3 id="应用程序类加载器-ApplicationClassLoader"><a href="#应用程序类加载器-ApplicationClassLoader" class="headerlink" title="应用程序类加载器(ApplicationClassLoader)"></a>应用程序类加载器(ApplicationClassLoader)</h3><p>加载在classpath下用户编写的所有java类和jar包</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>用户为了实现某些特定功能编写的，首先说明在java中的ClassLoader继承结构，ClassLoader是一个抽象类，URLClassLoader实现了在对应路径下的二进制文件写入内存的操作。其中由几个重要方法：</p>
<ul>
<li><code>protected Class&lt;?&gt; findClass(String name)</code>：传入的参数为全限定名。默认实现是空方法，在URLClassLoader中将全限定名转换成了路径（.改成了&#x2F;，后缀添上了.class），自定义类加载器需要重写该方法，自定义逻辑去实际查找并加载类的字节码。例如，从网络、数据库或非标准路径加载类。</li>
<li><code>public Class&lt;?&gt; loadClass(String name)</code>：入口方法，遵循双亲委派机制。<strong>双亲委派机制</strong>：当要加载一个类的时候，如果当前类加载器发现已经加载过该类（调用findLoadedClass，这个方法会使用native方法完成判断是否加载），就直接返回该Class对象，如果没有加载就委派父加载器进行加载，直到启动类加载器。启动类加载器会自顶向下判断是否能够加载当前类，比如启动类加载器加载不了的就给扩展类加载器，如果全部都加载不了，则报错ClassNotFoundException<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 检查类是否已经被加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 委派给父类加载器</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 使用引导类加载器加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 父加载器找不到类</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果父加载器也找不到类，则调用 findClass 方法加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>protected final Class&lt;?&gt; defineClass()</code>：做一些类名的校验，然后调用虚拟机的native方法将字节码信息加载到虚拟机缓存中</li>
</ul>
<blockquote>
<p>defineClass() 与 loadClass() 和 findClass() 的关系:</p>
<ul>
<li>loadClass()：loadClass() 是类加载的入口方法，负责按照双亲委派模型加载类。如果父类加载器无法加载该类，loadClass() 最后会调用当前类加载器的 findClass()。 </li>
<li>findClass()：findClass() 是自定义类加载器用于查找类字节码的地方。一般自定义类加载器会重写 findClass()，在找到类的字节码后，通过调用 defineClass() 将其定义为 Class 对象。 </li>
<li>defineClass()：defineClass() 是类加载过程中的核心步骤，负责将字节码转化为 JVM 识别的 Class 对象。通常是 findClass() 方法中的最后一步。</li>
<li>调用关系：loadClass双亲委派机制，用findClass实现文件到字节数组的转换，defineCLass完成字节数组到内存的转化</li>
</ul>
</blockquote>
<p><strong>还有一个要注意的点：</strong></p>
<p>loadClass()有一个resolve参数，这个参数默认为false，代表只进行加载阶段，不进行连接阶段。比如要加载的类中有静态代码块，只调用loadclass是不会初始化这个代码块的，原因是只有加载阶段，不会进行连接更不会初始化了。</p>
<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><ol>
<li>自底向上委托父类加载器完成加载</li>
<li>自顶向下加载类</li>
<li>好处：可以避免重复加载类；保证安全性</li>
</ol>
<h2 id="打破双亲委派机制——Tomcat"><a href="#打破双亲委派机制——Tomcat" class="headerlink" title="打破双亲委派机制——Tomcat"></a>打破双亲委派机制——Tomcat</h2><p>在Tomcat中，往往包含了很多的web应用，这些应用的全限定名很可能相同（例如启动了两个相同的服务）。对于双亲委派机制而言，每一个web应用都会委派父类加载器进行加载来保证当前classpath下的全限定名唯一性，比如demo1加载了com&#x2F;yyf&#x2F;service.class而demo2也有这个类，此时根据机制由于存在一个全限定名相同的类，demo2下的新类不会被加载，这样就会出现问题，因此我们要打破双亲委派机制。</p>
<h3 id="Tomcat的类加载器"><a href="#Tomcat的类加载器" class="headerlink" title="Tomcat的类加载器"></a>Tomcat的类加载器</h3><p>Tomcat定义了一系列类加载器：<br><img src="/../img/jvm/img_2.png"></p>
<ul>
<li>common：通用类，Tomcat和web应用都要使用的类</li>
<li>catalina:Tomcat要使用的类（注意：在tomcat中默认没有配置这个的路径，此时catalina类加载器即为common加载器，如果需要使用catalina加载器，需要在catalina.properties中进行路径的配置）</li>
<li>shared：web应用要使用的可以共享的类，比如spring和mybatis（注意：与上面的类似，tomcat默认没有配置，此时也为common类加载器）</li>
<li>并行web应用类加载器：每个应用一个</li>
</ul>
<blockquote>
<p>注：共享类加载器<br>如果所有的web应用都是基于SSM的，可以配置共享类加载器实现只加载一次Spring容器，但是可能由于版本不同可能导致兼容问题，以及由于存在的大量反射会导致类污染，所以需要谨慎选择shared加载的类</p>
</blockquote>
<h3 id="如何打破双亲委派机制"><a href="#如何打破双亲委派机制" class="headerlink" title="如何打破双亲委派机制"></a>如何打破双亲委派机制</h3><p>有了前面web应用隔离的需求，tomcat通过为每一个web应用创建一个并行web类加载器，只有当全限定名和加载器都是同一个时，才会被认为是重复加载，<br><img src="/../img/jvm/img_3.png"></p>
<ul>
<li>左边是双亲委派机制：当需要加载一些内部类的时候还是要走双亲委派机制到启动类加载器</li>
<li>右边是打破双亲委派机制：比如com&#x2F;yyf&#x2F;myclass.class这个类，并行web应用类加载器就会直接自己加载，但是如果没有加载成功还是会委派父类加载器进行加载</li>
</ul>
<h2 id="打破双亲委派机制？——spi机制"><a href="#打破双亲委派机制？——spi机制" class="headerlink" title="打破双亲委派机制？——spi机制"></a>打破双亲委派机制？——spi机制</h2><p>spi机制是一种服务发现机制，分为服务提供者和调用者，spi机制规定了需要在classpath下的META-INF&#x2F;service下以服务调用者的全限定名为文件名创建一个文件，内容为服务提供者的全限定名。再使用ServiceLoader加载服务调用者，就可以调用多个服务提供者。</p>
<p>在jdbc中，可能有多个数据库源。java.sql.Driver需要能够调用多个数据库的驱动比如mysql和Oracle，Driver位于rt中需要用启动类加载器进行加载，而mysql驱动是第三方jar包，需要用应用程序类加载器。<strong>但是在默认情况下，一个类及其依赖类由同一个类加载器加载。</strong>由于spi的存在，mysql的实现类也会在Driver加载的时候通过启动类加载器进行加载，这显然是错误的。</p>
<h3 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h3><p>问题重述，对于Driver这个类，是需要用启动类加载器进行加载，但由于spi让其发现了mysql的实现类，需要对其进行加载，此时需要打破双亲委派机制，<strong>启动类加载器委派应用程序加载器加载mysql驱动</strong>。</p>
<p>其实在每个线程都会默认保存一个应用程序类加载器，一般来说子线程会继承父线程的应用程序类加载器。在spi问题中，我们只需要取出线程保存的应用程序类加载器实现mysql驱动的加载即可。</p>
<p>同样的，在前文所述的tomcat的spring加载中，我们的代码会使用到spring的一系列注解，在spring容器初始化的过程中也会产生依赖。也就是说，本来是shared（也有可能是common）类加载器加载的spring类，但需要用到classpath下的自己写的应该由并行web应用处理的类。这与spi机制所产生的问题是一致的。</p>
<p>此时也是通过线程上下文类加载器进行解决，只不过这里在开辟一个线程的时候重新set这个变量为当前的并行web应用类加载器，原理与上面的类似。<br><img src="/../img/jvm/img_4.png"></p>
<h3 id="真的打破了双亲委派机制吗？"><a href="#真的打破了双亲委派机制吗？" class="headerlink" title="真的打破了双亲委派机制吗？"></a>真的打破了双亲委派机制吗？</h3><p>其实没有，从宏观上看，这里的Driver还是启动类加载器进行加载，mysql还是应用程序类加载器进行加载，也没有重新写loadclass方法。但也确实是由启动类加载器委派应用程序类加载器进行了加载。只不过是角度不同的问题，从宏观上没有打破，微观上打破了。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/08/14/jvm-class%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">jvm-class文件和类的加载过程</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-08-14
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="class文件"><a href="#class文件" class="headerlink" title="class文件"></a>class文件</h1><p>java所推出的口号是：一次编译，处处执行。这种跨平台性主要就是由屏蔽操作系统底层的jvm所实现的，java程序从编译到执行有几个阶段，首先是java程序被javac编译器编译成.class的字节码文件，jvm加载并运行这一个中间文件，再通过jvm自身的接近底层的方法，实现在window，macos和linux上的跨平台。</p>
<p>我的个人理解是，java为了保证跨平台性牺牲了一部分效率，这部分牺牲主要体现在要多一个通用的字节码文件的编译，而不是直接就从java变成机器能够执行的汇编了。</p>
<h2 id="class文件的结构"><a href="#class文件的结构" class="headerlink" title="class文件的结构"></a>class文件的结构</h2><p>字节码文件主要有几个部分构成：</p>
<ol>
<li>魔数和大小版本号：“cafebabe”，大版本号码就是-44，比如jdk8的版本号是52</li>
<li>常量池：最核心的部分，主要是字面量和符号引用，注意：在class文件中的都是符号引用，可以想象成逻辑地址，而在类加载的<strong>解析</strong>过程中，才会变为物理地址的引用。</li>
<li>字段表：当前类的变量</li>
<li>方法表：当前类的方法</li>
<li>属性：很复杂的一个表示</li>
</ol>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">J</span> <span class="operator">=</span> <span class="string">&quot;2222222&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getK</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setK</span><span class="params">(<span class="type">int</span> k)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.k = k;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="魔数和大小版本号"><a href="#魔数和大小版本号" class="headerlink" title="魔数和大小版本号"></a>魔数和大小版本号</h3><p>首先，改变一个文件的后缀名是不会改变其文件本身的编码结构的，jvm不能仅仅是校验后缀是不是.class来判断是否为一个字节码文件，所以在文件内容的开头有一个cafebabe的校验，只有以这个为开头的才是jvm所需要的字节码文件，当然也不仅仅是要满足这一点，在后续类加载过程的<strong>校验过程</strong>中会详细说明。<br>其次大版本号码就是当前jdk版本+44，还有小版本，这一部分是为了jvm在校验的过程中判断当前的class是否能够兼容版本，一般当然是只能向下兼容。、</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><blockquote>
<p>在常量池之前，需要补充一下各种名以及描述符</p>
<ul>
<li>全限定名和非限定名：<strong>Class文件中的类和接口，都是使用全限定名，又被称作Class的二进制名称</strong>。例如“com&#x2F;ikang&#x2F;JVM&#x2F;classfile”是这个类的全限定名，仅仅是把类全名中的“.”替换成了“&#x2F;”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。<br><strong>非限定名又被称作简单名称</strong>，Class文件中的方法、字段、局部变量、形参名称，都是使用简单名称，没有类型和参数修饰，例如这个类中的getK()方法和k字段的简单名称分别是“getK”和“m”。<br>非限定名不得包含ASCII字符. ; [ &#x2F; ，此外方法名称除了特殊方法名称&lt; init &gt;和&lt; clinit &gt;方法之外，它们不能包含ASCII字符&lt;或&gt;，字段名称或接口方法名称可以是&lt; init &gt;或&lt; clinit &gt;，但是没有方法调用指令可以引用&lt; clinit &gt;，只有invokespecial指令可以引用&lt; init &gt;。</li>
<li>描述符：在class文件里的方法和基本数据类型也有特定的写法，一般来说基本数据类型都是首字母大写作为描述，比如int就为I，<strong>其中long特殊，描述为J</strong>，void为V，引用类型为L+类的全限定名，对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组，将被记录为：“[[Ljava&#x2F;lang&#x2F;String；”，一个整型数组“int[]”将被记录为“[I”<br>方法描述符的写法看一眼就会，比如Object m(int i, double d, Thread t) {… }则描述符为(IDLjava&#x2F;lang&#x2F;Thread;)Ljava&#x2F;lang&#x2F;Object;</li>
</ul>
</blockquote>
<p>言归正传，常量池有两部分内容：字面量和符号引用。字面量就是一个变量的对应值，符号引用就是名称，主要有三部分名称：类与接口的全限定名，字段的名称和描述符（NameAndType），方法的名称和描述符（NameAndType）。<br>每一个字段都有自己的结构，具体见<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43767015/article/details/105310047?ops_request_misc=&request_id=&biz_id=102&utm_term=class%E6%96%87%E4%BB%B6&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-105310047.142%5Ev100%5Epc_search_result_base4&spm=1018.2226.3001.4187">这篇博客</a>。<br>说几个比较重要的：</p>
<ol>
<li>CONSTANT_Utf8_info和CONSTANT_String_info：前者是真正存储字符串本体的，而后者的结构只包含引用utf8的索引位置，为什么这样设计？当多个String名字不同但是值相同的时候，就可以只创建一条CONSTANT_Utf8_info常量，多个String可以引用，从而节省空间；其次是有可能符号引用也是当前值，例如声明了String a &#x3D; “a”，这样多少也能节约空间。</li>
<li>CONSTANT_NameAndType_info：name就是字段或者方法的非限定名，type是其描述符，这个同样是引用类型，放的是CONSTANT_Utf8_info的索引。例如println:(Ljava&#x2F;lang&#x2F;String;)V</li>
<li>CONSTANT_Fieldref_info和CONSTANT_Methodref_info：两个字段，前者是这个字段或者方法的名字引用，后者是CONSTANT_Methodref_info的引用 <div style="text-align: center;">
   <img src="../img/jvm/img.png" alt="" />
 </div></li>
<li>CONSTANT_Class_info：类的全限定名，注意所有的类都会有java&#x2F;lang&#x2F;Object这个类的class常量，因为除了Object本身，其余都是继承自它。</li>
</ol>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>用2字节作为访问标志，其中16位的某些位置可能代表了某些修饰词，例如public，final，interface等</p>
<h3 id="当前类，父类和接口索引"><a href="#当前类，父类和接口索引" class="headerlink" title="当前类，父类和接口索引"></a>当前类，父类和接口索引</h3><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 implements (如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。</p>
<h3 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h3><ul>
<li>access_flags: 字段的作用域（public ,private,protected修饰符），是实例变量还是类变量（static修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li>
<li>name_index: 对常量池的引用，表示的字段的名称；</li>
<li>descriptor_index: 对常量池的引用，表示字段和方法的描述符；</li>
<li>attributes_count: 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li>attributes[attributes_count]: 存放具体属性具体内容。</li>
</ul>
<blockquote>
<p>这里说一下字段里面常见的属性：<br>ConstantValue：一个字段有了这个说明是被static修饰了的。目前Sun Javac编译器的选择是：如果同时使用final和static来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者java.lang.String的话，就生成ConstantValue属性来进行初始化，即编译的时候；如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在＜clinit＞方法中进行初始化，即类加载的时候。</p>
</blockquote>
<h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><p>内容基本上与上面一致，也是有访问标志，name，descriptor和属性，这里的属性只要方法内不为空都会有code这个属性</p>
<p>方法里常见的属性：</p>
<ul>
<li>Code：Java方法体里面的代码经过Javac编译之后，最终变为字节码指令存储在Code属性内，Code属性出现在在method_info结构的attributes表中，但在接口或抽象类中就不存在Code属性（JDK1.8可以出现了）。一个方法中的Code属性值有一个。在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。在字节码指令之后的是这个方法的显式异常处理表（下文简称异常表）集合，异常表对于Code属性来说并不是必须存在的。</li>
<li>LineNumberTable：位于Code属性中，描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。主要是如果抛出异常时，编译器会显示行号，比如调试程序时展示的行号，就是这个属性的作用。Code属性表中，LineNumberTable可以属性可以按照任意顺序出现。在Code属性 attributes表中，可以有不止一个LineNumberTable属性对应于源文件中的同一行。也就是说，多个LineNumberTable属性可以合起来表示源文件中的某行代码，属性与源文件的代码行之间不必有一一对应的关系。</li>
<li>exception_table： <strong>在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表来完成的。</strong> 异常表中每一个数据由4部分组成，分别是start_pc、end_pc、handler_pc和catch_type。这4项表示从方法字节码的start_pc偏移量开始（包括）到end_pc 偏移量为止（不包括）的这段代码中，如果遇到了catch_type所指定的异常， 那么代码就跳转到handler_pc的位置执行，handler_pc即一个异常处理器的起点。在这4项中， start_pc、end_pc和handlerpc 都是字节码的编译量， 也就是在code[code_length]中的位置， 而catch_type为指向常量池的索引，它指向一个CONSTANT_Class_info 类，表示需要处理的异常类型。如果catch_type值为0,那么将会在所有异常抛出时都调用这个异常处理器，这被用于实现finally语句</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/07/21/%E4%BB%A3%E9%A9%BE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE-%E4%B9%98%E5%AE%A2%E4%B8%8B%E5%8D%95/">代驾微服务项目-乘客下单</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-07-21
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="乘客下单"><a href="#乘客下单" class="headerlink" title="乘客下单"></a>乘客下单</h1><p>主要业务是从乘客选择起始地点和终止地点之后，也就是初步计算了估计价格然后点击呼叫司机之后的过程。等到附近的司机抢单成功，该业务执行完毕。</p>
<p>流程大致是：</p>
<ol>
<li>在乘客点击下单之后，向数据库增加了一个order，前端每5s询问一次order的当前状态是否为接单，在这期间就没有客户端的事情了。</li>
<li>这个下单的动作会激活xxl-job的一个任务调度，给附近已经开启接单的司机的队列中加上这个order的id</li>
<li>等到司机端前端检查队列发现了这个订单，就会弹窗问是否需要接取，随后就是一个加锁然后抢票的逻辑了，需要有高并发的支持。</li>
<li>这个司机抢到了之后就会update这个订单，把司机的id变为自己的，状态改变。</li>
<li>等到乘客5s轮询发现改变了状态，此时接单成功。</li>
</ol>
<p>其中，最重要的过程是xxl-job的这个任务如何找到周围的司机。平时使用xxl-job都是在web新建的，这里要求每一个订单自动给xxl-job，也就是要对xxl-job的接口做调整，使其能够继承springboot新建任务。<br>那么周围的司机如何找，每一个司机在接单的时候都会把自己的地理纬度上传到redis，用redis的数据结构geo快速完成计算。</p>
<h2 id="新建订单"><a href="#新建订单" class="headerlink" title="新建订单"></a>新建订单</h2><h3 id="POST”-order-submitOrder”"><a href="#POST”-order-submitOrder”" class="headerlink" title="POST”&#x2F;order&#x2F;submitOrder”"></a>POST”&#x2F;order&#x2F;submitOrder”</h3><p>由前端调用百度的api得到的初始位置和结束位置，以及乘客的id来在order数据库中新建一个订单。</p>
<p><strong>对外接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Operation(summary = &quot;乘客下单&quot;)</span></span><br><span class="line"><span class="meta">@GuiguLogin</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/submitOrder&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Long&gt; <span class="title function_">submitOrder</span><span class="params">(<span class="meta">@RequestBody</span> SubmitOrderForm submitOrderForm)</span> &#123;</span><br><span class="line">   submitOrderForm.setCustomerId(AuthContextHolder.getUserId());</span><br><span class="line">   <span class="keyword">return</span> Result.ok(orderService.submitOrder(submitOrderForm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在数据库中这个表是需要有估计里程和估计价格的，也就是说还要再去调用一次map微服务和rule微服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrderInfoFeignClient orderInfoFeignClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">submitOrder</span><span class="params">(SubmitOrderForm submitOrderForm)</span> &#123;</span><br><span class="line">    <span class="comment">//1.重新计算驾驶线路</span></span><br><span class="line">    <span class="type">CalculateDrivingLineForm</span> <span class="variable">calculateDrivingLineForm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculateDrivingLineForm</span>();</span><br><span class="line">    BeanUtils.copyProperties(submitOrderForm, calculateDrivingLineForm);</span><br><span class="line">    <span class="type">DrivingLineVo</span> <span class="variable">drivingLineVo</span> <span class="operator">=</span> mapFeignClient.calculateDrivingLine(calculateDrivingLineForm).getData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.重新计算订单费用</span></span><br><span class="line">    <span class="type">FeeRuleRequestForm</span> <span class="variable">calculateOrderFeeForm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FeeRuleRequestForm</span>();</span><br><span class="line">    calculateOrderFeeForm.setDistance(drivingLineVo.getDistance());</span><br><span class="line">    calculateOrderFeeForm.setStartTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    calculateOrderFeeForm.setWaitMinute(<span class="number">0</span>);</span><br><span class="line">    <span class="type">FeeRuleResponseVo</span> <span class="variable">feeRuleResponseVo</span> <span class="operator">=</span> feeRuleFeignClient.calculateOrderFee(calculateOrderFeeForm).getData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.封装订单信息对象</span></span><br><span class="line">    <span class="type">OrderInfoForm</span> <span class="variable">orderInfoForm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderInfoForm</span>();</span><br><span class="line">    <span class="comment">//订单位置信息</span></span><br><span class="line">    BeanUtils.copyProperties(submitOrderForm, orderInfoForm);</span><br><span class="line">    <span class="comment">//预估里程</span></span><br><span class="line">    orderInfoForm.setExpectDistance(drivingLineVo.getDistance());</span><br><span class="line">    orderInfoForm.setExpectAmount(feeRuleResponseVo.getTotalAmount());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.保存订单信息</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> orderInfoFeignClient.saveOrderInfo(orderInfoForm).getData();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//TODO启动任务调度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> orderId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>订单微服务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrderInfoService orderInfoService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Operation(summary = &quot;保存订单信息&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/saveOrderInfo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Long&gt; <span class="title function_">saveOrderInfo</span><span class="params">(<span class="meta">@RequestBody</span> OrderInfoForm orderInfoForm)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> Result.ok(orderInfoService.saveOrderInfo(orderInfoForm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置订单的信息，状态为正在等待接单，给redis设置一个标识，说明正在接单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrderInfoMapper orderInfoMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrderStatusLogMapper orderStatusLogMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;Exception.class&#125;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">saveOrderInfo</span><span class="params">(OrderInfoForm orderInfoForm)</span> &#123;</span><br><span class="line">   <span class="type">OrderInfo</span> <span class="variable">orderInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderInfo</span>();</span><br><span class="line">   BeanUtils.copyProperties(orderInfoForm, orderInfo);</span><br><span class="line">   <span class="type">String</span> <span class="variable">orderNo</span> <span class="operator">=</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">   orderInfo.setStatus(OrderStatus.WAITING_ACCEPT.getStatus());</span><br><span class="line">   orderInfo.setOrderNo(orderNo);</span><br><span class="line">   orderInfoMapper.insert(orderInfo);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//记录日志</span></span><br><span class="line">   <span class="built_in">this</span>.log(orderInfo.getId(), orderInfo.getStatus());</span><br><span class="line"></span><br><span class="line">   <span class="comment">//接单标识，标识不存在了说明不在等待接单状态了</span></span><br><span class="line">   redisTemplate.opsForValue().set(RedisConstant.ORDER_ACCEPT_MARK, <span class="string">&quot;0&quot;</span>, RedisConstant.ORDER_ACCEPT_MARK_EXPIRES_TIME, TimeUnit.MINUTES);</span><br><span class="line">   <span class="keyword">return</span> orderInfo.getId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Long orderId, Integer status)</span> &#123;</span><br><span class="line">   <span class="type">OrderStatusLog</span> <span class="variable">orderStatusLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderStatusLog</span>();</span><br><span class="line">   orderStatusLog.setOrderId(orderId);</span><br><span class="line">   orderStatusLog.setOrderStatus(status);</span><br><span class="line">   orderStatusLog.setOperateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">   orderStatusLogMapper.insert(orderStatusLog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="司机和乘客查询订单状态GET”-getOrderStatus-orderId-”"><a href="#司机和乘客查询订单状态GET”-getOrderStatus-orderId-”" class="headerlink" title="司机和乘客查询订单状态GET”&#x2F;getOrderStatus&#x2F;{orderId}”"></a>司机和乘客查询订单状态GET”&#x2F;getOrderStatus&#x2F;{orderId}”</h3><p>乘客下完单后，订单状态为1，乘客端小程序会轮询订单状态，当订单状态为2时，说明已经有司机接单了，那么页面进行跳转，进行下一步操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getOrderStatus</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">   LambdaQueryWrapper&lt;OrderInfo&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">   queryWrapper.eq(OrderInfo::getId, orderId);</span><br><span class="line">   queryWrapper.select(OrderInfo::getStatus);</span><br><span class="line">   <span class="type">OrderInfo</span> <span class="variable">orderInfo</span> <span class="operator">=</span> orderInfoMapper.selectOne(queryWrapper);</span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">null</span> == orderInfo) &#123;</span><br><span class="line">      <span class="comment">//返回null，feign解析会抛出异常，给默认值，后续会用</span></span><br><span class="line">      <span class="keyword">return</span> OrderStatus.NULL_ORDER.getStatus();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> orderInfo.getStatus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>乘客端是一下单就一直询问这个接口有没有改变；司机端得是抢到单了然后才能有订单的id，再去用这个id请求方法</p>
</blockquote>
<h2 id="xxl-job和redis完成司机搜索调度"><a href="#xxl-job和redis完成司机搜索调度" class="headerlink" title="xxl-job和redis完成司机搜索调度"></a>xxl-job和redis完成司机搜索调度</h2><p>xxl-job定时任务查询附近司机，开启接单的司机会把地理坐标传到redis</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">updateDriverLocation</span><span class="params">(UpdateDriverLocationForm updateDriverLocationForm)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Redis GEO 主要用于存储地理位置信息，并对存储的信息进行相关操作，该功能在 Redis 3.2 版本新增。</span></span><br><span class="line"><span class="comment">     *  后续用在，乘客下单后寻找5公里范围内开启接单服务的司机，通过Redis GEO进行计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(updateDriverLocationForm.getLongitude().doubleValue(), updateDriverLocationForm.getLatitude().doubleValue());</span><br><span class="line">    redisTemplate.opsForGeo().add(RedisConstant.DRIVER_GEO_LOCATION, point, updateDriverLocationForm.getDriverId().toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">removeDriverLocation</span><span class="params">(Long driverId)</span> &#123;</span><br><span class="line">    redisTemplate.opsForGeo().remove(RedisConstant.DRIVER_GEO_LOCATION, driverId.toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="POST”-searchNearByDriver”"><a href="#POST”-searchNearByDriver”" class="headerlink" title="POST”&#x2F;searchNearByDriver”"></a>POST”&#x2F;searchNearByDriver”</h3><p>司机端的小程序开启接单服务后，开始实时上传司机的定位信息到redis的GEO缓存，前面乘客已经下单，现在我们就要查找附近适合接单的司机，如果有对应的司机，那就给司机发送新订单消息。</p>
<p>首先是配置经纬度点和距离，作为中心和半径传入redis的arg，得到了一个升序排序的位置表，然后根据这些待选司机的一些配置（比如超过多少距离不予配送）筛选出符合的一队司机，作为结果返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DriverInfoFeignClient driverInfoFeignClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;NearByDriverVo&gt; <span class="title function_">searchNearByDriver</span><span class="params">(SearchNearByDriverForm searchNearByDriverForm)</span> &#123;</span><br><span class="line">    <span class="comment">// 搜索经纬度位置5公里以内的司机</span></span><br><span class="line">    <span class="comment">//定义经纬度点</span></span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(searchNearByDriverForm.getLongitude().doubleValue(), searchNearByDriverForm.getLatitude().doubleValue());</span><br><span class="line">    <span class="comment">//定义距离：5公里(系统配置)</span></span><br><span class="line">    <span class="type">Distance</span> <span class="variable">distance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Distance</span>(SystemConstant.NEARBY_DRIVER_RADIUS, RedisGeoCommands.DistanceUnit.KILOMETERS);</span><br><span class="line">    <span class="comment">//定义以point点为中心，distance为距离这么一个范围</span></span><br><span class="line">    <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(point, distance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义GEO参数</span></span><br><span class="line">    RedisGeoCommands.<span class="type">GeoRadiusCommandArgs</span> <span class="variable">args</span> <span class="operator">=</span> RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs()</span><br><span class="line">            .includeDistance() <span class="comment">//包含距离</span></span><br><span class="line">            .includeCoordinates() <span class="comment">//包含坐标</span></span><br><span class="line">            .sortAscending(); <span class="comment">//排序：升序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.GEORADIUS获取附近范围内的信息</span></span><br><span class="line">    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; result = <span class="built_in">this</span>.redisTemplate.opsForGeo().radius(RedisConstant.DRIVER_GEO_LOCATION, circle, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.收集信息，存入list</span></span><br><span class="line">    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; content = result.getContent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.返回计算后的信息</span></span><br><span class="line">    List&lt;NearByDriverVo&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">if</span>(!CollectionUtils.isEmpty(content)) &#123;</span><br><span class="line">        Iterator&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; iterator = content.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; item = iterator.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//司机id</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">driverId</span> <span class="operator">=</span> Long.parseLong(item.getContent().getName());</span><br><span class="line">            <span class="comment">//当前距离</span></span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">currentDistance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(item.getDistance().getValue()).setScale(<span class="number">2</span>, RoundingMode.HALF_UP);</span><br><span class="line">            log.info(<span class="string">&quot;司机：&#123;&#125;，距离：&#123;&#125;&quot;</span>,driverId, item.getDistance().getValue());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取司机接单设置参数</span></span><br><span class="line">            <span class="type">DriverSet</span> <span class="variable">driverSet</span> <span class="operator">=</span> driverInfoFeignClient.getDriverSet(driverId).getData();</span><br><span class="line">            <span class="comment">//接单里程判断，acceptDistance==0：不限制，</span></span><br><span class="line">            <span class="keyword">if</span>(driverSet.getAcceptDistance().doubleValue() != <span class="number">0</span> &amp;&amp; driverSet.getAcceptDistance().subtract(currentDistance).doubleValue() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//订单里程判断，orderDistance==0：不限制</span></span><br><span class="line">            <span class="keyword">if</span>(driverSet.getOrderDistance().doubleValue() != <span class="number">0</span> &amp;&amp; driverSet.getOrderDistance().subtract(searchNearByDriverForm.getMileageDistance()).doubleValue() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//满足条件的附近司机信息</span></span><br><span class="line">            <span class="type">NearByDriverVo</span> <span class="variable">nearByDriverVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NearByDriverVo</span>();</span><br><span class="line">            nearByDriverVo.setDriverId(driverId);</span><br><span class="line">            nearByDriverVo.setDistance(currentDistance);</span><br><span class="line">            list.add(nearByDriverVo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>xxl-job这里配置就不做介绍了，主要梳理业务</p>
</blockquote>
<p>准备一个添加任务调度的业务，一分钟执行一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">addAndStartTask</span><span class="params">(NewOrderTaskVo newOrderTaskVo)</span> &#123;</span><br><span class="line">    <span class="type">OrderJob</span> <span class="variable">orderJob</span> <span class="operator">=</span> orderJobMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;OrderJob&gt;().eq(OrderJob::getOrderId, newOrderTaskVo.getOrderId()));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == orderJob) &#123;</span><br><span class="line">        <span class="comment">//新增一个名为newOrderTaskHandler的任务调度，一分钟执行一次</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">jobId</span> <span class="operator">=</span> xxlJobClient.addAndStart(<span class="string">&quot;newOrderTaskHandler&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;0 0/1 * * * ?&quot;</span>, <span class="string">&quot;新订单任务,订单id：&quot;</span>+newOrderTaskVo.getOrderId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录订单与任务的关联信息</span></span><br><span class="line">        orderJob = <span class="keyword">new</span> <span class="title class_">OrderJob</span>();</span><br><span class="line">        orderJob.setOrderId(newOrderTaskVo.getOrderId());</span><br><span class="line">        orderJob.setJobId(jobId);</span><br><span class="line">        orderJob.setParameter(JSONObject.toJSONString(newOrderTaskVo));</span><br><span class="line">        orderJobMapper.insert(orderJob);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> orderJob.getJobId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>newOrderTaskHandler</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;newOrderTaskHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newOrderTaskHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;新订单调度任务：&#123;&#125;&quot;</span>, XxlJobHelper.getJobId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录定时任务相关的日志信息</span></span><br><span class="line">    <span class="comment">//封装日志对象</span></span><br><span class="line">    <span class="type">XxlJobLog</span> <span class="variable">xxlJobLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobLog</span>();</span><br><span class="line">    xxlJobLog.setJobId(XxlJobHelper.getJobId());</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        newOrderService.executeTask(XxlJobHelper.getJobId());</span><br><span class="line"></span><br><span class="line">        xxlJobLog.setStatus(<span class="number">1</span>);<span class="comment">//成功</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        xxlJobLog.setStatus(<span class="number">0</span>);<span class="comment">//失败</span></span><br><span class="line">        xxlJobLog.setError(ExceptionUtil.getAllExceptionMsg(e));</span><br><span class="line">        log.error(<span class="string">&quot;定时任务执行失败，任务id为：&#123;&#125;&quot;</span>, XxlJobHelper.getJobId());</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//耗时</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> (<span class="type">int</span>) (System.currentTimeMillis() - startTime);</span><br><span class="line">        xxlJobLog.setTimes(times);</span><br><span class="line">        xxlJobLogMapper.insert(xxlJobLog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">executeTask</span><span class="params">(Long jobId)</span> &#123;</span><br><span class="line">    <span class="comment">//获取任务参数</span></span><br><span class="line">    <span class="type">OrderJob</span> <span class="variable">orderJob</span> <span class="operator">=</span> orderJobMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;OrderJob&gt;().eq(OrderJob::getJobId, jobId));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == orderJob) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">NewOrderTaskVo</span> <span class="variable">newOrderTaskVo</span> <span class="operator">=</span> JSONObject.parseObject(orderJob.getParameter(), NewOrderTaskVo.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询订单状态，如果该订单还在接单状态，继续执行；如果不在接单状态，则停止定时调度</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">orderStatus</span> <span class="operator">=</span> orderInfoFeignClient.getOrderStatus(newOrderTaskVo.getOrderId()).getData();</span><br><span class="line">    <span class="keyword">if</span>(orderStatus.intValue() != OrderStatus.WAITING_ACCEPT.getStatus().intValue()) &#123;</span><br><span class="line">        xxlJobClient.stopJob(jobId);</span><br><span class="line">        log.info(<span class="string">&quot;停止任务调度: &#123;&#125;&quot;</span>, JSON.toJSONString(newOrderTaskVo));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜索附近满足条件的司机</span></span><br><span class="line">    <span class="type">SearchNearByDriverForm</span> <span class="variable">searchNearByDriverForm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchNearByDriverForm</span>();</span><br><span class="line">    searchNearByDriverForm.setLongitude(newOrderTaskVo.getStartPointLongitude());</span><br><span class="line">    searchNearByDriverForm.setLatitude(newOrderTaskVo.getStartPointLatitude());</span><br><span class="line">    searchNearByDriverForm.setMileageDistance(newOrderTaskVo.getExpectDistance());</span><br><span class="line">    List&lt;NearByDriverVo&gt; nearByDriverVoList = locationFeignClient.searchNearByDriver(searchNearByDriverForm).getData();</span><br><span class="line">    <span class="comment">//给司机派发订单信息</span></span><br><span class="line">    nearByDriverVoList.forEach(driver -&gt; &#123;</span><br><span class="line">        <span class="comment">//记录司机id，防止重复推送订单信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">repeatKey</span> <span class="operator">=</span> RedisConstant.DRIVER_ORDER_REPEAT_LIST+newOrderTaskVo.getOrderId();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> redisTemplate.opsForSet().isMember(repeatKey, driver.getDriverId());</span><br><span class="line">        <span class="keyword">if</span>(!isMember) &#123;</span><br><span class="line">            <span class="comment">//记录该订单已放入司机临时容器</span></span><br><span class="line">            redisTemplate.opsForSet().add(repeatKey, driver.getDriverId());</span><br><span class="line">            <span class="comment">//过期时间：15分钟，新订单15分钟没人接单自动取消</span></span><br><span class="line">            redisTemplate.expire(repeatKey, RedisConstant.DRIVER_ORDER_REPEAT_LIST_EXPIRES_TIME, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">            <span class="type">NewOrderDataVo</span> <span class="variable">newOrderDataVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewOrderDataVo</span>();</span><br><span class="line">            newOrderDataVo.setOrderId(newOrderTaskVo.getOrderId());</span><br><span class="line">            newOrderDataVo.setStartLocation(newOrderTaskVo.getStartLocation());</span><br><span class="line">            newOrderDataVo.setEndLocation(newOrderTaskVo.getEndLocation());</span><br><span class="line">            newOrderDataVo.setExpectAmount(newOrderTaskVo.getExpectAmount());</span><br><span class="line">            newOrderDataVo.setExpectDistance(newOrderTaskVo.getExpectDistance());</span><br><span class="line">            newOrderDataVo.setExpectTime(newOrderTaskVo.getExpectTime());</span><br><span class="line">            newOrderDataVo.setFavourFee(newOrderTaskVo.getFavourFee());</span><br><span class="line">            newOrderDataVo.setDistance(driver.getDistance());</span><br><span class="line">            newOrderDataVo.setCreateTime(newOrderTaskVo.getCreateTime());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将消息保存到司机的临时队列里面，司机接单了会定时轮询到他的临时队列获取订单消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstant.DRIVER_ORDER_TEMP_LIST+driver.getDriverId();</span><br><span class="line">            redisTemplate.opsForList().leftPush(key, JSONObject.toJSONString(newOrderDataVo));</span><br><span class="line">            <span class="comment">//过期时间：1分钟，1分钟未消费，自动过期</span></span><br><span class="line">            <span class="comment">//注：司机端开启接单，前端每5秒（远小于1分钟）拉取1次“司机临时队列”里面的新订单消息</span></span><br><span class="line">            redisTemplate.expire(key, RedisConstant.DRIVER_ORDER_TEMP_LIST_EXPIRES_TIME, TimeUnit.MINUTES);</span><br><span class="line">            log.info(<span class="string">&quot;该新订单信息已放入司机临时队列: &#123;&#125;&quot;</span>, JSON.toJSONString(newOrderDataVo));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再在下单的那个任务中执行添加xxl-job任务调度。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/07/19/%E4%BB%A3%E9%A9%BE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE-%E4%B9%98%E5%AE%A2%E7%AB%AF%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/">代驾微服务项目-乘客端核心业务逻辑</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-07-19
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><h2 id="微信的登录逻辑"><a href="#微信的登录逻辑" class="headerlink" title="微信的登录逻辑"></a>微信的登录逻辑</h2><div style="text-align: center;">
  <img src="../img/daijia/img.png" alt="" />
</div>
说明：

<ol>
<li>调用 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html">wx.login()</a> 获取 <strong>临时登录凭证code</strong> ，并回传到开发者服务器。</li>
<li>调用 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user-login/code2Session.html">auth.code2Session</a> 接口，换取 <strong>用户唯一标识 OpenID</strong> 、 用户在微信开放平台账号下的<strong>唯一标识UnionID</strong>（若当前小程序已绑定到微信开放平台账号） 和 <strong>会话密钥 session_key</strong>。</li>
</ol>
<p>之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份</p>
<p>对于业务而言，最首先返回的就是这个code，后端要做的就是把这个code结合自己小程序的appid和appsecret去请求微信后台，给出当前用户的openid。</p>
<h3 id="接口1：GET”-customer-login-code-”"><a href="#接口1：GET”-customer-login-code-”" class="headerlink" title="接口1：GET”&#x2F;customer&#x2F;login&#x2F;{code}”"></a>接口1：GET”&#x2F;customer&#x2F;login&#x2F;{code}”</h3><p>整体的流程是：</p>
<ol>
<li>对外service拿着这个前端发来的code去远程调用乘客微服务</li>
<li>乘客微服务请求微信的后台得到openid，然后去数据库查是否存在这个openid，也就是是否注册过了</li>
<li>如果没有注册就进行注册，最后写入操作日志，返回这个openid对应的数据库id，我们的业务是基于自家数据库的。</li>
<li>对外service拿到了这个id，将其缓存进redis中，key是UUID，value是在<strong>自家数据库</strong>中的id，也就是说在redis中有这个键值对那就说明是登录状态。</li>
<li>最后redis中的这个UUID作为token给前端，前端每次发请求都携带这个token。<strong>优化：</strong> 可以使用jwt？</li>
</ol>
<p><strong>对外接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Operation(summary = &quot;小程序授权登录&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/login/&#123;code&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">wxLogin</span><span class="params">(<span class="meta">@PathVariable</span> String code)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> Result.ok(customerInfoService.login(code));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CustomerInfoFeignClient customerInfoFeignClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String code)</span> &#123;</span><br><span class="line">   <span class="comment">//获取openId</span></span><br><span class="line">   Result&lt;Long&gt; result = customerInfoFeignClient.login(code);</span><br><span class="line">   <span class="keyword">if</span>(result.getCode().intValue() != <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GuiguException</span>(result.getCode(), result.getMessage());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">Long</span> <span class="variable">customerId</span> <span class="operator">=</span> result.getData();</span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">null</span> == customerId) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GuiguException</span>(ResultCodeEnum.DATA_ERROR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">   redisTemplate.opsForValue().set(RedisConstant.USER_LOGIN_KEY_PREFIX+token, customerId.toString(), RedisConstant.USER_LOGIN_KEY_TIMEOUT, TimeUnit.SECONDS);</span><br><span class="line">   <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>乘客微服务接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Operation(summary = &quot;小程序授权登录&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/login/&#123;code&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Long&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@PathVariable</span> String code)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> Result.ok(customerInfoService.login(code));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WxMaService wxMaService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CustomerLoginLogMapper customerLoginLogMapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 条件：</span></span><br><span class="line"><span class="comment"> *      1、前端开发者appid与服务器端appid一致</span></span><br><span class="line"><span class="comment"> *      2、前端开发者必须加入开发者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;Exception.class&#125;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">login</span><span class="params">(String code)</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">openId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//获取openId</span></span><br><span class="line">      <span class="type">WxMaJscode2SessionResult</span> <span class="variable">sessionInfo</span> <span class="operator">=</span> wxMaService.getUserService().getSessionInfo(code);</span><br><span class="line">      openId = sessionInfo.getOpenid();</span><br><span class="line">      log.info(<span class="string">&quot;【小程序授权】openId=&#123;&#125;&quot;</span>, openId);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GuiguException</span>(ResultCodeEnum.WX_CODE_ERROR);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//查本地数据库是否有这条</span></span><br><span class="line">   <span class="type">CustomerInfo</span> <span class="variable">customerInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.getOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;CustomerInfo&gt;().eq(CustomerInfo::getWxOpenId, openId));</span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">null</span> == customerInfo) &#123;</span><br><span class="line">      customerInfo = <span class="keyword">new</span> <span class="title class_">CustomerInfo</span>();</span><br><span class="line">      customerInfo.setNickname(String.valueOf(System.currentTimeMillis()));</span><br><span class="line">      customerInfo.setAvatarUrl(<span class="string">&quot;https://oss.aliyuncs.com/aliyun_id_photo_bucket/default_handsome.jpg&quot;</span>);</span><br><span class="line">      customerInfo.setWxOpenId(openId);</span><br><span class="line">      <span class="built_in">this</span>.save(customerInfo);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//登录日志</span></span><br><span class="line">   <span class="type">CustomerLoginLog</span> <span class="variable">customerLoginLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerLoginLog</span>();</span><br><span class="line">   customerLoginLog.setCustomerId(customerInfo.getId());</span><br><span class="line">   customerLoginLog.setMsg(<span class="string">&quot;小程序登录&quot;</span>);</span><br><span class="line">   customerLoginLogMapper.insert(customerLoginLog);</span><br><span class="line">   <span class="keyword">return</span> customerInfo.getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口2：GET”-customer-getCustomerLoginInfo”"><a href="#接口2：GET”-customer-getCustomerLoginInfo”" class="headerlink" title="接口2：GET”&#x2F;customer&#x2F;getCustomerLoginInfo”"></a>接口2：GET”&#x2F;customer&#x2F;getCustomerLoginInfo”</h3><p>当前一个方法执行成功后，返回了一个token，每次请求都会携带这个token。有了这个token后前端会发这个请求获得该用户的详细信息。那既然把UUID和value都放在redis里了，那每一次都从redis取就好了。</p>
<p><strong>AOP+注解+ThreadLocal</strong><br>这个注解的主要思路是，在每个controller方法调用之前，先去解析request请求的token，token里面是登录时所给的UUID，然后再去访问redis得到当前登录用户的本地数据库id，把它放在一个ThreadLocal保存，这样该方法执行的过程中只用在ThreadLocal中取这个就可以用了。</p>
<p><em><strong>主要是用于取代网关的prehandle，其实本质是一样的，网关是直接拦截request得到token，进行处理后再放到ThreadLocal中</strong></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GuiguLogin &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(100)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuiguLoginAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> guiguLogin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.atguigu.daijia.*.controller.*.*(..)) &amp;&amp; @annotation(guiguLogin)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(ProceedingJoinPoint joinPoint, GuiguLogin guiguLogin)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">RequestAttributes</span> <span class="variable">ra</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">sra</span> <span class="operator">=</span> (ServletRequestAttributes) ra;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> sra.getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasText(token)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GuiguException</span>(ResultCodeEnum.LOGIN_AUTH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String)redisTemplate.opsForValue().get(RedisConstant.USER_LOGIN_KEY_PREFIX+token);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasText(userId)) &#123;</span><br><span class="line">            AuthContextHolder.setUserId(Long.parseLong(userId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个注解再进行个人资料的获取，现在直接就在接口上用则个注解，然后再在方法里面取出id就可以了，大致流程是：</p>
<ol>
<li>用注解得到的id请求客户微服务</li>
<li>客户微服务用id查数据库</li>
</ol>
<p><strong>对外接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Operation(summary = &quot;获取客户登录信息&quot;)</span></span><br><span class="line"><span class="meta">@GuiguLogin</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getCustomerLoginInfo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;CustomerLoginVo&gt; <span class="title function_">getCustomerLoginInfo</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">Long</span> <span class="variable">customerId</span> <span class="operator">=</span> AuthContextHolder.getUserId();</span><br><span class="line">   <span class="keyword">return</span> Result.ok(customerInfoService.getCustomerLoginInfo(customerId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CustomerLoginVo <span class="title function_">getCustomerLoginInfo</span><span class="params">(Long customerId)</span> &#123;</span><br><span class="line">   Result&lt;CustomerLoginVo&gt; result = customerInfoFeignClient.getCustomerLoginInfo(customerId);</span><br><span class="line">   <span class="keyword">if</span>(result.getCode().intValue() != <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GuiguException</span>(result.getCode(), result.getMessage());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">CustomerLoginVo</span> <span class="variable">customerLoginVo</span> <span class="operator">=</span> result.getData();</span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">null</span> == customerLoginVo) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GuiguException</span>(ResultCodeEnum.DATA_ERROR);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> customerLoginVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户微服务：</strong><br>这里只写实现类，接口只是传导没有实际逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CustomerLoginVo <span class="title function_">getCustomerLoginInfo</span><span class="params">(Long customerId)</span> &#123;</span><br><span class="line">   <span class="type">CustomerInfo</span> <span class="variable">customerInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(customerId);</span><br><span class="line">   <span class="type">CustomerLoginVo</span> <span class="variable">customerInfoVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerLoginVo</span>();</span><br><span class="line">   BeanUtils.copyProperties(customerInfo, customerInfoVo);</span><br><span class="line">   <span class="comment">//判断是否绑定手机号码，如果未绑定，小程序端发起绑定事件</span></span><br><span class="line">   <span class="type">Boolean</span> <span class="variable">isBindPhone</span> <span class="operator">=</span> StringUtils.hasText(customerInfo.getPhone());</span><br><span class="line">   customerInfoVo.setIsBindPhone(isBindPhone);</span><br><span class="line">   <span class="keyword">return</span> customerInfoVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义feign全局处理"><a href="#自定义feign全局处理" class="headerlink" title="自定义feign全局处理"></a>自定义feign全局处理</h2><p>在Feign调用的过程中，由于全局异常的处理，所有的Feign调用都会返回Result<T>对象，我们还必须判断它的code是否等于200，如果不等于200，那么说明调用结果抛出异常了，我们必须返回异常信息提示给接口，如果返回code等于200，我们又必须判断data是否等于null，处理方式都一致，处理起来很繁琐，有没有好的统一处理方式呢？</p>
<p>答案是肯定的，我们可以通过全局自定义Feign结果解析来处理就可以了。</p>
<p>说明：任何Feign调用Result<T>对象的data我们都必须默认给一个返回值，否则任务数据异常。</p>
<p><strong>自定义解码器:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * OpenFeign 自定义结果解码器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignCustomDataDecoder</span> <span class="keyword">implements</span> <span class="title class_">Decoder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SpringDecoder decoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FeignCustomDataDecoder</span><span class="params">(SpringDecoder decoder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.decoder = decoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">decode</span><span class="params">(Response response, Type type)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.decoder.decode(response, type);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == object) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DecodeException</span>(ResultCodeEnum.FEIGN_FAIL.getCode(), ResultCodeEnum.FEIGN_FAIL.getMessage(), response.request());<span class="comment">//&quot;数据解析失败&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(object <span class="keyword">instanceof</span> Result&lt;?&gt;) &#123;</span><br><span class="line">            Result&lt;?&gt; result = ( Result&lt;?&gt;)object;</span><br><span class="line">            <span class="comment">//返回状态!=200，直接抛出异常，全局异常捕获异常，接口提示</span></span><br><span class="line">            <span class="keyword">if</span> (result.getCode().intValue() != ResultCodeEnum.SUCCESS.getCode().intValue()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DecodeException</span>(result.getCode(), result.getMessage(), response.request());<span class="comment">//&quot;数据解析失败&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//远程调用必须有返回值，具体调用中不用判断result.getData() == null，这里统一处理</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == result.getData()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DecodeException</span>(ResultCodeEnum.FEIGN_FAIL.getCode(), ResultCodeEnum.FEIGN_FAIL.getMessage(), response.request());<span class="comment">//&quot;数据解析失败&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义解析器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msgConverters 信息转换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> customizers   自定义参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解析器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Decoder <span class="title function_">decoder</span><span class="params">(ObjectFactory&lt;HttpMessageConverters&gt; msgConverters, ObjectProvider&lt;HttpMessageConverterCustomizer&gt; customizers)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptionalDecoder</span>((<span class="keyword">new</span> <span class="title class_">ResponseEntityDecoder</span>(<span class="keyword">new</span> <span class="title class_">FeignCustomDataDecoder</span>(<span class="keyword">new</span> <span class="title class_">SpringDecoder</span>(msgConverters, customizers)))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;TODO: 这一块需要对了解openfeign的结构有一定的了解，后续将对这一块进行补充</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/07/19/%E6%96%B0%E5%9D%91-%E4%BB%A3%E9%A9%BE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/">新坑-代驾微服务项目</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-07-19
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>前言：一直都想做一个有点高级但是又重复度低的项目，正好让我遇上了这个尚硅谷刚发的《乐尚代驾》，做了一下感觉还是有学到很多东西的，不管以后放不放在简历里面，算是先开了一个小头，弄懂再说。</p>
</blockquote>
<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>该项目是模仿滴滴的一个代驾系统，前端是基于uniapp的微信小程序，分为三个端口：客户端，司机端和管理系统。业务很纯粹，就是乘客基于当前位置呼叫周围正在接单的司机，司机接单后对车辆的基本情况进行上传，然后就可以开始代驾了，到达终点后计算金额并用微信支付；此外还涉及到优惠券业务，也就是传统的那套秒杀逻辑，分布式锁+lua脚本那些。</p>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li>SpringCloudAlibaba：包括nacos，openfeign，gateway这些，其实后续还可以做一些熔断和限流操作。</li>
<li>redis：项目中主要是用到了geo数据结构，在司机开启抢单的时候将地理坐标上传到redis；此外也用到了redisson实现分布式锁和延迟队列（这里的延迟队列就是超时15分钟自动取消，其实也可以用rabbitmq实现）</li>
<li>xxl-job：项目最核心的业务是通过xxl-job实现的，每次下单客户端都会创建一个新的任务调度，这个任务可以定时寻找周围司机。</li>
<li>mongodb：在代驾订单进行过程中的地理坐标不好放在mysql里面，用mongodb存储地理坐标，考虑了其在实时性方面的优化</li>
<li>rabbitmq：延迟队列，业务解耦和流量削峰</li>
<li>Drools：第一次听说，规则引擎，就是把一些业务计算逻辑抽取出来，不硬编码在程序中，项目中用规则引擎定义了路程和费用的计算，还有最后算金额也用到了规则引擎，它有自己的一套语法。</li>
<li>seata：分布式事务，在分布式系统中一个事务的回调是无法用@Transactional进行回调的，这里就用了阿里的这个分布式事务中间件完成，目前还没有太了解这个，只知道导入包只会加一个注释就能完成功能。</li>
<li>minio：存储上传照片和音频文件</li>
</ul>
<h2 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h2><ul>
<li>使用<strong>aop+注解+threadlocal</strong>的方式完成登录状态保存，微信小程序登录，做到了对业务代码的零入侵。</li>
<li>在下单后用<strong>xxl-job</strong>进行任务调度，定时搜索周围司机，并基于<strong>redis的geo</strong>数据结构，提高附近司机的搜索速度，完成司乘对接。</li>
<li>为了减小mysql访问压力使用<strong>mongodb</strong>记录沿途地理坐标，并使用基于<strong>rabbitmq</strong>的延迟队列将多次写请求合并为一次写入，再次减小了数据库操作。</li>
<li>使用<strong>策略模式和规则引擎Drools</strong>，定义了业务执行过程中的多种流程，例如代驾费用计算，司机积分计算以及优惠卷最大优惠策略计算。</li>
<li>使用<strong>Redisson分布式锁</strong>解决了高并发场景下的司机抢单和优惠卷超发问题，使用Redisson提供的<strong>延时队列</strong>完成了订单超出时间限制后自动取消。</li>
<li>使用<strong>CompletableFuture</strong>完成了订单结束提交过程的异步编排，提高了响应效率，并使用<strong>seata</strong>来保证分布式事务的执行。</li>
</ul>
<h2 id="可以有增量的地方"><a href="#可以有增量的地方" class="headerlink" title="可以有增量的地方"></a>可以有增量的地方</h2><ul>
<li>数据库分库分表，ShardingSphere可以尝试一下</li>
<li>二级缓存，本地caffeine和redis二级缓存</li>
<li>做限流和熔断，以及redis集群和哨兵</li>
<li>点赞（set），评论，排行榜（zset），签到（bitmap）和UV统计（hyperloglog）都是可以用redis解决的</li>
<li>kafka-stream还是没能找到应用的场景，</li>
<li>binlog实现与mysql的持久化</li>
<li>优惠卷兑换算法和优惠卷的最大优惠计算</li>
</ul>
<h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><h3 id="乘客端："><a href="#乘客端：" class="headerlink" title="乘客端："></a>乘客端：</h3><blockquote>
<p>登录–选择代驾地址–呼叫代驾–等待接单–15分钟没有司机接单自动取消–15内有司机接单，司乘同显–账单支付</p>
</blockquote>
<ol>
<li>登录：前端首先调用wx.login()，返回一串字符串，然后后端拿到这个去请求微信服务器得到当前登录的openid，也就是微信的唯一id（可以理解为wx.login()请求发出之后，wx的缓存中就保存了这个键值对，键是这个字符串，值是当前用户的结构，必须是连贯的动作，可能设置了失效时间，这也是为什么我后面拿postman同样请求得不到的原因）</li>
<li>选择代驾地址：百度地图的api返回距离和时间，这个参数给后端规则引擎计算出费用</li>
<li>等待接单：xxl-job新增一个订单任务，每隔一分钟根据redis的geo搜索周围的汽车，然后在附近开启接单的汽车的队列里面（通过redis的list实现）添加这个订单。</li>
<li>15分钟没有司机接单自动取消：通过redisson实现或者rabbitmq的延迟队列实现</li>
<li>15内有司机接单，司乘同显：当司机抢到了该订单后，订单状态改变，进入司乘同显模式，此后基本上没有乘客端什么事情了，前端会一直轮询订单当前状态，并根据司机端存在mongodb中的数据获取车的位置。</li>
<li>账单支付：微信支付</li>
</ol>
<h3 id="司机端："><a href="#司机端：" class="headerlink" title="司机端："></a>司机端：</h3><blockquote>
<p>登录–认证–开始接单–抢单–开始代驾–生成账单，发送乘客</p>
</blockquote>
<ol>
<li>登录：逻辑类似</li>
<li>认证：司机需要上传身份证驾驶证人脸等，通过腾讯云，我懒得注册这部分就跳过了</li>
<li>开始接单：开始接单后会把当前的坐标上传到redis，然后每隔5s询问一次当前队列状态，当xxl-job把订单放在了该司机的队列里面，前端就会有显示可以抢单</li>
<li>抢单：分布式锁，无需多言，抢单之后将订单状态改变，这样乘客端轮询这个订单的时候就会发现有司机已经接单了。</li>
<li>到达乘客指定地点，这里会有一个刷单的校验，也就是说在距离地点1km之内才能有效</li>
<li>上传车辆状况和车牌号：拍照上传minio</li>
<li>开始代驾：每隔几秒钟将当前的坐标上传到mongodb中，实现与乘客端同步显示。</li>
<li>生成账单：根据规则引擎分账，然后推送微信支付给乘客。</li>
</ol>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/07/11/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB-DOMINANT/">论文精读-DOMINANT</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-07-11
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <!-- TOC -->
<ul>
<li><a href="#deep-anomaly-detection-on-attributed-networks">Deep Anomaly Detection on Attributed Networks</a><ul>
<li><a href="#%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">图卷积神经网络</a></li>
<li><a href="#%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84">模型架构</a></li>
<li><a href="#%E5%B8%A6%E5%B8%A6%E9%94%90%E8%AF%84">带带锐评</a><!-- TOC -->
<blockquote>
<p>开发项目虽好，但是还是要毕业的嘛，正好今天做完了组会汇报ppt，趁热打铁写一篇读后感。</p>
<p><strong>2024-7-11，我研究生生涯的第一篇论文，我会记住你的。</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="Deep-Anomaly-Detection-on-Attributed-Networks"><a href="#Deep-Anomaly-Detection-on-Attributed-Networks" class="headerlink" title="Deep Anomaly Detection on Attributed Networks"></a>Deep Anomaly Detection on Attributed Networks</h1><blockquote>
<p>在说明这篇文章之前，首先说一下图卷积神经网络（GSN）</p>
</blockquote>
<h2 id="图卷积神经网络"><a href="#图卷积神经网络" class="headerlink" title="图卷积神经网络"></a>图卷积神经网络</h2><p>&nbsp;&nbsp;图是一种数据结构，相比于离散的点，更具有特征的是边带来的结构上的关系。普通的卷积神经网络处理的主要是结构性数据，类似图片或者nlp任务，这一类任务的输入数据是有迹可循的，结构不会发生变化，图片可以拆为像素进行卷积核操作，nlp可以将词进行词嵌入。</p>
<p>&nbsp;&nbsp;而图不一样，图的拓扑结构是无迹可寻的，这也意味着普通的cnn无法满足在图上的搜索，但是我们可以参考cnn的公式$Y&#x3D;XW+B$，结合图的规律探索出图的卷积神经网络。</p>
<p>&nbsp;&nbsp;首先我们定义一个图，$\mathcal{G}&#x3D;(\mathcal{V},\epsilon,X)$，（1）节点集合$\mathcal{V} &#x3D; \mathcal{v_1},\mathcal{v_2},\ldots,\mathcal{v_n}$，其中$\left|\mathcal{V}\right|&#x3D;\mathcal{n}$ （2）边集$\epsilon$，其中$\left|\epsilon\right|&#x3D;\mathcal{m}$（3）节点属性$\mathrm{X}\in\Bbb{R}^{n \times d}$,其中第i行向量$\mathrm{x_i}\in\Bbb{R}^{d}(i&#x3D;1,\ldots,n)$表示的是第i个节点的属性表示，d是属性的数量。举例如下：</p>
<div style="text-align: center;">
  <img src="../img/oodPaper/img_1.png" alt="" />
</div>

<p>&nbsp;&nbsp;这里举例是有权图，如果是无权图那就都为0或者1，这张图的邻接矩阵A为：</p>
<table>
<thead>
<tr>
<th></th>
<th>v1</th>
<th>v2</th>
<th>v3</th>
<th>v4</th>
</tr>
</thead>
<tbody><tr>
<td>v1</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>v2</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>v3</td>
<td>5</td>
<td>0</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>v4</td>
<td>6</td>
<td>0</td>
<td>3</td>
<td>0</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;节点属性H，比如这四个点代表一个人，属性就可能是身高体重这类，举例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>姓名</th>
<th>性别</th>
<th>身高</th>
<th>体重</th>
</tr>
</thead>
<tbody><tr>
<td>H1</td>
<td>239</td>
<td>2</td>
<td>175</td>
<td>120</td>
</tr>
<tr>
<td>H2</td>
<td>542</td>
<td>1</td>
<td>168</td>
<td>100</td>
</tr>
<tr>
<td>H3</td>
<td>937</td>
<td>2</td>
<td>188</td>
<td>150</td>
</tr>
<tr>
<td>H4</td>
<td>365</td>
<td>1</td>
<td>163</td>
<td>90</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;如果我们取矩阵中的一行A1点乘H，即有：<br>$$<br>A_1 \cdot H&#x3D;(0 \times H_1 +2 \times H_2 +5 \times H_3 + 6 \times H_4)<br>$$</p>
<p>&nbsp;&nbsp;可以看出，这个结果是V1的邻居节点信号的加权求和，其中权重为关系强弱数值，由A提供，但是这个权重并没有进行归一化，也就是说，如果某个节点的邻居顶点越多，关系数值越强，这个结果就越大，为了避免这种情况，我们进行了归一化操作，即，让权重除以该节点所有边的关系数值的和，上这些边的关系数值成为真正意义上和为1的“权值”。那么我们所需要的数学过程即让A的每一行都除以该行的和。这是我们引入一个新的矩阵D，这个矩阵为对角矩阵，每行对角线上的元素为A的这行的元素和，也就是该顶点的度。</p>
<p>&nbsp;&nbsp;D矩阵：</p>
<table>
<thead>
<tr>
<th><!-- --></th>
<th><!-- --></th>
<th><!-- --></th>
<th><!-- --></th>
</tr>
</thead>
<tbody><tr>
<td>13</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>8</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>9</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;接着执行$D^{-1}A$操作，即把A的每个关系数值都归一化了，变为权重，最后与H相乘，归一化后的表达式为：</p>
<p>$$<br>D_{1}^{-1}A_1 \cdot H&#x3D;(1&#x2F;13) \times (0 \times H_1 +2 \times H_2 +5 \times H_3 + 6 \times H_4)<br>$$</p>
<p>&nbsp;&nbsp;所有行都进行同样的操作，$D^{-1}A \times\ H$，则每一行的量纲都一样了，不会出现某一行计算结果特别夸张。此时我们来考虑这个结果是什么，它相当于是某一个顶点周围所有顶点的信号按关系（权重）相加（聚合），那么这个结果就能表征出周围节点对自己的影响了，同时由于是通过矩阵进行运算，数据结构变得很规整，可以使用计算机来运算。</p>
<blockquote>
<p>到这里为止有两个问题：</p>
<ul>
<li>首先是自身的因素没有考虑，就如上面的例子，没有考虑到$H_1$的影响，也就是自己，这是很不合理的，在传播过程中需要有“我”的参与，而不是都是客体。</li>
<li>其次是没有考虑到邻居的影响，假如我的朋友只有一个大佬，那么我和大佬的关系网络如果用平均算法的话就等同了，所以直接把B的特征赋给A肯定是不合适的。</li>
</ul>
</blockquote>
<div style="text-align: center;">
  <img src="../img/oodPaper/img_2.png" alt="" />
</div>

<p><strong>针对第一个问题：</strong><br>把“我”的信息加进去<br>$$\tilde{A}&#x3D;A+a \cdot I$$<br>这样A就不再是一个单位阵，在进行矩阵运算的时候就能考虑到自己的因素，因此D也要随之改变，D原本是表示出度，此时要变为出度+a<br>$$\tilde{D}&#x3D;D+a \cdot I$$</p>
<p><strong>针对第二个问题：</strong><br>关系数值我们一般是通过两顶点信号之间的欧氏距离得到的，这只跟这两个顶点有关系，与其二阶邻居的信号是无关的，但是显然，邻居的邻居对我影响应该也是有的，我们怎样才能把二阶邻居的影响考虑进来呢？</p>
<p>比如，我叫V2，是个自闭症患者，班里一共四个人，我们自己的信号为社交能力值，我只认识V1，认识V1也不是因为我和他聊得来，纯纯是因为V1是个社牛， V1谁都认识。在这个例子中，如果考虑V2经过一次传播后形成的新V2，是通过$\tilde{D_2^{-1}}\tilde{A_2}H$计算的，结果为$\tilde{D_2^{-1}}\tilde{A_2}H$&#x3D;(1&#x2F;3)×(2×H1 + 1×H2 + 0×H3 + 0×H4) &#x3D;2&#x2F;3 H1 + 1&#x2F;3H2 ,可以看出，此时新的V2的信号绝大部分来源于原来V1的信号，这当然不行，怎么经过一次传播后，把我一个社恐变成了社牛，这显然传播仍然存在问题，我希望能把二阶邻居和一阶邻居都考虑进去，二阶邻居和一阶邻居数量差别较大的时候，我希望能衰减这种影响，尽可能让自己的信号和别人的信号尽可能的分开来，那么就容易得到两种思路了，一是传播中我尽可能保留自己的权重，削减别人的权重，即$\tilde{A}$对做处理，第二是让“我”的信号根据传播产生某种线性变化，即随着二阶邻居和一阶邻居数量差别越大我信号越小，这样也可以把我和别人区分出来，也可以有我自己单独的特征，就是信号特别小嘛。GCN中是按照第二个思路来的，在数学上新的传播过程表示为：</p>
<p>$$<br>\tilde{D^{-\frac{1}{2}}}\tilde{A}\tilde{D^{-\frac{1}{2}}}H<br>$$<br>为什么是开根号，因为在衰减的时候还是要尽量满足归一化。可以看作对$\tilde{A_{i,j}}$做了如下操作：</p>
<p>$$<br>\tilde{A_{ij}} &#x3D; \frac{A_{ij}}{\sqrt{D_{ii}} \sqrt{D_{jj}}}<br>$$</p>
<p>这样，当一阶邻居顶点j的度（边数量，也就是它的一阶邻居数量）很大，那么传播一次后信号就会变得很小，比如对V2来讲：</p>
<p>$$<br>\tilde{D_{22}^{-\frac{1}{2}}}\tilde{A_2}\tilde{D_{11}^{-\frac{1}{2}}}H&#x3D;\frac{1}{\sqrt{3} \sqrt{14}}(2H_1+H_2)<br>$$</p>
<p>最后再通过一个激活函数，以及一个阈值b，就可以类似cnn得到一个前向传播公式：</p>
<p>$$<br>H^{l+1}&#x3D;\sigma (\tilde{D^{-\frac{1}{2}}}\tilde{A}\tilde{D^{-\frac{1}{2}}}H^{l}W^{l}+b^{l})<br>$$</p>
<p>其中$\tilde{D^{-\frac{1}{2}}}\tilde{A}\tilde{D^{-\frac{1}{2}}}$是固定不变的，其余的工作就是构建全连接层，损失函数，反向传播，更新参数。</p>
<h2 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h2><p>前面铺垫了这么多，那么这个模型是什么呢，说白了就是类似transformer的编码器解码器，基于重构的方法。</p>
<div style="text-align: center;">
  <img src="../img/oodPaper/img_3.png" alt="" />
</div>

<ul>
<li>编码器：将输入的属性矩阵通过前面所述的图卷积神经网络提取特征，得到了一个杂糅属性和结构关系的低维向量表示。</li>
<li>解码器：根据这个得到的中间表示<strong>重构</strong>，结构通过结构解码器进行重构，属性通过属性编码器进行重构。然后计算重构结果与实际结果，完成损失函数最小化。原文这里的结构解码器非常简单暴力，就用中间低维特征提取的内积完成，$\sigma(Z*Z^{T})$，属性用另一层GSN进行映射。</li>
</ul>
<p><strong>那么是怎么判断出异常的？</strong></p>
<p>通过以上步骤重建拓扑网络结构，将结构和属性的重构误差共同学习，可以表示为：<br>$$<br>\mathcal{L}&#x3D;(1-\alpha)R_S+\alpha R_A&#x3D;(1-\alpha){\Vert A-\hat{A} \Vert}_F^2+\alpha {\Vert X-\hat{X} \Vert}_F^2<br>$$<br>式中，是用来平衡结构重建和属性重建影响的一个重要参数。</p>
<p>通过最小化目标函数，自编码器可以基于编码的潜在表示迭代地近似输入的属性网络，直至收敛。最后，使用两项重构误差之和来评估节点的异常性。 也就是，得分越高的实例越是被认为异常。再由该分数来计算属性网络的异常排名</p>
<h2 id="带带锐评"><a href="#带带锐评" class="headerlink" title="带带锐评"></a>带带锐评</h2><ul>
<li>优点：结构新颖，基于图卷积神经网络，特征提取考虑了结构和点属性两方面特征，更能检测出异常，对稀疏图数据的处理有优势。</li>
<li>缺点：重构本身具有一定的局限性，只适用于异常数据占比比较小的数据集进行训练，否则通过重构方法后的误差较大，还有前文所说的解码器构造有一点暴力了，因为Z不止有结构还有属性，直接内积会有干扰，改进措施应该可以剔除这部分因素进行单纯的结构重构。</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/06/11/redis%E9%A1%B9%E7%9B%AE-elasticsearch%E4%B8%8Emongodb/">redis项目-elasticsearch与mongodb</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-06-11
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>其实这个搜索的功能反倒跟redis没啥关系了，所以我也没归类在redis里。基于es的搜索也不无非是增删改查，先简单说一下项目里用到的这两个功能和api。后续我会详细学习</p>
</blockquote>
<h2 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h2><p>es是一个搜索器，具体怎么搜的我不知道（笑）。目前的理解是在新增blog的时候同时把这个对象给es服务器，它通过索引的方式进行缓存。后续查找的时候就可以根据field，也就是字段名来指定匹配位置。</p>
<p>比如这里要搜索文章标题的关键字，就用title；如果是内容的，就用content。经过我的实验发现黑马给的分词器只能检索中文，我想要搜素字母“s”，都搜不到。</p>
<p>项目里的应用也比较简单，就是上述的关键字搜索，然后返回前端的时候要标红，这个步骤是通过在前后加font标签完成的。</p>
<p>首先是配置：</p>
<p>这里用到的对象是RestHighLevelClient，我们只需要配置端口号和ip就可以了，这个客户端会使用es的restful端口进行增删改查。</p>
<p>我们对其的增删改查操作就跟redistemplate一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticSearchConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置RestHighLevelClient对象</span></span><br><span class="line"><span class="comment">     * 将该对象交给Spring容器去管理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RestHighLevelClient对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">restHighLevelClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="comment">//若有多个，可以传一个数组</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">HttpHost</span>(host, port, <span class="string">&quot;http&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用这个RestHighLevelClient，传输的是一个httprequest，返回的是response。思路是创建一个request，查询标题和内容两个方面的关键词。<br>返回以后进行一个转换，返回的加上颜色标签的hits是一个数组，需要转换成字符串。最后向前端返回这个字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">searchBlog</span><span class="params">(QueryBlogDto dto)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.输入校验</span></span><br><span class="line">    <span class="keyword">if</span> (dto == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;输入为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dto.getKeyWord() == <span class="literal">null</span> || dto.getKeyWord().isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;输入关键词为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异步给mongo</span></span><br><span class="line">    insertSearchHistory(dto.getKeyWord());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.查询条件</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hmdp_blogs&quot;</span>);</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.1布尔类型的查询</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 查询标题和内容两方面的关键词</span></span><br><span class="line">    <span class="type">QueryStringQueryBuilder</span> <span class="variable">queryStringQueryBuilder</span> <span class="operator">=</span> QueryBuilders.queryStringQuery(dto.getKeyWord()).field(<span class="string">&quot;content&quot;</span>).field(<span class="string">&quot;title&quot;</span>).defaultOperator(Operator.OR);</span><br><span class="line">    builder.must(queryStringQueryBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 文本高亮这个查找到的关键字</span></span><br><span class="line">    <span class="type">HighlightBuilder</span> <span class="variable">highlightBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>();</span><br><span class="line">    highlightBuilder.field(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">    highlightBuilder.field(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">    <span class="comment">//2.3.1 标红</span></span><br><span class="line">    highlightBuilder.preTags(<span class="string">&quot;&lt;font style=&#x27;color: red; font-size: inherit;&#x27;&gt;&quot;</span>);</span><br><span class="line">    highlightBuilder.postTags(<span class="string">&quot;&lt;/font&gt;&quot;</span>);</span><br><span class="line">    searchSourceBuilder.highlighter(highlightBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.4 传给searchRequest</span></span><br><span class="line">    searchSourceBuilder.query(builder);</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.5 包装好了的request给客户端返回</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 处理消息回应，一个gethits是一个类，要获取这个数组需要在这个包装类里面再获取。</span></span><br><span class="line">    SearchHit[] hits = response.getHits().getHits();</span><br><span class="line">    List&lt;Map&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> JSONUtil.toBean(json, Map.class);</span><br><span class="line">        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (highlightFields != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">title</span> <span class="operator">=</span> highlightFields.get(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">content</span> <span class="operator">=</span> highlightFields.get(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (title != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//title高亮</span></span><br><span class="line">                Text[] titleFragments = title.getFragments();</span><br><span class="line">                <span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> Arrays.stream(titleFragments).map((value) -&gt; value.toString()).collect(Collectors.joining());</span><br><span class="line">                map.put(<span class="string">&quot;title&quot;</span>,collect);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (content != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//content高亮</span></span><br><span class="line">                Text[] contentFragments = content.getFragments();</span><br><span class="line">                <span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> Arrays.stream(contentFragments).map((value) -&gt; value.toString()).collect(Collectors.joining());</span><br><span class="line">                map.put(<span class="string">&quot;content&quot;</span>,collect);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.add(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h2><p>登录用户的查询记录很多而且变化频繁。需要用非关系型数据库来存储。（其实我个人觉得没必要存在服务器上，这些缓存应该都是在客户端上保留的）</p>
<p>mongodb的配置比较简单，甚至不用写配置类。直接看使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存搜索记录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyWord</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertSearchHistory</span><span class="params">(String keyWord)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userID</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//1 先从db找这个数据</span></span><br><span class="line">    <span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;userId&quot;</span>).is(userID).and(<span class="string">&quot;keyWord&quot;</span>).is(keyWord));</span><br><span class="line">    <span class="type">QueryBlogDto</span> <span class="variable">searchHistory</span> <span class="operator">=</span> mongoTemplate.findOne(query, QueryBlogDto.class);</span><br><span class="line">    <span class="comment">//2 如果又就更新创建时间</span></span><br><span class="line">    <span class="keyword">if</span> (searchHistory != <span class="literal">null</span>)&#123;</span><br><span class="line">        searchHistory.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3 没有就存进db</span></span><br><span class="line">    <span class="type">QueryBlogDto</span> <span class="variable">dto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryBlogDto</span>();</span><br><span class="line">    dto.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    dto.setUserId(userID);</span><br><span class="line">    dto.setKeyWord(keyWord);</span><br><span class="line"></span><br><span class="line">    <span class="type">Query</span> <span class="variable">query1</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;userId&quot;</span>).is(userID))</span><br><span class="line">            .with(Sort.by(Sort.Direction.DESC,<span class="string">&quot;createTime&quot;</span>));</span><br><span class="line">    List&lt;QueryBlogDto&gt; dtos = mongoTemplate.find(query1, QueryBlogDto.class);</span><br><span class="line">    <span class="comment">//3.1 如果数量少于10条就直接存</span></span><br><span class="line">    <span class="keyword">if</span> (dtos.size() &lt; <span class="number">10</span>)&#123;</span><br><span class="line">        mongoTemplate.save(dto);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2 如果多余10就要替换了</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">QueryBlogDto</span> <span class="variable">last</span> <span class="operator">=</span> dtos.get(dtos.size() - <span class="number">1</span>);</span><br><span class="line">        mongoTemplate.findAndReplace(Query.query(Criteria.where(<span class="string">&quot;keyWord&quot;</span>).is(last.getKeyWord())),dto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>值得注意的是这里使用了@Async，gpt给我的答案是这个跟你新开一个线程没有区别，但是注意要在启动类上enable。这里query更像lambdaQueryWrapper那种。具体的增删改查语法以后再学。</p>

    
    
  </div>

  

  

</article>
  
    
  <nav class="pagination">  
      
      <a class="prev" href="/page/3/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text">上一页</span>  
      </a>  
      
      
      <a class="next" href="/page/5/">  
        <span class="next-text">下一页</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  
</section>
        </div>
          

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:1050886654@qq.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/yyf1050886654" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2024 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">Yifan Yang</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    

  







<script type="text/javascript" src="/lib/jquery"></script>



<script type="text/javascript" src="/lib/slideout"></script>



<script type="text/javascript" src="/lib/fancybox"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>