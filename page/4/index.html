<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/default" title="YYF's Blog" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://yyf1050886654.github.io/page/4/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>YYF&#39;s Blog</title>

<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">YYF&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/collect/">
      <li class="mobile-menu-item">
        
        
        收藏              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">YYF's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/collect/">  
              
              
              收藏  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <section id="posts" class="posts">
  
  
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/05/mysql-%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/">mysql-索引和索引失效</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-05
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><h2 id="左匹配或者左右匹配"><a href="#左匹配或者左右匹配" class="headerlink" title="左匹配或者左右匹配"></a>左匹配或者左右匹配</h2><p>当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效。</p>
<p><strong>为什么 like 关键字左或者左右模糊匹配无法走索引呢？</strong></p>
<p>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</p>
<p>举个例子，下面这张二级索引图（图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行），是以 name 字段有序排列存储的。</p>
<p><img src="/../img/Mysql/img_13.png"></p>
<p>假设我们要查询 name 字段前缀为「林」的数据，也就是 name like ‘林%’，扫描索引的过程（这里中文都是按照某种排序，不知道是不是按照utf-8的编码值比较的，但是这个规则不影响寻找到逻辑）：</p>
<ul>
<li>节点1判断出“林”小于“周”并且大于“陈”（这个步骤是通过<strong>页目录</strong>进行搜索的，回顾一下：假设这里头指针是一个分组，陈是一个分组，剩下两个和尾指针是一个分组，二分查找目录项，由于目录项指向分组的最大值，那么“林”是大于陈小于周的，按照目录项的规则，从<em>包含尾指针的那个分组开始</em>，但是由于存的是最大值也就是尾指针，为了从头开始遍历，就要找到上一个槽的指针，往后数一个就是当前的最小值，结果发现当前的最小值“周”还是大于“林”，这样就定位在“陈”和“周”之间，按照存储规则，<strong>非叶子节点存的是下一个节点的最小值</strong>，那就要在“陈”这个节点找）</li>
<li>节点2继续比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4</li>
<li>节点4查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。</li>
</ul>
<p>如果使用 name like ‘%林’ 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。</p>
<blockquote>
<p>总而言之，索引是从左边开始匹配的，如果左边第一个都不能确定，那就要全部遍历</p>
</blockquote>
<h2 id="对索引使用函数"><a href="#对索引使用函数" class="headerlink" title="对索引使用函数"></a>对索引使用函数</h2><p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。</p>
<p><strong>为什么对索引使用函数，就无法走索引了呢？</strong></p>
<p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p>
<p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p>
<p>举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_user add key idx_name_length ((length(name)));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总而言之，索引保存的是原始值，使用函数后重新计算导致不能索引到，就失效了，但是如果对这个函数也建立一个索引，那也可以走索引</p>
</blockquote>
<h2 id="数据类型强制转换"><a href="#数据类型强制转换" class="headerlink" title="数据类型强制转换"></a>数据类型强制转换</h2><blockquote>
<p>这个印象比较深刻：首先举一个例子，select “10” &gt; 9，通过这个例子可以看出来在mysql是怎么处理字符串的</p>
<ul>
<li>如果是结果是1，也就是select 10&gt;9，那么内部会把字符串处理成数字</li>
<li>如果结果是0，也就是select “10” &gt; “9”，字符串是比较首位，1肯定小于9，所以这个结果是0，那么内部把数字处理成字符串<br>结果是1，也就是<strong>mysql内部把字符串变成数字进行比较</strong></li>
</ul>
</blockquote>
<p>假设phone在数据库是用varchar存的，有了这个结论，那么</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where phone = 1300000001;</span><br></pre></td></tr></table></figure>
<p>这个代码就会变成：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where CAST(phone AS signed int) = 1300000001;</span><br></pre></td></tr></table></figure>
<p>因为内部会把索引的字符串变成整数进行比较，相当于给索引使用了函数，所以就会失效</p>
<p>如果查询条件是字符串，id在数据库用int存的</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where id = &quot;1&quot;;</span><br></pre></td></tr></table></figure>
<p>那么就会变成：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where id = CAST(&quot;1&quot; AS signed int);</span><br></pre></td></tr></table></figure>
<p>也就是说，只有这个查询条件会要用这个函数，索引没有用，索引就不失效</p>
<h2 id="对索引进行表达式计算"><a href="#对索引进行表达式计算" class="headerlink" title="对索引进行表达式计算"></a>对索引进行表达式计算</h2><p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p>
<p>比如，下面这条查询语句，执行计划中 type &#x3D; ALL，说明是通过全表扫描的方式查询数据的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user where id + 1 = 10;</span><br></pre></td></tr></table></figure>

<p><strong>为什么对索引进行表达式计算，就无法走索引了呢？</strong></p>
<p>原因跟对索引使用函数差不多。</p>
<p>因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</p>
<p>有的同学可能会说，这种对索引进行简单的表达式计算，在代码特殊处理下，应该是可以做到索引扫描的，比方将 id + 1 &#x3D; 10 变成 id &#x3D; 10 - 1。</p>
<p>是的，是能够实现，但是 MySQL 还是偷了这个懒，没有实现。</p>
<p>我的想法是，可能也是因为，表达式计算的情况多种多样，每种都要考虑的话，代码可能会很臃肿，所以干脆将这种索引失效的场景告诉程序员，让程序员自己保证在查询条件中不要对索引进行表达式计算。</p>
<h2 id="联合索引的左匹配问题"><a href="#联合索引的左匹配问题" class="headerlink" title="联合索引的左匹配问题"></a>联合索引的左匹配问题</h2><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p>
<p>那么多个普通字段组合在一起创建的索引就叫做联合索引，也叫组合索引。</p>
<p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。</p>
<p>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配。</p>
<p>比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a&#x3D;1；</li>
<li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li>
<li>where a&#x3D;1 and b&#x3D;2；<br>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</li>
</ul>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b&#x3D;2；</li>
<li>where c&#x3D;3；</li>
<li>where b&#x3D;2 and c&#x3D;3；<blockquote>
<p>其实类似第一种情况，不管是字符串还是索引，都是按照最左匹配的，如果连第一个都没有，那就会导致索引失效，这里还有一个<strong>索引下推</strong>的机制，等以后再来补。</p>
</blockquote>
</li>
</ul>
<h2 id="or导致的失效问题"><a href="#or导致的失效问题" class="headerlink" title="or导致的失效问题"></a>or导致的失效问题</h2><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>
<p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p>
<blockquote>
<p>or就是两个里面满足一个，也就是索引要有两个，才可以一起用索引，and其实是只要有一个是索引就可以走索引的，要注意</p>
</blockquote>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/05/mysql-Buffer-Pool/">mysql-Buffer Pool</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-05
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/05/mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC/">mysql-事务隔离级别与MVCC</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-05
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="事务的特性（ACID）"><a href="#事务的特性（ACID）" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h1><ul>
<li>原子性（Atomicity）：要么一起成功，要么一起失败，是一个操作，不可分割</li>
<li>一致性（Consistency）：是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行前后，数据库都必须处于一致性状态。换句话说，事务的执行结果必须是使数据库从一个一致性状态转变到另一个一致性状态。</li>
<li>隔离性（Isolation）：多个并发事务操作是隔离的，不会彼此打扰</li>
<li>持久性（Durability）：修改之后是持久的，不会掉电就失效了</li>
</ul>
<h1 id="并发导致的不一致性"><a href="#并发导致的不一致性" class="headerlink" title="并发导致的不一致性"></a>并发导致的不一致性</h1><ul>
<li>脏读<br><strong>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</strong></li>
</ul>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。</p>
<p><img src="/../img/Mysql/img_14.png"></p>
<p>因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读</p>
<blockquote>
<p>也就是事务B在A还没提交之前就已经读到了修改的数据，但是A因为某些原因回滚了，这个时候B就读到了脏数据，称为脏读</p>
</blockquote>
<ul>
<li>不可重复读<br><strong>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</strong></li>
</ul>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</p>
<p><img src="/../img/Mysql/img_15.png"></p>
<blockquote>
<p>也就是A读到了B修改前和修改后的两次数据，不一致的问题，就是不可重复读</p>
</blockquote>
<ul>
<li>幻读</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/03/mysql-B-%E6%A0%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%9D%97/">mysql-B+树与数据页</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-03
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>我们先从最基本的存储引擎InnoDB开始学起，<a target="_blank" rel="noopener" href="https://blog.csdn.net/liang921119/article/details/130556995">原文链接</a></p>
</blockquote>
<h1 id="InnoDB-是如何存储数据的？"><a href="#InnoDB-是如何存储数据的？" class="headerlink" title="InnoDB 是如何存储数据的？"></a>InnoDB 是如何存储数据的？</h1><p>MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同的，我们最常使用的是 InnoDB 存储引擎，所以就跟大家图解下InnoDB 是如何存储数据的。</p>
<p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p>
<p>因此，InnoDB 的数据是按「数据页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
<h1 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h1><p>数据库的 I&#x2F;O 操作的最小单位是页，InnoDB 数据页的默认大小是 16KB，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p>
<p>数据页包括七个部分，结构如下图：</p>
<p><img src="/../img/Mysql/img.png"></p>
<p><img src="/../img/Mysql/img_1.png"></p>
<blockquote>
<p>这里最重要的是最小和最大记录，以及用户记录</p>
</blockquote>
<h2 id="用户真实记录在数据页中的存储（Free-Space）"><a href="#用户真实记录在数据页中的存储（Free-Space）" class="headerlink" title="用户真实记录在数据页中的存储（Free Space）"></a>用户真实记录在数据页中的存储（Free Space）</h2><p>在页的7个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。这个过程的图示如下：</p>
<p><img src="/../img/Mysql/img_2.png"></p>
<p>为了更好的管理在User Records中的这些记录，InnoDB可费了一番力气呢，在哪费力气了呢？不就是把记录按照指定的行格式一条一条摆在User Records部分么？其实这话还得从记录行格式的记录头信息中说起</p>
<h2 id="记录头信息引出的数据页“记录”结构"><a href="#记录头信息引出的数据页“记录”结构" class="headerlink" title="记录头信息引出的数据页“记录”结构"></a>记录头信息引出的数据页“记录”结构</h2><p>我们这里先创建一张表</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table demo5 (c1 int, c2 int, c3 varchar(10000),primary key (c1)) charset=ascii row_format=compact;</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br></pre></td></tr></table></figure>

<p>这个新建的表有三个列，c1和c2列是用来存储整数的，c3存储的字符串，但是我们指定c1位主键，所以在具体的行格式中，Innodb就没有必要给我们创建row_id隐藏列了 <strong>（这里说的隐藏列是在没有明确给主键的时候，mysql会自己找一个unique并且没有空值的列为主键索引，这个就是隐藏列）</strong>。所以表中的行格式示意图如下：</p>
<p><img src="/../img/Mysql/img_3.png"></p>
<p><img src="/../img/Mysql/img_4.png"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>⼤⼩（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1</td>
<td>1</td>
<td>没有使⽤</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使⽤</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树的每层⾮叶⼦节点中的最⼩记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型，0表示普通记录，1表示B+树⾮叶⼦节点记录，2表示最⼩记录，3表示最⼤记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>表示下⼀条记录的相对位置</td>
</tr>
</tbody></table>
<p>假设我们插入了几条数据：</p>
<p><img src="/../img/Mysql/img_5.png"></p>
<p>接下来会一个个解释这几个字段</p>
<h3 id="delete-mask"><a href="#delete-mask" class="headerlink" title="delete_mask"></a>delete_mask</h3><p>这个属性标记当前记录是否被删除，占用一个二进制位，为0为没有删除，为1被删除</p>
<blockquote>
<p>被删除的记录不立即从磁盘上移除，因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为所谓的可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。这个delete_mask位设置为1和将被删除的记录加入到垃圾链表中是两个阶段</p>
</blockquote>
<h3 id="min-rec-mask"><a href="#min-rec-mask" class="headerlink" title="min_rec_mask"></a>min_rec_mask</h3><p>B+树的每层非叶子节点中的最小记录都会添加该标记。值为1，表示该条记录是B+树的非叶子节点中的最小记录；值为0，意味着该条数据不是B+树的非叶子节点中的最小记录 <strong>（暂时还不知道这个具体作用，可能就是记录每一层的头节点？）</strong></p>
<h3 id="n-owned"><a href="#n-owned" class="headerlink" title="n_owned"></a>n_owned</h3><p>这个涉及到<strong>分组</strong>的概念了，存的就是当前分组有多少个元素，后续会介绍</p>
<h3 id="heap-no"><a href="#heap-no" class="headerlink" title="heap_no"></a>heap_no</h3><p>这个属性表示当前记录在本页中的位置（类似页表中的本页地址字段，但是这个单纯用来比较顺序）。MySQL自动给每个页里边儿加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录（这就是最前面介绍的7部分中的 <strong>最大最小记录</strong>）。</p>
<p>记录也可以比大小，对于一条完整的记录来说，比较记录的大小就是比较主键的大小。但是不管我们向页中插入了多少自己的记录，InnoDB规定他们定义的两条伪记录分别为最小记录与最大记录。这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p>
<p><img src="/../img/Mysql/img_6.png"></p>
<blockquote>
<p>这里规定的最小记录的heapno为0，最大记录的为1</p>
</blockquote>
<h3 id="record-type"><a href="#record-type" class="headerlink" title="record_type"></a>record_type</h3><p>这个属性表示当前记录的类型，一共有4种类型的记录，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们record_type值都是0，而最小记录和最大记录的record_type值分别为2和3，至于record_type为1的情况，我们之后在说索引的时候会重点强调的。</p>
<h3 id="next-record"><a href="#next-record" class="headerlink" title="next_record"></a>next_record</h3><p>这个信息非常重要，表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。如果你熟悉数据结构的话，就立即明白了，这其实是个链表，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是，下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是Supremum记录（也就是最大记录） ，为了更形象的表示一下这个next_record起到的作用，我们用箭头来替代一下next_record中的地址偏移量：</p>
<p><img src="/../img/Mysql/img_7.png"></p>
<p>假设删掉第2条记录后，由于删除只是标记为删除，实际上没有删除，就会变成：</p>
<p><img src="/../img/Mysql/img_8.png"></p>
<p>从图中可以看出来，删除第2条记录前后主要发生了这些变化：</p>
<ul>
<li>第2条记录并没有从存储空间中移除，而是把该条记录的delete_mask值设置为1。</li>
<li>第2条记录的next_record值变为了0，意味着该记录没有下一条记录了。</li>
<li>第1条记录的next_record值变为了64，指向了第3条记录。</li>
<li>最大记录的n_owned值从5变成了4，关于这一点的变化我们稍后会详细说明的。<br>所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的</li>
</ul>
<h2 id="页目录（重要）"><a href="#页目录（重要）" class="headerlink" title="页目录（重要）"></a>页目录（重要）</h2><blockquote>
<p>页目录的存在意义主要是加速检索速度，并不是将他们重新分组，我最开始以为是将记录再分成几块进行检索，但是其实只是一个方便二分查找的工具</p>
</blockquote>
<p>现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？比如说这样的查询语句：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from where c1=3;</span><br></pre></td></tr></table></figure>
<p>最笨的办法：从Infimum记录（最小记录）开始，沿着链表一直往后找，总会找到。在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。</p>
<p>但是InnoDB能用这么笨的办法么，当然是要设计一种更快的查找方式，于是乎从书的目录中找到了灵感。</p>
<p>我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。InnoDB为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：</p>
<ul>
<li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li>
<li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</li>
<li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的Page Directory，也就是页目录。页面目录中的这些地址偏移量被称为槽（英文名：Slot），所以这个页面目录就是由槽组成的。<br>需要注意的是，Page Directory是逆序存放的，每个槽占2字节</li>
</ul>
<p><img src="/../img/Mysql/img_9.png"></p>
<blockquote>
<p>这里第一个slot为什么是99？因为是从页的第一位开始算 <del>（文件头+页头+最小记录前的6字节&#x3D;38+56+5&#x3D;100，但是是0开始的，所以）</del> 最小记录单成一个分组，那slot也就指向的是最小记录的数据</p>
</blockquote>
<p>从这个图中我们需要注意这么几点：</p>
<p>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。</p>
<p>注意最小和最大记录的头信息中的n_owned属性</p>
<p>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</p>
<p>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</p>
<p>99和112这样的地址偏移量很不直观，我们用箭头指向的方式替代数字，这样更易于我们理解，所以修改后的示意图就是这样：</p>
<p><img src="/../img/Mysql/img_10.png"></p>
<p><img src="/../img/Mysql/img_11.png"></p>
<p>InnoDB对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1 ~ 8条之间，剩下的分组中记录的条数范围只能在是4 ~ 8条之间。所以分组是按照下边的步骤进行的：</p>
<ul>
<li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li>
<li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li>
<li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">insert into demo5 values(1,100,&#x27;aaaa&#x27;),(2,200,&#x27;bbbb&#x27;),(3,300,&#x27;cccc&#x27;),(4,400,&#x27;dddd&#x27;);</span><br><span class="line">insert into demo5 values(5, 500, &#x27;eeee&#x27;);</span><br><span class="line">insert into demo5 values(6, 600, &#x27;ffff&#x27;);</span><br><span class="line">insert into demo5 values(7, 700, &#x27;gggg&#x27;);</span><br><span class="line">insert into demo5 values(8, 800, &#x27;hhhh&#x27;);</span><br><span class="line">insert into demo5 values(9, 900, &#x27;iiii&#x27;);</span><br><span class="line">insert into demo5 values(10, 1000, &#x27;jjjj&#x27;);</span><br><span class="line">insert into demo5 values(11, 1100, &#x27;kkkk&#x27;);</span><br><span class="line">insert into demo5 values(12, 1200, &#x27;llll&#x27;);</span><br><span class="line">insert into demo5 values(13, 1300, &#x27;mmmm&#x27;);</span><br><span class="line">insert into demo5 values(14, 1400, &#x27;nnnn&#x27;);</span><br><span class="line">insert into demo5 values(15, 1500, &#x27;oooo&#x27;);</span><br><span class="line">insert into demo5 values(16, 1600, &#x27;pppp&#x27;);</span><br></pre></td></tr></table></figure>
<p><img src="/../img/Mysql/img_12.png"></p>
<p>因为把16条记录的全部信息都画在一张图里太占地方，让人眼花缭乱的，所以只保留了用户记录头信息中的n_owned和next_record属性，也省略了各个记录之间的箭头，我没画不等于没有啊！现在看怎么从这个页目录中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low&#x3D;0，最高的槽就是high&#x3D;4。比方说我们想找主键值为6的记录，过程是这样的：</p>
<ul>
<li>计算中间槽的位置：(0+4)&#x2F;2&#x3D;2，所以查看槽2，对应记录的主键值为8，又因为8 &gt; 6，所以设置high&#x3D;2，low保持不变。</li>
<li>重新计算中间槽的位置：(0+2)&#x2F;2&#x3D;1，所以查看槽1对应的主键值为4，又因为4 &lt; 6，所以设置low&#x3D;1，high保持不变。</li>
<li>因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中，此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</li>
</ul>
<p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p>
<ul>
<li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li>
<li>通过记录的next_record属性遍历该槽所在的组中的各个记录</li>
</ul>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/03/redis-%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/">redis-读写一致性</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-03
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="Mysql如何与Redis保持同步"><a href="#Mysql如何与Redis保持同步" class="headerlink" title="Mysql如何与Redis保持同步"></a>Mysql如何与Redis保持同步</h1><p><img src="/../img/Redis/img_24.png"></p>
<p>类比计算机组成原理中的cache和内存，redis也就是mysql的缓存，那么保持读写一致性也是十分重要的，我们在修改数据库的同时，缓存中也要对应更新。</p>
<ul>
<li>读操作：缓存命中就直接返回，缓存未命中就查找数据库，然后更新缓存</li>
<li>写操作：<strong>延迟双删</strong><br><img src="/../img/Redis/img_25.png"></li>
</ul>
<h2 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h2><ol>
<li><strong>正常情况</strong></li>
</ol>
<p><img src="/../img/Redis/img_26.png"></p>
<p>首先线程1删除缓存，然后更新数据库，此时没有任何线程来打扰，完成操作以后线程2再来查找缓存，这个时候由于线程1已经删除了缓存，那就会查找数据库找到刚刚更新的数据，最后写入缓存。这个过程不会出现读写一致性问题</p>
<ol start="2">
<li><strong>特殊情况</strong><blockquote>
<p>其实下面先写后删除的特殊情况也适用于本例中，首先线程1查询到了一个过期key，去数据库找，暂时保存，但是没写进redis。此时另一个进程是写进程，先删除了这个key，随后更新，最后才轮到线程1，写回刚刚的旧数据到redis，同样会有数据不一致</p>
</blockquote>
</li>
</ol>
<p><img src="/../img/Redis/img_27.png"></p>
<p>我们假设线程1删除缓存之后，由于线程是并发的，线程2来查询，此时由于还没有更新数据库，找到的还是原来的数据，随后放回缓存，这个时候才轮到线程1，更新数据库，但是此时redis还是用的以前的数据，数据库的是刚刚更新的，就出现了读写一致性问题</p>
<h2 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h2><blockquote>
<p>那如果我们先更新数据库，在更新缓存是不是正确的呢？<strong>答案是还是会有读写一致性问题</strong></p>
</blockquote>
<ol>
<li><strong>正常情况</strong></li>
</ol>
<p> <img src="/../img/Redis/img_28.png"><br>线程2先更新数据库，然后删除，跟上面的一样，只要两个操作是原子性的就不会有问题，但是只要是线程是并发的，那就肯定不一致</p>
<ol start="2">
<li><strong>特殊情况</strong></li>
</ol>
<p><img src="/../img/Redis/img_29.png"></p>
<blockquote>
<p>如果在不在这个刚刚过期的时间节点，那会怎么样呢？其实如果不是刚刚要过期，那就直接会拿走缓存中的数据，也不会删除缓存，那写进程后续先改再写redis也不会出现读写一致性问题，个人觉得核心的问题在于读进程的机制，没查到或者过期的缓存就会主动去数据库里调用，会扰乱正常的写进程导致不一致</p>
<p>如果是命中的读进程，那就根本不会扰乱写进程，只是脏数据的问题，redis和mysql最终都是一致的。而这里讨论的刚好过期，才会导致读进程写redis，才会有不一致性的问题发生）</p>
</blockquote>
<p>线程1先去查询缓存，这个时候刚好key过期，就要去数据库找，在数据库找到的是旧数据，先保存下来，但是此时线程2更新了数据库，然后删除，最后才是线程1写回旧数据到redis，出现不一致。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li><strong>分布式锁</strong>：在更新缓存前先加个分布式锁，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。</li>
<li><strong>延迟双删</strong>：针对「先删除缓存，再更新数据库」方案在「读 + 写」并发请求而造成缓存不一致的解决办法是「延迟双删」。</li>
<li><ul>
<li>为什么要双删？因为刚刚在[先删除缓存，再更新数据库]方案中会出现读写一致问题，这个时候只要再去删除一次缓存就可以了，下一个来的读请求会发现不存在对应的key，然后从数据库找，最终达到一致性</li>
</ul>
</li>
<li><ul>
<li>为什么要延迟？主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。<br>所以，请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。因为这个延时时间不好控制，在极端情况下还是会出现读写不一致的现象。</li>
</ul>
</li>
<li><strong>使用「先更新数据库，再删除缓存」方案</strong>：其实这种方案的特殊情况很难遇见，因为<strong>缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。<br>而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。<strong>（意思是即使B先写了数据库，A再写旧的值，因为数据库涉及io（扯远点就是io中断）阻塞进程B直到时间片到了，进程会交替执行而io搁一边，可能当执行到A写完了旧值，更新才刚刚结束，这个时候B再执行删除，就可以保证一致性）</strong></li>
</ul>
<h2 id="在不那么要求强一致性的场景"><a href="#在不那么要求强一致性的场景" class="headerlink" title="在不那么要求强一致性的场景"></a>在不那么要求强一致性的场景</h2><p>有的时候可以容忍一瞬间的脏数据，但是要保持最终一致性的场景，可以使用以下两种方法：</p>
<ul>
<li>基于消息队列（例如kafka）：写入数据库后，发一个消息给mq通知redis更新缓存，这种方式的可靠性主要取决于mq，肯定是有一定的延时的，但是最终会保证一致</li>
<li>基于阿里巴巴的Canal中间件：「先更新数据库，再删缓存」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。<br>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/02/leetcode-2024-4-2/">leetcode-2024-4-2</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-02
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="894-所有可能的真二叉树"><a href="#894-所有可能的真二叉树" class="headerlink" title="894 所有可能的真二叉树"></a>894 所有可能的真二叉树</h1><p>给你一个整数 n ，请你找出所有可能含 n 个节点的 真二叉树 ，并以列表形式返回。答案中每棵树的每个节点都必须符合 Node.val &#x3D;&#x3D; 0 。</p>
<p>答案的每个元素都是一棵真二叉树的根节点。你可以按 任意顺序 返回最终的真二叉树列表。</p>
<p>真二叉树 是一类二叉树，树中每个节点恰好有 0 或 2 个子节点。</p>
<p><img src="/../img/coding/2024_4_2_1.png"></p>
<blockquote>
<p>感觉很像之前写过的一道题</p>
</blockquote>
<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>由分析知道，n不能为偶数，叶子节点为（n+1）&#x2F;2，度为二的节点为(n-1)&#x2F;2，n&#x3D;1的时候就只有一个节点，n可以拆分出[x,1,y]三个，x和y都必须是奇数，x和y都比n小而且一定在之前的遍历中已经计算过，只要深拷贝n&#x3D;x和n&#x3D;y的数组，作为左边右边，就可以得到最终答案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//记忆化保存的数组</span></span><br><span class="line">    List&lt;List&lt;TreeNode&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; treeNodeList;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">allPossibleFBT</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//排除偶数</span></span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        treeNodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        treeNodeList.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">0</span>));</span><br><span class="line">        list.add(treeNodeList);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">3</span>; k &lt;= n; k+=<span class="number">2</span>) &#123;</span><br><span class="line">            treeNodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k-<span class="number">1</span>; i+=<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//System.out.println(i);</span></span><br><span class="line">                <span class="comment">//由于i是+=2的，对应的list下标是++，所以要/2</span></span><br><span class="line">                List&lt;TreeNode&gt; left = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.get(i/<span class="number">2</span>));</span><br><span class="line">                List&lt;TreeNode&gt; right = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.get((k-<span class="number">1</span>-i)/<span class="number">2</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; left.size(); p++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">0</span>; q &lt; right.size(); q++) &#123;</span><br><span class="line">                        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                        root.left = left.get(p);</span><br><span class="line">                        root.right = right.get(q);</span><br><span class="line">                        <span class="comment">//先保存到treenodeList里</span></span><br><span class="line">                        treeNodeList.add(root);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(treeNodeList.size());</span></span><br><span class="line">            <span class="comment">//最后加上这个</span></span><br><span class="line">            list.add(treeNodeList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(list.get(n/2).size());</span></span><br><span class="line">        <span class="comment">//返回记忆化搜索最后一个</span></span><br><span class="line">        <span class="keyword">return</span> list.get(n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/02/redis-%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87/">redis-高可用篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-02
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>单点Redis的并发能力是由上限的，如果都存储在一台服务器上，出事了就会有很严重的影响。</p>
<ul>
<li>如果出现了宕机，那么数据恢复需要时间，而且主进程在此期间不能服务新请求，</li>
<li>硬盘出了问题那就会造成数据丢失。<br>如何解决这种问题，并且还要进一步提高并发性？可以搭建<strong>主从模式</strong>，实现读写分离。</li>
</ul>
<blockquote>
<p><strong>读写分离</strong>:<br>主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。<br><img src="/../img/Redis/img_12.png"></p>
<p>也就是说，所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。</p>
</blockquote>
<h2 id="第一次同步"><a href="#第一次同步" class="headerlink" title="第一次同步"></a>第一次同步</h2><p>多台服务器之间要通过什么方式来确定谁是主服务器，或者谁是从服务器呢？</p>
<p>我们可以使用 replicaof（Redis 5.0 之前使用 slaveof）命令形成主服务器和从服务器的关系。</p>
<p>比如，现在有服务器 A 和 服务器 B，我们在服务器 B 上执行下面这条命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 服务器 B 执行这条命令</span><br><span class="line">replicaof &lt;服务器 A 的 IP 地址&gt; &lt;服务器 A 的 Redis 端口号&gt;</span><br></pre></td></tr></table></figure>

<p>接着，服务器 B 就会变成服务器 A 的「从服务器」，然后与主服务器进行第一次同步。</p>
<p>主从服务器间的第一次同步的过程可分为三个阶段：</p>
<ul>
<li>第一阶段是建立链接、协商同步；</li>
<li>第二阶段是主服务器同步数据给从服务器；</li>
<li>第三阶段是主服务器发送新写操作命令给从服务器。</li>
</ul>
<p><img src="/../img/Redis/img_13.png"></p>
<blockquote>
<ol>
<li>一个从服务器要加入主服务器的从节点，首先执行上面这条replicaof，告诉主服务器我是新加入的</li>
<li>然后建立连接。这里有两个关键参数<strong>replication id</strong>，标识一个数据集，每一个master都会有一个这个id，相当于标记了一块空间，当slave加入时，并不知道master的这个id，就给“？”，还有一个参数<strong>offset</strong>也就是偏移量，表示复制的进度，初始化为-1，（<em><strong>有点类似TCP的序号和确认号</strong></em>）。<br>执行psync命令，告诉主服务器一个从节点要建立连接了</li>
<li>主服务器判断来的这个replication id是否是自己的，如果不是自己的说明是第一次加入的从服务器，返回前面的这两个值，自己的id和当前的复制进度。</li>
<li>从服务器收到响应之后会记录这两个值，准备进行<strong>全量复制</strong></li>
<li>此时主服务器fork一个子进程完成bgsave命令，生成<strong>RDB</strong>文件，然后传输给从服务器。此时不会阻塞主进程，还是能接收新的数据，那么就需要一个数据结构来存这些刚刚加入，但是没有写入RDB文件的数据，这里就有一个<strong>replication buffer</strong>缓冲区用来存这些数据</li>
<li>从服务器收到了bump.rdb文件，然后进行载入，在此之前清空当前数据</li>
<li>对于主服务器在<strong>复制传输和子服务器重建</strong>过程中新到的数据，缓冲区内的数据发送新的写命令给从服务器。</li>
</ol>
</blockquote>
<p><strong>第一阶段：建立链接、协商同步</strong></p>
<p>执行了 replicaof 命令后，从服务器就会给主服务器发送 psync 命令，表示要进行数据同步。</p>
<p>psync 命令包含两个参数，分别是主服务器的 runID 和复制进度 offset。</p>
<p>runID，每个 Redis 服务器在启动时都会自动生产一个随机的 ID 来唯一标识自己。当从服务器和主服务器第一次同步时，因为不知道主服务器的 run ID，所以将其设置为 “?”。<br>offset，表示复制的进度，第一次同步时，其值为 -1。<br>主服务器收到 psync 命令后，会用 FULLRESYNC 作为响应命令返回给对方。</p>
<p>并且这个响应命令会带上两个参数：主服务器的 runID 和主服务器目前的复制进度 offset。从服务器收到响应后，会记录这两个值。</p>
<p>FULLRESYNC 响应命令的意图是采用全量复制的方式，也就是主服务器会把所有的数据都同步给从服务器。</p>
<p>所以，第一阶段的工作时为了全量复制做准备。</p>
<p>那具体怎么全量同步呀呢？我们可以往下看第二阶段。</p>
<p><strong>第二阶段：主服务器同步数据给从服务器</strong></p>
<p>接着，主服务器会执行 bgsave 命令来生成 RDB 文件，然后把文件发送给从服务器。</p>
<p>从服务器收到 RDB 文件后，会先清空当前的数据，然后载入 RDB 文件。</p>
<p>这里有一点要注意，主服务器生成 RDB 这个过程是不会阻塞主线程的，因为 bgsave 命令是产生了一个子进程来做生成 RDB 文件的工作，是异步工作的，这样 Redis 依然可以正常处理命令。</p>
<p>但是，这期间的写操作命令并没有记录到刚刚生成的 RDB 文件中，这时主从服务器间的数据就不一致了。</p>
<p>那么为了保证主从服务器的数据一致性，主服务器在下面这三个时间间隙中将收到的写操作命令，写入到 replication buffer 缓冲区里：</p>
<ul>
<li>主服务器生成 RDB 文件期间；</li>
<li>主服务器发送 RDB 文件给从服务器期间；</li>
<li>「从服务器」加载 RDB 文件期间；</li>
</ul>
<p><strong>第三阶段：主服务器发送新写操作命令给从服务器</strong></p>
<p>在主服务器生成的 RDB 文件发送完，从服务器收到 RDB 文件后，丢弃所有旧数据，将 RDB 数据载入到内存。完成 RDB 的载入后，会回复一个确认消息给主服务器。</p>
<p>接着，主服务器将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，从服务器执行来自主服务器 replication buffer 缓冲区里发来的命令，这时主从服务器的数据就一致了。</p>
<p>至此，主从服务器的第一次同步的工作就完成了。</p>
<h2 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h2><p>主从服务器在完成第一次同步以后就会维护一个Tcp连接。</p>
<p><img src="/../img/Redis/img_14.png"></p>
<p>后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。</p>
<p>而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。</p>
<p>上面的这个过程被称为基于长连接的命令传播，通过这种方式来保证第一次同步后的主从服务器的数据一致性。</p>
<h2 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h2><blockquote>
<p>主从服务器在第一次同步之后，就会建立一个tcp长连接完成命令传输。但是此时网络产生延迟或者断开。那么就不能进行命令传播了（这里的断开网络指的是主从服务器之间的同步被打断），那么客户端还是可以从从服务器读到旧的数据产生不一致性。</p>
</blockquote>
<p><img src="/../img/Redis/img_15.png"></p>
<p>如果此时网络又恢复正常了，从服务器已经落后主服务器，要进行再次同步，这个时候用<strong>全局复制</strong>造成的开销会很大，可以采用<strong>增量复制</strong>的方法进行同步，只会把网络断开期间主服务器收到的写操作同步给从服务器，利用的就是offset之间的差值。<br><img src="/../img/Redis/img_16.png"></p>
<blockquote>
<ol>
<li>恢复连接后从服务器给主服务器发送id和offset</li>
<li>主服务器知道id是自己的，但是offest落后的有点多，这个时候就会计算自己的offset和从服务器给的offset之间差了多少，然后发送CONTINUE命令，告诉从服务器要发送增量数据。</li>
<li>从服务器重新执行这些命令</li>
</ol>
</blockquote>
<p><strong>offset具体怎么计算？</strong></p>
<ul>
<li>repl_backlog_buffer，是一个「环形」缓冲区，用于主从服务器断连后，从中找到差异的数据；</li>
<li>replication offset，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 master_repl_offset 来记录自己「写」到的位置，从服务器使用 slave_repl_offset 来记录自己「读」到的位置。</li>
</ul>
<p><strong>那 repl_backlog_buffer 缓冲区是什么时候写入的呢？</strong></p>
<p>在主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会将写命令写入到 repl_backlog_buffer 缓冲区里，因此 这个缓冲区里会保存着最近传播的写命令。</p>
<p>网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：</p>
<ul>
<li>如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用增量同步的方式；</li>
<li>相反，如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用全量同步的方式。（这是由于缓冲区是环形的，时间过长就会导致原来的数据被覆盖）</li>
</ul>
<p><strong>环形缓冲区repl_backlog_buffer</strong></p>
<p>当主服务器在 repl_backlog_buffer 中找到主从服务器差异（增量）的数据后，就会将增量的数据写入到 replication buffer 缓冲区，这个缓冲区我们前面也提到过，它是缓存将要传播给从服务器的命令。</p>
<p>repl_backlog_buffer 缓行缓冲区的默认大小是 1M，并且由于它是一个环形缓冲区，所以当缓冲区写满后，主服务器继续写入的话，就会覆盖之前的数据。因此，当主服务器的写入速度远超于从服务器的读取速度，缓冲区的数据一下就会被覆盖。</p>
<p>那么在网络恢复时，如果从服务器想读的数据已经被覆盖了，主服务器就会采用全量同步，这个方式比增量同步的性能损耗要大很多。</p>
<p>因此，为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，我们应该调整下 repl_backlog_buffer 缓冲区大小，尽可能的大一些，减少出现从服务器要读取的数据被覆盖的概率，从而使得主服务器采用增量同步的方式。</p>
<p><strong>repl_backlog_buffer 缓冲区具体要调整到多大呢？</strong></p>
<p>$$<br>second * write_size_per_second<br>$$</p>
<ul>
<li>second为从服务器掉线以后重新连上主服务器所需的平均时间（以秒计算）</li>
<li>write_size_per_second为主服务器平均每秒产生的写命令数据量大小</li>
</ul>
<blockquote>
<p>环形缓冲区的大小不能低于平均掉线时间*主服务器平均每秒产生的数据量，要不然会频繁bgsave影响主进程，开销大</p>
<p>举个例子，如果主服务器平均每秒产生 1 MB 的写命令，而从服务器断线之后平均要 5 秒才能重新连接主服务器。</p>
<p>那么 repl_backlog_buffer 大小就不能低于 5 MB，否则新写地命令就会覆盖旧数据了。</p>
<p>当然，为了应对一些突发的情况，可以将 repl_backlog_buffer 的大小设置为此基础上的 2 倍，也就是 10 MB。</p>
<p>关于 repl_backlog_buffer 大小修改的方法，只需要修改配置文件里下面这个参数项的值就可以。 repl-backlog-size 1mb</p>
</blockquote>
<h1 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h1><p>在 Redis 的主从架构中，由于主从模式是读写分离的，如果主节点（master）挂了，那么将没有主节点来服务客户端的写操作请求，也没有主节点给从节点（slave）进行数据同步了。<br><img src="/../img/Redis/img_17.png"><br>这时如果要恢复服务的话，需要人工介入，选择一个「从节点」切换为「主节点」，然后让其他从节点指向新的主节点，同时还需要通知上游那些连接 Redis 主节点的客户端，将其配置中的主节点 IP 地址更新为「新主节点」的 IP 地址。</p>
<p>这样也不太“智能”了，要是有一个节点能监控「主节点」的状态，当发现主节点挂了，它自动将一个「从节点」切换为「主节点」的话，那么可以节省我们很多事情啊！</p>
<p>Redis 在 2.8 版本以后提供的<strong>哨兵（Sentinel）机制</strong>，它的作用是实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端</p>
<h2 id="哨兵的功能"><a href="#哨兵的功能" class="headerlink" title="哨兵的功能"></a>哨兵的功能</h2><ul>
<li>监控：Sentinel会定期检查master和slave是否按照预期工作（通过心跳机制）</li>
<li>自动故障恢复：如果master故障，就选举出一个slave作为新的master，然后进行主节点故障迁移</li>
<li>通知：当发生故障转移时，会将最新信息发送给Redis客户端 <img src="/../img/Redis/img_18.png"></li>
</ul>
<h2 id="服务状态监控"><a href="#服务状态监控" class="headerlink" title="服务状态监控"></a>服务状态监控</h2><blockquote>
<p>Sentinel基于心跳机制ping-pong，每隔1秒向每个集群内的实例发送ping。</p>
<ul>
<li>主观下线：如果某sentinel节点发现实例没有在规定时间内响应，那就标记成<strong>主观下线</strong>，这个规定的时间是配置项down-after-milliseconds 参数设定的，单位是毫秒。</li>
<li>客观下线：有的时候主节点其实并没有发生故障，只是因为网络拥塞，导致没有在规定时间响应Ping。为了减少误判的情况，哨兵不会之配置成一个节点（至少有三台机器来部署哨兵集群）如果超过指定数量（quorum）的哨兵认为该实例主观下线，那么该节点就是<strong>客观下线</strong>，那就被认为是故障。</li>
</ul>
</blockquote>
<p>哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。</p>
<p>如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「主观下线」。这个「规定的时间」是配置项 down-after-milliseconds 参数设定的，单位是毫秒。</p>
<p>之所以针对「主节点」设计「主观下线」和「客观下线」两个状态，是因为有可能「主节点」其实并没有故障，可能只是因为主节点的系统压力比较大或者网络发送了拥塞，导致主节点没有在规定时间内响应哨兵的 PING 命令。</p>
<p>所以，为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成哨兵集群（最少需要三台机器来部署哨兵集群），通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p>
<p>具体是怎么判定主节点为「客观下线」的呢？</p>
<p>当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。</p>
<p><img src="/../img/Redis/img_19.png"></p>
<p>当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。</p>
<p>例如，现在有 3 个哨兵，quorum 配置的是 2，那么一个哨兵需要 2 张赞成票，就可以标记主节点为“客观下线”了。这 2 张赞成票包括哨兵自己的一张赞成票和另外两个哨兵的赞成票（<strong>包括自己的一票</strong>）。</p>
<p>PS：quorum 的值一般设置为哨兵个数的二分之一加 1，例如 3 个哨兵就设置 2。</p>
<p>哨兵判断完主节点客观下线后，哨兵就要开始在多个「从节点」中，选出一个从节点来做新主节点</p>
<h2 id="由哪个哨兵进行主从故障转移？"><a href="#由哪个哨兵进行主从故障转移？" class="headerlink" title="由哪个哨兵进行主从故障转移？"></a>由哪个哨兵进行主从故障转移？</h2><blockquote>
<p>假设刚刚在哨兵的内部已经将主节点标记成了<strong>客观下线</strong>，那么哨兵集群哪个节点来对其进行故障转移呢？</p>
<p>这个时候需要选举一个哨兵集群的leader来进行故障转移，但是在投票之前肯定需要一个<strong>候选者</strong>，这个候选者一般是首先发现主节点的哨兵。</p>
<p>那么怎么样成为leader呢，哨兵集群需要进行投票，每个哨兵只有一次投票机会，只有候选者能够投给自己（一般也只有一个候选者，除非出现同一时间点有两个哨兵发现了主节点故障发起主观下线）</p>
<p>在投票过程中，只要候选者达到以下条件就可以变成leader：</p>
<ul>
<li>第一，拿到半数以上的赞成票</li>
<li>第二，票数还要同时大于等于quorum 值</li>
</ul>
</blockquote>
<p><strong>如果某个时间点，刚好有两个哨兵节点判断到主节点为客观下线，那这时不就有两个候选者了？这时该如何决定谁是 Leader 呢？</strong></p>
<p>每位候选者都会先给自己投一票，然后向其他哨兵发起投票请求。如果投票者先收到「候选者 A」的投票请求，就会先投票给它，如果投票者用完投票机会后，收到「候选者 B」的投票请求后，就会拒绝投票。这时，候选者 A 先满足了上面的那两个条件，所以「候选者 A」就会被选举为 Leader。</p>
<p><strong>Redis 1 主 4 从，5 个哨兵，quorum 设置为 3，如果 2 个哨兵故障，当主节点宕机时，哨兵能否判断主节点“客观下线”？主从能否自动切换？</strong></p>
<ul>
<li><p>哨兵集群可以判定主节点“客观下线”。哨兵集群还剩下 3 个哨兵，当一个哨兵判断主节点“主观下线”后，询问另外 2 个哨兵后，有可能能拿到 3 张赞同票，这时就达到了 quorum 的值，因此，哨兵集群可以判定主节点为“客观下线”。</p>
</li>
<li><p>哨兵集群可以完成主从切换。当有个哨兵标记主节点为「客观下线」后，就会进行选举 Leader 的过程，因为此时哨兵集群还剩下 3 个哨兵，那么还是可以拿到半数以上（5&#x2F;2+1&#x3D;3）的票，而且也达到了 quorum 值，满足了选举 Leader 的两个条件，所以就能选举成功，因此哨兵集群可以完成主从切换。</p>
</li>
</ul>
<p>如果 quorum 设置为 2，并且如果有 3 个哨兵故障的话。此时哨兵集群还是可以判定主节点为“客观下线”，但是哨兵不能完成主从切换了，大家可以自己推演下。</p>
<p>如果 quorum 设置为 3，并且如果有 3 个哨兵故障的话，哨兵集群即不能判定主节点为“客观下线”，也不能完成主从切换了。</p>
<p>可以看到，quorum 为 2 的时候，并且如果有 3 个哨兵故障的话，虽然可以判定主节点为“客观下线”，但是不能完成主从切换，这样感觉「判定主节点为客观下线」这件事情白做了一样，既然这样，还不如不要做，quorum 为 3 的时候，就可以避免这种无用功。</p>
<p><strong>所以，quorum 的值建议设置为哨兵个数的二分之一加 1，例如 3 个哨兵就设置 2，5 个哨兵设置为 3，而且哨兵节点的数量应该是奇数。</strong></p>
<h2 id="主从故障转移的过程"><a href="#主从故障转移的过程" class="headerlink" title="主从故障转移的过程"></a>主从故障转移的过程</h2><blockquote>
<p>主从故障转移操作包含以下四个步骤： </p>
<ul>
<li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。</li>
<li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li>
<li>第三步：将新主节点的 IP 地址和信息，通过「发布者&#x2F;订阅者机制」通知给客户端； </li>
<li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点</li>
</ul>
</blockquote>
<h3 id="步骤一：选出新节点"><a href="#步骤一：选出新节点" class="headerlink" title="步骤一：选出新节点"></a>步骤一：选出新节点</h3><p>故障转移操作第一步要做的就是在已下线主节点属下的所有「从节点」中，挑选出一个状态良好、数据完整的从节点，然后向这个「从节点」发送 SLAVEOF no one 命令，将这个「从节点」转换为「主节点」。</p>
<p>那么多「从节点」，到底选择哪个从节点作为新主节点的？</p>
<p>随机的方式好吗？随机的方式，实现起来很简单，但是如果选到一个网络状态不好的从节点作为新主节点，那么可能在将来不久又要做一次主从故障迁移。</p>
<p>所以，我们首先要把网络状态不好的从节点给过滤掉。首先把已经下线的从节点过滤掉，然后把以往网络连接状态不好的从节点也给过滤掉。</p>
<p>怎么判断从节点之前的网络连接状态不好呢？</p>
<p>Redis 有个叫 down-after-milliseconds * 10 配置项，其 down-after-milliseconds 是主从节点断连的最大连接超时时间。如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从节点的网络状况不好，不适合作为新主节点。</p>
<p>至此，我们就把网络状态不好的从节点过滤掉了，接下来要对所有从节点进行三轮考察：<strong>优先级、复制进度、ID 号</strong>。在进行每一轮考察的时候，哪个从节点优先胜出，就选择其作为新主节点。</p>
<ol>
<li>第一轮考察：哨兵首先会根据从节点的优先级来进行排序，优先级越小排名越靠前， </li>
<li>第二轮考察：如果优先级相同，则查看复制的下标，哪个从「主节点」接收的复制数据多，哪个就靠前（也就是offset更靠近主节点那个）</li>
<li>第三轮考察：如果优先级和下标都相同，就选择从节点 ID 较小的那个。</li>
</ol>
<p><img src="/../img/Redis/img_20.png"></p>
<h3 id="步骤二：将从节点指向主节点"><a href="#步骤二：将从节点指向主节点" class="headerlink" title="步骤二：将从节点指向主节点"></a>步骤二：将从节点指向主节点</h3><p>当新主节点出现之后，哨兵 leader 下一步要做的就是，让已下线主节点属下的所有「从节点」指向「新主节点」，这一动作可以通过向「从节点」发送 SLAVEOF 命令来实现。</p>
<p>如下图，哨兵 leader 向所有从节点（server3 和 server4）发送 SLAVEOF ，让它们成为新主节点的从节点。</p>
<p><img src="/../img/Redis/img_21.png"></p>
<p><img src="/../img/Redis/img_22.png"></p>
<h3 id="步骤三：通知客户的主节点已更换"><a href="#步骤三：通知客户的主节点已更换" class="headerlink" title="步骤三：通知客户的主节点已更换"></a>步骤三：通知客户的主节点已更换</h3><p>经过前面一系列的操作后，哨兵集群终于完成主从切换的工作，那么新主节点的信息要如何通知给客户端呢？</p>
<p>这主要通过 Redis 的发布者&#x2F;订阅者机制来实现的。每个哨兵节点提供发布者&#x2F;订阅者机制，客户端可以从哨兵订阅消息。</p>
<blockquote>
<p>类似kafka那种订阅机制，也可以想象成计网的那种广播信道，每个哨兵进行广播，客户端接受相应表头的时间，完成通知</p>
</blockquote>
<p>哨兵提供的消息订阅频道有很多，不同频道包含了主从节点切换过程中的不同关键事件，几个常见的事件如下：<br><img src="/../img/Redis/img_23.png"></p>
<p>客户端和哨兵建立连接后，客户端会订阅哨兵提供的频道。主从切换完成后，哨兵就会向 +switch-master 频道发布新主节点的 IP 地址和端口的消息，这个时候客户端就可以收到这条信息，然后用这里面的新主节点的 IP 地址和端口进行通信了。</p>
<p>通过发布者&#x2F;订阅者机制机制，有了这些事件通知，客户端不仅可以在主从切换后得到新主节点的连接信息，还可以监控到主从节点切换过程中发生的各个重要事件。这样，客户端就可以知道主从切换进行到哪一步了，有助于了解切换进度。</p>
<h3 id="步骤四：将旧主节点变为从节点"><a href="#步骤四：将旧主节点变为从节点" class="headerlink" title="步骤四：将旧主节点变为从节点"></a>步骤四：将旧主节点变为从节点</h3><p>故障转移操作最后要做的是，继续监视旧主节点，当旧主节点重新上线时，哨兵集群就会向它发送 SLAVEOF 命令，让它成为新主节点的从节点</p>
<p>至此，整个主从节点的故障转移的工作结束</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/01/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E7%AF%87/">redis-持久化篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-01
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>Redis 是<strong>内存数据库</strong>，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了**持久化功能 **!</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是定期把内存所有数据都记录到磁盘中。</p>
<p>一旦Redis实例出现故障重启，就会从磁盘中读取快照文件，恢复数据</p>
<blockquote>
<p>什么是快照？可以理解成定期给当前的内存中的redis数据拍一张照，然后保存下来。</p>
</blockquote>
<h3 id="RDB触发机制"><a href="#RDB触发机制" class="headerlink" title="RDB触发机制"></a>RDB触发机制</h3><p>  可以分为手动触发和自动触发，手动的save占用主进程，bgsave是fork一个新进程来完成快照保存，在此期间主进程通过copyonwrite的机制（类似copyonwrite的Arraylist那样），拷贝一份当前数据，在拷贝的地方进行修改，等到子进程完成磁盘写之后再进行覆盖。</p>
<p>  自动触发写在redis.conf上，save X Y，表示在X秒内如果有Y个key修改，那么就save（注意这里触发的还是bgsave）<br><img src="/../img/Redis/img_7.png"></p>
<ul>
<li>手动触发<br><img src="/../img/Redis/img_6.png"><br>用bgsave可以防止主进程被阻塞，提高效率</li>
</ul>
<p>fork采用的是copy-on-write</p>
<ul>
<li>当主进程执行读操作的时候可以访问共享内存</li>
<li>当主进程执行写操作的时候，则会拷贝一份数据</li>
</ul>
<p><img src="/../img/Redis/img_9.png"></p>
<blockquote>
<p>子进程和主线程怎么共享内存，也就是怎么让子进程知道redis的内存是那些块？通过拷贝主进程的页表（没错就是计组那个页表），这样就知道主进程占用的虚拟地址和物理地址的映射关系，从而找到这些块。</p>
<p>copyonwrite会将此时的共享内存变成<strong>只读</strong>，主进程来读的时候就可以直接读，写的时候拷贝一份。</p>
</blockquote>
<ul>
<li>自动触发<br><img src="/../img/Redis/img_8.png"><blockquote>
<p>注意这里save其实也是bgsave，一般都不会影响主进程</p>
</blockquote>
</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li>只有一个dump.rdb，方便持久化，是一个紧凑的二进制文件，恢复的时候速度也比AOF更快，在数据量大的时候更明显。</li>
<li>实现了性能的最大化，fork子进程来完成而不影响主进程，保证了Redis的高性能。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>可能存在数据丢失，在两次RDB的时间里，如果出现宕机，这段时间没有写入的数据都将丢失</li>
<li>没有办法做到秒级持久化&#x2F;实时持久化</li>
<li>对于cpu和内存的开销比较大，毕竟要fork一个新进程占用cpu，还要进行COW占用内存而，AOF主要占用的是IO资源</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>可以容忍数分钟数据丢失，追求更快的启动速度和恢复速度。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF（append only file） 持久化，采用日志的形式来记录每个写操作，追加到AOF文件的末尾。</p>
<blockquote>
<p>意思就是把操作的每一条语句都记录下来，那肯定占用的空间大</p>
</blockquote>
<p>Redis默认情况是不开启AOF的。重启时再重新执行AOF文件中的命令来恢复数据。它主要解决数据持久化的实时性问题。</p>
<p><img src="/../img/Redis/img_10.png"></p>
<p>AOF是<strong>执行完命令后才记录日志</strong>的。为什么不先记录日志再执行命令呢？这是因为Redis在向AOF记录日志时，不会先对这些命令进行语法检查，如果先记录日志再执行命令，日志中可能记录了错误的命令，Redis使用日志回复数据时，可能会出错。</p>
<p>正是因为执行完命令后才记录日志，所以不会阻塞当前的写操作。但是会存在两个风险：</p>
<ul>
<li>更执行完命令还没记录日志时，宕机了会导致数据丢失</li>
<li>AOF不会阻塞当前命令，但是可能会阻塞下一个操作。</li>
</ul>
<blockquote>
<p>这两个风险最好的解决方案是折中妙用AOF机制的三种写回策略 appendfsync：</p>
<ul>
<li>always，同步写回，每个子命令执行完，都立即将日志写回磁盘。</li>
<li>everysec，每个命令执行完，只是先把日志写到AOF内存缓冲区，每隔一秒同步到磁盘。</li>
<li>no：只是先把日志写到AOF内存缓冲区，有操作系统去决定何时写入磁盘。</li>
</ul>
</blockquote>
<p><img src="/../img/Redis/img_11.png"></p>
<p>always同步写回，可以基本保证数据不丢失，no策略则性能高但是数据可能会丢失，一般可以考虑折中选择everysec。</p>
<p>如果接受的命令越来越多，AOF文件也会越来越大，文件过大还是会带来性能问题。日志文件过大怎么办呢？</p>
<blockquote>
<p><strong>AOF重写机制</strong>就是随着时间推移，AOF文件会有一些冗余的命令如：无效命令、过期数据的命令等等，AOF重写机制就是把它们合并为一个命令（类似批处理命令），从而达到精简压缩空间的目的。</p>
<p>AOF重写会阻塞嘛？AOF日志是由主线程会写的，而重写则不一样，重写过程是由后台子进程bgrewriteaof完成。</p>
</blockquote>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li>实时持久化，数据安全，AOF持久化配置为always就可以基本上避免丢失，但是开销比较大，通常用容忍1s内丢失的everysec</li>
<li>通过append模式写文件，那么即使中途服务器宕机，也可以尽量解决一致性问题（取决于刷盘策略）</li>
<li>重写机制，在文件太大的时候可以压缩空间</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>文件比RDB大，恢复时间也会慢很多</li>
<li>启动效率低</li>
<li>文件体积迅速变大，需要定期执行重写机制降低文件体积。</li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>对数据安全性有较高需求的场景</li>
</ul>
<blockquote>
<p>Redis4.0开始支持RDB和AOF的混合持久化，就是内存快照以一定频率执行，两次快照之间，再使用AOF记录这期间的所有命令操作。</p>
</blockquote>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/03/31/redis-%E7%BC%93%E5%AD%98%E4%B8%89%E5%85%84%E5%BC%9F/">redis-缓存三兄弟</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-03-31
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><blockquote>
<p>这里的redis可以全部想象成cache，数据库可以想象成cpu，穿透有点绕过redis的意思</p>
</blockquote>
<p><img src="/../img/Redis/img.png"><br>假设有一个请求api&#x2F;news&#x2F;getById&#x2F;1，但是这个id为1的键并<strong>不存在</strong>于数据库，所以也不会存在于缓存，那么如果有很多这种请求，那么都会绕过redis去查询数据库，造成数据库的负载。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li>缓存空数据，就算是数据库找不到也要缓存一个空数据给redis，要不然就会一直会去绕过redis去找数据库。比如给的key&#x3D;1但是mysql没有相应数据，那么在redis上缓存一个key&#x3D;1，value&#x3D;null的键值对。</li>
</ol>
<ul>
<li><strong>优点</strong>：非常简单，维护方便</li>
<li><strong>缺点</strong>：会造成额外的内存消耗，因为redis是存在内存中的，有多少个没有的键就会有多少个空，浪费内存。还可能造成<strong>短期不一致</strong>问题，如果在redis里面存了这个空但是这个时候数据库更新了这个键值对，那么在这一段时间访问redis的还是null，就会造成不一致的问题</li>
</ul>
<ol start="2">
<li>布隆过滤器<br>在客户端与Redis之间加了一个布隆过滤器，对于请求进行过滤。</li>
</ol>
<p><img src="/../img/Redis/img_1.png"></p>
<blockquote>
<p><strong>布隆过滤器</strong></p>
<ul>
<li>bitmap（位图）:bit位的数组，数组的元素是0或者1，所以布隆过滤器占用的内存小</li>
<li><img src="/../img/Redis/img_2.png"></li>
<li>作用：可以用来检索元素，相当于一种校验电路</li>
<li>实现原理：类似hashmap，假设来了一个键，用三种不同的hash算法得到位图的三个位置，然后这些位置都置为1，这里要跟redis缓存的保持一致，在初始化的时候就要预热进布隆过滤器。那么就会有很多重复的，数组越大这种情况会越少。那么此时有一个<strong>确实不存在的元素</strong>，但是计算出来的三个哈希值就是都是1，那么还是会发生缓存穿透的现象</li>
<li>判断不存在的时候一定不存在，也就是说3个地方一定都不为1</li>
<li>判断存在的时候不一定存在，因为有可能会有误判</li>
<li><strong>优点</strong>：内存占用小，没有多余key</li>
<li><strong>缺点</strong>：实现比较复杂，存在误判，大概在5%左右，但是对于数据库也是可以接受的</li>
</ul>
</blockquote>
<p>布隆过滤器的大致的原理：布隆过滤器中存放二进制位。数据库的数据通过hash算法计算其hash值并存放到布隆过滤器中，之后判断数据是否存在的时候，就是判断该hash值是0还是1。</p>
<p>但是这个玩意是一种概率上的统计，当其判断不存在的时候就一定是不存在；当其判断存在的时候就不一定存在。所以有一定的穿透风险！！！</p>
<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>缓存击穿，指的是一个key在不断地支撑高并发，高并发持续对这个点进行访问，当这个点在失效的瞬间，50ms左右，大量的高并发就冲坡缓存请求数据库，造成数据库瘫痪。</p>
<p>对于一般的网站而言很难有缓存击穿的级别，一般是热门网站或者秒杀瞬时高并发。</p>
<h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li>互斥锁</li>
</ol>
<p><img src="/../img/Redis/img_3.png"></p>
<p>类似pv操作，给临界区上互斥锁，一段时间只要一个线程在重建数据就行，但是这样会造成其他线程等待。通常是需要强一致性的应用需要这种策略。</p>
<ul>
<li><strong>优点</strong>：强一致性，在redis没有更新完之前都不许访问，只能要最新的，一般涉及钱的都会有这种逻辑</li>
<li><strong>缺点</strong>：性能差</li>
</ul>
<ol start="2">
<li>逻辑过期</li>
</ol>
<p><img src="/../img/Redis/img_4.png"></p>
<p>逻辑过期就是在一个键值对的最后加上逻辑时间，并不真实设置过期时间。也就是说，不会真正的过期只会逻辑上的过期。</p>
<p>当一个线程去访问一个逻辑时间到了的键值对，那么其实redis也还有这部分，他还是<strong>那这部分旧的数据</strong>，但是会开启一个新的线程来完成数据库到mysql的更新</p>
<ul>
<li><strong>优点</strong>：可用性强，性能强在不注重强一致性的场景，不会有其他线程等待的情况，但是拿的都是旧数据</li>
<li><strong>缺点</strong>：一致性弱</li>
</ul>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>如果缓存集中在一段时间内过期，那么会有大量的缓存穿透，所有的查询都落在数据库上，造成缓存雪崩</p>
<blockquote>
<p>缓存雪崩和缓存击穿的区别：缓存击穿是针对某一个key，缓存雪崩是针对很多key集中过期，</p>
</blockquote>
<p><img src="/../img/Redis/img_5.png"></p>
<h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><ol>
<li>给不同的key的TTL添加随机值</li>
<li>多个redis集群提高服务的可用性</li>
</ol>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/03/31/%E5%91%A8%E8%B5%9B2024-3-31/">周赛2024-3-31</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-03-31
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>因为第三题long被卡了三发wa，所以即使做出了第三题也没上次排名高</p>
</blockquote>
<h1 id="第一题：哈沙德数"><a href="#第一题：哈沙德数" class="headerlink" title="第一题：哈沙德数"></a>第一题：哈沙德数</h1><p>如果一个整数能够被其各个数位上的数字之和整除，则称之为 <strong>哈沙德数</strong>（Harshad number）。给你一个整数 x 。如果 x 是 <strong>哈沙德数</strong> ，则返回 x 各个数位上的数字之和，否则，返回 -1 。</p>
<blockquote>
<p>字符串拆分成数组，然后累计和，最后做个判断</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfTheDigitsOfHarshadNumber</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>+x;</span><br><span class="line">        String[] split = num.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(split));</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; split.length; i++) &#123;</span><br><span class="line">            ans+=Integer.parseInt(split[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x % ans ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第二题：换水问题"><a href="#第二题：换水问题" class="headerlink" title="第二题：换水问题"></a>第二题：换水问题</h1><p>给你两个整数 numBottles 和 numExchange 。</p>
<p>numBottles 代表你最初拥有的满水瓶数量。在一次操作中，你可以执行以下操作之一：</p>
<ul>
<li>喝掉任意数量的满水瓶，使它们变成空水瓶。</li>
<li>用 numExchange 个空水瓶交换一个满水瓶。然后，将 numExchange 的值增加 1 。<br>注意，你不能使用相同的 numExchange 值交换多批空水瓶。例如，如果 numBottles &#x3D;&#x3D; 3 并且 numExchange &#x3D;&#x3D; 1 ，则不能用 3 个空水瓶交换成 3 个满水瓶。</li>
</ul>
<p>返回你 <strong>最多</strong> 可以喝到多少瓶水。</p>
<p><img src="/../img/coding/2024_3_31_2.png"></p>
<blockquote>
<p>小学奥数貌似碰到过这样的问题，就是没兑换一次，兑换的要求就多一瓶，直接暴力模拟就行</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxBottlesDrunk</span><span class="params">(<span class="type">int</span> numBottles, <span class="type">int</span> numExchange)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">empty</span> <span class="operator">=</span> numBottles;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> numBottles;</span><br><span class="line">        <span class="comment">//直到换不了了</span></span><br><span class="line">        <span class="keyword">while</span> (empty &gt;= numExchange)&#123;</span><br><span class="line">            <span class="comment">//兑换新的之后剩下的</span></span><br><span class="line">            empty -=numExchange;</span><br><span class="line">            numExchange++;</span><br><span class="line">            <span class="comment">//兑换多的</span></span><br><span class="line">            empty +=<span class="number">1</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第三题：交替子数组计数"><a href="#第三题：交替子数组计数" class="headerlink" title="第三题：交替子数组计数"></a>第三题：交替子数组计数</h1><p>给你一个<strong>二进制数组</strong>nums 。</p>
<p>如果一个子数组中 <strong>不存在</strong> 两个 <strong>相邻</strong> 元素的值 <strong>相同</strong> 的情况，我们称这样的子数组为 <strong>交替子数组</strong> 。</p>
<p>返回数组 nums 中交替子数组的数量。</p>
<p>示例 1：</p>
<p>输入： nums &#x3D; [0,1,1,1]</p>
<p>输出： 5</p>
<p>解释： 以下子数组是交替子数组：[0] 、[1] 、[1] 、[1] 以及 [0,1] 。</p>
<blockquote>
<p>这里有个用例真的好恶心，wa三次都是这一个用例没过，需要全开long或者long long才能过</p>
</blockquote>
<h2 id="记忆化搜索超出内存限制"><a href="#记忆化搜索超出内存限制" class="headerlink" title="记忆化搜索超出内存限制"></a>记忆化搜索超出内存限制</h2><blockquote>
<p>最早的思路是用一个二维数组存dp[i][j]是否是一个交替子数组，为1表示i到j是一个交替子数组，判断条件$$ dp[i][j-1] &#x3D;&#x3D; 1 &amp;&amp; nums[j] !&#x3D; nums[j-1] $$</p>
<p>其实完全不用这么大的空间，二维数组超空间也是应该的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countAlternatingSubarrays</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//记忆化搜索</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length][nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="comment">//对角线肯定是交替子数组</span></span><br><span class="line">                <span class="keyword">if</span> (i==j)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//只有前面是一个交替子数组并且不等于最后的那个元素</span></span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j-<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; nums[j] != nums[j-<span class="number">1</span>])&#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后再遍历一次数组，每一个1就是一个交替子数组</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    ans+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针-AC"><a href="#双指针-AC" class="headerlink" title="双指针(AC)"></a>双指针(AC)</h2><blockquote>
<p>思路是，如果一个数组是交替数组，那么子数组肯定也是，利用双指针找到尽量最长的交替子数组存起来，最后遍历这些最长的交替子数组。由于他们的子数组肯定也是交替的，那就是等差数列求和就可以算出。最后累加得到答案</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countAlternatingSubarrays</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//恶心的long</span></span><br><span class="line">        List&lt;<span class="type">long</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">rear</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//双指针找到长的数组，存起来他们的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;head,rear&#125;);</span><br><span class="line">                head = i;</span><br><span class="line">            &#125;</span><br><span class="line">            rear++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个没加上就退出循环了，需要最后加上</span></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;head,rear&#125;);</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">length</span> <span class="operator">=</span> list.get(i)[<span class="number">1</span>]-list.get(i)[<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//子数组的数量</span></span><br><span class="line">            ans += length *(length+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度:o(n)<br>空间复杂度：o(n)</p>

    
    
  </div>

  

  

</article>
  
    
  <nav class="pagination">  
      
      <a class="prev" href="/page/3/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text">上一页</span>  
      </a>  
      
      
      <a class="next" href="/page/5/">  
        <span class="next-text">下一页</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  
</section>
        </div>
          

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:1050886654@qq.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/yyf1050886654" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2024      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">Yifan Yang</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    

  







<script type="text/javascript" src="/lib/jquery"></script>



<script type="text/javascript" src="/lib/slideout"></script>



<script type="text/javascript" src="/lib/fancybox"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>