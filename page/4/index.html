<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/default" title="YYF's Blog" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://yyf1050886654.github.io/page/4/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>YYF&#39;s Blog</title>

<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">YYF&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/collect/">
      <li class="mobile-menu-item">
        
        
        收藏              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">YYF's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/collect/">  
              
              
              收藏  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <section id="posts" class="posts">
  
  
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/05/30/redis%E9%A1%B9%E7%9B%AE-%E7%99%BB%E5%BD%95%E9%80%BB%E8%BE%91/">redis项目-登录逻辑</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-05-30
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>毕业设计和各种考试耽搁了快两个月了，突然意识到再不继续学跟我的想法就会越走越远了，遂开始黑马点评的学习</p>
</blockquote>
<h2 id="基于session实现登录"><a href="#基于session实现登录" class="headerlink" title="基于session实现登录"></a>基于session实现登录</h2><p><strong>发送验证码</strong></p>
<p>首先校验手机号，通过正则表达式，然后再随机生成一个长度为6的字符串，保存在session中</p>
<p><strong>登录注册</strong></p>
<p>如果输入的验证码和存在session中的是一样的，那么就通过校验找对应的user实体类，user为空就直接注册（也就是insert），然后将user放在session中</p>
<p><strong>检验登录状态</strong></p>
<p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p>
<p><img src="/../img/hmdp/img.png"></p>
<h3 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码"></a>发送验证码</h3><blockquote>
<p>Todo：后续可以根据Ruoyi那个图片验证码改进，但是逻辑都差不多</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.保存验证码到 session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">    <span class="comment">// 5.发送验证码</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="comment">// 返回ok</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验验证码</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span>(cacheCode == <span class="literal">null</span> || !cacheCode.toString().equals(code))&#123;</span><br><span class="line">         <span class="comment">//3.不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一致，根据手机号查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//不存在，则创建</span></span><br><span class="line">        user =  createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h3><blockquote>
<p>初始版本看session中是否有user对象，如果有就把他放到ThreadLocal中，方便后续调用，为什么不每次都在session中取呢？我猜是因为http的request不是随时随地哪个方法都要写的，threadlocal可以比较方便</p>
</blockquote>
<p>先写登录的拦截器，由于要进行处理，就跟aop一样，有一个pre有一个after，实现的是HandlerInterceptor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2.获取session中的用户</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.不存在，拦截，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser((User)user);</span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个拦截器但是还要让他生效，被springmvc管理，需要一个配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.interceptor.LoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.interceptor.RefreshInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// token刷新的拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebMvcConfigurer配置类其实是Spring内部的一种配置方式，采用JavaBean的形式来代替传统的xml配置文件形式进行针对框架个性化定制，可以自定义一些Handler，Interceptor，ViewResolver，MessageConverter。基于java-based方式的spring mvc配置，需要创建一个配置类并实现WebMvcConfigurer 接口；</p>
<p>常用的方法：</p>
<p><strong>addInterceptors：拦截器</strong></p>
<ul>
<li>addInterceptor：需要一个实现HandlerInterceptor接口的拦截器实例</li>
<li>addPathPatterns：用于设置拦截器的过滤路径规则；addPathPatterns(“&#x2F;**”)对所有请求都拦截</li>
<li>excludePathPatterns：用于设置不需要拦截的过滤规则</li>
<li>拦截器主要用途：进行用户登录状态的拦截，日志的拦截等。</li>
</ul>
<p><strong>addViewControllers：页面跳转</strong></p>
<p>拦截到一个路径就跳转到对应的页面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">    registry.addViewController(<span class="string">&quot;/toLogin&quot;</span>).setViewName(<span class="string">&quot;login&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法意思估计就是当&#x2F;toLogin”路径的时候跳转到login页面</p>
<blockquote>
<p>Todo：以后慢慢补充</p>
</blockquote>
<h2 id="Redis代替session的业务"><a href="#Redis代替session的业务" class="headerlink" title="Redis代替session的业务"></a>Redis代替session的业务</h2><blockquote>
<p>code和user都存在session中，而session是本地的，在集群模式下会失效，所以需要一个全局的解决方案。</p>
</blockquote>
<p>基本的解决思路就是把验证码和user都存在redis里面，设定过期时间，拦截器变成续期即可。有一个问题就是以什么数据结构来存。code可以以string类型来存储。<br>user其实也可以，我这里原本想的是用JSON存，但是不够直观，而且存储效率也没有hash好，所以还是跟着他用了hash。</p>
<p><img src="/../img/hmdp/img_1.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//这里用Redis完成</span></span><br><span class="line">        <span class="comment">//session.setAttribute(&quot;code&quot;,code);</span></span><br><span class="line">        redisTemplate.opsForValue().set(redisConstants.LOGINREDISCODE + phone,code, <span class="number">60</span>,TimeUnit.SECONDS);</span><br><span class="line">        log.debug(<span class="string">&quot;验证码为：&quot;</span>+code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(loginForm.getPhone())||RegexUtils.isCodeInvalid(loginForm.getCode()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里改用Redis</span></span><br><span class="line">        <span class="comment">//String sessionCode = session.getAttribute(&quot;code&quot;).toString();</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> redisTemplate.opsForValue().get(redisConstants.LOGINREDISCODE + loginForm.getPhone());</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="literal">null</span> || !loginForm.getCode().equals(code))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.eq(User::getPhone,loginForm.getPhone());</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getOne(lambdaQueryWrapper);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            temp.setPhone(loginForm.getPhone());</span><br><span class="line">            save(temp);</span><br><span class="line">            user = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID(<span class="literal">true</span>).toString();</span><br><span class="line">        <span class="comment">//用json存储</span></span><br><span class="line">        <span class="comment">//String jsonStr = JSONUtil.toJsonStr(user);</span></span><br><span class="line">        <span class="comment">//用hash存储</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">        Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                CopyOptions.create()</span><br><span class="line">                        .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                        .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForHash().putAll(redisConstants.LOGINUSER+token,userMap);</span><br><span class="line">        redisTemplate.expire(redisConstants.LOGINUSER,<span class="number">30</span>,TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主要就是用了redisTemplate的两种方法，string类型的就用opsForValue，hash用opsForHash，值得注意的是这里putAll是将一个map全部存进去，只有两个参数，而put可能指的是<strong>在这个key下的map中的其中一行</strong>，也就是说有三个参数，key，name和value。</p>
<p>这里的beanToMap主要记住setFieldValueEditor是编辑域的，那当然有两个参数，修改对应fieldName下的fieldValue</p>
<p>还有一个是setFieldNameEditor编辑name的，比如你想让name变成大写，就用UpperCase</p>
</blockquote>
<h2 id="解决登录刷新问题"><a href="#解决登录刷新问题" class="headerlink" title="解决登录刷新问题"></a>解决登录刷新问题</h2><blockquote>
<p>我们之前的拦截器会排除一些路径进行刷新，但是我们要这些路径被访问的时候也要刷新，所以选择了连个拦截器的方案，其中第一个完成所有redis的续期，后面一个延续拦截指定路径校验登录状态。</p>
</blockquote>
<p><img src="/../img/hmdp/img_2.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.检验是否有token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span> || token.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//1.1 如果没有token直接放行给下一个拦截器，这样肯定会被拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.检验是否在redis中</span></span><br><span class="line">        <span class="comment">//entries得到的是一个map，get查具体的，所以有两个参数key和fieldName</span></span><br><span class="line">        Map&lt;Object, Object&gt; objectMap = stringRedisTemplate.opsForHash().entries(redisConstants.LOGINUSER + token);</span><br><span class="line">        <span class="keyword">if</span> (objectMap.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">dto</span> <span class="operator">=</span> BeanUtil.mapToBean(objectMap, UserDTO.class, CopyOptions.create());</span><br><span class="line">        <span class="comment">//3.保存在threadLocal中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//UserDTO userDTO = BeanUtil.fillBeanWithMap(objectMap, new UserDTO(), false);</span></span><br><span class="line">        log.debug(dto.toString());</span><br><span class="line">        UserHolder.saveUser(dto);</span><br><span class="line">        <span class="comment">//4.刷新时间</span></span><br><span class="line">        stringRedisTemplate.expire(redisConstants.LOGINUSER + token,<span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;当前用户:&quot;</span>+user.getNickName());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/08/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%8A%EF%BC%89/">java-虚拟机（上）</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-08
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h1><p>按照大的来分可以分为三部分：</p>
<ol>
<li>类加载器，由于java是纯面向对象语言，类加载器会把java类转换成成字节码</li>
<li>运行时数据区（内存分区）：再细分可以分为共享的方法区和堆，线程不共享的虚拟机栈和本地方法栈，还有每个线程的指针</li>
<li>执行引擎：将中间代码转换成机器指令（x86，arm等）</li>
<li>本地库接口</li>
</ol>
<h1 id="运行时数据区详细介绍"><a href="#运行时数据区详细介绍" class="headerlink" title="运行时数据区详细介绍"></a>运行时数据区详细介绍</h1><ul>
<li>堆（线程共享）</li>
<li>方法区（线程共享）</li>
<li>程序计数器（线程独占）</li>
<li>虚拟机栈（线程独占）</li>
<li>本地方法栈（线程独占）</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>就如同cpu中的pc，虚拟机中也有对应代码的pc，为了实现并发，每一个线程程序运行到哪里都不一样，也就需要保存，恢复上下文也方便。所以在jvm中程序计数器是私有的。</p>
<p>注意：pc是唯一一个不会发生OOM的内存区域，估计是因为本来就放一个指针，再怎么样也超不出去。生存周期，随着线程的创建而创建，随着线程死亡而死亡。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>这里的虚拟机栈跟真实的用c语言编译的栈类似，都是存函数调用的，有返回地址，局部变量，操作数，这里还有一个<strong>动态链接</strong></p>
<ul>
<li>局部变量表：主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</li>
<li>操作数栈：主要是作为方法调用的中间站，比如addi a,b,a（估计不是这么写的，反正就是a+b计算出来的值再赋给a），存放的那个临时变量就a+b就放在操作数栈</li>
<li>动态链接：运行到一定位置的时候可能会需要调用其他的类或者方法，这个时候就要把<strong>符号引用转换为调用方法的直接引用</strong>，因为再编译的时候都是用的常量池，在常量池引用的，一层套一层，这个时候就要把最核心的那个函数给拿出来，变成直接引用<br>虚拟机栈超出会报错的，栈帧数量不能多于一个值。比如无限递归，最后报错报的是栈溢出，而不是堆溢出，因为在爆堆之前就已经爆栈</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>这个跟虚拟机栈很像，但是虚拟机栈是为了java语句服务的，本地方法栈是使用到的本地native方法服务</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><blockquote>
<p>注意，我们在这里说的这五个其实是逻辑部分，就好像计算机组成原理中那五个部分一样，但是实际cpu又是控制器和运算器组合的。</p>
<p>这里也是类似，可以理解为这是jvm的逻辑设计图，具体实现的比如jdk1.7的持久代和1.8的元空间，其实也只是方法区的一个实现罢了</p>
</blockquote>
<h2 id="持久代和元空间"><a href="#持久代和元空间" class="headerlink" title="持久代和元空间"></a>持久代和元空间</h2><p>最大的一块，jdk1.7主要是三块，新生代，老年代和持久代，1.8把持久代取消了，取而代之的是元空间</p>
<p>个人理解，本来在堆中就完成了方法区的设计，在持久区放静态变量，代码块和编译好的代码，但是由于可能会出现oom，以及越来越多的动态类，时的很容易爆堆，这个时候不如把它提出虚拟机吧！放在实际内存下面，这样就有更广阔的空间给你爆了。</p>
<p>于是元空间这个概念就出来了，但是也不是无限扩大，有大小限制的</p>
<p><strong>为什么使用元空间？</strong></p>
<ul>
<li>1）由于 PermGen 内存经常会溢出，引发OutOfMemoryError，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM。</li>
<li>2）移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</li>
<li>3）减轻gc的负担，放在外面的元空间可以不用gc</li>
</ul>
<p>准确来说，Perm 区中的字符串常量池被移到了堆内存中是在 Java7 之后，Java 8 时，PermGen 被元空间代替，其他内容比如<strong>类元信息、字段、静态属性、方法、常量</strong>等都移动到元空间区。比如 java&#x2F;lang&#x2F;Object 类元信息、静态属性 System.out、整型常量等。</p>
<p>元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p>
<h2 id="新生代和老年代"><a href="#新生代和老年代" class="headerlink" title="新生代和老年代"></a>新生代和老年代</h2><ul>
<li>年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到老年代区间。</li>
<li>老年代主要保存生命周期长的对象，一般是一些老的对象</li>
</ul>
<p>这就涉及到后面的垃圾回收算法了</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>一般来存静态变量，常量以及编译好的代码</p>
<blockquote>
<p>这里要注意，既然方法区里面有常量，那也会有运行时常量池。这里要区分<strong>字符串常量池</strong>，jdk1.7之前，字符串常量池是跟持久代放在一起的，是持久代的一个组成部分，1.7之后，字符串常量池就放在堆空间里了，也就是说提出来了，直到现在也还是在堆空间</p>
<p><strong>为什么？</strong></p>
<p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>
<p>而运行时常量池是放在方法区的，也就是元空间</p>
</blockquote>
<h1 id="类加载器与双亲委派模型"><a href="#类加载器与双亲委派模型" class="headerlink" title="类加载器与双亲委派模型"></a>类加载器与双亲委派模型</h1><blockquote>
<p>这里的加载有点像dns的递归查找</p>
</blockquote>
<ul>
<li>bootstrapClassLoader：根加载器，每个都会从它开始</li>
<li>ExtClassLoader：扩展功能的一些jar包里面的类</li>
<li>AppClassLoader：应用类加载器</li>
<li>自定义，可以重写方法</li>
</ul>
<p><strong>双亲委派模型</strong></p>
<p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就返回成功；只有父类加载器无法完成此加载任务时，才由下一级去加载。 </p>
<p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现两个不同的 Object 类。双亲委派模型可以保证加载的是 JRE 里的那个 Object 类，而不是你写的 Object 类。这是因为 AppClassLoader 在加载你的 Object 类时，会委托给 ExtClassLoader 去加载，而 ExtClassLoader 又会委托给 BootstrapClassLoader，BootstrapClassLoader 发现自己已经加载过了 Object 类，会直接返回，不会去加载你写的 Object 类</p>
<p>好处：</p>
<ul>
<li>防止核心库被篡改</li>
<li>不重复加载类</li>
</ul>
<h1 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h1><p>tomcat，重写了loadClass方法</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/07/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%AD/">java-多线程-ThreadLocal和线程池</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-07
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</p>
<p>JDK 中自带的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<p>再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="/../img/Java/img_5.png"></p>
<p>其实不是ThreadLocal有这个数据结构，是Thread持有的，有一个ThreadLocalMap的数组，专门放键值对，K为ThreadLocal的类对象，V为ThreadLocal泛型的数据。</p>
<p>也就是说，在一个线程中，如果有多个ThreadLocal，查找Map键为这个ThreadLocal变量，就可以很轻松拿到存的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h2><p>这个Map里面，Key是弱引用的，也就是说每次gc都会回收key，而value是强引用的。这个时候就会出现，key被gc回收了为null，value还有的情况。这个时候就会产生内存泄露。</p>
<p>解决方法：释放的时候手动remove。</p>
<h1 id="线程池的四个种类"><a href="#线程池的四个种类" class="headerlink" title="线程池的四个种类"></a>线程池的四个种类</h1><ol>
<li>newCachedThreadPool创建一个可缓存的线程池，默认阻塞队列是SynchronousQueue</li>
<li>newFixedThreadPool创建一个定长的线程池，默认阻塞队列是LinkedBlockingQueue</li>
<li>newSingleThreadExecutor创建一个单例线程，默认也是LinkedBlockingQueue</li>
<li>newScheduled创建一个可以设置定时任务的线程</li>
</ol>
<h1 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h1><p>除了上面四种封装好的，还可以自己创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                           )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>七个核心参数：</p>
<ol>
<li>核心线程数量</li>
<li>最大线程数量</li>
<li>过期时间：如果线程池的线程数量大于核心线程数量，如果没有新的任务提交，那么已经到期的线程不会立刻销毁，而是等一段时间销毁</li>
<li>过期时间单位：可以是秒，毫秒</li>
<li>阻塞队列：刚刚提的那些，后面还会说</li>
<li>饱和缩略</li>
<li>线程工厂类：一般都是默认的，可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li>
</ol>
<h1 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h1><p>当阻塞队列满了，而且最大线程数量也满了，就会触发饱和策略</p>
<ol>
<li>抛出异常，不让加了</li>
<li>线程不走线程池，提交线程的那个线程自己来运行</li>
<li>不报错，直接丢弃</li>
<li>丢弃队列最前面那个，然后加进队列</li>
</ol>
<h1 id="如何确定线程数量"><a href="#如何确定线程数量" class="headerlink" title="如何确定线程数量"></a>如何确定线程数量</h1><ul>
<li>io密集型：2n+1</li>
<li>cpu密集型：n+1<br>这里的n都是当前机器的虚拟内核数量，io密集型主要都是io时间多，对于cpu负载并不大</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/07/zjava-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%8A/">java-多线程-volatile，synchronized和lock</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-07
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>由于东西很多很乱，就按照Q&amp;A的方式整理以下</p>
</blockquote>
<h1 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h1><ul>
<li>调度方面：在传统计算机中，进程是调度的基本单位，但是在引入线程之后，线程是调度的基本单位。同一个进程下的线程切换不会引起进程切换，但是不同的就会影响</li>
<li>拥有资源方面：进程是拥有资源的单位，线程之间共享内存空间</li>
<li>切换方面：进程切换要保存上下文程序计数器很多东西，而线程切换只用保存一些寄存器。开销远小于进程</li>
<li>并发性：同一个进程下的线程可以并发，不同进程下的线程也可以并发</li>
</ul>
<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p>volatile是不稳定的意思，不止用于java，c++也有使用，声明了这个关键字的变量会禁用缓存，每一次都从内存找最新的值，这样就能保证可见性，但是不会保证原子性，例如下面这段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileAtomicityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatileAtomicityDemo</span> <span class="variable">volatileAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatileAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待1.5秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里得不到结果的主要原因是，inc++不是一个原子操作，其实是由三个操作并成，先读取inc，再++，最后写回，可能两个线程同时都读到inc为100，这个时候再同时更改写回内存，这样就会达不到预期，所以volatile关键之<strong>只能保证可见性，不能保证原子性</strong></p>
<p>如果要保证原子性，可以使用：</p>
<ul>
<li>synchronized关键字上锁increase方法</li>
<li>既然可以用synchronized方法，那肯定也可以用ReentrantLock，关于这两者的区别后文再说</li>
<li>ReentrantLock基于CAS和AQS，那肯定用CAS的原子方法也可以解决，后文再说</li>
</ul>
<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><ul>
<li>悲观锁：悲观的觉得临界区一定会有人来竞争，所以每次访问的时候一定要上锁，synchronized和ReentrantLock就是比较典型的悲观锁</li>
<li>乐观锁：很投机的觉得，这段代码可能不会有别的线程访问，就算有我也不上锁，用其他的方法，例如队列，链表的方式，比较典型的就是CAS（其实我觉得MVCC多少也有点这种思想）<br>最大的区别就是锁的粒度不一样，悲观锁由于每一次都要上锁，肯定效率没有乐观锁高，反而言之，如果频繁发生冲突，乐观锁的效率也是很低的。总而言之，在读多写少的场景，可以使用乐观锁，写多读少的情况下，使用悲观锁。</li>
</ul>
<h1 id="CAS和自旋锁"><a href="#CAS和自旋锁" class="headerlink" title="CAS和自旋锁"></a>CAS和自旋锁</h1><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>compare and swap，比较并且交换，主要思想是给出三个数据：要修改的数据的更新值，这个要修改的数据的预期值，要修改数据的实际值。什么意思呢，例如我们要把一个等于1的数据修改成6，我对于这个要修改数据的预期值就是1，当且仅当数据是1的时候，我才会把它修改成6.<br>这个思想怎么在并发的环境下体现呢？比如这个时候两个线程都要修改这个数据，有一个别的线程抢占先机，由于这个是由volatile修饰的，另一边立即会就看到修改成了另外一个值，不再是预期值1，这个时候cas就会失效，从而保证了并发。</p>
<p><strong>为什么这样就能作为锁呢？</strong></p>
<p>理由很简单，cas<strong>保证原子性</strong>，为什么他敢理直气壮的说自己是原子的。这就要涉及到一个神奇的类Unsafe，在实现java虚拟机的时候，由于jvm的隔离性，使得java很难接近底层操作系统，Unsafe这个类里面全都是native方法，也就是用的本地方法，对于cas而言，这个底层的方法不是java实现的，是由Unsafe调用dll动态库，也就是c++实现的，cas这条操作可以理解成汇编的一个原子指令，既然是一条指令，那么肯定是可以保证原子性的。</p>
<p>那么问题来了，为什么不直接弄一条锁的原子指令，而这么拐弯抹角的用到这个语句间接完成乐观锁，小编也不知道</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>我们有了这个CAS操作，到底怎么用到锁上面呢？我们先看一个用CAS的例子：</p>
<p>AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。AtomicInteger是一个操作Integer类型的原子操作类，这里的getAndAddInt可以保证线程安全，获取Object对象在内存偏移量，然后在+i</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span> <span class="params">(Object var1, Long var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">	<span class="type">int</span> var5;</span><br><span class="line">    <span class="comment">//自循环的思想，每一次循环都找Object的偏移量为var2的那个值，这个获得的就是预期值，</span></span><br><span class="line">    <span class="comment">//循环条件是如果跟他一样就断开，如果不一样，不阻塞，不释放CPU，但是也达到了锁的功能</span></span><br><span class="line">    <span class="comment">//能加就加，加不上就一只循环一直尝试</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">	&#125; <span class="keyword">while</span>( !<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主要思想是加的上就加，加不上一直尝试，即使没有加锁，但是也达到了锁的功能。</p>
<p>这种思想称为<strong>自旋</strong>，我们把这种dowhile的思想运用到类上就是<strong>自旋锁</strong>，我猜取这个名字的原因是因为一直循环，很像自己一个人在转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 如果锁未被占用，则设置当前线程为锁的拥有者</span></span><br><span class="line">        <span class="keyword">while</span> (!owner.compareAndSet(<span class="literal">null</span>, currentThread)) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 只有锁的拥有者才能释放锁</span></span><br><span class="line">        owner.compareAndSet(currentThread, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AtomicReference是一个原子类，提供的compareAndSet方法封装了CAS方法，参数中前面是预期值，后面是要修改的值，如果预期值和实际值是一样的，那么就设置为修改值。</p>
<p>上锁过程：owner这里空参数构造，所以我的预期值是空，如果这个时候只有一个线程，那么没有人上锁肯定也是空，所以实际值也是空，满足条件，那么就把空设置为当前线程。如果有两个线程，都同时要上锁，先进来的那个上了锁，下一个compareAndSet方法肯定是假，就会一直while，不会释放cpu</p>
<p>解锁过程：预期值为当前线程，这个线程刚刚上锁了，所以实际值肯定存的也是这个，最后满足条件就把锁设置为null，此时第二个线程终于不用自旋了，就会获取锁。</p>
<p>通过这个过程也看到了，自旋的优点和缺点都很明显，优点是如果时间短的话，可以免去线程的上下文切换时间；但是如果时间长，那就是很消耗cpu的，一直不释放，这个缺点有改进措施，可以用<strong>自适应自旋锁</strong>，也就说，不再是无限循环，可以设置一个最大循环次数，就不会导致死循环的情况。</p>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>CAS存在一个问题，判断实际值和预期值相同，其实不一定就能说明没改过，有可能预期值是A，实际值从A变成了B再变成了A，这个问题其实蛮严重的，如果是变量还好，如果在链表中，判断头节点没变化，不代表接下来的节点没有变化，就会导致完全不一样的结果。</p>
<p>如何避免？</p>
<p>加时间戳，上文用了AtomicReference，这回用AtomicStampedReference，这里使用了时间戳，只有当时间戳相同并且实际值等于预期值，才可以。</p>
<h1 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h1><p>在 Java 早期版本中，synchronized 属于 重量级锁，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>不过，在 Java 6 之后， synchronized 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 synchronized 锁的效率提升了很多。因此， synchronized 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 synchronized 。</p>
<p>关于偏向锁多补充一点：由于偏向锁增加了 JVM 的复杂性，同时也并没有为所有应用都带来性能提升。因此，在 JDK15 中，偏向锁被默认关闭（仍然可以使用 -XX:+UseBiasedLocking 启用偏向锁），在 JDK18 中，偏向锁已经被彻底废弃（无法通过命令行打开）。</p>
<h2 id="如何使用Synchronized关键字？"><a href="#如何使用Synchronized关键字？" class="headerlink" title="如何使用Synchronized关键字？"></a>如何使用Synchronized关键字？</h2><ol>
<li>修饰方法</li>
<li>修饰静态方法（锁住当前类）：注意修饰静态方法是没有互斥性的，因为静态方法是放在进程中静态代码块那一部分的，所有线程共享，每一个线程都可以访问</li>
<li>修饰代码块：</li>
</ol>
<ul>
<li>synchronized(object) 表示进入同步代码库前要获得 给定对象的锁。</li>
<li>synchronized(类.class) 表示进入同步代码前要获得 给定 Class 的锁</li>
</ul>
<p>总结：</p>
<ul>
<li>synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁；</li>
<li>synchronized 关键字加到实例方法上是给对象实例上锁；</li>
<li>尽量不要使用 synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能。</li>
</ul>
<h2 id="构造方法可以被Synchronized修饰吗》"><a href="#构造方法可以被Synchronized修饰吗》" class="headerlink" title="构造方法可以被Synchronized修饰吗》"></a>构造方法可以被Synchronized修饰吗》</h2><p>不可以，因为本身构造方法就已经是线程安全的了</p>
<h2 id="Synchronized底层原理"><a href="#Synchronized底层原理" class="headerlink" title="Synchronized底层原理"></a>Synchronized底层原理</h2><p>基于jvm的monitor,在java编译的时候会给加锁代码加上monitorenter和两个monitorexit，在这中间的就是互斥的，为什么要有两个呢，线程有的时候会抛出异常或者错误，这个时候就会走第二个exit，用两个是为了保证一定能退出。</p>
<p>monitor也是基于c++的，分为三个部分，一个是当前获取锁的对象，还有一个是等待队列，一个是阻塞队列。</p>
<p>上锁成功的标志是monitor的拥有者为当前线程，当释放的时候会唤醒阻塞进程，有一点要说明的是这个过程是非公平，也就是运行不在队列里的新进程也来抢。</p>
<h2 id="Synchronized锁升级原理"><a href="#Synchronized锁升级原理" class="headerlink" title="Synchronized锁升级原理"></a>Synchronized锁升级原理</h2><blockquote>
<p>这一块暂时还没有细细研究。</p>
</blockquote>
<p>有四种锁等级，锁的重量依次递增：</p>
<ol>
<li>不加锁</li>
<li>加偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令。这也是某种投机行为，乐观锁思想，在很少有进程竞争的时候比较节约资源</li>
<li>加轻度锁：也就是自旋锁等，每次操作都是cas，还是乐观锁思想，这个就比偏向锁稍微控制了一点</li>
<li>重度锁，使用monitor那种悲观锁</li>
</ol>
<p>Synchronized发生竞争会依次升级锁，高并发下变成悲观锁</p>
<h2 id="Synchronized和volatile什么区别"><a href="#Synchronized和volatile什么区别" class="headerlink" title="Synchronized和volatile什么区别"></a>Synchronized和volatile什么区别</h2><ol>
<li>Synchronized修饰方法，静态方法，代码块等，而volatile修饰变量</li>
<li>volatile是线程同步的轻量实现，具有可见性但是没有原子性，Synchronized可以保证可见性和原子性</li>
<li>volatile性能肯定比Synchronized好，但是主要解决的是变量的问题，Synchronized解决方法的同步和互斥。</li>
</ol>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>可重入锁，实现了Lock接口，相比Synchronized功能更多，实现了轮询，超时，中断，公平锁和非公平锁。</p>
<p>公平和非公平锁主要是Sync里面实现的，而Sync继承自<strong>AQS</strong>，也就是说ReentrantLock用的就是AQS思想。</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>主要数据结构是CLH，最早的CLH是一个虚拟的单向链表，为什么是虚拟的呢，因为甚至连指针都没有，一个CLH节点就包含两个结构，一个是当前线程，另外一个是一个bool变量，用来表示是否获得了锁。</p>
<p><strong>那是怎么运作的呢？</strong></p>
<p>初始化一个尾节点，线程那部分为空，bool部分为true，也就是说可以被上锁，每一个线程都用<strong>自旋的方式</strong>尝试获得来的时候的尾节点的bool值，那么这个时候来了一个线程，用CAS尝试获取现在的尾节点的bool，为真，那就可以上锁为false，同时自己的bool也为false，表示前面的节点都不能用，所以下一个也不能。</p>
<p>来了一个线程2，现在的尾节点是线程1，他的bool是false，线程2会一直自旋的获取前一个节点的bool值，后面的也是，如果此时线程1好了，那么线程2监听到前面一个变成了true，那就会开始线程2，以此类推。</p>
<p>优点很明显：如果时间短，那么获取和释放锁的开销小。CLH 的锁状态不再是单一的原子变量，而是分散在每个节点的状态中，降低了自旋锁在竞争激烈时频繁同步的开销。还有就是公平，先进先出</p>
<p>这样的CLH有什么缺点呢，首先是都是自旋，如果时间短还好，长了那肯定浪费资源。功能单一，不能支持ReentrantLock的那些接口功能。</p>
<p><strong>AQS对于CLH的改造</strong></p>
<p>针对自旋，AQS都改造成了阻塞，还是不能用自旋。针对第二个功能单一的缺点，使用了双向链表和一个全局变量state（其实我觉得之前那种看上一个节点情况的机制还蛮好的，这不是又重新变成信号量那种机制了）</p>
<p>state属性表示资源的状态，为0表示可以抢了，为1表示不能，为1时候来的线程进阻塞队列</p>
<ul>
<li>公平与非公平，公平就是直接每次都唤醒队列头的，非公平就是来的也一起竞争，但是可能会导致饥饿</li>
<li>可重入：一个线程多次进入可以state自增，如果重入两次那么state就是2，但是要保证加锁几次就解锁几次，保证最终还是0</li>
</ul>
<h1 id="ReentrantLock和synchronized区别"><a href="#ReentrantLock和synchronized区别" class="headerlink" title="ReentrantLock和synchronized区别"></a>ReentrantLock和synchronized区别</h1><ol>
<li>首先两者都是悲观锁，也都是可重入的，synchronized是一个关键字，基于jvm实现，ReentrantLock是一个是实现类，实现Lock接口，使用的时候需要声明。</li>
<li>ReentrantLock功能比较多，实现了可中断（中断也就说如果得不到锁就去干别的事情了，synchronized不可中断），可超时（ReentrantLock实现了，如果超时多少就不去争抢锁了，syn实现不了），锁可以绑定多个条件（Condition类，就相当于不同的信号量，可以控制一部分Condition下的进程等待，另一部分的执行）</li>
<li>没有竞争的时候synchronized优化很多，锁没有升级的时候性能很好；重度的时候Lock的性能比较好，因为底层还是用了cas的一部分乐观机制，相比synchronized的monitor还是好一点</li>
</ol>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/05/mysql-%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88/">mysql-索引和索引失效</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-05
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h1><h2 id="左匹配或者左右匹配"><a href="#左匹配或者左右匹配" class="headerlink" title="左匹配或者左右匹配"></a>左匹配或者左右匹配</h2><p>当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效。</p>
<p><strong>为什么 like 关键字左或者左右模糊匹配无法走索引呢？</strong></p>
<p>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</p>
<p>举个例子，下面这张二级索引图（图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行），是以 name 字段有序排列存储的。</p>
<p><img src="/../img/Mysql/img_13.png"></p>
<p>假设我们要查询 name 字段前缀为「林」的数据，也就是 name like ‘林%’，扫描索引的过程（这里中文都是按照某种排序，不知道是不是按照utf-8的编码值比较的，但是这个规则不影响寻找到逻辑）：</p>
<ul>
<li>节点1判断出“林”小于“周”并且大于“陈”（这个步骤是通过<strong>页目录</strong>进行搜索的，回顾一下：假设这里头指针是一个分组，陈是一个分组，剩下两个和尾指针是一个分组，二分查找目录项，由于目录项指向分组的最大值，那么“林”是大于陈小于周的，按照目录项的规则，从<em>包含尾指针的那个分组开始</em>，但是由于存的是最大值也就是尾指针，为了从头开始遍历，就要找到上一个槽的指针，往后数一个就是当前的最小值，结果发现当前的最小值“周”还是大于“林”，这样就定位在“陈”和“周”之间，按照存储规则，<strong>非叶子节点存的是下一个节点的最小值</strong>，那就要在“陈”这个节点找）</li>
<li>节点2继续比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4</li>
<li>节点4查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。</li>
</ul>
<p>如果使用 name like ‘%林’ 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。</p>
<blockquote>
<p>总而言之，索引是从左边开始匹配的，如果左边第一个都不能确定，那就要全部遍历</p>
</blockquote>
<h2 id="对索引使用函数"><a href="#对索引使用函数" class="headerlink" title="对索引使用函数"></a>对索引使用函数</h2><p>有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。</p>
<p><strong>为什么对索引使用函数，就无法走索引了呢？</strong></p>
<p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p>
<p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p>
<p>举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_user add key idx_name_length ((length(name)));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总而言之，索引保存的是原始值，使用函数后重新计算导致不能索引到，就失效了，但是如果对这个函数也建立一个索引，那也可以走索引</p>
</blockquote>
<h2 id="数据类型强制转换"><a href="#数据类型强制转换" class="headerlink" title="数据类型强制转换"></a>数据类型强制转换</h2><blockquote>
<p>这个印象比较深刻：首先举一个例子，select “10” &gt; 9，通过这个例子可以看出来在mysql是怎么处理字符串的</p>
<ul>
<li>如果是结果是1，也就是select 10&gt;9，那么内部会把字符串处理成数字</li>
<li>如果结果是0，也就是select “10” &gt; “9”，字符串是比较首位，1肯定小于9，所以这个结果是0，那么内部把数字处理成字符串<br>结果是1，也就是<strong>mysql内部把字符串变成数字进行比较</strong></li>
</ul>
</blockquote>
<p>假设phone在数据库是用varchar存的，有了这个结论，那么</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where phone = 1300000001;</span><br></pre></td></tr></table></figure>
<p>这个代码就会变成：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where CAST(phone AS signed int) = 1300000001;</span><br></pre></td></tr></table></figure>
<p>因为内部会把索引的字符串变成整数进行比较，相当于给索引使用了函数，所以就会失效</p>
<p>如果查询条件是字符串，id在数据库用int存的</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where id = &quot;1&quot;;</span><br></pre></td></tr></table></figure>
<p>那么就会变成：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where id = CAST(&quot;1&quot; AS signed int);</span><br></pre></td></tr></table></figure>
<p>也就是说，只有这个查询条件会要用这个函数，索引没有用，索引就不失效</p>
<h2 id="对索引进行表达式计算"><a href="#对索引进行表达式计算" class="headerlink" title="对索引进行表达式计算"></a>对索引进行表达式计算</h2><p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p>
<p>比如，下面这条查询语句，执行计划中 type &#x3D; ALL，说明是通过全表扫描的方式查询数据的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user where id + 1 = 10;</span><br></pre></td></tr></table></figure>

<p><strong>为什么对索引进行表达式计算，就无法走索引了呢？</strong></p>
<p>原因跟对索引使用函数差不多。</p>
<p>因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</p>
<p>有的同学可能会说，这种对索引进行简单的表达式计算，在代码特殊处理下，应该是可以做到索引扫描的，比方将 id + 1 &#x3D; 10 变成 id &#x3D; 10 - 1。</p>
<p>是的，是能够实现，但是 MySQL 还是偷了这个懒，没有实现。</p>
<p>我的想法是，可能也是因为，表达式计算的情况多种多样，每种都要考虑的话，代码可能会很臃肿，所以干脆将这种索引失效的场景告诉程序员，让程序员自己保证在查询条件中不要对索引进行表达式计算。</p>
<h2 id="联合索引的左匹配问题"><a href="#联合索引的左匹配问题" class="headerlink" title="联合索引的左匹配问题"></a>联合索引的左匹配问题</h2><p>对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。</p>
<p>那么多个普通字段组合在一起创建的索引就叫做联合索引，也叫组合索引。</p>
<p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。</p>
<p>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配。</p>
<p>比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a&#x3D;1；</li>
<li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li>
<li>where a&#x3D;1 and b&#x3D;2；<br>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</li>
</ul>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b&#x3D;2；</li>
<li>where c&#x3D;3；</li>
<li>where b&#x3D;2 and c&#x3D;3；<blockquote>
<p>其实类似第一种情况，不管是字符串还是索引，都是按照最左匹配的，如果连第一个都没有，那就会导致索引失效，这里还有一个<strong>索引下推</strong>的机制，等以后再来补。</p>
</blockquote>
</li>
</ul>
<h2 id="or导致的失效问题"><a href="#or导致的失效问题" class="headerlink" title="or导致的失效问题"></a>or导致的失效问题</h2><p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>
<p>这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p>
<blockquote>
<p>or就是两个里面满足一个，也就是索引要有两个，才可以一起用索引，and其实是只要有一个是索引就可以走索引的，要注意</p>
</blockquote>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/05/mysql-Buffer-Pool/">mysql-Buffer Pool</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-05
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/05/mysql-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC/">mysql-事务隔离级别与MVCC</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-05
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="事务的特性（ACID）"><a href="#事务的特性（ACID）" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h1><ul>
<li>原子性（Atomicity）：要么一起成功，要么一起失败，是一个操作，不可分割</li>
<li>一致性（Consistency）：是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行前后，数据库都必须处于一致性状态。换句话说，事务的执行结果必须是使数据库从一个一致性状态转变到另一个一致性状态。</li>
<li>隔离性（Isolation）：多个并发事务操作是隔离的，不会彼此打扰</li>
<li>持久性（Durability）：修改之后是持久的，不会掉电就失效了</li>
</ul>
<h1 id="并发导致的不一致性"><a href="#并发导致的不一致性" class="headerlink" title="并发导致的不一致性"></a>并发导致的不一致性</h1><ul>
<li>脏读<br><strong>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</strong></li>
</ul>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。</p>
<p><img src="/../img/Mysql/img_14.png"></p>
<p>因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读</p>
<blockquote>
<p>也就是事务B在A还没提交之前就已经读到了修改的数据，但是A因为某些原因回滚了，这个时候B就读到了脏数据，称为脏读</p>
</blockquote>
<ul>
<li>不可重复读<br><strong>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</strong></li>
</ul>
<p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</p>
<p><img src="/../img/Mysql/img_15.png"></p>
<blockquote>
<p>也就是A读到了B修改前和修改后的两次数据，不一致的问题，就是不可重复读</p>
</blockquote>
<ul>
<li>幻读</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/03/mysql-B-%E6%A0%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%9D%97/">mysql-B+树与数据页</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-03
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>我们先从最基本的存储引擎InnoDB开始学起，<a target="_blank" rel="noopener" href="https://blog.csdn.net/liang921119/article/details/130556995">原文链接</a></p>
</blockquote>
<h1 id="InnoDB-是如何存储数据的？"><a href="#InnoDB-是如何存储数据的？" class="headerlink" title="InnoDB 是如何存储数据的？"></a>InnoDB 是如何存储数据的？</h1><p>MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同的，我们最常使用的是 InnoDB 存储引擎，所以就跟大家图解下InnoDB 是如何存储数据的。</p>
<p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p>
<p>因此，InnoDB 的数据是按「数据页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
<h1 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h1><p>数据库的 I&#x2F;O 操作的最小单位是页，InnoDB 数据页的默认大小是 16KB，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p>
<p>数据页包括七个部分，结构如下图：</p>
<p><img src="/../img/Mysql/img.png"></p>
<p><img src="/../img/Mysql/img_1.png"></p>
<blockquote>
<p>这里最重要的是最小和最大记录，以及用户记录</p>
</blockquote>
<h2 id="用户真实记录在数据页中的存储（Free-Space）"><a href="#用户真实记录在数据页中的存储（Free-Space）" class="headerlink" title="用户真实记录在数据页中的存储（Free Space）"></a>用户真实记录在数据页中的存储（Free Space）</h2><p>在页的7个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。这个过程的图示如下：</p>
<p><img src="/../img/Mysql/img_2.png"></p>
<p>为了更好的管理在User Records中的这些记录，InnoDB可费了一番力气呢，在哪费力气了呢？不就是把记录按照指定的行格式一条一条摆在User Records部分么？其实这话还得从记录行格式的记录头信息中说起</p>
<h2 id="记录头信息引出的数据页“记录”结构"><a href="#记录头信息引出的数据页“记录”结构" class="headerlink" title="记录头信息引出的数据页“记录”结构"></a>记录头信息引出的数据页“记录”结构</h2><p>我们这里先创建一张表</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table demo5 (c1 int, c2 int, c3 varchar(10000),primary key (c1)) charset=ascii row_format=compact;</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br></pre></td></tr></table></figure>

<p>这个新建的表有三个列，c1和c2列是用来存储整数的，c3存储的字符串，但是我们指定c1位主键，所以在具体的行格式中，Innodb就没有必要给我们创建row_id隐藏列了 <strong>（这里说的隐藏列是在没有明确给主键的时候，mysql会自己找一个unique并且没有空值的列为主键索引，这个就是隐藏列）</strong>。所以表中的行格式示意图如下：</p>
<p><img src="/../img/Mysql/img_3.png"></p>
<p><img src="/../img/Mysql/img_4.png"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>⼤⼩（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1</td>
<td>1</td>
<td>没有使⽤</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使⽤</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树的每层⾮叶⼦节点中的最⼩记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型，0表示普通记录，1表示B+树⾮叶⼦节点记录，2表示最⼩记录，3表示最⼤记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>表示下⼀条记录的相对位置</td>
</tr>
</tbody></table>
<p>假设我们插入了几条数据：</p>
<p><img src="/../img/Mysql/img_5.png"></p>
<p>接下来会一个个解释这几个字段</p>
<h3 id="delete-mask"><a href="#delete-mask" class="headerlink" title="delete_mask"></a>delete_mask</h3><p>这个属性标记当前记录是否被删除，占用一个二进制位，为0为没有删除，为1被删除</p>
<blockquote>
<p>被删除的记录不立即从磁盘上移除，因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为所谓的可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。这个delete_mask位设置为1和将被删除的记录加入到垃圾链表中是两个阶段</p>
</blockquote>
<h3 id="min-rec-mask"><a href="#min-rec-mask" class="headerlink" title="min_rec_mask"></a>min_rec_mask</h3><p>B+树的每层非叶子节点中的最小记录都会添加该标记。值为1，表示该条记录是B+树的非叶子节点中的最小记录；值为0，意味着该条数据不是B+树的非叶子节点中的最小记录 <strong>（暂时还不知道这个具体作用，可能就是记录每一层的头节点？）</strong></p>
<h3 id="n-owned"><a href="#n-owned" class="headerlink" title="n_owned"></a>n_owned</h3><p>这个涉及到<strong>分组</strong>的概念了，存的就是当前分组有多少个元素，后续会介绍</p>
<h3 id="heap-no"><a href="#heap-no" class="headerlink" title="heap_no"></a>heap_no</h3><p>这个属性表示当前记录在本页中的位置（类似页表中的本页地址字段，但是这个单纯用来比较顺序）。MySQL自动给每个页里边儿加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录（这就是最前面介绍的7部分中的 <strong>最大最小记录</strong>）。</p>
<p>记录也可以比大小，对于一条完整的记录来说，比较记录的大小就是比较主键的大小。但是不管我们向页中插入了多少自己的记录，InnoDB规定他们定义的两条伪记录分别为最小记录与最大记录。这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。</p>
<p><img src="/../img/Mysql/img_6.png"></p>
<blockquote>
<p>这里规定的最小记录的heapno为0，最大记录的为1</p>
</blockquote>
<h3 id="record-type"><a href="#record-type" class="headerlink" title="record_type"></a>record_type</h3><p>这个属性表示当前记录的类型，一共有4种类型的记录，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们record_type值都是0，而最小记录和最大记录的record_type值分别为2和3，至于record_type为1的情况，我们之后在说索引的时候会重点强调的。</p>
<h3 id="next-record"><a href="#next-record" class="headerlink" title="next_record"></a>next_record</h3><p>这个信息非常重要，表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。如果你熟悉数据结构的话，就立即明白了，这其实是个链表，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是，下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是Supremum记录（也就是最大记录） ，为了更形象的表示一下这个next_record起到的作用，我们用箭头来替代一下next_record中的地址偏移量：</p>
<p><img src="/../img/Mysql/img_7.png"></p>
<p>假设删掉第2条记录后，由于删除只是标记为删除，实际上没有删除，就会变成：</p>
<p><img src="/../img/Mysql/img_8.png"></p>
<p>从图中可以看出来，删除第2条记录前后主要发生了这些变化：</p>
<ul>
<li>第2条记录并没有从存储空间中移除，而是把该条记录的delete_mask值设置为1。</li>
<li>第2条记录的next_record值变为了0，意味着该记录没有下一条记录了。</li>
<li>第1条记录的next_record值变为了64，指向了第3条记录。</li>
<li>最大记录的n_owned值从5变成了4，关于这一点的变化我们稍后会详细说明的。<br>所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的</li>
</ul>
<h2 id="页目录（重要）"><a href="#页目录（重要）" class="headerlink" title="页目录（重要）"></a>页目录（重要）</h2><blockquote>
<p>页目录的存在意义主要是加速检索速度，并不是将他们重新分组，我最开始以为是将记录再分成几块进行检索，但是其实只是一个方便二分查找的工具</p>
</blockquote>
<p>现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？比如说这样的查询语句：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from where c1=3;</span><br></pre></td></tr></table></figure>
<p>最笨的办法：从Infimum记录（最小记录）开始，沿着链表一直往后找，总会找到。在找的时候还能投机取巧，因为链表中各个记录的值是按照从小到大顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值时，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。</p>
<p>但是InnoDB能用这么笨的办法么，当然是要设计一种更快的查找方式，于是乎从书的目录中找到了灵感。</p>
<p>我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。InnoDB为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：</p>
<ul>
<li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。</li>
<li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。</li>
<li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的Page Directory，也就是页目录。页面目录中的这些地址偏移量被称为槽（英文名：Slot），所以这个页面目录就是由槽组成的。<br>需要注意的是，Page Directory是逆序存放的，每个槽占2字节</li>
</ul>
<p><img src="/../img/Mysql/img_9.png"></p>
<blockquote>
<p>这里第一个slot为什么是99？因为是从页的第一位开始算 <del>（文件头+页头+最小记录前的6字节&#x3D;38+56+5&#x3D;100，但是是0开始的，所以）</del> 最小记录单成一个分组，那slot也就指向的是最小记录的数据</p>
</blockquote>
<p>从这个图中我们需要注意这么几点：</p>
<p>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。</p>
<p>注意最小和最大记录的头信息中的n_owned属性</p>
<p>最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。</p>
<p>最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。</p>
<p>99和112这样的地址偏移量很不直观，我们用箭头指向的方式替代数字，这样更易于我们理解，所以修改后的示意图就是这样：</p>
<p><img src="/../img/Mysql/img_10.png"></p>
<p><img src="/../img/Mysql/img_11.png"></p>
<p>InnoDB对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1 ~ 8条之间，剩下的分组中记录的条数范围只能在是4 ~ 8条之间。所以分组是按照下边的步骤进行的：</p>
<ul>
<li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li>
<li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li>
<li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">insert into demo5 values(1,100,&#x27;aaaa&#x27;),(2,200,&#x27;bbbb&#x27;),(3,300,&#x27;cccc&#x27;),(4,400,&#x27;dddd&#x27;);</span><br><span class="line">insert into demo5 values(5, 500, &#x27;eeee&#x27;);</span><br><span class="line">insert into demo5 values(6, 600, &#x27;ffff&#x27;);</span><br><span class="line">insert into demo5 values(7, 700, &#x27;gggg&#x27;);</span><br><span class="line">insert into demo5 values(8, 800, &#x27;hhhh&#x27;);</span><br><span class="line">insert into demo5 values(9, 900, &#x27;iiii&#x27;);</span><br><span class="line">insert into demo5 values(10, 1000, &#x27;jjjj&#x27;);</span><br><span class="line">insert into demo5 values(11, 1100, &#x27;kkkk&#x27;);</span><br><span class="line">insert into demo5 values(12, 1200, &#x27;llll&#x27;);</span><br><span class="line">insert into demo5 values(13, 1300, &#x27;mmmm&#x27;);</span><br><span class="line">insert into demo5 values(14, 1400, &#x27;nnnn&#x27;);</span><br><span class="line">insert into demo5 values(15, 1500, &#x27;oooo&#x27;);</span><br><span class="line">insert into demo5 values(16, 1600, &#x27;pppp&#x27;);</span><br></pre></td></tr></table></figure>
<p><img src="/../img/Mysql/img_12.png"></p>
<p>因为把16条记录的全部信息都画在一张图里太占地方，让人眼花缭乱的，所以只保留了用户记录头信息中的n_owned和next_record属性，也省略了各个记录之间的箭头，我没画不等于没有啊！现在看怎么从这个页目录中查找记录。因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用所谓的二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low&#x3D;0，最高的槽就是high&#x3D;4。比方说我们想找主键值为6的记录，过程是这样的：</p>
<ul>
<li>计算中间槽的位置：(0+4)&#x2F;2&#x3D;2，所以查看槽2，对应记录的主键值为8，又因为8 &gt; 6，所以设置high&#x3D;2，low保持不变。</li>
<li>重新计算中间槽的位置：(0+2)&#x2F;2&#x3D;1，所以查看槽1对应的主键值为4，又因为4 &lt; 6，所以设置low&#x3D;1，high保持不变。</li>
<li>因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中，此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</li>
</ul>
<p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p>
<ul>
<li>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</li>
<li>通过记录的next_record属性遍历该槽所在的组中的各个记录</li>
</ul>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/03/redis-%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/">redis-读写一致性</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-03
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="Mysql如何与Redis保持同步"><a href="#Mysql如何与Redis保持同步" class="headerlink" title="Mysql如何与Redis保持同步"></a>Mysql如何与Redis保持同步</h1><p><img src="/../img/Redis/img_24.png"></p>
<p>类比计算机组成原理中的cache和内存，redis也就是mysql的缓存，那么保持读写一致性也是十分重要的，我们在修改数据库的同时，缓存中也要对应更新。</p>
<ul>
<li>读操作：缓存命中就直接返回，缓存未命中就查找数据库，然后更新缓存</li>
<li>写操作：<strong>延迟双删</strong><br><img src="/../img/Redis/img_25.png"></li>
</ul>
<h2 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h2><ol>
<li><strong>正常情况</strong></li>
</ol>
<p><img src="/../img/Redis/img_26.png"></p>
<p>首先线程1删除缓存，然后更新数据库，此时没有任何线程来打扰，完成操作以后线程2再来查找缓存，这个时候由于线程1已经删除了缓存，那就会查找数据库找到刚刚更新的数据，最后写入缓存。这个过程不会出现读写一致性问题</p>
<ol start="2">
<li><strong>特殊情况</strong><blockquote>
<p>其实下面先写后删除的特殊情况也适用于本例中，首先线程1查询到了一个过期key，去数据库找，暂时保存，但是没写进redis。此时另一个进程是写进程，先删除了这个key，随后更新，最后才轮到线程1，写回刚刚的旧数据到redis，同样会有数据不一致</p>
</blockquote>
</li>
</ol>
<p><img src="/../img/Redis/img_27.png"></p>
<p>我们假设线程1删除缓存之后，由于线程是并发的，线程2来查询，此时由于还没有更新数据库，找到的还是原来的数据，随后放回缓存，这个时候才轮到线程1，更新数据库，但是此时redis还是用的以前的数据，数据库的是刚刚更新的，就出现了读写一致性问题</p>
<h2 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h2><blockquote>
<p>那如果我们先更新数据库，在更新缓存是不是正确的呢？<strong>答案是还是会有读写一致性问题</strong></p>
</blockquote>
<ol>
<li><strong>正常情况</strong></li>
</ol>
<p> <img src="/../img/Redis/img_28.png"><br>线程2先更新数据库，然后删除，跟上面的一样，只要两个操作是原子性的就不会有问题，但是只要是线程是并发的，那就肯定不一致</p>
<ol start="2">
<li><strong>特殊情况</strong></li>
</ol>
<p><img src="/../img/Redis/img_29.png"></p>
<blockquote>
<p>如果在不在这个刚刚过期的时间节点，那会怎么样呢？其实如果不是刚刚要过期，那就直接会拿走缓存中的数据，也不会删除缓存，那写进程后续先改再写redis也不会出现读写一致性问题，个人觉得核心的问题在于读进程的机制，没查到或者过期的缓存就会主动去数据库里调用，会扰乱正常的写进程导致不一致</p>
<p>如果是命中的读进程，那就根本不会扰乱写进程，只是脏数据的问题，redis和mysql最终都是一致的。而这里讨论的刚好过期，才会导致读进程写redis，才会有不一致性的问题发生）</p>
</blockquote>
<p>线程1先去查询缓存，这个时候刚好key过期，就要去数据库找，在数据库找到的是旧数据，先保存下来，但是此时线程2更新了数据库，然后删除，最后才是线程1写回旧数据到redis，出现不一致。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li><strong>分布式锁</strong>：在更新缓存前先加个分布式锁，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。</li>
<li><strong>延迟双删</strong>：针对「先删除缓存，再更新数据库」方案在「读 + 写」并发请求而造成缓存不一致的解决办法是「延迟双删」。</li>
<li><ul>
<li>为什么要双删？因为刚刚在[先删除缓存，再更新数据库]方案中会出现读写一致问题，这个时候只要再去删除一次缓存就可以了，下一个来的读请求会发现不存在对应的key，然后从数据库找，最终达到一致性</li>
</ul>
</li>
<li><ul>
<li>为什么要延迟？主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。<br>所以，请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。因为这个延时时间不好控制，在极端情况下还是会出现读写不一致的现象。</li>
</ul>
</li>
<li><strong>使用「先更新数据库，再删除缓存」方案</strong>：其实这种方案的特殊情况很难遇见，因为<strong>缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。<br>而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。<strong>（意思是即使B先写了数据库，A再写旧的值，因为数据库涉及io（扯远点就是io中断）阻塞进程B直到时间片到了，进程会交替执行而io搁一边，可能当执行到A写完了旧值，更新才刚刚结束，这个时候B再执行删除，就可以保证一致性）</strong></li>
</ul>
<h2 id="在不那么要求强一致性的场景"><a href="#在不那么要求强一致性的场景" class="headerlink" title="在不那么要求强一致性的场景"></a>在不那么要求强一致性的场景</h2><p>有的时候可以容忍一瞬间的脏数据，但是要保持最终一致性的场景，可以使用以下两种方法：</p>
<ul>
<li>基于消息队列（例如kafka）：写入数据库后，发一个消息给mq通知redis更新缓存，这种方式的可靠性主要取决于mq，肯定是有一定的延时的，但是最终会保证一致</li>
<li>基于阿里巴巴的Canal中间件：「先更新数据库，再删缓存」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。<br>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/02/leetcode-2024-4-2/">leetcode-2024-4-2</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-02
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="894-所有可能的真二叉树"><a href="#894-所有可能的真二叉树" class="headerlink" title="894 所有可能的真二叉树"></a>894 所有可能的真二叉树</h1><p>给你一个整数 n ，请你找出所有可能含 n 个节点的 真二叉树 ，并以列表形式返回。答案中每棵树的每个节点都必须符合 Node.val &#x3D;&#x3D; 0 。</p>
<p>答案的每个元素都是一棵真二叉树的根节点。你可以按 任意顺序 返回最终的真二叉树列表。</p>
<p>真二叉树 是一类二叉树，树中每个节点恰好有 0 或 2 个子节点。</p>
<p><img src="/../img/coding/2024_4_2_1.png"></p>
<blockquote>
<p>感觉很像之前写过的一道题</p>
</blockquote>
<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>由分析知道，n不能为偶数，叶子节点为（n+1）&#x2F;2，度为二的节点为(n-1)&#x2F;2，n&#x3D;1的时候就只有一个节点，n可以拆分出[x,1,y]三个，x和y都必须是奇数，x和y都比n小而且一定在之前的遍历中已经计算过，只要深拷贝n&#x3D;x和n&#x3D;y的数组，作为左边右边，就可以得到最终答案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//记忆化保存的数组</span></span><br><span class="line">    List&lt;List&lt;TreeNode&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; treeNodeList;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">allPossibleFBT</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//排除偶数</span></span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        treeNodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        treeNodeList.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">0</span>));</span><br><span class="line">        list.add(treeNodeList);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">3</span>; k &lt;= n; k+=<span class="number">2</span>) &#123;</span><br><span class="line">            treeNodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k-<span class="number">1</span>; i+=<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//System.out.println(i);</span></span><br><span class="line">                <span class="comment">//由于i是+=2的，对应的list下标是++，所以要/2</span></span><br><span class="line">                List&lt;TreeNode&gt; left = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.get(i/<span class="number">2</span>));</span><br><span class="line">                List&lt;TreeNode&gt; right = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.get((k-<span class="number">1</span>-i)/<span class="number">2</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; left.size(); p++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">0</span>; q &lt; right.size(); q++) &#123;</span><br><span class="line">                        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                        root.left = left.get(p);</span><br><span class="line">                        root.right = right.get(q);</span><br><span class="line">                        <span class="comment">//先保存到treenodeList里</span></span><br><span class="line">                        treeNodeList.add(root);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(treeNodeList.size());</span></span><br><span class="line">            <span class="comment">//最后加上这个</span></span><br><span class="line">            list.add(treeNodeList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(list.get(n/2).size());</span></span><br><span class="line">        <span class="comment">//返回记忆化搜索最后一个</span></span><br><span class="line">        <span class="keyword">return</span> list.get(n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    
    
  </div>

  

  

</article>
  
    
  <nav class="pagination">  
      
      <a class="prev" href="/page/3/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text">上一页</span>  
      </a>  
      
      
      <a class="next" href="/page/5/">  
        <span class="next-text">下一页</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  
</section>
        </div>
          

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:1050886654@qq.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/yyf1050886654" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2024      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">Yifan Yang</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    

  







<script type="text/javascript" src="/lib/jquery"></script>



<script type="text/javascript" src="/lib/slideout"></script>



<script type="text/javascript" src="/lib/fancybox"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>