<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/default" title="YYF's Blog" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://yyf1050886654.github.io/page/2/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>YYF&#39;s Blog</title>

<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">YYF&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/collect/">
      <li class="mobile-menu-item">
        
        
        收藏              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">YYF's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/collect/">  
              
              
              收藏  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <section id="posts" class="posts">
  
  
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/10/08/%E7%BD%91%E7%BB%9C%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E7%AF%87/">网络和操作系统面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-10-08
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h2><p>https主要有非对称加密，对称加密和数字签名三部分。具体流程是服务器先向证书颁发机构注册和验证。客户端请求服务器的时候，服务器会把自己非对称加密的钥匙发给客户端，这个钥匙是需要数字签名进行盖章的，这样客户端就知道这个网站是合法的而不是钓鱼网站。接收到了服务器非对称加密的钥匙，再把对称加密的钥匙通过这个公钥发给服务器，服务器用私钥进行解密。后续就根据对称加密进行传输。</p>
<h2 id="http的状态码"><a href="#http的状态码" class="headerlink" title="http的状态码"></a>http的状态码</h2><ul>
<li>1xx：正在处理的状态，一般见不到</li>
<li>2xx：成功状态码</li>
<li>3XX：301永久重定向，302临时重定向</li>
<li>4XX：401资源未授权，403被屏蔽了，404找不到</li>
<li>5XX：500服务器问题。502网关收到了，但是服务器转发有问题</li>
</ul>
<h2 id="http版本"><a href="#http版本" class="headerlink" title="http版本"></a>http版本</h2><ul>
<li>http1.0：短链接，一个资源一次tcp。</li>
<li>http1.1：长连接，但是还是有hol问题，即大文件传输会挡住小文件传输从而影响体验</li>
<li>http2.0：长连接，通过二进制帧解决了hol的问题，将大文件分成小份传输。同时长连接也改进成了多路复用</li>
<li>http3.0：tcp+quic（udp）优化了握手，安全性也进行了更新</li>
</ul>
<h2 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h2><ul>
<li>客户端先发送同步信号SYN，再带上自己的seq，进入syn-send状态</li>
<li>服务器接收到了发送ack和sys，进入syn-recv</li>
<li>客户端收到了之后在发送一个ack，建立连接</li>
</ul>
<p><strong>为什么是三次握手</strong></p>
<p>因为只有三次握手才能使双方都知道各方面正常。</p>
<ul>
<li>第一次握手，客户端什么都不能确认，服务器可以确认自己接受正常，客户端发送正常。</li>
<li>第二次握手，客户端可以确认自己发送和接收正常，服务器发送和接收正常；服务器可以确认自己接收正常，客户端发送正常</li>
<li>第三次握手，服务器可以确认自己发送和接收正常，客户端发送和接收正常</li>
</ul>
<h2 id="tcp四次握手"><a href="#tcp四次握手" class="headerlink" title="tcp四次握手"></a>tcp四次握手</h2><ul>
<li>客户端发送fin和seq，进入fin-wait-1</li>
<li>服务器接收到发送ack和seq，进入close-wait，客户端接收到了变为fin-wait-2</li>
<li>可能服务器还会有要发送的，发送完了发送fin，变为last-ack</li>
<li>客户端接收到了变为time-wait，等到2ttl时间，如果没有等到服务器的消息就自己关闭。</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/10/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-seata/">分布式事务-seata</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-10-05
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h2><p>TCC模式是try，confirm，cancel。不依赖本地事务，通过业务代码解决。try先预留事务所需的资源，confirm确保任务的执行并且消耗第一阶段预留的资源，如果在这个阶段出现差错就进入cancel。</p>
<p>优点：</p>
<ul>
<li>不依赖数据库的事务，可以用在非事务型数据库</li>
<li>不用全局锁，无需生成快照，效率较高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>代码侵入：需要程序员手动设计事务逻辑，增加了开发的复杂度</li>
<li>中间有软状态，是最终一致性，confirm和cancel出现问题会有一致性问题。</li>
<li>幂等问题：如果由于在confirm和cancel阶段出现网络波动，可能多次释放资源，出现严重后果。所以为了保证信息只被回滚一次需要保证幂等性。可以用状态表来实现（但是我觉得还是会有并发问题）</li>
<li>空回滚：try的期间阻塞一条，回滚的时候也会回滚这个空的。可能造成资源无故释放。解决方法也是状态表，如果第一阶段有记录成功过了就执行回滚。如果没有就不用</li>
<li>资源倒挂：也是网络环境变化，try阶段某个分支事务阻塞了直到最后回滚了才执行，是空回滚的另一个结果。解决方案是空回滚的时候加一条状态记录。在try阶段如果没有这个就执行，如果有分支事务的id。说明已经被空回滚发现，不再执行。</li>
</ul>
<h2 id="saga模式"><a href="#saga模式" class="headerlink" title="saga模式"></a>saga模式</h2><p>Saga模式是一种用于处理分布式事务的模式，它通过将长时间的、复杂的事务分解为多个小的、可逆的事务片段，以实现事务的一致性和可靠性。</p>
<p>在Saga模式中，每个事务片段称为一个补偿操作。每个补偿操作都与一个正向操作相对应，正向操作是事务的一部分，而补偿操作是用于撤销或修复正向操作的。Saga模式通过按照事务执行的顺序，依次执行正向操作和补偿操作，来确保事务在发生失败或异常时能够进行回滚或恢复。</p>
<p>Saga模式的执行过程如下：</p>
<p>执行正向操作：按照事务的逻辑顺序，依次执行正向操作。每个正向操作都会记录事务的执行状态。<br>如果所有的正向操作都成功执行，则事务提交完成。<br>如果某个正向操作失败，将会触发相应的补偿操作。补偿操作会撤销或修复正向操作的影响。<br>执行补偿操作：按照逆序依次执行已经触发的补偿操作。补偿操作应该具备幂等性，以便可以多次执行而不会造成副作用。<br>如果所有的补偿操作都成功执行，则事务回滚完成。<br>如果补偿操作也失败，需要人工介入或其他手段来解决事务的一致性问题。</p>
<p>Seata的Saga模式：</p>
<p>Seata的Saga模式通过Seata框架来管理和协调分布式事务，提供了对事务的编排和状态管理的支持。它与Seata的其他特性（如AT模式、TCC模式）结合在一起，构成了Seata全面的分布式事务解决方案。</p>
<p>Seata的Saga模式相对于传统的Saga模式，具有以下特点：</p>
<ul>
<li>集成性：Seata的Saga模式与Seata框架紧密集成，可以与Seata的其他特性一起使用，如分布式事务日志和分布式锁等。</li>
<li>强一致性：Seata的Saga模式提供了强一致性的事务支持，确保事务的执行顺序和一致性。</li>
<li>可靠性：Seata的Saga模式在补偿操作的执行过程中，支持重试和恢复机制，提高了事务的可靠性和恢复能力。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>业务流程长、业务流程多</li>
<li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>一阶段提交本地事务，无锁，高性能</li>
<li>事件驱动架构，参与者可异步执行，高吞吐</li>
<li>补偿服务易于实现，不用编写TCC中的三个阶段，实现简单</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>没有锁，不保证隔离性，会有脏写；</li>
<li>软状态持续时间不确定，时效性差；</li>
</ul>
<h2 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h2><p>就是二阶段提交2pc模式。保证强一致性，只能一起提交或者失效。效率最低。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/10/04/%E5%9C%BA%E6%99%AF%E9%A2%98/">场景题</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-10-04
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="如何设计一个秒杀系统"><a href="#如何设计一个秒杀系统" class="headerlink" title="如何设计一个秒杀系统"></a>如何设计一个秒杀系统</h2><ul>
<li>高性能：高性能核心就是响应时间快，一般来说都会把热点数据放在redis中，但是秒杀高峰的时候有可能连redis都应付不了。有几种解决方案：首先是二级缓存，redis之外用jvm的缓存例如caffeine，一定要控制空间大小，所以必须上淘汰策略例如lru；或者在业务层面进行UV统计，但是需要改写redis的jar；或者直接使用开源解决方案比如京东的hotkey。此外为了提高响应速度还可以将静态资源放到cdn上，例如七牛云阿里云，图片不会再占用服务器的带宽，但是这种属于钞能力的解决方案。</li>
<li>高可用：保证节点的故障恢复。需要用集群。包括但不限redis-sentinel，redis-cluster；此外还可以用分布式限流框架sentinel，实现服务限流和降级；优化异步请求可以用mq，mq对于高可用的贡献是流量削峰，将请求打入消息队列，对于高性能的贡献是将减库存缓存和减数据异步化，更快返回请求。</li>
<li>一致性：如何防止超卖，可以用lua脚本查询redis中的余量，但是lua的原子性保证的是脚本内都是一条语句，而不是事务上的原子性，出错了是不会回滚的；redis减库存后需要同步到mysql中，可以用mq完成。扣减余额也要考虑并发问题，可以用mysql的排他锁。</li>
<li>幂等性：也就是常说的一人一单，可以考虑用分布式锁来锁住当前用户。</li>
</ul>
<h2 id="大文件断点续传问题"><a href="#大文件断点续传问题" class="headerlink" title="大文件断点续传问题"></a>大文件断点续传问题</h2><ul>
<li>前端文件分片，并且通过sha算法生成一个校验和。</li>
<li>后端根据这个校验和先去查minio是否有当前分片，如果有就直接跳过</li>
<li>如果没有先检验sha校验和，如果匹配说明有效。可以采用并行的方式加快传输</li>
<li>所有分片发送完毕后，前端会进行校验，发送整个的sha，与后端合并后的文件进行校验</li>
</ul>
<h2 id="40亿qq号，如何去重"><a href="#40亿qq号，如何去重" class="headerlink" title="40亿qq号，如何去重"></a>40亿qq号，如何去重</h2><p>哈希表和哈希集肯定是不行的，可以考虑用位图。或者数据结构那种外部归并排序</p>
<h2 id="动态线程池"><a href="#动态线程池" class="headerlink" title="动态线程池"></a>动态线程池</h2><p>要用到nacos动态配置核心参数</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/30/JVM%E9%9D%A2%E8%AF%95%E7%AF%87/">JVM面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-30
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="JVM如何解决跨代问题"><a href="#JVM如何解决跨代问题" class="headerlink" title="JVM如何解决跨代问题"></a>JVM如何解决跨代问题</h2><p>如果在年轻代的某个对象引用了老年代的对象，在触发Young GC的时候只会检查年轻代而不会检查老年代，此时如果老年代引用了一个年轻代的对象就不会被YGC发现而回收了此对象。但是这种情况出现的比较少，除非是老年代动态的引用了一个刚产生的对象。</p>
<p><strong>记忆集和卡表</strong><br>如果为了小概率事件每次YGC都去扫描一遍永久代，开销会很大。此时我们只需要保存从非扫描区域到扫描区域的指针就可以了。这个保存的扫描指针逻辑上叫做记忆集，放在新生代中。</p>
<p>卡表是hotspot虚拟机对于记忆集的具体实现，类似位图，把非扫描区域分块，然后用一个卡表数组来记录对应块是否变脏，如果记录的为1说明变脏，在YGC的时候把对应块加入扫描。本质上是用空间换时间。</p>
<p><strong>写屏障</strong><br>这里的写屏障跟volatile的不一样，这里仅仅是对引用操作做了一层aop，在写后屏障加入添加卡表的操作，在写前屏障添加该页是否脏的判断，可以解决伪共享问题。</p>
<h2 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h2><p>三色标记算法是可达性分析的一个扫描过程，例如CMS，先做初始标记标记出GCroot，然后再并发标记，这个过程是通过三色标记算法实现的。最后扫描到的白色节点就被视为没有引用，在下一轮GC会被回收。</p>
<ul>
<li>黑色，直接或者间接连接到GCroot并且自身所有引用都被扫描过了</li>
<li>灰色：从黑色节点扩散，但是自己的子节点还没有被完全扫描</li>
<li>白色：没有被染指的节点，也就是不可达区域</li>
</ul>
<p><strong>三色标记的缺点</strong></p>
<ol>
<li>多标问题：在一个节点被标记成灰色之后，上一个节点断开联系，最终这个节点还是会被染黑，但实际上是垃圾。这个现象称为浮动垃圾，在下一轮会被回收。</li>
<li>漏标问题：多标至少可以通过下一轮垃圾回收清除，漏标就严重多了。当一个灰色节点与一个白色节点断掉之后立刻有黑色节点相连。这个时候三色标记算法还是会认为这个节点是白色的，就会被垃圾回收，而此时确实有黑色节点的引用，会报空指针异常。</li>
</ol>
<div style="text-align: center;">
  <img src="../img/jvm/img_5.png" alt="" />
</div>

<p><strong>如何解决</strong><br>两个条件同时发生才会有漏标现象：首先是有灰色节点与白色节点断开联系，又有黑色节点与白色节点产生联系。</p>
<p>破坏一个就不会产生漏标：</p>
<ul>
<li>增量更新：增量更新破坏了第一个条件：「至少有一个黑色对象新增了对白色对象的引用」，在并发标记阶段，黑色对象D指向了白色对象G，这时会把黑色对象D记录下来，在重新标记阶段，会把黑色对象D标记为灰色对象D，然后以灰色对象D为根节点，扫描整个引用链，白色对象G就会被依次标记为灰色、黑色，白色对象G漏标的问题就解决了。 缺点是会重新扫描以黑色对象为根节点的子树，时间长（CMS解决方案）</li>
<li>原始快照：原始快照破坏了第二个条件：「所有灰色对象指向该白色对象的引用都断开了」，在并发标记阶段，灰色对象E断开了对白色对象G的引用，这是会把白色对象G记录下来，在最终标记阶段，会把白色对象G标记为灰色，然后以灰色对象G为根节点，扫描整个引用链，如此以来原来的白色对象G就会被依次标记为灰色、黑色，白色对象G漏标的问题就解决了。缺点是如果没有黑色对象来引用就会变成浮动垃圾（G1解决方案）</li>
</ul>
<h2 id="类的回收"><a href="#类的回收" class="headerlink" title="类的回收"></a>类的回收</h2><p>类的元数据在方法区也就是元空间中，在fullGC是有可能会被垃圾回收的。一个类能被垃圾回收需要满足三个要求：</p>
<ol>
<li>没有实例对象</li>
<li>没有静态方法的引用</li>
<li>类加载器已经被GC</li>
</ol>
<p><strong>private static final int I &#x3D; 0，这个i会回收吗</strong></p>
<p>看情况，跟着类走，本身这就是一个GCroot，一共有四种GCroot（类的常量引用类似这种，静态引用，虚拟机栈的引用，本地方法栈的引用）。如果不是类被卸载的话是不能被GC的。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95%E7%AF%87/">设计模式面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-28
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>设计模式一般可以分为三大类</p>
<ul>
<li>创建型：工厂模式，单例模式</li>
<li>结构型：装饰器模式，适配器模式</li>
<li>行为型：策略模式，观察者模式<br>设计原则：</li>
<li>单一职责原则</li>
<li>开放封闭原则</li>
<li>里式替换原则</li>
<li>接口隔离原则</li>
<li>依赖倒置原则</li>
<li>迪米特原则</li>
<li>合成复用原则</li>
</ul>
</blockquote>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是在不改变原先对象的前提下，通过生成一个代理对象，扩展原先对象的一些功能。比如aop，不入侵业务代码实现方法前后逻辑。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理是写死的，也就是说需要程序员手动写一个proxy代理类，与原先类共同继承一个接口（个人理解其实从实现层面是可以不共同实现一个接口的，但是这样就会导致管理混乱，代理对象如果能复用这个接口那就会逻辑上通顺很多）</p>
<p>静态代理实现步骤:</p>
<ul>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ul>
<p>一旦要新增方法，代理对象也会改变，不满足设计模式中开放封闭的原则。这些代理类实际都是在编译过程中产生的class文件</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>分为jdk动态代理和gclib。前者必须要求代理类实现了某个接口，后者没有这点限制。但是相对于jkd而言，gclib效率较低速度较慢。gclib的原理是生成一个子类来代理父类，由于不能继承final类，所以gclib不能代理final类</p>
<p><strong>jdk动态代理</strong></p>
<ol>
<li>Proxy.newProxyInstance方法，得到动态代理对象。传入参数是对象的类加载器，类的接口和一个InvocationHandler自定义的处理逻辑</li>
<li>新建一个类实现InvocationHandler，这里面只有一个方法invoke，包装了反射中的method.invoke，我们需要在这句调用前后加上自己的逻辑就可以简单实现aop。</li>
<li>新建一个工厂类的静态方法来获取这个动态代理对象</li>
<li>使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好，&quot;</span> + name + <span class="string">&quot;！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InvocationHandler实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法调用前的处理逻辑&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;方法调用后的处理逻辑&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 被代理的对象</span></span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">helloService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建InvocationHandler</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloInvocationHandler</span>(helloService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (HelloService) Proxy.newProxyInstance(</span><br><span class="line">                helloService.getClass().getClassLoader(),</span><br><span class="line">                helloService.getClass().getInterfaces(),</span><br><span class="line">                handler</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用代理对象的方法</span></span><br><span class="line">        proxyInstance.sayHello(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>gclib动态代理</strong></p>
<ol>
<li>首先自定义MethodInterceptor，这一点与上面的InvocationHandler是一致的。但是注意这里不是method.invoke来调用实际逻辑了。这里用methodProxy来调用原始方法。</li>
<li>使用的时候首先创建增强类Enhancer</li>
<li>设置类加载器和父类（也就是被代理对象）</li>
<li>设置拦截器，就是第一点创建的对象</li>
<li>最后获取这个代理类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好，&quot;</span> + name + <span class="string">&quot;！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的MethodInterceptor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在方法执行前添加逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理类：方法调用前的处理&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在方法执行后添加逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理类：方法调用后的处理&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Enhancer对象</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(Person.class); <span class="comment">// 设置被代理类的父类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">PersonMethodInterceptor</span>()); <span class="comment">// 设置回调</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">proxyPerson</span> <span class="operator">=</span> (Person) enhancer.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用代理对象的方法</span></span><br><span class="line">        proxyPerson.sayHello(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在spring aop中，如果某个类实现了接口，则默认使用jdk动态代理；否则使用cglib</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证只有一个全局访问点，无论怎么访问都只有一个对象。</p>
<p><strong>饿汉式单例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类加载初始化的时候就直接创建单例对象，适合于程序运行期间始终都需要这个对象的场景。</p>
<p><strong>懒汉式单例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> singleton INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> singleton <span class="title function_">getINSTANCE</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是可能会有并发安全问题，如果两个都没有获取到当前对象就会产生覆盖或者数据不一致，可以使用synchronized来锁住这个方法，但是会影响性能。</p>
<p><strong>双重校验锁</strong></p>
<p>上面那种情况下无论是否已经实例化了都需要获取锁，但其实如果其实已经实例化了就不需要上锁。还有一个关键问题是会指令重排。一个对象在创建1过程中会经历三步：</p>
<ol>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>指针指向该对象<br>如果3重排就会变成132，此时还没有进行初始化。两个线程并发就会导致报空指针异常。为了解决这个问题需要volatile禁止指令重排。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile 关键字确保实例的可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供全局访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内部静态类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供全局访问点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>内部静态类在被调用的时候才会被加载，而且类加载不会有线程安全问题，天然解决并发问题。</p>
<blockquote>
<p>单例模式是可以被破坏的，只要通过反射拿到private的构造器就可以了</p>
</blockquote>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>一种方法可以用多种算法实现就可以使用策略模式，根据不同情况下用不同的算法。也可以消除”if-else”这样的控制语句。</p>
<ul>
<li>上下文：持有一个策略的引用，并提供一个接口来调用策略</li>
<li>策略接口：定义了一系列算法的公共接口</li>
<li>具体实现：策略的具体实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回执处理策略接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReceiptHandleStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handleReceipt</span><span class="params">(Receipt receipt)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略实现类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mt1011ReceiptHandleStrategy</span> <span class="keyword">implements</span> <span class="title class_">ReceiptHandleStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReceipt</span><span class="params">(Receipt receipt)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;解析报文MT1011: &quot;</span> + receipt.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mt2101ReceiptHandleStrategy</span> <span class="keyword">implements</span> <span class="title class_">ReceiptHandleStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReceipt</span><span class="params">(Receipt receipt)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;解析报文MT2101: &quot;</span> + receipt.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上下文类,持有策略接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiptStrategyContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReceiptHandleStrategy receiptHandleStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReceiptHandleStrategy</span><span class="params">(ReceiptHandleStrategy receiptHandleStrategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiptHandleStrategy = receiptHandleStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用策略类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReceipt</span><span class="params">(Receipt receipt)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(receipt != <span class="literal">null</span>)&#123;</span><br><span class="line">            receiptHandleStrategy.handleReceipt(receipt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略工厂，用哈希表保存策略，根据参数选择策略</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiptHandleStrategyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReceiptHandleStrategyFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Map集合存储策略信息,彻底消除if...else</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,ReceiptHandleStrategy&gt; strategyMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化具体策略,保存到map集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        strategyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        strategyMap.put(<span class="string">&quot;MT1011&quot;</span>,<span class="keyword">new</span> <span class="title class_">Mt1011ReceiptHandleStrategy</span>());</span><br><span class="line">        strategyMap.put(<span class="string">&quot;MT2101&quot;</span>,<span class="keyword">new</span> <span class="title class_">Mt2101ReceiptHandleStrategy</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据回执类型获取对应策略类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReceiptHandleStrategy <span class="title function_">getReceiptHandleStrategy</span><span class="params">(String receiptType)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategyMap.get(receiptType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟回执</span></span><br><span class="line">        List&lt;Receipt&gt; receiptList = ReceiptBuilder.genReceiptList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//策略上下文</span></span><br><span class="line">        <span class="type">ReceiptStrategyContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReceiptStrategyContext</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//策略模式将策略的 定义、创建、使用这三部分进行了解耦</span></span><br><span class="line">        <span class="keyword">for</span> (Receipt receipt : receiptList) &#123;</span><br><span class="line">            <span class="comment">//获取置策略</span></span><br><span class="line">            ReceiptHandleStrategyFactory.init();</span><br><span class="line">            <span class="type">ReceiptHandleStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> ReceiptHandleStrategyFactory.getReceiptHandleStrategy(receipt.getType());</span><br><span class="line">            <span class="comment">//设置策略</span></span><br><span class="line">            context.setReceiptHandleStrategy(strategy);</span><br><span class="line">            <span class="comment">//执行策略</span></span><br><span class="line">            context.handleReceipt(receipt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>让一个实现类满足统一的接口，使不同的实现类可以一起工作。满足开放封闭原则。</p>
<ol>
<li>例如在Spring AOP中不同的Advice实现的方式不一样类也不一样，可能实现的时候这个类的某个方法叫run，另一个叫start，为了是这些实现类完成统一，就需要加一层适配器，把名字都叫做advicerun，给客户端呈现的就是这个名字。</li>
<li>SpringMVC也是，不同的控制器种类有很多，例如有注解的有自己写的，需要用适配器统一起来</li>
</ol>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>扩展类的功能，比起直接继承，装饰器模式可以实现单一责任原则，也便于功能的组合，避免类的层次结构复杂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleNotification</span> <span class="keyword">implements</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending notification: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">NotificationDecorator</span> <span class="keyword">implements</span> <span class="title class_">Notification</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Notification decoratedNotification;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationDecorator</span><span class="params">(Notification notification)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.decoratedNotification = notification;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        decoratedNotification.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰器 - 邮件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailNotificationDecorator</span> <span class="keyword">extends</span> <span class="title class_">NotificationDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EmailNotificationDecorator</span><span class="params">(Notification notification)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.send(message);</span><br><span class="line">        sendEmail(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending email with message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰器 - 短信</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSNotificationDecorator</span> <span class="keyword">extends</span> <span class="title class_">NotificationDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SMSNotificationDecorator</span><span class="params">(Notification notification)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.send(message);</span><br><span class="line">        sendSMS(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendSMS</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending SMS with message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Notification</span> <span class="variable">notification</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleNotification</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加邮件功能</span></span><br><span class="line">        notification = <span class="keyword">new</span> <span class="title class_">EmailNotificationDecorator</span>(notification);</span><br><span class="line">        notification.send(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加短信功能</span></span><br><span class="line">        notification = <span class="keyword">new</span> <span class="title class_">SMSNotificationDecorator</span>(notification);</span><br><span class="line">        notification.send(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式通过定义一对多的依赖关系，使得一个对象状态的改变能够自动通知并更新所有相关对象。它在软件开发中具有广泛的应用，尤其适用于事件驱动系统和需要解耦组件的场景。在Spring框架中，观察者模式通过事件发布和监听机制得到了高效的实现，增强了应用程序的灵活性和可维护性。</p>
<p>尽管观察者模式带来了许多优点，但在使用时也需注意避免过多的观察者导致系统复杂性增加，以及潜在的性能问题。合理地设计和管理观察者列表，确保事件通知的有效性和高效性，是成功应用观察者模式的关键。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/25/kafka%E9%9D%A2%E8%AF%95%E7%AF%87/">消息队列面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-25
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>rocketMq的架构是类似于kafka的，实现了许多kafka没有的功能，但是依旧没有在市场上打败kafka，kafka的性能这么高的原因得益于零拷贝技术。</p>
<p>在传统io方式中是需要经过cpu的，用户调用read()方法，数据通过dma传输到内存缓冲区，然后通过cpu拷贝到用户态的用户缓冲区，得到了用户能见的数据。再通过write()将数据拷贝到操作系统内核态的socket写缓冲区，最后通过网卡发送数据。这个过程一共经历了四次用户态和内核态的切换：</p>
<ol>
<li>系统调用read，用户态-&gt;内核态</li>
<li>dma后，cpu将数据从内核态拷贝回用户态</li>
<li>系统调用write，用户态-&gt;内核态</li>
<li>write方法返回，重新回到用户态</li>
</ol>
<p>以及四次数据的拷贝。</p>
<p><strong>mmap</strong></p>
<p>mmap是一种将内存映射到用户态空间的系统调用。简单来说就是用户态和内核态使用同一片空间，不用进行上下文切换。因此整个流程就会变为：</p>
<ol>
<li>mmap系统调用，用户态-&gt;内核态</li>
<li>dma将磁盘数据写到内核态的缓冲区，返回给用户态，同时用户态也能看到这片缓冲区，可以进行操作。需要进行上下文切换但不用拷贝</li>
<li>操作完了之后系统调用write写到网卡发送，用户态-&gt;内核态</li>
<li>拷贝两次，从内核态缓冲区拷贝到socket缓冲区，再用dma方式写回磁盘或者网卡，最后回到用户态</li>
</ol>
<p>综上所述，总共经历了3次io和四次上下文切换。减少的这一次叫做零拷贝。</p>
<p><strong>sendfile</strong></p>
<p>sendfile不会给用户态返回具体的数据，直接从内核态走socket传输走了。</p>
<ol>
<li>sendfile系统调用，用户态-&gt;内核态</li>
<li>dma拷贝到内核态的缓冲区，这里不会返回给用户态具体的信息，也就是说用户态操作不了，直接拷贝给socket</li>
<li>再从socket拷贝到网卡，返回用户态</li>
</ol>
<p>综上所述，一共两次上下文切换和三次io，对比 mmap+write，主要是没有再用户态进行拷贝。</p>
<p>说了这么多，到底跟kafka和rocketmq有什么关系呢？kafka是基于sendfile的，而rocketmq是基于mmap的，都使用了零拷贝技术，但是由于rocketmq新增了一些高级功能，需要直到具体的数据信息而不是直接发送，就用了能看见数据的mmap方式。kafka为了追求极致性能就没有这些花里胡哨的功能，使用了效率更高的sendfile</p>
<h2 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h2><ul>
<li>异步：不用等待同步操作，把消息扔给mq然后就直接返回，mq连接的另一端会异步进行操作</li>
<li>解耦：可以将业务进行拆分，也是上面异步的思想</li>
<li>削峰：到来的高并发请求先进入mq，类似漏桶限流算法，避免打倒服务器和数据库</li>
</ul>
<h2 id="Kafka的架构"><a href="#Kafka的架构" class="headerlink" title="Kafka的架构"></a>Kafka的架构</h2><p>kafka是基于发布者-订阅者模型的，在这个模型中有发布者，订阅者，broker和服务发现中心。具体到kafka就是producer，consumer，broker，topic，partition，配置中心是zookeeper：</p>
<ul>
<li>broker：就是一个物理上的kafka服务实体</li>
<li>topic：消息是按照主题划分的，例如业务消息和日志消息就可以用两个topic划分</li>
<li>partition：一个topic内也不只有一个队列，这个分区就是队列的意思。需要注意的是kafka在逻辑上是一个整体，但是物理上一个topic内所有分区不一定在同一个broker上。</li>
</ul>
<div style="text-align: center;">
  <img src="../img/kafka/img.png" alt="" />
</div>

<ul>
<li>生产者组：生成消息放入消息队列，是多对多的关系，一个生产者可以生成很多个topic的消息，也可以生成一个topic内多个partition的消息</li>
<li>消费者组：消费的进度用offset表示，消费者组并不会真的把消息队列的信息删除，而是用一个偏移量来表示消费到了哪里。每一个消费者组的偏移量可以是不同的，一般来说一个partition最好只有一个消费者，如果多了的话并发控制也会成为性能影响因素</li>
<li>zookeeper：对于如此庞大规模的kafka集群，实体之间是怎么互相发现对方的？这里使用了zookeeper作为服务发现框架。kafka高度依赖zookeeper</li>
</ul>
<p>kafka为了保证高可用，还有类似主从架构的副本机制，使得某个broker挂了之后，部署在其他地方的partition能够继续工作。总而言之，一个topic多个partition的机制能够使消息分散在多个broker上，实现负载均衡。partition的副本也会保存在不同的机器上。从逻辑上看是整体的，物理上看都不会集中在一块区域。</p>
<h2 id="Kafka的存储机制"><a href="#Kafka的存储机制" class="headerlink" title="Kafka的存储机制"></a>Kafka的存储机制</h2><p>前情提要：一个topic可能横跨多个broker，每一个broker的文件系统只会保存自己实际物理存储的日志。只有通过zookeeper才能看到一个topic的全部分区信息。</p>
<p>在一个broker下，文件信息是这么存储的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;kafka-log-dir&gt;/</span><br><span class="line">    └── &lt;topic-name&gt;/</span><br><span class="line">        └── &lt;partition-number&gt;/</span><br><span class="line">            ├── 00000000000000000000.log        # 日志文件</span><br><span class="line">            ├── 00000000000000000000.index      # 偏移量索引文件</span><br><span class="line">            ├── 00000000000000000000.timeindex  # 时间索引文件</span><br><span class="line">            ├── 00000000000000000001.log        # 下一日志段</span><br><span class="line">            ├── 00000000000000000001.index      # 下一日志段的偏移量索引文件</span><br><span class="line">            ├── 00000000000000000001.timeindex  # 下一日志段的时间索引文件</span><br></pre></td></tr></table></figure>
<ul>
<li>日志段（segment）：一个分区下有多个segment，segment中保存了实际的数据，这些数据的key是offset，每一个segment以当前最小的offset命名。查询的时候通过二分查找找到对应的offset</li>
<li>索引（index）：同时会生成一个与segment同名的索引。保存当前segment下offset的索引信息（类似二级索引），加快日志内的查找速度</li>
<li>时间索引文件：存储offset对应的时间戳，便于根据时间查找信息。</li>
</ul>
<p><strong>生产者</strong></p>
<p>当收到生产者数据的时候，用户态内存接收到之后，会给操作系统内核态的page cache，os再择机刷盘。这个写过程是顺序写，也就是说在对应的分区的最后一个log后面写刚刚的消息。</p>
<p><strong>消费者</strong></p>
<p>消费者消费数据的时候，根据offset先在文件名中二分查找到segment，再用对应的索引来加速搜索。</p>
<p><strong>日志滚动</strong></p>
<p>如果一个segment达到了默认的1GB或者超过了7天没有新增，那就会有一个新的segment</p>
<p><strong>日志删除</strong></p>
<p>可以配置kafka的消息删除时间，这个时候上面的日志索引文件就有用了，通过判断时间戳来删除。在删除过程中会使用copyonwrite以避免有消费者这个时候消费消息。</p>
<h2 id="Kafka如何保证消息不丢失"><a href="#Kafka如何保证消息不丢失" class="headerlink" title="Kafka如何保证消息不丢失"></a>Kafka如何保证消息不丢失</h2><p>消息丢失不是Kafka一个管道能说了算的，可能在生产者传输的过程中丢失，也有可能消费者offset更新完了之后就掉了导致没有真正消费信息。</p>
<ul>
<li>生产者的信息丢失：类似tcp的各种握手，可以使用一个回调函数返回kafka是否接收到了信息，这里最好不要用同步操作get，用异步ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt;开一个线程监听；如果失败了就重传，可以设置重传次数。</li>
<li>消费者的信息丢失：offset默认是消费者接受了这个消息就更新，但是可能会发生拿到消息就掉电导致消息没有实际被消耗。可以采用offset手动更新，在消费者逻辑的最后手动提交offset，这样就能保证消费完了才更新offset</li>
<li>kafka的信息丢失：架构中都有这么多副本在兜底了，但是副本之间不一定时时刻刻都保持同步。设置几个参数就能保证kafka的高可用</li>
</ul>
<blockquote>
<ul>
<li>acks&#x3D;all，表示所有副本都更新完写操作才返回，默认值是1，也就是主节点更新了就返回，但是这样依旧可能造成丢数据问题。因此为了绝对安全可以设置acks&#x3D;all，但是会极大的影响性能。</li>
<li>设置副本数量&gt;&#x3D;3，虽然造成了数据冗余，但是可以保证高可用</li>
<li>设置更新的副本数量&gt;1，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。min.insync.replicas 的默认值为 1 ，在实际生产中应尽量避免默认值 1，是acks&#x3D;all的一种折中</li>
<li>设置 unclean.leader.election.enable &#x3D; false，当发生主从数据不一致的时候，只有完全同步的数据副本才能被选举为leader</li>
</ul>
</blockquote>
<p>kafka是ap架构还cp架构？从上面的各种默认参数来看，比如acks&#x3D;1，默认的时候还是倾向于可用性的，也就是会牺牲一部分一致性。但是经过上面的种种配置之后，就可以使kafka集群是强一致性的，在某些场合下可以灵活改变配置。</p>
<h2 id="生产者向Kafka发送消息的执行流程"><a href="#生产者向Kafka发送消息的执行流程" class="headerlink" title="生产者向Kafka发送消息的执行流程"></a>生产者向Kafka发送消息的执行流程</h2><ol>
<li>配置生产者，一般消息有三个值，topic，key和value（保证顺序的话就要指定partition）。还可以配置acks的参数，reties的次数，配置完这些之后产生一个生产者对象。</li>
<li>序列化消息，将key和value序列化，例如StringSerializer</li>
<li>消息需要选择进入哪个分区，如果key没有配置的话就轮询（RR），如果有的话就hash然后取模</li>
<li>如果配置了批处理，先把消息放在缓冲区，等达到了batchsize再传送</li>
<li>请求压缩：kafka集群主要的瓶颈在网络io而不是cpu，在进入的时候压缩，在出去的时候解压，能够减少网络延迟</li>
<li>当达到了batchsize，根据选择的分区发往broker。根据acks配置的参数返回消息</li>
<li>超时重试</li>
<li>如果有回调函数就会执行</li>
</ol>
<blockquote>
<p>kafka可以在分区内保证顺序，但是消费的整体顺序是无法保证的，如果需要严格的顺序消费，以下有两种方法解决：</p>
<ul>
<li>指定key是相同的，在序列化的时候无法保证不同的key散列取余以后是在同一个分区，如果key是相同的就可以保证在一个分区</li>
<li>key可以不同，指定partition相同就可以了，从根源上解决问题</li>
</ul>
</blockquote>
<h2 id="消费者消费失败会怎样"><a href="#消费者消费失败会怎样" class="headerlink" title="消费者消费失败会怎样"></a>消费者消费失败会怎样</h2><p>消费者会有一个重试次数，如果由于网络导致消费失败，信息不会阻塞，会进入一个死信队列。可以在这个队列里面进一步分析原因，也可以继续消费这个队列的信息。</p>
<p>重试次数默认是10次，并且间隔是0s，也就是立即重试10次，没有消费成功就进入死信队列，不会阻塞下一条信息。</p>
<h2 id="Kafka如何保证不重复消费信息"><a href="#Kafka如何保证不重复消费信息" class="headerlink" title="Kafka如何保证不重复消费信息"></a>Kafka如何保证不重复消费信息</h2><p>如上面所述，即便是手动提交offset还是可能出现重复消费，这个时候只能通过消费者的幂等进行校验了</p>
<p><strong>三种消息投递保证</strong></p>
<ul>
<li>At most once：至多一次，对应上面的消费者自动提交offset，这个时候掉电了这条消息就没有了</li>
<li>At least once：对应手动提交offset，可能会重复多次。需要消费者自己做幂等</li>
<li>Exactly once：消息精确传输一次。这不仅仅依赖于kafka，同时也要消费者的配合。</li>
</ul>
<p>kafka的生产者在发送的时候会用全局唯一id+offset来进行幂等发送，避免因为发送端超时重试而导致重复消费。同时开启事务，确保消息是原子性的。</p>
<p>消费者只会消费已经提交过事务的消息（类似MVCC，未提交事务的信息是有可能回滚的，消费他们有风险）。同时类似At Least once，消费者也需要配合做幂等。</p>
<h3 id="Exactly-Once-的实现机制"><a href="#Exactly-Once-的实现机制" class="headerlink" title="Exactly Once 的实现机制"></a>Exactly Once 的实现机制</h3><ol>
<li><p><strong>生产者的角色</strong>：</p>
<ul>
<li><strong>幂等性</strong>：生产者通过启用幂等性功能（<code>enable.idempotence=true</code>）来确保在发送过程中，每条消息只有一个唯一的 ID。即使发生网络错误或重试，生产者也不会重复发送相同的消息。</li>
<li><strong>事务支持</strong>：生产者使用事务来发送消息。在一个事务中，生产者可以发送多条消息，这些消息在调用 <code>commitTransaction()</code> 之前对消费者是不可见的。如果在发送过程中出现错误，生产者可以调用 <code>abortTransaction()</code>，此时所有消息都将被丢弃，确保没有未提交的消息被消费。</li>
</ul>
</li>
<li><p><strong>消费者的角色</strong>：</p>
<ul>
<li>**配置为 <code>read_committed</code>**：消费者配置为 <code>isolation.level=read_committed</code>，确保只读取那些已成功提交的事务消息。这意味着消费者只会处理生产者通过 <code>commitTransaction()</code> 提交的消息。</li>
<li><strong>手动提交偏移量</strong>：消费者在处理每条消息后手动提交偏移量（<code>commitSync()</code>），以标记这些消息已被成功处理。只有在确认消息处理成功后，才提交偏移量，以避免处理失败导致的重复消费。</li>
<li><strong>实现幂等性处理</strong>：消费者在业务逻辑中需要实现幂等性，以确保即使同一条消息被多次消费，最终的业务效果也应该一致。例如，使用数据库的唯一约束来避免重复插入。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>唯一性保证</strong>：通过生产者的唯一 ID 和事务管理，确保在 Kafka 中发送的消息是唯一的，并且不会因重试而重复。</li>
<li><strong>消费的一致性</strong>：消费者通过手动提交偏移量和实现幂等性来确保消息的消费是唯一的，并且只处理那些已经提交的消息，避免了未提交消息可能引起的回滚和不一致。</li>
<li><strong>消息可见性</strong>：未提交的事务消息对消费者是不可见的，确保了只有经过确认的消息才能被消费。</li>
</ul>
<p>这种机制结合起来，使得在 Kafka 中能够实现 <strong>Exactly Once</strong> 的消息处理语义，从而在关键任务和需要高一致性的数据流动场景中得以应用。</p>
<blockquote>
<p>乱入一下rocketmq</p>
</blockquote>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>阿里的rocketmq参考了kafka的架构，在架构上做减法，在功能上做加法。主要区别有：</p>
<ul>
<li>存储模式：kafka的数据存储是按照segment，一个partition有很多segment，做的是追加写，但是一个broker下面有很多的topic，访问量大起来就不是追加写会退化为随机写。rocketmq发现了这一点，他将所有的queue都放在一个文件上commitlog，而queue只放offset和对应索引。这样就能一直是追加写了</li>
<li>同步模式：按照上面的逻辑，kafka那种replica就不行了，因为kafka是按照partition进行同步和冗余的，partition可以分布在不同的broker上的一个原因就是segment是分开来的。rocketmq把这一点优化了，所以rocketmq是类似redis和mysql那样，以broker为单位进行主从同步</li>
<li>简化协调节点：kafka高度依靠zookeeper，太重了。rocketmq直接用nacos就可以了，作为微服务的一个模块</li>
<li>零拷贝：kafka是sendfile而rocketmq是mmap+write</li>
<li>功能增强：延迟队列，死信队列，按照tag过滤消息，事务</li>
</ul>
<blockquote>
<p>乱入一下elasticsearch，估计问的也不多，简单了解一下</p>
</blockquote>
<h2 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h2><p>微观到宏观，最小单元segment-&gt;shard-&gt;node-&gt;集群。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">服务器实体 (Node 1)                服务器实体 (Node 2)</span><br><span class="line">+---------------------+            +---------------------+</span><br><span class="line">|  Primary Shard 1    |            |  Primary Shard 2    |</span><br><span class="line">|  (Lucene Instance 1)|            |  (Lucene Instance 2)|</span><br><span class="line">|     +-------------+ |            |     +-------------+ |</span><br><span class="line">|     | Segment 1   | |            |     | Segment 3   | |</span><br><span class="line">|     | Segment 2   | |            |     | Segment 4   | |</span><br><span class="line">|     +-------------+ |            |     +-------------+ |</span><br><span class="line">|                     |            |                     |</span><br><span class="line">|  Replica Shard 2    |            |  Replica Shard 1    |</span><br><span class="line">|  (Lucene Instance 3)|            |  (Lucene Instance 4)|</span><br><span class="line">|     +-------------+ |            |     +-------------+ |</span><br><span class="line">|     | Segment 5   | |            |     | Segment 6   | |</span><br><span class="line">|     | Segment 6   | |            |     | Segment 7   | |</span><br><span class="line">|     +-------------+ |            |     +-------------+ |</span><br><span class="line">+---------------------+            +---------------------+</span><br></pre></td></tr></table></figure>
<h3 id="segment"><a href="#segment" class="headerlink" title="segment"></a>segment</h3><ol>
<li>倒排索引：用分词器将每个单词作为键，值为对应的句子id就可以方便关键词查找了</li>
<li>前缀索引：单靠上面的倒排索引查询起来还是很费劲。可以使用前缀树trie完成。放在内存里方便查询</li>
<li>句子实际的存储位置：倒排索引只是放了句子的id，真正的句子存储在这里</li>
<li>一种方便排序和聚合的数据结构：某些时候用户可能想要按照时间排序，但是这些字段放在3中是很不好的，需要回表再去排序。不如直接用空间换时间，将时间信息提取出来单独做一个表</li>
</ol>
<p>以上的四个部分共同构成了一个segment，这是搜索引擎的最小单元。但是由于前缀索引不好进行扩容，可以约定新增几条句子就开辟一个新的segment，同时也解决了读写问题。问题是文件会变多，可以采用定时合并的方法。这样多个segment就构成了lucene（shard）。如果有搜索请求就会并发在所有segment里面进行搜索。</p>
<h3 id="shard"><a href="#shard" class="headerlink" title="shard"></a>shard</h3><p>其实上面的多个segment加起来就是一个lucene，在es中如果只有一个lucene那么读写效率会变得很慢：</p>
<ul>
<li>在垂直上可以参考kafka的topic设置多个index_name，例如分体育新闻和娱乐新闻。一个index对应一个lucene。</li>
<li>在水平上可以将lucene再分小一点，每个段少分一点segment，这就变成了标题所说的shard，本质上shard就是lucene的一个实例。这样读写操作有可能会被分开，提高效率</li>
</ul>
<p>同时为了高可用还未每个shard提供了副本机制，分散在不同的node中</p>
<h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p>一个node就是一个服务器节点，类似kafka的broker，可以放很多不同topic的不同partition，包括副本啥的。这里就会要一个类似zookeeper的服务发现中心，但在es里是去中心化的，通过raft协议选举。</p>
<p>node有很多职责，有负责管理集群的（类似哨兵负责故障转移和选主），有存储数据的。有实现restful接口的，在集群环境下可以分开。每一个node负责不同的职责。</p>
<p><strong>数据如何查找</strong></p>
<ol>
<li>客户端发送rest的http请求给集群中负责接收的node</li>
<li>在指定index_name下hash分片找到对应的shard</li>
<li>在shard中并行查找segment</li>
<li>segment根据倒排索引找到对应句子的id返回</li>
<li>再去根据id进行回表，找到句子返回</li>
</ol>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/22/Mysql%E9%9D%A2%E8%AF%95%E7%AF%87/">Mysql面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-22
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="Mysql的数据结构"><a href="#Mysql的数据结构" class="headerlink" title="Mysql的数据结构"></a>Mysql的数据结构</h2><ul>
<li>数字型：整型（tinyint,smallint,int,bigint），浮点型（float,double），定点型（decimal）</li>
<li>字符串：char，varchar，tinytext，text，mediumtext，longtext，tinyblob，blob，mediumblob，longblob</li>
<li>日期：date，timestamp</li>
</ul>
<blockquote>
<p>定点型是指定小数点后几位的。char是定长的，varchar是可变的，一般设计的是最大长度。如果超过长度char是需要修改表结构的。而且相同字符串在存储层面两者是相同的。但是varchar内存占用稍高，某些高级操作是需要遍历。</p>
</blockquote>
<h2 id="Mysql查询流程"><a href="#Mysql查询流程" class="headerlink" title="Mysql查询流程"></a>Mysql查询流程</h2><ol>
<li>连接器：连接客户端的http请求，校验用户名密码</li>
<li>查询缓存，如果缓存里面有就直接返回（这里在8版本就废弃了，因为命中率实在太低了）</li>
<li>词法分析语法分析</li>
<li>执行器：包括预处理，例如将*换成表的字段；优化器，选择效率较高的执行计划执行，能用索引就不用全表扫描；执行器，执行sql然后返回结果给客户端</li>
</ol>
<h2 id="InnoDB和MyISAM"><a href="#InnoDB和MyISAM" class="headerlink" title="InnoDB和MyISAM"></a>InnoDB和MyISAM</h2><ol>
<li>事务</li>
<li>行级锁</li>
<li>索引</li>
<li>支持外键</li>
<li>崩溃恢复redolog</li>
</ol>
<h2 id="InnoDB的存储形式"><a href="#InnoDB的存储形式" class="headerlink" title="InnoDB的存储形式"></a>InnoDB的存储形式</h2><p>众所周知InnoDB存储数据的数据结构是B+树，其中树的节点就是数据页。</p>
<p>数据页内部：</p>
<p>一个数据页上会有多条记录，对应着实际的记录。在数据页内部是按照主键id顺序排列的。除此之外还有一个页目录，将顺序排列的某些记录归为一个槽。例如一个数据页有12345，可能12是一个槽，345是另一个，槽只保存最大的那个节点。当搜索的时候，比如我要搜索4，由于4大于12这个页的最大值2，所以会在345里面搜索。这个时候需要遍历的成本就低很多了。一般来说槽只会包含不超过8条记录。使用二分法找到这个槽，然后在在这个槽进行遍历。页目录只是为了加快在页内的查找速度。实际上每一个页里面记录也是通过链表串起来的。对外只会暴露当前页主键最大值和最小值。方便b+树的查找。</p>
<p>B+树：</p>
<p>b+树与b树的不同点在于，b+只有底层真正存储数据，b树在非叶子节点也会存储数据。而且b+底层是一个双向链表，可以方便进行范围查询。对于innoDB而言，为索引节点还是数据节点根据页头的某个字段决定。索引节点中存储着下一个表对应的最小主键。我们可以把查找一次当作一次io，由于索引节点能存储的数据是很多的，千万级别的数据最多也不过三四层，也就是说io次数会很小。b+树的缺点是会由于添加数据导致分裂，影响性能。</p>
<blockquote>
<p>InnoDB默认得要一个索引，可以不显式的给出，但是背后隐藏列会默认出一个索引作为数据页的排序参照</p>
</blockquote>
<h2 id="为什么用B-树而不是B树，红黑树或者跳表"><a href="#为什么用B-树而不是B树，红黑树或者跳表" class="headerlink" title="为什么用B+树而不是B树，红黑树或者跳表"></a>为什么用B+树而不是B树，红黑树或者跳表</h2><ul>
<li>b树：由于非叶子节点也会存储数据，那么就没有b+树存储数据多。查询的效率也不稳定，可能在非底层就查询到数据了。而且不是双向链表，范围查询做不到</li>
<li>红黑树：也是二叉树，io次数肯定比b+树多，跳表同理</li>
<li>哈希表：不支持范围查询，这同样是redis为什么用跳表而不是哈希表的理由</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是为了加快搜索而建立的数据结构</p>
<ul>
<li>按照数据结构划分：B+树索引，Hash索引</li>
<li>物理存储划分：聚簇索引（叶子节点是数据），非聚簇索引（叶子节点存的是主键id，后续还要回表去聚簇索引找）</li>
<li>字段特性：主键索引，唯一索引（建立在唯一字段上的索引），普通索引，前缀索引（查电话号码）</li>
</ul>
<blockquote>
<p>唯一索引：create unique index index_name on table(index_column_1)</p>
<p>普通索引：create index index_name on table(index_column_1)</p>
<p>前缀索引：create index index_name on table(length(index_column_1))</p>
</blockquote>
<ul>
<li>字段个数：单列索引，联合索引</li>
</ul>
<blockquote>
<p>联合索引：create index index_name on table(index_column_1,index_column_2)</p>
</blockquote>
<h2 id="联合索引范围查询"><a href="#联合索引范围查询" class="headerlink" title="联合索引范围查询"></a>联合索引范围查询</h2><p><strong>select * from t_table where a &gt; 1 and b &#x3D; 1</strong></p>
<p>这里只会用到a一个索引，因为只有a能缩小范围，b是无序的，无法缩小范围。如果没有索引下推只能一个个回表通过b进行筛选</p>
<p><strong>select * from t_table where a &gt;&#x3D; 1 and b &#x3D; 1</strong></p>
<p>这里会用到两个索引，因为a&#x3D;1的时候b是有序的，b能够缩小范围</p>
<p><strong>select * from t_table where a between 1 and 2 and b &#x3D; 1</strong></p>
<p>mysql中between是左闭右闭区间，所以两个都能用</p>
<p><strong>select * from t_table where a like ‘m%’ and b &#x3D; 1</strong></p>
<p>mysql中between是左闭区间，所以b也能用</p>
<h2 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h2><blockquote>
<p>什么时候无法使用索引？就是通过某些手段找不到原先的顺序了</p>
</blockquote>
<ul>
<li>左或左右模糊匹配：例如%like和%like%，索引在这个字段上是根据最左匹配的，如果第一个字符都不知道，那后续的就是无序的了</li>
<li>对索引使用函数：例如count()某个索引，这个时候也是走不了的，因为count不是一个索引</li>
<li>对索引进行表达式计算：只要是在等号左边的也用不了，mysql没做这部分优化</li>
<li>对索引隐式类型转换：在mysql中字符串会自动变成数字进行比较，索引当索引为字符串，而查询的时候用id&#x3D;1来比较，会自动类型转换，相当于索引使用了隐式函数变成数字于查询条件进行比较</li>
<li>联合索引非最左匹配：联合索引（a,b,c）如果查询条件只有b，c，就不会走索引。但是如果是ac还是可以走a的索引，如果有索引下推的话在二级索引可以通过判断c减少回表次数；如果没有就只能用a减少判断，最后回到server也就是索引是id的那个表中一个个判断c，这样会有很多回表</li>
<li>where子句中的or：如果只有一个条件是有索引，那就会失效，因为在or条件下只用满足一个就可以了</li>
</ul>
<h2 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h2><p>首先是事务的ACID四个特性：</p>
<ul>
<li>原子性：事务内的东西是同时完成或者同时取消的。innodb的事务可以做到，redis的事务就没有原子性。</li>
<li>一致性：事务完成前后，由一个一致的状态转移到另一个一致的状态。例如银行转账两个账户600+800，转账后总数是不能变的</li>
<li>隔离性：并发导致的事务之间应该隔离，一个人购买商品的事务不应该影响另一个人的购买</li>
<li>持久性：持久化下来，掉电也不会丢失</li>
</ul>
<p>InnoDB的持久性是通过redolog完成的，原子性是undolog，隔离性是MVCC完成的，一致性是上面三者都完成后就会保证一致性。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul>
<li>脏读：一个事务还没有提交，别的事务就能看到它的修改了。例如事务1修改了余额，事务2读取了这部分，但是事务1触发回滚，这就导致事务2读到了脏数据。</li>
<li>不可重复读：在一个事务内读取两次数据，两次数据读取的不一样。这通常是由于另一个事务的提交，这个数据对于其他事务都是可见的（有点像volatile）</li>
<li>幻读： 查询数量，事务内前后查询两次不一致，像发生了幻觉</li>
</ul>
<p>事务隔离级别：</p>
<ul>
<li>读未提交：</li>
<li>读提交：解决脏读</li>
<li>可重复读：解决脏读+不可重复读</li>
<li>串行化：解决幻读+不可重复读+幻读</li>
</ul>
<h2 id="MVCC（多版本并发控制）"><a href="#MVCC（多版本并发控制）" class="headerlink" title="MVCC（多版本并发控制）"></a>MVCC（多版本并发控制）</h2><p>在前面讲的记录中有两个隐藏字段：添加该条记录的事务id和指向上一个版本undolog指针。MVCC是依靠这两个字段完成的，更新数据时会在数据页中替换新的记录，然后将旧的记录作为指针保存下来，这时所有的版本都连成一条链，包含了当时进行更新的事务id。</p>
<p>MVCC提供了ReadView这个数据结构，由于事务id是顺序递增的，ReadView将事务id分为三个部分，已经提交的事务，正在进行的事务和没有发生的事务。已经提交的事务是有访问权的，正在运行的事务是不允许查看的，此时如果发生并发现象，查询数据的时候会根据这三个范围和当前全部的事务id进行过滤，这样就能避免读到还没有提交事务的数据。从而解决了脏读问题</p>
<p><strong>MVCC是如何解决不可重复读的</strong></p>
<p>主要是ReadView生成的时机问题，如果每一次快照读都生成一个ReadView，有可能在两次快照读期间有别的事务提交了，这两次的ReadView范围就会不一样，还是会发生不可重复读。但是如果在事务刚开始的时候就生成ReadView，就能保证执行下来的可见性，即使在第二次读之前，在readview中的那个事务提交了，还能保证接下来的读操作不可见这个数据。</p>
<p><strong>MVCC解决了幻读吗</strong></p>
<p>在默认隔离级别下的innoDB很大程度能够避免幻读，范围查询也需要看版本号。在某些情况下还是能出现幻读，例如当前没有s&#x3D;5的数据，此时进行查询是没有的，另一个事务添加了这条数据，此时事务id在readview里面，是不允许访问的。但是原来事务又更新了这条数据，现在事务id是自己的了。下次查询的时候就会查询出来。（虽然更新一条不存在的数据逻辑上很诡异）</p>
<p>需要通过间隙锁才能解决幻读，也就是锁住一段范围内的，其他事务添加这段范围内的数据就会被阻塞。</p>
<h2 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h2><p>前面所讲的数据库事务的ACID中，持久性就是由redolog保证的。mysql在更新的时候先写redolog，然后再在合适的实际将redolog真正写在数据页上。首先读取操作的时候不会每次都从磁盘io，会缓存在buffer pool中，那么写操作也会在buffer pool中操作，此时就变成了一个脏页。redolog的左右就是把这个脏页的操作记录并持久化下来，这个过程是比刷数据页要快的，很多时候查询的并不是顺序读，有可能在很多数据页上。</p>
<p><strong>刷盘时机:</strong></p>
<p>redolog也是有缓冲区的，把buffer pool中的修改保存在redolog缓存区中，然后再在合适的时机刷盘，一般有以下几个时机：</p>
<ul>
<li>mysql正常关闭</li>
<li>后台线程会每隔1s刷盘</li>
<li>当缓冲区满了一半就触发</li>
<li>根据刷盘策略</li>
</ul>
<p>刷盘策略有以下三种：</p>
<ul>
<li>每次事务提交只写在缓冲区中，但是如果在1s内掉电，redolog buffer就会没有了，这种策略可能会掉最多1s的数据</li>
<li>每次事务提交直接写磁盘，效率较低，但是安全</li>
<li>每次事务提交给操作系统的page cache，交给操作系统写。这种情况如果mysql停机了还是能写，因为操作系统没有停止，但是如果掉点了还是会丢1s的数据，算是上面两种的一个折中。</li>
</ul>
<div style="text-align: center;">
  <img src="../img/Mysql/img_16.png" alt="" />
</div>

<p><strong>日志文件组：</strong></p>
<p>redolog不是一个文件，而是多个文件，这些文件按照环形存储，会覆盖。头指针是checkpoint，尾指针是write pos。每次有缓冲区来的数据就移动pos。如果mysql进行了redolog到数据块的持久化，checkpoint就往后移动。</p>
<p>如果这个环形文件满了，就需要阻塞mysql，进行部分redolog到数据页的操作。</p>
<p><strong>总结：</strong></p>
<p>redolog保证了mysql的持久性，这种操作比直接修改数据页要高效，由于直接修改数据页可能会存在随机写的情况，而redolog是追加写，就好像每次找东西随机写就是看目录找书页，而追加就是往后翻一页。</p>
<p>然而redolog在某些策略下也不是万无一失的，因为redolog也是有缓存的，如果没有及时写在磁盘里就会丢失1s的数据。</p>
<blockquote>
<p>由此可见redolog和真正存在数据页中还有一段时间差，那这个时候来了一个读请求，怎么保证一致性？<br>会在buffer pool找，而不是直接去磁盘找，本来redolog就是为了存buffer pool的脏页的，是内存同步到外存，</p>
</blockquote>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>binlog是解决主从同步的一种日志形式，只记录写操作，select和show是不记录的。有三种格式形式：</p>
<ul>
<li>statement：只记录更新的语句，不管前后状态，一般存储的数据量较小</li>
<li>row：不光记录更新的具体语句，更新前后的状态也保存，一般用在需要计算的sql语句，例如now()，用第一种方式就会造成数据不一致，第二种会保存在主机上面的结果。当然存储的数据量会更大</li>
<li>mix：根据具体sql的形式选取策略，例如正常sql就用statement，涉及到计算的就用row</li>
</ul>
<p><strong>刷盘方式：</strong></p>
<p>与redolog类似，也有一个缓冲区，但是binlog的缓冲区线程之间是独立的，最终都要写进磁盘。</p>
<ul>
<li>0：不同线程的binlog buffer写到page cache里面，由操作系统写回</li>
<li>1：直接写到磁盘</li>
<li>n：n个线程的binlog buffer写到page cache后触发一次写到磁盘。掉电就丢失n个线程的数据</li>
</ul>
<h2 id="binlog就够了为什么还需要redolog"><a href="#binlog就够了为什么还需要redolog" class="headerlink" title="binlog就够了为什么还需要redolog"></a>binlog就够了为什么还需要redolog</h2><p>binlog主要负责主从同步，redolog负责恢复数据库。一个是外部机制，一个是内部机制，两者独立但是互补，服务于不同的需求。</p>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>如果在binlog和redolog之间出现问题就会导致数据不一致。所以需要两阶段提交</p>
<div style="text-align: center;">
  <img src="../img/Mysql/img_17.png" alt="" />
</div>

<p>写redo的时候设置为prepare，等到binlog写完了才设置为commit状态。mysql认为binlog写完了就是一个事务结束，即便没有再设置redolog的状态。</p>
<p>例如在写完redolog时宕机，binlog没有写，这个时候就会触发回滚；但是写完了binlog宕机了，redolog没有被改变为commit，还是会被认为事务提交了</p>
<p><strong>存在什么问题：</strong></p>
<ul>
<li>多线程下需要原子性</li>
<li>如果是“双1配置”，一个事务io两次</li>
</ul>
<h2 id="Mysql的锁"><a href="#Mysql的锁" class="headerlink" title="Mysql的锁"></a>Mysql的锁</h2><ol>
<li>数据库锁：只有在进行数据库备份或者迁移的时候才会用</li>
<li>表级锁：表级读锁写锁，读写意向锁，自增锁，元数据锁</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>IX</td>
<td>不兼容</td>
<td>兼容</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td>不兼容</td>
<td>不兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IS</td>
<td>不兼容</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<blockquote>
<p>解释一下：IX表示表内已经有行在进行X操作了，此时不允许全局上锁，所以全局X和S都不允许；全局X的条件是里面没有任何一个在进行读写操作，所以与所有都不兼容；IS和IX能兼容是因为都只是作为指示作用，IS和IX可能锁住的列不一样，他们的存在只能影响全局锁。<br>3. 行级锁：记录锁（锁住id&#x3D;1这条记录），间隔锁（锁住（2，5）区间的），临键锁（锁住（2,5]）</p>
</blockquote>
<h2 id="Mysql什么时候上锁"><a href="#Mysql什么时候上锁" class="headerlink" title="Mysql什么时候上锁"></a>Mysql什么时候上锁</h2><p>执行select for update或者update的时候，在事务执行范围内会上一个对当前事务有效的锁，一般锁的单位是<strong>临键锁</strong>，在某些情况下会退化成记录锁或者间隔锁。这一部分的提出正是为了解决。</p>
<p><strong>唯一索引等值查询</strong></p>
<ol>
<li>select * from user where id &#x3D; 1 for update;如果有id&#x3D;1这条记录，临键锁就会退化为记录锁，只锁住当前这个id&#x3D;1，因为这样就不会有别的事务来进行更改避免不可重复读</li>
<li>select * from user where id &#x3D; 1 for update；如果没有id&#x3D;1这条记录，就会退化为间隔锁，找到最近的两个区间例如（0，3）锁住这段，不允许添加数据避免幻读</li>
</ol>
<p><strong>唯一索引范围查询</strong></p>
<ol>
<li>select * from user where id &gt; 15 for update;如果有id&#x3D;20的记录，那就会加锁(15,20]，(20,INf]</li>
<li>select * from user where id &gt;&#x3D; 15 for update;如果有id&#x3D;15，加锁15，(15,20]，(20,INf]</li>
<li>select * from user where id &lt; 6 for update;如果有id&#x3D;1,5,10的记录，加锁(-INF,1],(1,5],(5,10)</li>
<li>select * from user where id &lt;&#x3D; 5 for update;(-INF,1],(1,5]</li>
</ol>
<p><strong>非唯一索引等值查找</strong></p>
<p>只用记住一点，非唯一索引是按照大小排序的，索引值相同再按照id升序排序。{(15,14),(25,20)}，锁住非唯一索引（15，25），如果新增的值在其中就不允许插入，如果&#x3D;15且id&gt;14也是不允许的，右边同理。</p>
<h2 id="Mysql死锁"><a href="#Mysql死锁" class="headerlink" title="Mysql死锁"></a>Mysql死锁</h2><div style="text-align: center;">
  <img src="../img/Mysql/img_18.png" alt="" />
</div>

<p>由于间隙锁是可以重复的，两边都锁住了不允许添加。</p>
<h2 id="慢sql"><a href="#慢sql" class="headerlink" title="慢sql"></a>慢sql</h2><p><strong>产生慢sql的原因</strong></p>
<ol>
<li>索引未生效或者根本没有索引，导致全表扫描</li>
<li>数据量太大了，加索引都不行。这个时候就要考虑分库分表了</li>
<li>sql书写不当，过多的join操作或者子查询过多，子查询会产生一张新表；或者是深度分页；用了比较长的排序</li>
<li>数据量比较大的时候，redolog满了，在更新checkpoint的时候会阻塞</li>
<li>等待行级锁</li>
</ol>
<p><strong>如何发现慢sql</strong></p>
<ol>
<li>mysql自己可以开启慢sql查询日志，将查询时间大于1s的记录下来</li>
<li>预防慢sql，做全局sql扫描。阿里的<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/LZRSQJufGRpRw6u4h_Uyww">这篇文章</a>提到了可以使用JVM的沙箱模型。相当于一个大的aop模型（值得一提的是gclib也是跟这个原理类似），通过在实例前后进行监听就可以无侵入式地录制HTTP&#x2F;Java&#x2F;Dubbo入参&#x2F;返回值，业务系统无感知。基于这个能力，我们可以方便的采集和SQL执行相关的Java方法参数以及返回值。通过配置采集点，来采集执行sql的java代码的相关方法、参数和返回值，辅助实现sql采集功能。</li>
</ol>
<p><strong>如何识别高危sql</strong></p>
<ul>
<li>不符合规范的sql：不允许使用外键，深度分页优化，子查找过多，有*</li>
<li>用explain观察，row字段过多需要优化，type字段是否使用索引，extra是否有排序操作，以及是否索引下推，索引覆盖。</li>
</ul>
<h2 id="常见的sql优化手段"><a href="#常见的sql优化手段" class="headerlink" title="常见的sql优化手段"></a>常见的sql优化手段</h2><ol>
<li>避免使用*：因为在查询的过程中还有一个预处理过程，可以自己写的就不要交给sql去查询，而且无法使用覆盖索引，也就是不用回表</li>
<li>深度分页优化：比如有1000000页，查询这个页的时候就是深度分页了。可以用子表查询这个页的第一条记录，然后再去查比这个大的10条记录作为范围。有两个缺点，首先是id必须自增，其次是子表查询不推荐</li>
<li>避免多join，避免使用外键</li>
<li>优化慢sql</li>
<li>正确使用索引：选择合适的字段创建索引（不为NULL的字段，频繁查找但是不是频繁增删的字段）；避免索引失效；考虑在字符串上建立前缀索引；避免冗余索引</li>
</ol>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/19/%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%88%B7%E9%A2%98/">一句话刷题</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-19
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <ul>
<li><strong>无重复字符的最长字串</strong>：滑动窗口+heshset，右窗口需要在for外，每轮循环移动右窗口</li>
<li>LRU缓存机制：偷懒直接linkedHashMap，hashmap长度并不为cachesize，重写替换条件为size&gt;cachesize，构造函数要传一个允许get后重排序的boolean</li>
<li>反转链表：pre,p,q三指针</li>
<li>数组第k个最大元素：快排思想，根据每次划分的结果二分查找</li>
<li>最大子数组和：动态规划，看前面的是否为负数，为负数就抛弃自己作为开头，为正数就自己加上</li>
<li>合并两个有序链表：模拟题</li>
<li><strong>最长回文字串</strong>：二维动态规划，撇去前后剩下的也是回文子串</li>
<li>两数之和：hashmap存余数</li>
<li>二叉树层次遍历：queue秒杀，记得最牢的一集</li>
<li>搜索旋转排序数组：随便划分总有一段是顺序的</li>
<li>岛屿数量：dfs上下左右</li>
<li>全排列：dfs回溯，visited数组</li>
<li>有效的括号：stack秒了</li>
<li>二叉树的最近公共祖先：回溯，找两个列表的最末尾相同元素</li>
<li>环形链表：hashmap看是否包括</li>
<li>反转链表2：模拟</li>
<li><strong>最长递增子序列</strong>：动态规划，找前面每一个比自己小的，取最大值+1</li>
<li>字符串相加：太简单不说</li>
<li><strong>接雨水</strong>：单调栈，左-&gt;右和右-&gt;左，取最小值</li>
<li><strong>编辑距离</strong>：二维动态规划，需要考虑左右对角线三个，对角线（相同），左右对角线取最大+1（不相同）</li>
<li><strong>最长公共子序列</strong>：二维动态规划。比上面的好理解，对角线的+1（相同），左右取最大（不相同）</li>
<li>栈实现队列：两个栈来回倒，一个入一个出，在入之前检查出是否为空，反之亦然</li>
<li>括号生成：左右括号剩余数量判别，右边的数量一定得大于等于左边剩余</li>
<li>反转字符串中的单词：split和stringbuilder</li>
<li>二叉树的锯齿状层次遍历： 基本上就是普通的层次遍历，用reversed就可以倒转。</li>
<li>环形链表2：哈希表存节点，遍历的时候同时检车哈希表是否含有</li>
<li>二叉树右视图：层次遍历</li>
<li>子集：回溯，以1234为例，依次增加子集的元素个数</li>
<li>组合总和：回溯，每次dfs都是传剩余，递归终止条件是剩余&lt;0，&#x3D;0就添加一条，最后会有重复，需要一个排序+hashset去重</li>
<li><strong>分割回文串：</strong> 两步走：首先二维动态规则找到所有的回文字串；再类似prim算法遍历dp数组回溯</li>
<li>单词搜索：回溯，上下左右依次dfs，条件全为或，有一个为真就会是真</li>
<li>找到字符串中所有字母异位词：哈希表（偷懒方法，滑动窗口每一个与目标字符串数组进行比较，用toCharArray和Arrays.sort和equals）</li>
<li>电话号码的字母组合：哈希表写一个键盘集合，然后回溯</li>
<li>重排链表：快慢指针找中点（奇数得在正常中点的后面一个）+后半部分倒转链表+双指针连接</li>
<li>旋转图像：沿着左下右上对角线对调，然后按行按照中线对调</li>
<li>搜索二维矩阵2：四个指针上下左右，逐步缩小范围，当循环内不再发生改变就为真</li>
<li>腐烂的橘子：多源bfs，跟二叉树的层次遍历差不多</li>
<li>课程表：拓扑排序，先记录所有点的入度，每次都找到入度为0的点，如果最后还有入度不为0的说明有环</li>
<li>从前序与中序遍历序列构造二叉树：经典题目，要时不时写一下</li>
<li>实现前缀树：Trim[26]数组，要用一个isend区分是前缀还是单词</li>
<li>有序数组转化为二叉搜索树：二分+递归</li>
<li><strong>单词拆分：</strong> 动态规划，当dp[j] &#x3D;&#x3D; 1 &amp;&amp; hashset.contains(s.subString(i,j))时dp[i]&#x3D;1，字符串在字典里当且仅当划分的两部分应该也在字典里</li>
<li>打家劫舍：经典dp题目，有两种策略，不抢的时候选择上一个两种情况中最大的，抢的时候前一个只能不抢。</li>
<li><strong>最大正方形：</strong> 二维dp，dp[i][j]表示以ij为左下角的最大正方形，取左，上，对角线三个里面最小的。</li>
<li>最小路径和：二维dp入门题目，看一眼肯定会</li>
<li><strong>零钱兑换：</strong> dp数组长度为钱的多少，dp表示当前钱兑换的最少次数。每次往后移动都需要首尾指针一起动</li>
<li><strong>排序链表：</strong> 菜就多练</li>
<li>两数相加：两个链表做加法，太简单了不说，还有个2，就是反转之后相加</li>
<li>k个一组翻转链表：虽然是hard但是很简单，思路一定要清晰</li>
<li><strong>二叉树的最大路径和</strong>：树形dp，用一个全局变量保存全局最大路径和，返回的时候需要判断子树是否为负数，如果都为负数就返回自己，只要有一个是正数就返回自己+正数</li>
<li>二叉树的直径：跟上面思路是一样的，但是dp返回的是当前树的高度，也是用全局变量保存最大值</li>
<li>打家劫舍3：树形dp，根节点抢了子节点都不能抢了，取其中dp[0]的和再加自己的，不抢就找dp[0]和dp[1]中较大的那个</li>
<li>求根到叶子节点数字之和：深度和广度+回溯</li>
<li>路径总和：回溯</li>
<li><strong>字符串解码：</strong> 双栈，存数和字符串，遇到]后进行循环拼接，再将前面的依次出栈直到[</li>
<li>最长连续序列：首先set去重，然后遍历，如果有比当前元素小的就跳过，也就是说每次都找一段里面最小的元素。然后用一个全局变量保存最大的。</li>
<li>最长公共前缀：按列遍历，注意长度是否超出</li>
<li>螺旋矩阵：上下左右四个指针，需要注意只有一列或者一行的情况，在循环的过程中要保持上下界左右界不越界</li>
<li>合并K个升序链表：两两合并即可，或者每次都找最小节点</li>
<li>删除链表的倒数第N个节点：栈先进后出</li>
<li>复制ip地址：回溯，但是还有一点边界没搞明白</li>
<li><strong>二叉树的最大宽度</strong>：新建一个内部类，保存编号，左节点是<em>2，右节点是</em>2+1，按层次遍历，找出一层内编号差最大的。</li>
<li>对称二叉树：递归比较左子树和右字数</li>
<li><strong>每种字符至少取k个</strong>：反向思维，滑动窗口。先哈希表存所有元素的个数，然后再-k，r随着循环移动，移动一次对应元素个数-1，当哈希表内出现负数元素，左边指针移动并且释放元素直到哈希表内都不为负数。最后取出最大的那次</li>
<li><strong>最小覆盖字串</strong>：滑动窗口，首先哈希表保存目标字符的个数。r随着循环移动，每次都从哈希表减去对应字符的个数，如果不在哈希表就跳过。如果哈希表所有元素都小于等于0（也就是说集齐了所有，这里有可能比原来多），那么就记录这个长度，左边指针开始动直到再一次没有集齐元素</li>
<li>二叉树的最大深度：左右子树求最大，dp</li>
<li>平衡二叉树判断，返回一个数组，[0]是高度，[1]是是否平衡</li>
<li>岛屿的最大面积：dfs没什么好说的</li>
<li><strong>N皇后</strong>：终极回溯题，上下和两侧的对角线都不能有元素重复。设置四个visited数组，然后每一行开始尝试放q，如果能进行到最后一行那就保存，其余就是回溯操作</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/19/hot100%E5%A4%A9%E5%A4%A9%E5%88%B7-%E7%AC%AC%E4%B8%80%E6%9C%9F/">hot100天天刷-第一期</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-19
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>记住大概的方法就行了</p>
</blockquote>
<h2 id="1-无重复字符的最短字串（滑动窗口）"><a href="#1-无重复字符的最短字串（滑动窗口）" class="headerlink" title="1.无重复字符的最短字串（滑动窗口）"></a>1.无重复字符的最短字串（滑动窗口）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">原题：</a>给定一个字符串，找出不含有重复字符的最长<strong>字串</strong>（字串是连续的）。</p>
<p>滑动窗口：主要思想是随着左边窗口的移动，右边窗口也一定会向右边移动。每一次循环找的都是以charAt(i)开头的最长字串。由于i在增加，在每次移动的同时保存最长字串的长度就是结果。</p>
<p>判断是否重复：当右指针遍历到hashset含有的元素就停止右移。为了保证i移动的同时，后续字符都是以i这个元素开头的，当前循环结束以后需要把charAt(i)从hashset剔除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">//检查重复性</span></span><br><span class="line">    HashSet&lt;Character&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//p是最右边的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">//p一直向右边移动，直到碰到set里面有的元素，就进行下一次大循环</span></span><br><span class="line">        <span class="keyword">while</span> (p &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hashSet.contains(s.charAt(p)))&#123;</span><br><span class="line">                hashSet.add(s.charAt(p));</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//留一个max来返回最大值</span></span><br><span class="line">        max = Math.max(max,hashSet.size());</span><br><span class="line">        <span class="comment">//在下一次大循环前保证set只有当前元素以后的，所以要把上一个元素从set删除</span></span><br><span class="line">        hashSet.remove(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-最长回文字串（二维动态规划）"><a href="#2-最长回文字串（二维动态规划）" class="headerlink" title="2.最长回文字串（二维动态规划）"></a>2.最长回文字串（二维动态规划）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/">原题：</a>给你一个字符串，找到最长的回文字串。</p>
<p>动态规划：回文子串的性质是，把最开始和最末尾的元素删除还是一个回文字串。状态转移方程为<br>$$<br>dp[i][i] &#x3D; 1<br>$$<br>$$<br>dp[i][j] &#x3D; dp[i+1][j-1] \land (S_{i} &#x3D;&#x3D; S_{j})<br>$$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对角线上的元素都为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//沿着对角线逐渐增大，而不是根据表格行列遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; s.length(); k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//字串长度为2的时候单独考虑</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//aa，bb这种字串</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(i+k))&#123;</span><br><span class="line">                    dp[i][i+k] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//循环外部变量保存最大值和起始点和重点，因为返回的是具体的字串，需要调用substring</span></span><br><span class="line">                    <span class="keyword">if</span> (length &lt; k+<span class="number">1</span>)&#123;</span><br><span class="line">                        length = k+<span class="number">1</span>;</span><br><span class="line">                        head = i;tail = i+k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//其余长度</span></span><br><span class="line">            <span class="comment">//只有dp[i+1][i+k-1]为回文字串且[i]和[i+k]相同的时候才是一个回文字串</span></span><br><span class="line">            <span class="keyword">if</span> (i+k &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(i+k) &amp;&amp; dp[i+<span class="number">1</span>][i+k-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][i+k] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (k+<span class="number">1</span> &gt; length)&#123;</span><br><span class="line">                    length = k+<span class="number">1</span>;</span><br><span class="line">                    head = i;tail = i+k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(Arrays.deepToString(dp));</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(head,tail+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-最大子数组和（动态规划）"><a href="#3-最大子数组和（动态规划）" class="headerlink" title="3.最大子数组和（动态规划）"></a>3.最大子数组和（动态规划）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">原题：</a>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>动态规划：pre表示的是i之前的最大子数组和的最大值.如果pre是负数，那就相当于拖nums[i]后腿了，与其加上前面的不如自己作为开头。状态转移方程：</p>
<p>$$f(i) &#x3D; max ( f(i-1)+nums[i],nums[i] ) $$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        pre = Math.max(pre+nums[i],nums[i]);</span><br><span class="line">        max = Math.max(max,pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-最长公共子序列（二维动态规划，与dp-i-1-j-1-dp-i-1-j-dp-i-j-1-有关）"><a href="#4-最长公共子序列（二维动态规划，与dp-i-1-j-1-dp-i-1-j-dp-i-j-1-有关）" class="headerlink" title="4.最长公共子序列（二维动态规划，与dp[i-1][j-1],dp[i-1][j],dp[i][j-1]有关）"></a>4.最长公共子序列（二维动态规划，与dp[i-1][j-1],dp[i-1][j],dp[i][j-1]有关）</h2><blockquote>
<p>这道题和编辑长度是一个类型的</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">原题：</a>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>需要考虑dp[i-1][j-1],dp[i-1][j],dp[i][j-1]，所以dp[][]要多一行一列，状态转移方程：</p>
<ul>
<li>text1.charAt(i) &#x3D;&#x3D; text2.charAt(j):$dp[i][j] &#x3D; dp[i-1][j-1]+1$</li>
<li>text1.charAt(i) !&#x3D; text2.charAt(j):$dp[i][j] &#x3D; max(dp[i-1][j],dp[i][j-1])$</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="comment">//二维动态规划</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length()+<span class="number">1</span>][text2.length()+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][dp[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-编辑距离（二维动态规划，与dp-i-1-j-1-dp-i-1-j-dp-i-j-1-有关）"><a href="#5-编辑距离（二维动态规划，与dp-i-1-j-1-dp-i-1-j-dp-i-j-1-有关）" class="headerlink" title="5.编辑距离（二维动态规划，与dp[i-1][j-1],dp[i-1][j],dp[i][j-1]有关）"></a>5.编辑距离（二维动态规划，与dp[i-1][j-1],dp[i-1][j],dp[i][j-1]有关）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">原题：</a>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p>
<p>与上面那个很相似，如果两个字符是相同的话就看dp[i-1][j-1]，但是不同的话也需要看dp[i-1][j-1]，因为即便字符不同也可以通过替换解决。状态转移方程为：</p>
<ul>
<li>text1.charAt(i) &#x3D;&#x3D; text2.charAt(j):$dp[i][j] &#x3D; dp[i-1][j-1]$</li>
<li>text1.charAt(i) !&#x3D; text2.charAt(j):$dp[i][j] &#x3D; min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1$</li>
</ul>
<p>还有不同的就是初始化边缘不再都是0了，根据插入字符的数量决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length()+<span class="number">1</span>][word2.length()+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(Arrays.deepToString(dp));</span></span><br><span class="line">    <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][dp[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/17/Redis%E9%9D%A2%E8%AF%95%E7%AF%87/">Redis面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-17
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="redis的数据结构"><a href="#redis的数据结构" class="headerlink" title="redis的数据结构"></a>redis的数据结构</h2><ul>
<li>基本数据结构：string，hash，list，set，sorted set</li>
<li>高级数据结构：geo，hyperloglog，bitmap</li>
</ul>
<h2 id="String的SDS"><a href="#String的SDS" class="headerlink" title="String的SDS"></a>String的SDS</h2><p>redis是基于c的，但是其并没有采用c语言的字符串形式。c语言的字符串是给首数据的指针，遍历字符串的时候一直往后找直到出现”\0”，这对于需要快速处理字符串的redis是不可接受的。</p>
<p>于是redis发明了一个SDS（简单动态字符串），相对于原先的c语言字符串，这里最大的不同是使用一个数据结构里面保存字符串的数组和长度。优点如下：</p>
<ol>
<li>统计字符串的时间复杂度为o(1)：由于c语言的字符串是需要遍历的，类似链表的结构，但是sds直接就有一个字段保存长度</li>
<li>可以保存二进制信息：由于c语言是要找到”\0”为末尾信息，不允许有空格，使得c语言字符串的存储形式受限；而sds没有这方面的特性，直接保存在一个数组里面，因此redis可以用字符串存储图片等二进制信息。</li>
<li>不会发生溢出：由于保存了数组的长度和数组剩余长度，当进行字符串拼接的时候会校验新的长度是否会导致数组溢出，c语言是没有这个特性的。</li>
</ol>
<h2 id="压缩队列ziplist"><a href="#压缩队列ziplist" class="headerlink" title="压缩队列ziplist"></a>压缩队列ziplist</h2><p>在讲其他数据结构之前，需要讲一下压缩。在redis中list，set和zset都有两种数据结构，其中一种就是ziplist，初始为ziplist而当元素数量达到一定阈值就会进化为其他的。</p>
<p>一般来说存储数据每一个格子长度都是固定的，但redis为了节约这部分空白数据就使用了动态长度，也就是说每一个格子只会正好包括数据而不会有空白。但是这样不是固定长度也给遍历带来的问题，不能够按照数组那种长度*个数来找地址，于是redis也做了一些方便搜索的数据结构。</p>
<p><strong>连锁更新问题</strong></p>
<p>除了搜索有缺点，还存在着更新问题，也能想到，如果在中间的某个数据需要更新，那么后面所有的数据都需要向后移动，造成很大的开销，所以redis只在数据量很小的情况下使用这个数据结构。</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>类似jdk1.7实现的hashmap，就是拉链法解决哈希冲突。相较于jdk的hashmap，这里的扩容机制有很大不同。</p>
<p><strong>渐进式扩容</strong><br>对于redis来说，由于是单线程，hashmap扩容会导致线程阻塞，影响性能，所以采用了渐进式hash。每当需要进行扩容的时候不会立刻一次性全部扩容，而是同时创建一个两倍大小的hashmap，在以后的每一次请求中，都会移动一部分数据从旧的hashmap到新的hashmap中，新增的数据就直接写在新表上。</p>
<p>这样将一次扩容平坦到每次请求中，完成扩容的同时也没有严重影响性能。但是此时get一个数据就需要在两个表上都要找。</p>
<h2 id="sorted-set和跳表"><a href="#sorted-set和跳表" class="headerlink" title="sorted set和跳表"></a>sorted set和跳表</h2><p>zset是按照分数score有序排列的集合，底层使用了ziplist+skiplist，当元素数量大于128且元素长度大于64字节的时候自动扩展为跳表。</p>
<p><strong>跳表</strong></p>
<p>单向链表查找的时间复杂度平均为o(n)，跳表用多层链表实现在单向链表上查询的时间复杂度降低为logn</p>
<div style="text-align: center;">
  <img src="../img/Java/img_10.png" alt="" />
</div>

<p>查询就像坐了快车，只有大站到达，节约了不少遍历的时间，一般来说上一层的节点数量是下一层的一半，当需要添加数据的时候如何确定这个节点的层级呢。如果说加入一个节点那么它在最底层的概率为100%，由于上面一层的数量是一半，那么他是2层节点的概率就为50%，3层的就为25%。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机生成节点的层数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lvl</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (random.nextFloat() &lt; P &amp;&amp; lvl &lt; MAX_LEVEL) &#123;</span><br><span class="line">        lvl++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lvl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么用跳表而不是红黑树或者b树</strong></p>
<ul>
<li>hashmap的红黑树结构不适合范围查找，zset有个命令就是查询score在某个范围之内的，而且指针数量也较少，实现难度较低</li>
<li>b树数据结构较大，内存不友好。节点分裂等实现起来较为复杂。</li>
</ul>
<h2 id="redis为什么这么快"><a href="#redis为什么这么快" class="headerlink" title="redis为什么这么快"></a>redis为什么这么快</h2><ol>
<li>基于单线程的io阻塞模型，能够高效的进行网络io</li>
<li>基于内存，且有自己的vm，不会导致虚拟内存频繁换入换出</li>
<li>高效的数据结构</li>
</ol>
<h2 id="redis的单线程io多路复用模型"><a href="#redis的单线程io多路复用模型" class="headerlink" title="redis的单线程io多路复用模型"></a>redis的单线程io多路复用模型</h2><blockquote>
<p>select&#x2F;poll&#x2F;epoll：<br>这三种是操作系统提供给程序员的系统调用api，epoll只有linux内核可以用，这三个系统调用封装了io多路复用机制：</p>
<ul>
<li>select：对于到来的socket链接，操作系统会把它按照特定的数据结构组织成一个文件（这个文件中元素的数量是有上限的，为1024），select操作将这个文件给内核态进行遍历，根据这些数据结构的状态找到需要进行处理的socket然后标记，再返回给用户态。这样的优点是简单直接，缺点是找到需要处理的socket时间复杂度大，而且能够处理的socket有限，所以仅仅支持小规模的io多路复用</li>
<li>poll：是select的升级版，主要是将1024这个上线取消了，使用了链表就没有上限了，其余从用户态到内核态处理，从内核态到用户态都是一样的，都需要遍历两次，效率较低。</li>
<li>epoll：首先是对于数据结构的处理，epoll在内核态维护了一个红黑树，使得处理socket不用每次都在两个态之间每次都复制，仅仅是将新增的加入红黑树，而且查询效率也很高；其次是采用了事件驱动的方法，并不会像select&#x2F;poll那样轮询，这里是直接阻塞，等有消息再通知，是一种阻塞的方式。</li>
<li>水平触发和边缘触发：水平触发是有事件来了就一直通知，直到事件被处理；边缘触发是只通知一次，但是消息可能会丢失。</li>
</ul>
</blockquote>
<p>redis基于reactor模式建立了一套高效的单线程io模型（这里的单线程指的是从socket到epoll发现到执行器处理的流程是单线程），主要组件有：</p>
<ul>
<li>多个socket（多个客户端请求，四元组即为一个socket）</li>
<li>io多路复用：redis是基于epoll的，实现事件驱动的监听机制</li>
<li>事件分派器：根据epoll_wait监听到的socket事件来决定接下来的执行逻辑</li>
<li>事件执行逻辑：有accept，read，write。accept逻辑是根据新来的socket加入红黑树维护并监听</li>
</ul>
<div style="text-align: center;">
  <img src="../img/Java/img_11.png" alt="" />
</div>

<h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><ul>
<li>rdb：将当前的redis数据压缩成一个rdb文件，在文件压缩的过程中（save）会阻塞主线程，但是可以采用bgsave的方式，开辟一个新的线程执行。优点是数据形成的文件dump格式紧凑，redis恢复速度快；缺点是在两次save中间可能会导致丢数据，需要fork一个线程来进行save操作</li>
<li>aof：类似记录日志，每次操作都需要保存。优点是实时性比rdb要好，不容易丢数据；缺点是文件占的地方很大，可能偶尔还需要一个压缩线程来压缩，恢复速度也比dump.rdb慢</li>
</ul>
<p><strong>aof的刷盘方式</strong>：</p>
<ul>
<li>always：每次操作完就刷盘一条aof</li>
<li>everysec：每一秒钟刷盘一次</li>
<li>no：不主动刷盘，靠操作系统来刷盘</li>
</ul>
<p><strong>aof为什么是一条命令执行完了才触发</strong>：</p>
<ol>
<li>有可能命令是错误的，只有正确的命令会aof</li>
<li>不会阻塞当前的任务</li>
<li>缺点是反着来的，不阻塞当前任务但是会阻塞下条任务，有可能执行校验完了执行完了，但是出现异常使得数据丢失没有存储</li>
</ol>
<p><strong>rdb的机制</strong>：<br>bgsave：copyonwirte<br>save：save 50 1000，50s有1000条变化就触发</p>
<h2 id="过期删除"><a href="#过期删除" class="headerlink" title="过期删除"></a>过期删除</h2><ul>
<li>定时清除：在设置key的过期时间的同时给一个定时任务，过期了定时任务删除。这种策略对于cpu不友好，还需要监控每一个key的剩余时间</li>
<li>惰性删除：过期了不会立即删除，直到有访问的时候查询过期时间表，过期了就删除，返回空值。缺点是对于内存不友好</li>
<li>定期删除：根据某个时间进行定期删除，算是上面两种的折中方案</li>
</ul>
<p>redis是惰性删除和定期删除相结合的过期删除策略，根据cpu运载情况选择策略，对于定期删除是随机挑选一些key检查过期情况，其中过期的删除，但是当这个比例大于某个阈值的时候redis就认为有大量过期key需要处理，因此会立即做一次删除，以此类推。</p>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><ol>
<li>volatile-lru</li>
<li>volatile-lfu</li>
<li>volatile-random</li>
<li>volatile-ttl</li>
<li>all-lru</li>
<li>all-lfu</li>
<li>all-random</li>
<li>no-eviction：默认的策略，满了会报错，驱逐新请求</li>
</ol>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><ol>
<li>从服务器向主服务器发送replicaof命令，参数是自己的ip地址，请求主机的唯一id</li>
<li>主机收到了之后返回自己的runid和当前复制的offset</li>
<li>接着主机开始bgsave自己的rdb文件，与从机同步，每次复制都会有一个offset</li>
<li>在复制的过程中可能也会有新的数据，此时主机会用一个缓冲区缓存这部分数据</li>
<li>从机接受完成后，主机再把刚刚缓冲区的传给从机器</li>
</ol>
<h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>主机会维护一个环形缓冲区，储存最近的操作。如果这个环形缓冲区满了就说明有的请求恢复不了了，需要重新进行增量复制。如果没有满，就会用到上面说的那个offset进行增量复制。增量复制的时间很短，毕竟只用传掉线时间丢失的一部分数据。</p>
<p>这个缓冲区的大小应该设置为比掉线恢复时间*平均输入数据稍大，这样就可以避免丢失数据而全量复制</p>
<h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><blockquote>
<p>哨兵也是集群，集群管理集群</p>
</blockquote>
<p><strong>主官下线和客观下线</strong></p>
<p>redis集群通过心跳机制（ping-pong）来检测服务器是否存活，哨兵定期与服务器实例进行检测，当某一个哨兵发现主服务器没有在规定时间内返回pong，就会认为这个服务器下线了，这就是主观下线：</p>
<p>但是这也有可能是由于网络信道丢失消息，未必是主服务器真的宕机了，所以还需要其他哨兵对其进行判断，当超过参数quorum的哨兵认为是下线了，那么就会被认为是客观下线，这个时候就需要进行故障转移。</p>
<p><strong>选举和故障转移</strong></p>
<p>既然主节点发生了故障，那么由谁来进行故障转移呢。那当然是最先发现故障的哨兵，但也可以是两个哨兵同时发现了故障，这个时候就要选举了，每个哨兵只有一个选票，自己发现的需要我选我，当哨兵获得的选票大于半数且也要大于quorum的时候就被选举为故障转移的节点。</p>
<p>接下来就由这个节点进行故障转移：</p>
<ol>
<li>主节点周围的从节点选一个作为下个主节点，进行转移：首先过滤网络状态不好的；再按照优先级，复制进度，id号进行择优。（网络状态有一个主从复制的断连次数，根据这个可以排除网络状态）</li>
<li>其他的从节点全部修改为replicaof这个节点</li>
<li>订阅者通知频道告诉客户端进行了改变</li>
<li>继续监视被替换的这个主机，如果上线了就让他变成从机</li>
</ol>
<h2 id="大key问题"><a href="#大key问题" class="headerlink" title="大key问题"></a>大key问题</h2><p>什么是大key，一般来说String占用大于1MB，或者list，Hash，zset，set长度大于5000个会被认为是大key。String这种情况很可能是因为存储了二进制文件数据，其他顺序结构有可能是没有设计好表导致存储了过多数据。</p>
<p>原因：</p>
<ul>
<li>程序设计不当，使用String存储了二进制文件（SDS是可以存Base64的）</li>
<li>业务规模突然变大：导致list缓存了较多数据</li>
<li>没有清除，例如哈希表缓存了大量没有用的数据</li>
</ul>
<p>危害：</p>
<ul>
<li>太大了话会阻塞redis线程，redis脆弱的单线程</li>
<li>网络拥塞，一个大key就是1MB，1000个用户请求就是1GB</li>
</ul>
<p>如何发现：</p>
<ul>
<li>redis自带的–bigkeys参数</li>
<li>scan命令自己手动看，有点像redis自带的任务管理器，结合别的一些指令可以查看各种value的大小。这个命令效率比较低</li>
<li>第三方开源工具</li>
<li>阿里云内嵌的redis有工具能管理大key</li>
</ul>
<p>如何解决：</p>
<ul>
<li>大的hash表可以拆分为多个key，使用二次哈希拆分为多个hash</li>
<li>手动清理大的string（其实在redis桌面客户端就可以手动清理了，估计背后也是这一条命令）</li>
<li>采用合适的数据结构：不要拿string来存照片或者文本</li>
</ul>
<blockquote>
<p>redis里有一个非常大的key，比如一个set，set里面可能有几亿条数据，我现在需要把这个key删掉，你会怎么做？<br>一般情况下del是同步删除，手动清理会阻塞。在4.0版本以上提供了一个unlink命令，可以异步删除。非得用del的话可以先把其二次哈希到不同set，大事化小。</p>
</blockquote>
<h2 id="redis的阻塞原因"><a href="#redis的阻塞原因" class="headerlink" title="redis的阻塞原因"></a>redis的阻塞原因</h2><ol>
<li>使用了o(n)的命令，例如keys，这个会在全表找key匹配，还有一些查询范围的数据（zset那些，这个时候又要吟唱跳表的好处了）</li>
<li>大key</li>
<li>持久化：rdb的save会阻塞，bgsave不会；aof会阻塞下一条，重写也会阻塞（就是压缩aof大小的那个操作）</li>
<li>集群库容等各种硬件问题</li>
<li>swap：就是虚拟内存那一套，磁盘换内存，这对于redis也是很致命的。redis快的其中一条原因就是在内存中。因此需要禁止大量swap。</li>
</ol>
<h2 id="热key问题"><a href="#热key问题" class="headerlink" title="热key问题"></a>热key问题</h2><p>突如其来的集中访问某几个key，处理不好会导致缓存击穿。</p>
<p>如何发现：</p>
<ul>
<li>redis自带的参数–hotkeys，但是用这个的前提是内存替换策略要选lfu相关的（可能是因为有了lfu才开启了频率计算吧）</li>
<li>开源工具</li>
<li>monitor命令，可以监控redis当前的一些命令，自己观察某些key的频率手动解决。</li>
</ul>
<p>如何解决：</p>
<ul>
<li>读写分离主从架构</li>
<li>redis cluster：哈希槽，多个热点数据分散在多个库</li>
<li>二级缓存</li>
</ul>

    
    
  </div>

  

  

</article>
  
    
  <nav class="pagination">  
      
      <a class="prev" href="/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text">上一页</span>  
      </a>  
      
      
      <a class="next" href="/page/3/">  
        <span class="next-text">下一页</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  
</section>
        </div>
          

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:1050886654@qq.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/yyf1050886654" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2024 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">Yifan Yang</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    

  







<script type="text/javascript" src="/lib/jquery"></script>



<script type="text/javascript" src="/lib/slideout"></script>



<script type="text/javascript" src="/lib/fancybox"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>