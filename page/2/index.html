<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/default" title="YYF's Blog" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://yyf1050886654.github.io/page/2/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>YYF&#39;s Blog</title>

<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">YYF&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/collect/">
      <li class="mobile-menu-item">
        
        
        收藏              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">YYF's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/collect/">  
              
              
              收藏  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <section id="posts" class="posts">
  
  
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/07/19/%E6%96%B0%E5%9D%91-%E4%BB%A3%E9%A9%BE%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/">新坑-代驾微服务项目</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-07-19
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>前言：一直都想做一个有点高级但是又重复度低的项目，正好让我遇上了这个尚硅谷刚发的《乐尚代驾》，做了一下感觉还是有学到很多东西的，不管以后放不放在简历里面，算是先开了一个小头，弄懂再说。</p>
</blockquote>
<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>该项目是模仿滴滴的一个代驾系统，前端是基于uniapp的微信小程序，分为三个端口：客户端，司机端和管理系统。业务很纯粹，就是乘客基于当前位置呼叫周围正在接单的司机，司机接单后对车辆的基本情况进行上传，然后就可以开始代驾了，到达终点后计算金额并用微信支付；此外还涉及到优惠券业务，也就是传统的那套秒杀逻辑，分布式锁+lua脚本那些。</p>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li>SpringCloudAlibaba：包括nacos，openfeign，gateway这些，其实后续还可以做一些熔断和限流操作。</li>
<li>redis：项目中主要是用到了geo数据结构，在司机开启抢单的时候将地理坐标上传到redis；此外也用到了redisson实现分布式锁和延迟队列（这里的延迟队列就是超时15分钟自动取消，其实也可以用rabbitmq实现）</li>
<li>xxl-job：项目最核心的业务是通过xxl-job实现的，每次下单客户端都会创建一个新的任务调度，这个任务可以定时寻找周围司机。</li>
<li>mongodb：在代驾订单进行过程中的地理坐标不好放在mysql里面，用mongodb存储地理坐标，考虑了其在实时性方面的优化</li>
<li>rabbitmq：延迟队列，业务解耦和流量削峰</li>
<li>Drools：第一次听说，规则引擎，就是把一些业务计算逻辑抽取出来，不硬编码在程序中，项目中用规则引擎定义了路程和费用的计算，还有最后算金额也用到了规则引擎，它有自己的一套语法。</li>
<li>seata：分布式事务，在分布式系统中一个事务的回调是无法用@Transactional进行回调的，这里就用了阿里的这个分布式事务中间件完成，目前还没有太了解这个，只知道导入包只会加一个注释就能完成功能。</li>
<li>minio：存储上传照片和音频文件</li>
</ul>
<h2 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h2><ul>
<li>使用<strong>aop+注解+threadlocal</strong>的方式完成登录状态保存，微信小程序登录，做到了对业务代码的零入侵。</li>
<li>在下单后用<strong>xxl-job</strong>进行任务调度，定时搜索周围司机，并基于<strong>redis的geo</strong>数据结构，提高附近司机的搜索速度，完成司乘对接。</li>
<li>为了减小mysql访问压力使用<strong>mongodb</strong>记录沿途地理坐标，并使用基于<strong>rabbitmq</strong>的延迟队列将多次写请求合并为一次写入，再次减小了数据库操作。</li>
<li>使用<strong>策略模式和规则引擎Drools</strong>，定义了业务执行过程中的多种流程，例如代驾费用计算，司机积分计算以及优惠卷最大优惠策略计算。</li>
<li>使用<strong>Redisson分布式锁</strong>解决了高并发场景下的司机抢单和优惠卷超发问题，使用Redisson提供的<strong>延时队列</strong>完成了订单超出时间限制后自动取消。</li>
<li>使用<strong>CompletableFuture</strong>完成了订单结束提交过程的异步编排，提高了响应效率，并使用<strong>seata</strong>来保证分布式事务的执行。</li>
</ul>
<h2 id="可以有增量的地方"><a href="#可以有增量的地方" class="headerlink" title="可以有增量的地方"></a>可以有增量的地方</h2><ul>
<li>数据库分库分表，ShardingSphere可以尝试一下</li>
<li>二级缓存，本地caffeine和redis二级缓存</li>
<li>做限流和熔断，以及redis集群和哨兵</li>
<li>点赞（set），评论，排行榜（zset），签到（bitmap）和UV统计（hyperloglog）都是可以用redis解决的</li>
<li>kafka-stream还是没能找到应用的场景，</li>
<li>binlog实现与mysql的持久化</li>
<li>优惠卷兑换算法和优惠卷的最大优惠计算</li>
</ul>
<h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><h3 id="乘客端："><a href="#乘客端：" class="headerlink" title="乘客端："></a>乘客端：</h3><blockquote>
<p>登录–选择代驾地址–呼叫代驾–等待接单–15分钟没有司机接单自动取消–15内有司机接单，司乘同显–账单支付</p>
</blockquote>
<ol>
<li>登录：前端首先调用wx.login()，返回一串字符串，然后后端拿到这个去请求微信服务器得到当前登录的openid，也就是微信的唯一id（可以理解为wx.login()请求发出之后，wx的缓存中就保存了这个键值对，键是这个字符串，值是当前用户的结构，必须是连贯的动作，可能设置了失效时间，这也是为什么我后面拿postman同样请求得不到的原因）</li>
<li>选择代驾地址：百度地图的api返回距离和时间，这个参数给后端规则引擎计算出费用</li>
<li>等待接单：xxl-job新增一个订单任务，每隔一分钟根据redis的geo搜索周围的汽车，然后在附近开启接单的汽车的队列里面（通过redis的list实现）添加这个订单。</li>
<li>15分钟没有司机接单自动取消：通过redisson实现或者rabbitmq的延迟队列实现</li>
<li>15内有司机接单，司乘同显：当司机抢到了该订单后，订单状态改变，进入司乘同显模式，此后基本上没有乘客端什么事情了，前端会一直轮询订单当前状态，并根据司机端存在mongodb中的数据获取车的位置。</li>
<li>账单支付：微信支付</li>
</ol>
<h3 id="司机端："><a href="#司机端：" class="headerlink" title="司机端："></a>司机端：</h3><blockquote>
<p>登录–认证–开始接单–抢单–开始代驾–生成账单，发送乘客</p>
</blockquote>
<ol>
<li>登录：逻辑类似</li>
<li>认证：司机需要上传身份证驾驶证人脸等，通过腾讯云，我懒得注册这部分就跳过了</li>
<li>开始接单：开始接单后会把当前的坐标上传到redis，然后每隔5s询问一次当前队列状态，当xxl-job把订单放在了该司机的队列里面，前端就会有显示可以抢单</li>
<li>抢单：分布式锁，无需多言，抢单之后将订单状态改变，这样乘客端轮询这个订单的时候就会发现有司机已经接单了。</li>
<li>到达乘客指定地点，这里会有一个刷单的校验，也就是说在距离地点1km之内才能有效</li>
<li>上传车辆状况和车牌号：拍照上传minio</li>
<li>开始代驾：每隔几秒钟将当前的坐标上传到mongodb中，实现与乘客端同步显示。</li>
<li>生成账单：根据规则引擎分账，然后推送微信支付给乘客。</li>
</ol>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/07/11/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB-DOMINANT/">论文精读-DOMINANT</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-07-11
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <!-- TOC -->
<ul>
<li><a href="#deep-anomaly-detection-on-attributed-networks">Deep Anomaly Detection on Attributed Networks</a><ul>
<li><a href="#%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">图卷积神经网络</a></li>
<li><a href="#%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84">模型架构</a></li>
<li><a href="#%E5%B8%A6%E5%B8%A6%E9%94%90%E8%AF%84">带带锐评</a><!-- TOC -->
<blockquote>
<p>开发项目虽好，但是还是要毕业的嘛，正好今天做完了组会汇报ppt，趁热打铁写一篇读后感。</p>
<p><strong>2024-7-11，我研究生生涯的第一篇论文，我会记住你的。</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="Deep-Anomaly-Detection-on-Attributed-Networks"><a href="#Deep-Anomaly-Detection-on-Attributed-Networks" class="headerlink" title="Deep Anomaly Detection on Attributed Networks"></a>Deep Anomaly Detection on Attributed Networks</h1><blockquote>
<p>在说明这篇文章之前，首先说一下图卷积神经网络（GSN）</p>
</blockquote>
<h2 id="图卷积神经网络"><a href="#图卷积神经网络" class="headerlink" title="图卷积神经网络"></a>图卷积神经网络</h2><p>&nbsp;&nbsp;图是一种数据结构，相比于离散的点，更具有特征的是边带来的结构上的关系。普通的卷积神经网络处理的主要是结构性数据，类似图片或者nlp任务，这一类任务的输入数据是有迹可循的，结构不会发生变化，图片可以拆为像素进行卷积核操作，nlp可以将词进行词嵌入。</p>
<p>&nbsp;&nbsp;而图不一样，图的拓扑结构是无迹可寻的，这也意味着普通的cnn无法满足在图上的搜索，但是我们可以参考cnn的公式$Y&#x3D;XW+B$，结合图的规律探索出图的卷积神经网络。</p>
<p>&nbsp;&nbsp;首先我们定义一个图，$\mathcal{G}&#x3D;(\mathcal{V},\epsilon,X)$，（1）节点集合$\mathcal{V} &#x3D; \mathcal{v_1},\mathcal{v_2},\ldots,\mathcal{v_n}$，其中$\left|\mathcal{V}\right|&#x3D;\mathcal{n}$ （2）边集$\epsilon$，其中$\left|\epsilon\right|&#x3D;\mathcal{m}$（3）节点属性$\mathrm{X}\in\Bbb{R}^{n \times d}$,其中第i行向量$\mathrm{x_i}\in\Bbb{R}^{d}(i&#x3D;1,\ldots,n)$表示的是第i个节点的属性表示，d是属性的数量。举例如下：</p>
<div style="text-align: center;">
  <img src="../img/oodPaper/img_1.png" alt="" />
</div>

<p>&nbsp;&nbsp;这里举例是有权图，如果是无权图那就都为0或者1，这张图的邻接矩阵A为：</p>
<table>
<thead>
<tr>
<th></th>
<th>v1</th>
<th>v2</th>
<th>v3</th>
<th>v4</th>
</tr>
</thead>
<tbody><tr>
<td>v1</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>v2</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>v3</td>
<td>5</td>
<td>0</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>v4</td>
<td>6</td>
<td>0</td>
<td>3</td>
<td>0</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;节点属性H，比如这四个点代表一个人，属性就可能是身高体重这类，举例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>姓名</th>
<th>性别</th>
<th>身高</th>
<th>体重</th>
</tr>
</thead>
<tbody><tr>
<td>H1</td>
<td>239</td>
<td>2</td>
<td>175</td>
<td>120</td>
</tr>
<tr>
<td>H2</td>
<td>542</td>
<td>1</td>
<td>168</td>
<td>100</td>
</tr>
<tr>
<td>H3</td>
<td>937</td>
<td>2</td>
<td>188</td>
<td>150</td>
</tr>
<tr>
<td>H4</td>
<td>365</td>
<td>1</td>
<td>163</td>
<td>90</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;如果我们取矩阵中的一行A1点乘H，即有：<br>$$<br>A_1 \cdot H&#x3D;(0 \times H_1 +2 \times H_2 +5 \times H_3 + 6 \times H_4)<br>$$</p>
<p>&nbsp;&nbsp;可以看出，这个结果是V1的邻居节点信号的加权求和，其中权重为关系强弱数值，由A提供，但是这个权重并没有进行归一化，也就是说，如果某个节点的邻居顶点越多，关系数值越强，这个结果就越大，为了避免这种情况，我们进行了归一化操作，即，让权重除以该节点所有边的关系数值的和，上这些边的关系数值成为真正意义上和为1的“权值”。那么我们所需要的数学过程即让A的每一行都除以该行的和。这是我们引入一个新的矩阵D，这个矩阵为对角矩阵，每行对角线上的元素为A的这行的元素和，也就是该顶点的度。</p>
<p>&nbsp;&nbsp;D矩阵：</p>
<table>
<thead>
<tr>
<th><!-- --></th>
<th><!-- --></th>
<th><!-- --></th>
<th><!-- --></th>
</tr>
</thead>
<tbody><tr>
<td>13</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>8</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>9</td>
</tr>
</tbody></table>
<p>&nbsp;&nbsp;接着执行$D^{-1}A$操作，即把A的每个关系数值都归一化了，变为权重，最后与H相乘，归一化后的表达式为：</p>
<p>$$<br>D_{1}^{-1}A_1 \cdot H&#x3D;(1&#x2F;13) \times (0 \times H_1 +2 \times H_2 +5 \times H_3 + 6 \times H_4)<br>$$</p>
<p>&nbsp;&nbsp;所有行都进行同样的操作，$D^{-1}A \times\ H$，则每一行的量纲都一样了，不会出现某一行计算结果特别夸张。此时我们来考虑这个结果是什么，它相当于是某一个顶点周围所有顶点的信号按关系（权重）相加（聚合），那么这个结果就能表征出周围节点对自己的影响了，同时由于是通过矩阵进行运算，数据结构变得很规整，可以使用计算机来运算。</p>
<blockquote>
<p>到这里为止有两个问题：</p>
<ul>
<li>首先是自身的因素没有考虑，就如上面的例子，没有考虑到$H_1$的影响，也就是自己，这是很不合理的，在传播过程中需要有“我”的参与，而不是都是客体。</li>
<li>其次是没有考虑到邻居的影响，假如我的朋友只有一个大佬，那么我和大佬的关系网络如果用平均算法的话就等同了，所以直接把B的特征赋给A肯定是不合适的。</li>
</ul>
</blockquote>
<div style="text-align: center;">
  <img src="../img/oodPaper/img_2.png" alt="" />
</div>

<p><strong>针对第一个问题：</strong><br>把“我”的信息加进去<br>$$\tilde{A}&#x3D;A+a \cdot I$$<br>这样A就不再是一个单位阵，在进行矩阵运算的时候就能考虑到自己的因素，因此D也要随之改变，D原本是表示出度，此时要变为出度+a<br>$$\tilde{D}&#x3D;D+a \cdot I$$</p>
<p><strong>针对第二个问题：</strong><br>关系数值我们一般是通过两顶点信号之间的欧氏距离得到的，这只跟这两个顶点有关系，与其二阶邻居的信号是无关的，但是显然，邻居的邻居对我影响应该也是有的，我们怎样才能把二阶邻居的影响考虑进来呢？</p>
<p>比如，我叫V2，是个自闭症患者，班里一共四个人，我们自己的信号为社交能力值，我只认识V1，认识V1也不是因为我和他聊得来，纯纯是因为V1是个社牛， V1谁都认识。在这个例子中，如果考虑V2经过一次传播后形成的新V2，是通过$\tilde{D_2^{-1}}\tilde{A_2}H$计算的，结果为$\tilde{D_2^{-1}}\tilde{A_2}H$&#x3D;(1&#x2F;3)×(2×H1 + 1×H2 + 0×H3 + 0×H4) &#x3D;2&#x2F;3 H1 + 1&#x2F;3H2 ,可以看出，此时新的V2的信号绝大部分来源于原来V1的信号，这当然不行，怎么经过一次传播后，把我一个社恐变成了社牛，这显然传播仍然存在问题，我希望能把二阶邻居和一阶邻居都考虑进去，二阶邻居和一阶邻居数量差别较大的时候，我希望能衰减这种影响，尽可能让自己的信号和别人的信号尽可能的分开来，那么就容易得到两种思路了，一是传播中我尽可能保留自己的权重，削减别人的权重，即$\tilde{A}$对做处理，第二是让“我”的信号根据传播产生某种线性变化，即随着二阶邻居和一阶邻居数量差别越大我信号越小，这样也可以把我和别人区分出来，也可以有我自己单独的特征，就是信号特别小嘛。GCN中是按照第二个思路来的，在数学上新的传播过程表示为：</p>
<p>$$<br>\tilde{D^{-\frac{1}{2}}}\tilde{A}\tilde{D^{-\frac{1}{2}}}H<br>$$<br>为什么是开根号，因为在衰减的时候还是要尽量满足归一化。可以看作对$\tilde{A_{i,j}}$做了如下操作：</p>
<p>$$<br>\tilde{A_{ij}} &#x3D; \frac{A_{ij}}{\sqrt{D_{ii}} \sqrt{D_{jj}}}<br>$$</p>
<p>这样，当一阶邻居顶点j的度（边数量，也就是它的一阶邻居数量）很大，那么传播一次后信号就会变得很小，比如对V2来讲：</p>
<p>$$<br>\tilde{D_{22}^{-\frac{1}{2}}}\tilde{A_2}\tilde{D_{11}^{-\frac{1}{2}}}H&#x3D;\frac{1}{\sqrt{3} \sqrt{14}}(2H_1+H_2)<br>$$</p>
<p>最后再通过一个激活函数，以及一个阈值b，就可以类似cnn得到一个前向传播公式：</p>
<p>$$<br>H^{l+1}&#x3D;\sigma (\tilde{D^{-\frac{1}{2}}}\tilde{A}\tilde{D^{-\frac{1}{2}}}H^{l}W^{l}+b^{l})<br>$$</p>
<p>其中$\tilde{D^{-\frac{1}{2}}}\tilde{A}\tilde{D^{-\frac{1}{2}}}$是固定不变的，其余的工作就是构建全连接层，损失函数，反向传播，更新参数。</p>
<h2 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h2><p>前面铺垫了这么多，那么这个模型是什么呢，说白了就是类似transformer的编码器解码器，基于重构的方法。</p>
<div style="text-align: center;">
  <img src="../img/oodPaper/img_3.png" alt="" />
</div>

<ul>
<li>编码器：将输入的属性矩阵通过前面所述的图卷积神经网络提取特征，得到了一个杂糅属性和结构关系的低维向量表示。</li>
<li>解码器：根据这个得到的中间表示<strong>重构</strong>，结构通过结构解码器进行重构，属性通过属性编码器进行重构。然后计算重构结果与实际结果，完成损失函数最小化。原文这里的结构解码器非常简单暴力，就用中间低维特征提取的内积完成，$\sigma(Z*Z^{T})$，属性用另一层GSN进行映射。</li>
</ul>
<p><strong>那么是怎么判断出异常的？</strong></p>
<p>通过以上步骤重建拓扑网络结构，将结构和属性的重构误差共同学习，可以表示为：<br>$$<br>\mathcal{L}&#x3D;(1-\alpha)R_S+\alpha R_A&#x3D;(1-\alpha){\Vert A-\hat{A} \Vert}_F^2+\alpha {\Vert X-\hat{X} \Vert}_F^2<br>$$<br>式中，是用来平衡结构重建和属性重建影响的一个重要参数。</p>
<p>通过最小化目标函数，自编码器可以基于编码的潜在表示迭代地近似输入的属性网络，直至收敛。最后，使用两项重构误差之和来评估节点的异常性。 也就是，得分越高的实例越是被认为异常。再由该分数来计算属性网络的异常排名</p>
<h2 id="带带锐评"><a href="#带带锐评" class="headerlink" title="带带锐评"></a>带带锐评</h2><ul>
<li>优点：结构新颖，基于图卷积神经网络，特征提取考虑了结构和点属性两方面特征，更能检测出异常，对稀疏图数据的处理有优势。</li>
<li>缺点：重构本身具有一定的局限性，只适用于异常数据占比比较小的数据集进行训练，否则通过重构方法后的误差较大，还有前文所说的解码器构造有一点暴力了，因为Z不止有结构还有属性，直接内积会有干扰，改进措施应该可以剔除这部分因素进行单纯的结构重构。</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/06/11/redis%E9%A1%B9%E7%9B%AE-elasticsearch%E4%B8%8Emongodb/">redis项目-elasticsearch与mongodb</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-06-11
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>其实这个搜索的功能反倒跟redis没啥关系了，所以我也没归类在redis里。基于es的搜索也不无非是增删改查，先简单说一下项目里用到的这两个功能和api。后续我会详细学习</p>
</blockquote>
<h2 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h2><p>es是一个搜索器，具体怎么搜的我不知道（笑）。目前的理解是在新增blog的时候同时把这个对象给es服务器，它通过索引的方式进行缓存。后续查找的时候就可以根据field，也就是字段名来指定匹配位置。</p>
<p>比如这里要搜索文章标题的关键字，就用title；如果是内容的，就用content。经过我的实验发现黑马给的分词器只能检索中文，我想要搜素字母“s”，都搜不到。</p>
<p>项目里的应用也比较简单，就是上述的关键字搜索，然后返回前端的时候要标红，这个步骤是通过在前后加font标签完成的。</p>
<p>首先是配置：</p>
<p>这里用到的对象是RestHighLevelClient，我们只需要配置端口号和ip就可以了，这个客户端会使用es的restful端口进行增删改查。</p>
<p>我们对其的增删改查操作就跟redistemplate一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticSearchConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;elasticsearch.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置RestHighLevelClient对象</span></span><br><span class="line"><span class="comment">     * 将该对象交给Spring容器去管理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RestHighLevelClient对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">restHighLevelClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="comment">//若有多个，可以传一个数组</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">HttpHost</span>(host, port, <span class="string">&quot;http&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用这个RestHighLevelClient，传输的是一个httprequest，返回的是response。思路是创建一个request，查询标题和内容两个方面的关键词。<br>返回以后进行一个转换，返回的加上颜色标签的hits是一个数组，需要转换成字符串。最后向前端返回这个字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">searchBlog</span><span class="params">(QueryBlogDto dto)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.输入校验</span></span><br><span class="line">    <span class="keyword">if</span> (dto == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;输入为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dto.getKeyWord() == <span class="literal">null</span> || dto.getKeyWord().isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;输入关键词为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异步给mongo</span></span><br><span class="line">    insertSearchHistory(dto.getKeyWord());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.查询条件</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;hmdp_blogs&quot;</span>);</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.1布尔类型的查询</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.2 查询标题和内容两方面的关键词</span></span><br><span class="line">    <span class="type">QueryStringQueryBuilder</span> <span class="variable">queryStringQueryBuilder</span> <span class="operator">=</span> QueryBuilders.queryStringQuery(dto.getKeyWord()).field(<span class="string">&quot;content&quot;</span>).field(<span class="string">&quot;title&quot;</span>).defaultOperator(Operator.OR);</span><br><span class="line">    builder.must(queryStringQueryBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3 文本高亮这个查找到的关键字</span></span><br><span class="line">    <span class="type">HighlightBuilder</span> <span class="variable">highlightBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>();</span><br><span class="line">    highlightBuilder.field(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">    highlightBuilder.field(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">    <span class="comment">//2.3.1 标红</span></span><br><span class="line">    highlightBuilder.preTags(<span class="string">&quot;&lt;font style=&#x27;color: red; font-size: inherit;&#x27;&gt;&quot;</span>);</span><br><span class="line">    highlightBuilder.postTags(<span class="string">&quot;&lt;/font&gt;&quot;</span>);</span><br><span class="line">    searchSourceBuilder.highlighter(highlightBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.4 传给searchRequest</span></span><br><span class="line">    searchSourceBuilder.query(builder);</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.5 包装好了的request给客户端返回</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 处理消息回应，一个gethits是一个类，要获取这个数组需要在这个包装类里面再获取。</span></span><br><span class="line">    SearchHit[] hits = response.getHits().getHits();</span><br><span class="line">    List&lt;Map&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> JSONUtil.toBean(json, Map.class);</span><br><span class="line">        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (highlightFields != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">title</span> <span class="operator">=</span> highlightFields.get(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">content</span> <span class="operator">=</span> highlightFields.get(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (title != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//title高亮</span></span><br><span class="line">                Text[] titleFragments = title.getFragments();</span><br><span class="line">                <span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> Arrays.stream(titleFragments).map((value) -&gt; value.toString()).collect(Collectors.joining());</span><br><span class="line">                map.put(<span class="string">&quot;title&quot;</span>,collect);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (content != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//content高亮</span></span><br><span class="line">                Text[] contentFragments = content.getFragments();</span><br><span class="line">                <span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> Arrays.stream(contentFragments).map((value) -&gt; value.toString()).collect(Collectors.joining());</span><br><span class="line">                map.put(<span class="string">&quot;content&quot;</span>,collect);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.add(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h2><p>登录用户的查询记录很多而且变化频繁。需要用非关系型数据库来存储。（其实我个人觉得没必要存在服务器上，这些缓存应该都是在客户端上保留的）</p>
<p>mongodb的配置比较简单，甚至不用写配置类。直接看使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存搜索记录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyWord</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertSearchHistory</span><span class="params">(String keyWord)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userID</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">//1 先从db找这个数据</span></span><br><span class="line">    <span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;userId&quot;</span>).is(userID).and(<span class="string">&quot;keyWord&quot;</span>).is(keyWord));</span><br><span class="line">    <span class="type">QueryBlogDto</span> <span class="variable">searchHistory</span> <span class="operator">=</span> mongoTemplate.findOne(query, QueryBlogDto.class);</span><br><span class="line">    <span class="comment">//2 如果又就更新创建时间</span></span><br><span class="line">    <span class="keyword">if</span> (searchHistory != <span class="literal">null</span>)&#123;</span><br><span class="line">        searchHistory.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3 没有就存进db</span></span><br><span class="line">    <span class="type">QueryBlogDto</span> <span class="variable">dto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryBlogDto</span>();</span><br><span class="line">    dto.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    dto.setUserId(userID);</span><br><span class="line">    dto.setKeyWord(keyWord);</span><br><span class="line"></span><br><span class="line">    <span class="type">Query</span> <span class="variable">query1</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;userId&quot;</span>).is(userID))</span><br><span class="line">            .with(Sort.by(Sort.Direction.DESC,<span class="string">&quot;createTime&quot;</span>));</span><br><span class="line">    List&lt;QueryBlogDto&gt; dtos = mongoTemplate.find(query1, QueryBlogDto.class);</span><br><span class="line">    <span class="comment">//3.1 如果数量少于10条就直接存</span></span><br><span class="line">    <span class="keyword">if</span> (dtos.size() &lt; <span class="number">10</span>)&#123;</span><br><span class="line">        mongoTemplate.save(dto);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.2 如果多余10就要替换了</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">QueryBlogDto</span> <span class="variable">last</span> <span class="operator">=</span> dtos.get(dtos.size() - <span class="number">1</span>);</span><br><span class="line">        mongoTemplate.findAndReplace(Query.query(Criteria.where(<span class="string">&quot;keyWord&quot;</span>).is(last.getKeyWord())),dto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>值得注意的是这里使用了@Async，gpt给我的答案是这个跟你新开一个线程没有区别，但是注意要在启动类上enable。这里query更像lambdaQueryWrapper那种。具体的增删改查语法以后再学。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/06/07/redis%E9%A1%B9%E7%9B%AE-kafkaStream%E6%94%B9%E9%80%A0/">redis项目-kafkaStream改造</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-06-07
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>想到之前在黑马头条看到的流式实时更新排行，遂想用在这个项目里。</p>
</blockquote>
<p>目标是实时计算每一条博客的评论数，点赞数，还有浏览数收藏数来计算分数，更新在redis上，redis使用zset完成排序。</p>
<p>Todo：其实可以分离，点赞评论这一系列数据可以放在mongodb里面，不用写在sql中，后续改造这部分内容。</p>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>浏览量想用redis的这个hyperloglog实现，目前学的比较肤浅，这里只是把它当作一个有概率丢失但容量很大并且很高效的set。主要用stringRedisTemplate.opsForHyperLogLog()中的size和add，很简单前者是有多少个，后者是添加</p>
<h2 id="KafkaStream实现单词统计"><a href="#KafkaStream实现单词统计" class="headerlink" title="KafkaStream实现单词统计"></a>KafkaStream实现单词统计</h2><p>先从配置说起，hosts与kafka本身是一致的，APPLICATION_ID_CONFIG表示的是stream的唯一标识符，Kafka Streams利用这个ID来创建一个内部的消费组，跟踪处理的偏移量，并生成应用的状态存储。</p>
<p>CLIENT_ID_CONFIG是跟踪消费者的网络状态的客户端组</p>
<p>多个 CLIENT_ID_CONFIG 可以对应一个 APPLICATION_ID_CONFIG，这种配置允许在一个Kafka Streams应用中，细粒度地控制和监控不同的客户端实例或任务。这对于大型、复杂的应用尤其有用，使得在监控和调试中可以精确定位问题和分析性能。</p>
<ul>
<li>APPLICATION_ID_CONFIG 定义了Kafka Streams应用的全局标识，影响整个应用的行为、状态管理和数据分区处理。</li>
<li>CLIENT_ID_CONFIG 则用于标识具体的客户端实例或任务，便于监控、日志和调试。<br>这种配置方式增强了应用的灵活性和可管理性，使得在复杂的流处理场景中，能够更有效地跟踪和优化每个组件的表现。</li>
</ul>
<p>这里我们只有很简单的应用，直接就是一对一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;kafka&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableKafkaStreams</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaStreamConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_MESSAGE_SIZE</span> <span class="operator">=</span> <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> String hosts;</span><br><span class="line">    <span class="keyword">private</span> String group;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_CONFIG_BEAN_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> KafkaStreamsConfiguration <span class="title function_">defaultKafkaStreamsConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; props = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//ip地址和端口号</span></span><br><span class="line">        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, hosts);</span><br><span class="line">        <span class="comment">//全局标识</span></span><br><span class="line">        props.put(StreamsConfig.APPLICATION_ID_CONFIG, <span class="built_in">this</span>.getGroup()+<span class="string">&quot;_stream_aid&quot;</span>);</span><br><span class="line">        <span class="comment">//客户端标识</span></span><br><span class="line">        props.put(StreamsConfig.CLIENT_ID_CONFIG, <span class="built_in">this</span>.getGroup()+<span class="string">&quot;_stream_cid&quot;</span>);</span><br><span class="line">        props.put(StreamsConfig.RETRIES_CONFIG, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//key的序列化和反序列化都为string</span></span><br><span class="line">        props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());</span><br><span class="line">        <span class="comment">//value，也就是说键值对都得是String的，后面有坑点</span></span><br><span class="line">        props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KafkaStreamsConfiguration</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用例：</p>
<p>随机在这几种颜色里发送给kafka一个消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> KafkaTemplate&lt;String,String&gt; kafkaTemplate;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">KafkaTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    String[] field = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;red&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;yellow&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;black&quot;</span>,<span class="string">&quot;white&quot;</span>&#125;;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> field[random.nextInt(<span class="number">5</span>)];</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            kafkaTemplate.send(<span class="string">&quot;itcast-topic-input&quot;</span>,s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流式应用：</p>
<p>由于流式是不具有缓存功能的，也就是说一段时间内得到的结果只能代表这一段时间。不能与历史记录累加，这个时候就要存redis了，把每一段时间的数据都累加。</p>
<p>数据流向：测试线程一直发给itcast-topic-input主题，流式应用监听itcast-topic-input，通过处理得到键为单词，值为数量的键值对，传给itcast-topic-output主题。最后再有一个监听器把这些数据与redis进行处理和持久化。</p>
<blockquote>
<p>输入的数据是一个字符串，例如“apple apple tea tea”，对于这个构建的流来说，key为空，value为这个字符串，我们首先需要将这个字符串划分为四个键值对，要保留key的同时value变成各个单词（这里不能用map，map是一对一的，这里涉及拆分，需要一对多），得到了key为null，值为单词的很多键值对，<br>对这些键值对分组，key为它的值，也就是说所有是一个单词的分在一个组里面，方便后续统计。</p>
<p>随后可以用count直接得出每个组的数量，但是我嫌太简单了，用aggregate，这个方法有三个参数。作为聚合，你需要给这个聚合器一个初始的数据类型和数据，后续再对其进行叠加，第一个函数是这个初始化的动作，第二个函数有三个参数，分别是k，v和这个叠加器的传递值。第三个函数指定序列化类型，这个我也没太搞懂</p>
<p>在这个应用中，迭代器的初始为0，由于aggregate是对每个组进行聚合，因此迭代器只用每次将初始的值+1即可。</p>
<p>最后收集这个数据进行转换，发送到对应主题给redis监听。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> KStream&lt;String,String&gt; <span class="title function_">kStream</span><span class="params">(StreamsBuilder streamsBuilder)</span>&#123;</span><br><span class="line">    KStream&lt;String, String&gt; stream = streamsBuilder.stream(<span class="string">&quot;itcast-topic-input&quot;</span>);</span><br><span class="line">    stream.flatMapValues(((value)-&gt;Arrays.asList(value.split(<span class="string">&quot; &quot;</span>))))</span><br><span class="line">            .groupBy((key,value)-&gt;value)</span><br><span class="line">            .windowedBy(TimeWindows.of(Duration.ofSeconds(<span class="number">10</span>)))</span><br><span class="line">            .aggregate(()-&gt;<span class="string">&quot;0&quot;</span>,(key,value,aggValue)-&gt;&#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> Long.parseLong(aggValue)+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">            .toStream()</span><br><span class="line">            .map(<span class="keyword">new</span> <span class="title class_">KeyValueMapper</span>&lt;Windowed&lt;String&gt;, String, KeyValue&lt;?, ?&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> KeyValue&lt;String, String&gt; <span class="title function_">apply</span><span class="params">(Windowed&lt;String&gt; key, String value)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyValue</span>&lt;&gt;(key.key(),value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .to(<span class="string">&quot;itcast-topic-output&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听器：</p>
<p>先查找redis有没有这个key，后续就是简单的加上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener(topics = &quot;itcast-topic-out&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(ConsumerRecord&lt;String,String&gt; message)</span>&#123;</span><br><span class="line">    <span class="comment">//先在redis里找有没有这个单词</span></span><br><span class="line">    <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(REDIS_WORD, message.key());</span><br><span class="line">    <span class="keyword">if</span> (score == <span class="literal">null</span>)&#123;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(REDIS_WORD,message.key(), Double.parseDouble(message.value()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(REDIS_WORD,message.key(), score+Double.parseDouble(message.value()));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;总计：&quot;</span>+message.key()+<span class="string">&quot;:&quot;</span></span><br><span class="line">            +stringRedisTemplate.opsForZSet().score(REDIS_WORD, message.key()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="KafkaStream改造项目"><a href="#KafkaStream改造项目" class="headerlink" title="KafkaStream改造项目"></a>KafkaStream改造项目</h2><p>定义两个实体类：</p>
<ul>
<li>一个是传给kafkastream的消息实体，也就是要告诉stream那一篇文章，有了什么动作，点赞了还是评论了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpdateBlogMess</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文章id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> UpdateType updateType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新数值，点赞是1，取消点赞是-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> add;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UpdateType</span>&#123;</span><br><span class="line">        VIEW,LIKED,COMMENT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另一个是传出kafkastream的消息实体，输出处理后的当前片段内blog的一些统计结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogVisitedStreamMess</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文章id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * UV统计量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long view;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 点赞的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long liked;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 评论数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long comment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>流式应用：</p>
<p>如上所述，这里的输入是key为空，值为UpdateBlogMess的json字符串，</p>
<ol>
<li>首先要把json反序列化，映射到key为id，值为类型和数量，例如liked:1，</li>
<li>再对key进行分组，很多操作的都是同一篇文章。</li>
<li>聚合：根据对象的操作类型在对应的未知+1，初始化是一个”VIEW:0;COMMENT:0;LIKED:0”，后续的聚合都在这上面分割和校验。这里只测试了点赞的，对于view这个字段我打算是直接使用HyperLogLog来统计。评论这个功能暂时没做。</li>
<li>UV统计近一个礼拜的文章访问量。</li>
<li>最后返回一个key为文章id，值为BlogVisitedStreamMess的Json字符串</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KAFKA_STREAM_HOT_BLOG</span> <span class="operator">=</span> <span class="string">&quot;hotBlog-produce&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KAFKA_STREAM_HOT_BLOG_CONSUMER</span> <span class="operator">=</span> <span class="string">&quot;hotBlog-consumer&quot;</span>;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> KStream&lt;String,String&gt; <span class="title function_">kStream</span><span class="params">(StreamsBuilder streamsBuilder)</span>&#123;</span><br><span class="line">    KStream&lt;String, String&gt; stream = streamsBuilder.stream(KAFKA_STREAM_HOT_BLOG);</span><br><span class="line">    stream.map(<span class="keyword">new</span> <span class="title class_">KeyValueMapper</span>&lt;String, String, KeyValue&lt;String , String&gt;&gt;() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key 空</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value UpdateBlogMess的Json字符串</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> key为文章id，value为类型和数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> KeyValue&lt;String, String&gt; <span class="title function_">apply</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">            <span class="type">UpdateBlogMess</span> <span class="variable">blogMess</span> <span class="operator">=</span> JSONUtil.toBean(value, UpdateBlogMess.class);</span><br><span class="line">            <span class="comment">//key:120312391 value:LIKED:-1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyValue</span>&lt;&gt;(blogMess.getId()+<span class="string">&quot;&quot;</span>,blogMess.getUpdateType().name()+<span class="string">&quot;:&quot;</span>+blogMess.getAdd());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">            .groupBy((key,value)-&gt;key)</span><br><span class="line">            .windowedBy(TimeWindows.of(Duration.ofSeconds(<span class="number">10</span>)))</span><br><span class="line">            .aggregate(<span class="keyword">new</span> <span class="title class_">Initializer</span>&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;VIEW:0;COMMENT:0;LIKED:0&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> <span class="title class_">Aggregator</span>&lt;String, String, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String key, String value, String aggValue)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(StringUtils.isBlank(value))&#123;</span><br><span class="line">                        <span class="keyword">return</span> aggValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">viewNum</span> <span class="operator">=</span> <span class="number">0L</span>, commentNum = <span class="number">0L</span>, likedNum = <span class="number">0L</span>;</span><br><span class="line">                    <span class="comment">//处理aggValue</span></span><br><span class="line">                    String[] splits = aggValue.split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span> (String split : splits) &#123;</span><br><span class="line">                        String[] type = split.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                        <span class="keyword">switch</span> (UpdateBlogMess.UpdateType.valueOf(type[<span class="number">0</span>])) &#123;</span><br><span class="line">                            <span class="keyword">case</span> VIEW:</span><br><span class="line">                                viewNum = Long.parseLong(type[<span class="number">1</span>]);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> LIKED:</span><br><span class="line">                                likedNum = Long.parseLong(type[<span class="number">1</span>]);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> COMMENT:</span><br><span class="line">                                commentNum = Long.parseLong(type[<span class="number">1</span>]);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//处理value</span></span><br><span class="line">                    String[] splitVal = value.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                    <span class="keyword">switch</span> (UpdateBlogMess.UpdateType.valueOf(splitVal[<span class="number">0</span>])) &#123;</span><br><span class="line">                        <span class="keyword">case</span> VIEW:</span><br><span class="line">                            <span class="comment">//查询一周以内的UV访问量</span></span><br><span class="line">                            viewNum = calculateUV(key);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> LIKED:</span><br><span class="line">                            <span class="comment">//如果是liked:-1就要-1</span></span><br><span class="line">                            likedNum += Long.parseLong(splitVal[<span class="number">1</span>]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> COMMENT:</span><br><span class="line">                            commentNum += <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//最后返回agg</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;VIEW:&quot;</span> + viewNum + <span class="string">&quot;;COMMENT:&quot;</span> + commentNum + <span class="string">&quot;;LIKED:&quot;</span> + likedNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .toStream().map((key,value)-&gt;&#123;</span><br><span class="line">                <span class="type">BlogVisitedStreamMess</span> <span class="variable">blogVisitedStreamMess</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlogVisitedStreamMess</span>();</span><br><span class="line">                blogVisitedStreamMess.setId(Long.valueOf(key.key()));</span><br><span class="line">                String[] splits = value.split(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (String split:splits)&#123;</span><br><span class="line">                    String[] strings = split.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                    <span class="keyword">switch</span> (UpdateBlogMess.UpdateType.valueOf(strings[<span class="number">0</span>]))&#123;</span><br><span class="line">                        <span class="keyword">case</span> LIKED:</span><br><span class="line">                            blogVisitedStreamMess.setLiked(Long.valueOf(strings[<span class="number">1</span>]));</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> COMMENT:</span><br><span class="line">                            blogVisitedStreamMess.setComment(Long.parseLong(strings[<span class="number">1</span>]));</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> VIEW:</span><br><span class="line">                            blogVisitedStreamMess.setView(Long.parseLong(strings[<span class="number">1</span>]));</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyValue</span>&lt;&gt;(key.key(),JSONUtil.toJsonStr(blogVisitedStreamMess));</span><br><span class="line">            &#125;)</span><br><span class="line">            .to(KAFKA_STREAM_HOT_BLOG_CONSUMER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HyperLogLogPrefix</span> <span class="operator">=</span> <span class="string">&quot;HLL:blog:&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计一周以内的UV访问量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">calculateUV</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">UV4Week</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="comment">//不够优雅</span></span><br><span class="line">    <span class="comment">/*String yesterday = now.minusDays(1).format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));</span></span><br><span class="line"><span class="comment">    String theDayBeforeYesterday = now.minusDays(2).format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));*/</span></span><br><span class="line">    List&lt;LocalDate&gt; lastWeekDates = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">            .mapToObj(now::minusDays)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//blog的id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> Long.parseLong(key);</span><br><span class="line">    <span class="keyword">for</span> (LocalDate localDate:lastWeekDates)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> localDate.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        UV4Week += stringRedisTemplate.opsForHyperLogLog().size(HyperLogLogPrefix + <span class="string">&quot;:&quot;</span> + id + date);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> UV4Week;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续监听器根据这个消息操作redis，但是由于黑马点评这个项目里查询热点文章是直接走数据库，根据likes的升序查询，所有要改很多部分。今天先介绍到这里。</p>
<blockquote>
<p>2026.6.11更新</p>
</blockquote>
<p>实现了用xxl-job定期统计UV然后发送给管道.</p>
<p>这里还可以优化为scan命令，如果用key的话会在redis里全局找，开销很大。现在数据量小点还没关系，一旦大起来就效率很低了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 SCAN 命令获取与给定模式匹配的键</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式，例如 &quot;*HLL_PREFIX*&quot;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 匹配的键集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">scanKeys</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stringRedisTemplate.keys(<span class="string">&quot;*&quot;</span> + pattern + <span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时给kafka管道发view的消息，从HyperLogLog里找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">viewSchedule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查找所有文章</span></span><br><span class="line">    Set&lt;String&gt; keys = scanKeys(HLL_PREFIX);</span><br><span class="line">    <span class="keyword">for</span> (String key :keys)&#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> stringRedisTemplate.opsForHyperLogLog().size(key);</span><br><span class="line">        <span class="type">UpdateBlogMess</span> <span class="variable">mess</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateBlogMess</span>();</span><br><span class="line">        mess.setUpdateType(UpdateBlogMess.UpdateType.VIEW);</span><br><span class="line">        mess.setAdd(Math.toIntExact(size));</span><br><span class="line">        mess.setId(Long.valueOf(key.split(<span class="string">&quot;:&quot;</span>)[<span class="number">2</span>]));</span><br><span class="line">        log.debug(mess.toString());</span><br><span class="line">        kafkaTemplate.send(KAFKA_STREAM_HOT_BLOG, JSONUtil.toJsonStr(mess));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/06/04/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-CompletableFuture/">java-多线程-CompletableFuture</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-06-04
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>平时多线程都是用runnable，callable，FutureTask，线程池这类完成任务。而completableFuture可以完成异步任务的编排，更具有灵活性。</p>
</blockquote>
<h2 id="创建异步任务"><a href="#创建异步任务" class="headerlink" title="创建异步任务"></a>创建异步任务</h2><h3 id="supplyAsync"><a href="#supplyAsync" class="headerlink" title="supplyAsync"></a>supplyAsync</h3><p>两种方法，一种是用默认的线程池ForkJoinPool.commonPool()，另一种需要自己定义，推荐后者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带返回值异步请求，默认线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 带返回值的异步请求，可以自定义线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">myThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//这是有线程池的，这里lambda表达式也可以携程()-&gt;1，如果没有别的逻辑的话</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; test1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;,myThreadPool);</span><br><span class="line">    <span class="comment">//默认方法</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; test2 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(test1.get(<span class="number">10</span>, TimeUnit.SECONDS));</span><br><span class="line">    myThreadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread[ForkJoinPool.commonPool-worker-25,5,main]</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="runAsync"><a href="#runAsync" class="headerlink" title="runAsync"></a>runAsync</h3><p>与前面的supplyAsync相比，runAsync没有返回值，就相当于是runnable，前面那个是callable。同样也有两个方法，一个是用默认线程池，另一个自己定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">myThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        CompletableFuture&lt;Void&gt; test1 = CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread());</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(test1.get());</span><br><span class="line">        myThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果(这是默认线程)：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread[ForkJoinPool.commonPool-worker-25,5,main]</span><br><span class="line">null</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取结果的方法"><a href="#获取结果的方法" class="headerlink" title="获取结果的方法"></a>获取结果的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果完成则返回结果，否则就抛出具体的异常</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 最大时间等待返回结果，否则就抛出具体异常</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 完成时返回结果值，否则抛出unchecked异常。为了更好地符合通用函数形式的使用，如果完成此 CompletableFuture所涉及的计算引发异常，则此方法将引发unchecked异常并将底层异常作为其原因</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">join</span><span class="params">()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果完成则返回结果值（或抛出任何遇到的异常），否则返回给定的 valueIfAbsent。</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getNow</span><span class="params">(T valueIfAbsent)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果任务没有完成，返回的值设置为给定值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">complete</span><span class="params">(T value)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果任务没有完成，就抛出给定异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">completeExceptionally</span><span class="params">(Throwable ex)</span> </span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="异步回调处理"><a href="#异步回调处理" class="headerlink" title="异步回调处理"></a>异步回调处理</h2><blockquote>
<p>apply就是有参数有返回值，accept就是有参数没有返回值，run就是没有参数没有返回值。async都是可以有异步线程池的</p>
</blockquote>
<h3 id="thenApply和thenApplyAsync"><a href="#thenApply和thenApplyAsync" class="headerlink" title="thenApply和thenApplyAsync"></a>thenApply和thenApplyAsync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, TimeoutException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">myThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; task1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;task1&quot;</span>+Thread.currentThread()+<span class="string">&quot;-&gt;&quot;</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;,myThreadPool);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; task2 = task1.thenApply((result) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;task2&quot;</span>+Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + (<span class="number">1</span> + result));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + result;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; task3 = task1.thenApplyAsync((result) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;task3&quot;</span>+Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + (<span class="number">1</span> + result));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + result;</span><br><span class="line">    &#125;,myThreadPool);</span><br><span class="line"></span><br><span class="line">    System.out.println(task2.get());</span><br><span class="line"></span><br><span class="line">    System.out.println(task3.get());</span><br><span class="line"></span><br><span class="line">    myThreadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task1Thread[pool-1-thread-1,5,main]-&gt;1</span><br><span class="line">task2Thread[pool-1-thread-1,5,main]-&gt;2</span><br><span class="line">task3Thread[pool-1-thread-2,5,main]-&gt;2</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>这个结果挺有意思的，需要分析一下。首先是线程池里面提交的线程都是并发的，这里就体现了并发，task2和3先进行了标准输出再完成值的输出。说明并发乱序了。</p>
<p>还有就是thenApply用的是跟前一个任务相同的线程，而带参数的thenApplyAsync用的是不一样的。</p>
<p><strong>默认参数的supplyAsync和thenApply&#x2F;默认thenApplyAsync</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; task1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>+Thread.currentThread()+<span class="string">&quot;-&gt;&quot;</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这里用不加参数的thenApplyAsync也是一样的</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; task2 = task1.thenApply((result) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task2&quot;</span>+Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + (<span class="number">1</span> + result));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task1Thread[ForkJoinPool.commonPool-worker-25,5,main]-&gt;1</span><br><span class="line">task2Thread[ForkJoinPool.commonPool-worker-25,5,main]-&gt;2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>默认参数的supplyAsync和线程池thenApplyAsync</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; task1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>+Thread.currentThread()+<span class="string">&quot;-&gt;&quot;</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; task2 = task1.thenApplyAsync((result) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task2&quot;</span>+Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + (<span class="number">1</span> + result));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + result;</span><br><span class="line">&#125;,myThreadPool);</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task1Thread[ForkJoinPool.commonPool-worker-25,5,main]-&gt;1</span><br><span class="line">task2Thread[pool-1-thread-1,5,main]-&gt;2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>线程池的supplyAsync和thenApply</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; task1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>+Thread.currentThread()+<span class="string">&quot;-&gt;&quot;</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;,myThreadPool);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; task2 = task1.thenApply((result) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task2&quot;</span>+Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + (<span class="number">1</span> + result));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task1Thread[pool-1-thread-1,5,main]-&gt;1</span><br><span class="line">task2Thread[pool-1-thread-1,5,main]-&gt;2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>线程池的supplyAsync和线程池thenApplyAsync</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; task1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>+Thread.currentThread()+<span class="string">&quot;-&gt;&quot;</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;,myThreadPool);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; task2 = task1.thenApplyAsync((result) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task2&quot;</span>+Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + (<span class="number">1</span> + result));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + result;</span><br><span class="line">&#125;,myThreadPool);</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task1Thread[pool-1-thread-1,5,main]-&gt;1</span><br><span class="line">task2Thread[pool-1-thread-2,5,main]-&gt;2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>线程池supplyAsync和默认thenApplyAsync</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; task1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>+Thread.currentThread()+<span class="string">&quot;-&gt;&quot;</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;,myThreadPool);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; task2 = task1.thenApplyAsync((result) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task2&quot;</span>+Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + (<span class="number">1</span> + result));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task1Thread[pool-1-thread-1,5,main]-&gt;1</span><br><span class="line">task2Thread[ForkJoinPool.commonPool-worker-25,5,main]-&gt;2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结：</strong></p>
<p>thenApply无论如何都会与前一个任务用相同的线程，而thenApplyAsync是重新起一个线程完成，如果没有参数，那么就会使用默认的ForkJoinPool.commonPool()</p>
<p>在后面的有async都是这个逻辑</p>
</blockquote>
<h3 id="thenAccept和thenAcceptAsync"><a href="#thenAccept和thenAcceptAsync" class="headerlink" title="thenAccept和thenAcceptAsync"></a>thenAccept和thenAcceptAsync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; task1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>+Thread.currentThread()+<span class="string">&quot;-&gt;&quot;</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;,myThreadPool);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; task2 = task1.thenAccept((result) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task2&quot;</span> + Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + (<span class="number">1</span> + result));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Void&gt; task3 = task1.thenAcceptAsync((result) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task3&quot;</span> + Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + (<span class="number">1</span> + result));</span><br><span class="line">&#125;,myThreadPool);</span><br><span class="line">System.out.println(task2.get());</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task1Thread[pool-1-thread-1,5,main]-&gt;1</span><br><span class="line">task2Thread[pool-1-thread-1,5,main]-&gt;2</span><br><span class="line">task3Thread[pool-1-thread-2,5,main]-&gt;2</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
<p>这个结果也是乱序了，而且async的与之前一致。不再赘述。</p>
<h3 id="thenRun和thenRunAsync"><a href="#thenRun和thenRunAsync" class="headerlink" title="thenRun和thenRunAsync"></a>thenRun和thenRunAsync</h3><p>无入参数无返回值，其他都一样</p>
<h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><h3 id="thenCombine、thenAcceptBoth-和runAfterBoth"><a href="#thenCombine、thenAcceptBoth-和runAfterBoth" class="headerlink" title="thenCombine、thenAcceptBoth 和runAfterBoth"></a>thenCombine、thenAcceptBoth 和runAfterBoth</h3><p>combine就是有参数有返回值，accept就是有参数没返回值，run就是无参数无返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; task1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>+Thread.currentThread()+<span class="string">&quot;-&gt;&quot;</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task2&quot;</span> + Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;Integer&gt; task3 = task1.thenCombine(task2, (a, b) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task3&quot;</span> + Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + (a + b));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(task3.get());</span><br></pre></td></tr></table></figure>
<p>按道理来说task3应该是跟task1一样的线程，有一次结果是一样的，不知道这里为什么是main</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task1Thread[ForkJoinPool.commonPool-worker-25,5,main]-&gt;1</span><br><span class="line">task2Thread[ForkJoinPool.commonPool-worker-18,5,main]-&gt;2</span><br><span class="line">task3Thread[main,5,main]-&gt;3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>回答：为什么默认是主线程</strong></p>
<ol>
<li><p>主线程调用get方法：当主线程调用get方法时，如果task1和task2已经完成，组合任务task3会立即执行，而不需要切换到另一个线程。这样可以减少线程切换的开销，提高性能。</p>
</li>
<li><p>完成的线程：如果任务在某个线程中完成，且没有其他线程等待结果，那么回调任务可能在完成任务的线程中执行。这种行为由CompletableFuture的默认执行策略决定。</p>
</li>
</ol>
<p>使用thenCombineAsync可以显式指定在异步线程中执行回调任务，从而避免在主线程中执行组合任务。</p>
<blockquote>
<p>随后试了一下延长处理时间，发现还真是：</p>
<p>task1Thread[pool-1-thread-1,5,main]-&gt;1</p>
<p>task2Thread[pool-1-thread-2,5,main]-&gt;2</p>
<p>task3Thread[pool-1-thread-1,5,main]-&gt;3</p>
<p>3</p>
<p>说明确实是处理时间短，处理时间短会由于固定的策略直接main做，减少线程开销。所以需要async异步，显示给出</p>
</blockquote>
<h3 id="applyToEither，acceptEither，runAfterEither"><a href="#applyToEither，acceptEither，runAfterEither" class="headerlink" title="applyToEither，acceptEither，runAfterEither"></a>applyToEither，acceptEither，runAfterEither</h3><p>两个里面做完一个就可以了，其他都一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; task1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>+Thread.currentThread()+<span class="string">&quot;-&gt;&quot;</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;,myThreadPool);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task2&quot;</span> + Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;,myThreadPool);</span><br><span class="line">CompletableFuture&lt;Integer&gt; task3 = task1.applyToEither(task2,(first)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task3&quot;</span> + Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + first);</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(task3.get());</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task1Thread[pool-1-thread-1,5,main]-&gt;1</span><br><span class="line">task2Thread[pool-1-thread-2,5,main]-&gt;2</span><br><span class="line">task3Thread[pool-1-thread-2,5,main]-&gt;2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="allOf-anyOf"><a href="#allOf-anyOf" class="headerlink" title="allOf &#x2F; anyOf"></a>allOf &#x2F; anyOf</h3><p>allOf：CompletableFuture是多个任务都执行完成后才会执行，只有有一个任务执行异常，则返回的CompletableFuture执行get方法时会抛出异常，如果都是正常执行，则get返回null。</p>
<p>anyOf ：CompletableFuture是多个任务只要有一个任务执行完成，则返回的CompletableFuture执行get方法时会抛出异常，如果都是正常执行，则get返回执行完成任务的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; task1 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task1&quot;</span>+Thread.currentThread()+<span class="string">&quot;-&gt;&quot;</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;,myThreadPool);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task2&quot;</span> + Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;,myThreadPool);</span><br><span class="line">CompletableFuture&lt;Integer&gt; task3 = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;task3&quot;</span> + Thread.currentThread() + <span class="string">&quot;-&gt;&quot;</span> + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;,myThreadPool);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(CompletableFuture.allOf(task1,task2,task3).get());</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">task1Thread[pool-1-thread-1,5,main]-&gt;1</span><br><span class="line">task2Thread[pool-1-thread-2,5,main]-&gt;2</span><br><span class="line">task3Thread[pool-1-thread-3,5,main]-&gt;3</span><br><span class="line">null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//下面这是task2有1/0的情况</span><br><span class="line">task1Thread[pool-1-thread-1,5,main]-&gt;1</span><br><span class="line">task2Thread[pool-1-thread-2,5,main]-&gt;2</span><br><span class="line">task3Thread[pool-1-thread-3,5,main]-&gt;3</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.ArithmeticException: / by zero</span><br><span class="line">	at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:357)</span><br><span class="line">	at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1908)</span><br><span class="line">	at com.hmdp.service.impl.BlogServiceImpl.main(BlogServiceImpl.java:319)</span><br><span class="line">Caused by: java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.hmdp.service.impl.BlogServiceImpl.lambda$main$4(BlogServiceImpl.java:301)</span><br><span class="line">	at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1604)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:750)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>anyof很简单就不演示了</p>
</blockquote>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/06/01/redis%E9%A1%B9%E7%9B%AE-%E7%BC%93%E5%AD%98%E5%92%8C%E8%AF%BB%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/">redis项目-缓存和读写一致性</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-06-01
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>今天确实学到了蛮多东西的，忙里偷闲的感觉真好</p>
<p>回顾一下缓存，如同计组里面cache和内存之间的关系。在java项目中redis作为缓存，mysql就相当于内存。基本的逻辑是先找缓存，如果缓存没有命中就找mysql，然后再写到缓存中。<br>这里还有很多可以考虑的点，写策略和调度，后续都会考虑一遍。</p>
</blockquote>
<p>首先是redis如何作为缓存的，很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//读写锁</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:shop:write&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!lock.tryLock(<span class="number">1000</span>,<span class="number">2000</span>,TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//return Result.ok(getById(id));</span></span><br><span class="line">            <span class="comment">//1.先去查redis</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">shopJsonStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP + id);</span><br><span class="line">            <span class="comment">//2.如果redis没有就找数据库</span></span><br><span class="line">            <span class="keyword">if</span> (shopJsonStr == <span class="literal">null</span> || shopJsonStr.isEmpty())&#123;</span><br><span class="line">                <span class="comment">//2.1 找数据库</span></span><br><span class="line">                <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">                <span class="comment">//2.2 然后再写回redis里</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">                stringRedisTemplate.opsForValue().set(CACHE_SHOP + id,jsonString);</span><br><span class="line">                <span class="comment">//设置30s的过期时间</span></span><br><span class="line">                stringRedisTemplate.expire(CACHE_SHOP + id,<span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">                <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.如果redis有就返回</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJsonStr, Shop.class);</span><br><span class="line">                <span class="comment">//刷新过期时间</span></span><br><span class="line">                stringRedisTemplate.expire(CACHE_SHOP + id,<span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">                <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>这里主要考虑双写一致性。先删后写和先写后删都会有问题，详情见原来的blog。主要有三种解决方法：</p>
<ul>
<li>延迟双删：删除-&gt;写-&gt;删除，这样可以解决第一次删除之前读操作变更redis的脏数据，这里的最后一次删除为什么要延迟，因为至少得等存数据库操作做完才行，这是异步的，一般都以业务的平均时间作为延迟时间。</li>
<li>分布式锁：直接上读写锁，就没有这么多事情了</li>
<li>先写后删：其实这样的概率挺低的，一种投机方法。</li>
</ul>
<h3 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h3><p>这里用一个异步线程池完成，在写数据库的时候就开一个新的线程，最后根据延迟时间删除就行了。</p>
<p>值得注意的是这里可以用aop+注解的方式完成无侵入实现。相比前面的，后面这种的实用性更广泛。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延时双删</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">updateShopDoubleDel</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(CACHE_SHOP + shop.getId().toString());</span><br><span class="line">    <span class="comment">//更新数据库</span></span><br><span class="line">    updateById(shop);</span><br><span class="line">    <span class="comment">//开启一个新的线程延时删除</span></span><br><span class="line">    shopDoubleDelThreadPool.submit(<span class="keyword">new</span> <span class="title class_">doubleDelThread</span>(CACHE_SHOP + shop.getId().toString()));</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">shopDoubleDelThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟双删</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">doubleDelThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Result&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">doubleDelThread</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(DELAY_TIME);</span><br><span class="line">            stringRedisTemplate.delete(id);</span><br><span class="line">            log.debug(<span class="string">&quot;延迟1秒删除&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Result.ok();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;延迟双删出错&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;延迟双删出错&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>aop+注解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DelayDoubleDelete &#123;</span><br><span class="line">    <span class="comment">//必须填就不要写default</span></span><br><span class="line">    String <span class="title function_">redisKey</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">delayTime</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是第一次开发注解，踩了不少坑：</p>
<ul>
<li>首先aop只能作用于接口上，未在接口中声明的成员方法是不生效的，具体的可以看这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Show_line/article/details/136786252?ops_request_misc=&request_id=&biz_id=102&utm_term=aop%E5%BF%85%E9%A1%BB%E4%BD%9C%E7%94%A8%E4%BA%8E%E6%8E%A5%E5%8F%A3%E5%90%97&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-136786252.142%5Ev100%5Epc_search_result_base1&spm=1018.2226.3001.4187">https://blog.csdn.net/Show_line/article/details/136786252?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=aop%E5%BF%85%E9%A1%BB%E4%BD%9C%E7%94%A8%E4%BA%8E%E6%8E%A5%E5%8F%A3%E5%90%97&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-136786252.142^v100^pc_search_result_base1&amp;spm=1018.2226.3001.4187</a><blockquote>
<p>gpt的回答也很有意思：在 Spring 中，AOP 是通过代理对象来实现的，代理对象的创建方式有两种主要模式：JDK 动态代理和 CGLIB 代理。默认情况下，Spring 会根据目标类是否实现了接口来决定使用哪种代理机制：</p>
<ol>
<li><strong>JDK 动态代理</strong>：如果目标类实现了一个或多个接口，Spring 会使用 JDK 动态代理。JDK 动态代理只能代理接口中的方法。</li>
<li><strong>CGLIB 代理</strong>：如果目标类没有实现任何接口，Spring 会使用 CGLIB 来生成目标类的子类，从而创建代理对象。CGLIB 代理可以代理类中的所有方法（包括没有在接口中声明的方法）。</li>
</ol>
</blockquote>
</li>
</ul>
<blockquote>
<p>如果您在某个实现类的成员方法上使用注解但没有在接口中声明该方法，而该类实现了接口，那么默认情况下，Spring AOP 使用 JDK 动态代理，导致代理对象无法拦截实现类中没有在接口中声明的方法。这是因为 JDK 动态代理只能代理接口中的方法。</p>
<ol>
<li><strong>使用 CGLIB 代理</strong>：明确要求 Spring 使用 CGLIB 代理。这可以通过在 Spring 配置中设置代理模式来实现。</li>
<li><strong>确保接口中声明方法</strong>：将需要代理的方法声明在接口中，以便 JDK 动态代理能够正常工作。</li>
</ol>
</blockquote>
<ul>
<li>其次是，注解是无法直接访问被注解方法的参数的，但是可以进行隐式处理，proceedingJoinPoint.getArgs();可以得到这个函数的参数。这里用了around，因为延迟双删除刚好是执行业务的上下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayDoubleDeleteAspect</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">shopDoubleDelThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延迟双删</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">doubleDelThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Result&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> String id;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> DELAY_TIME;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">doubleDelThread</span><span class="params">(String id,<span class="type">int</span> DELAY_TIME)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.DELAY_TIME = DELAY_TIME;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Result <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(DELAY_TIME);</span><br><span class="line">                stringRedisTemplate.delete(id);</span><br><span class="line">                log.debug(<span class="string">&quot;延迟1秒删除&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> Result.ok();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;延迟双删出错&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;延迟双删出错&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.hmdp.annotation.DelayDoubleDelete)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span>&#123;</span><br><span class="line">        <span class="comment">//方法签名</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) proceedingJoinPoint.getSignature();</span><br><span class="line">        <span class="comment">//被环绕的方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">        <span class="comment">//方法参数</span></span><br><span class="line">        Object[] args = proceedingJoinPoint.getArgs();</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> (Shop) args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//找到注解</span></span><br><span class="line">        <span class="type">DelayDoubleDelete</span> <span class="variable">annotation</span> <span class="operator">=</span> AnnotationUtil.getAnnotation(signature.getMethod(), DelayDoubleDelete.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> annotation.redisKey();</span><br><span class="line">        <span class="type">int</span> <span class="variable">delayTime</span> <span class="operator">=</span> annotation.delayTime();</span><br><span class="line">        stringRedisTemplate.delete(redisKey+shop.getId());</span><br><span class="line">        <span class="comment">//proceed用来接受业务产生的结果</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//由于最后一个删除是要业务都做完了，所以需要在之后进行线程提交</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//继续业务</span></span><br><span class="line">            proceed = proceedingJoinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后删除</span></span><br><span class="line">        shopDoubleDelThreadPool.submit(<span class="keyword">new</span> <span class="title class_">doubleDelThread</span>(redisKey+shop.getId(), delayTime));</span><br><span class="line">        <span class="comment">//不用修改直接返回</span></span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><strong>写操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shop</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">updateShopLock</span><span class="params">(Shop shop)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:shop:write&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!lock.tryLock(<span class="number">1000</span>,<span class="number">2000</span>,TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//更新数据库</span></span><br><span class="line">            updateById(shop);</span><br><span class="line">            stringRedisTemplate.delete(CACHE_SHOP + shop.getId().toString());</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>读操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//读写锁</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:shop:write&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!lock.tryLock(<span class="number">1000</span>,<span class="number">2000</span>,TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//return Result.ok(getById(id));</span></span><br><span class="line">        <span class="comment">//1.先去查redis</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJsonStr</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP + id);</span><br><span class="line">        <span class="comment">//2.如果redis没有就找数据库</span></span><br><span class="line">        <span class="keyword">if</span> (shopJsonStr == <span class="literal">null</span> || shopJsonStr.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//2.1 找数据库</span></span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">            <span class="comment">//2.2 然后再写回redis里</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">            stringRedisTemplate.opsForValue().set(CACHE_SHOP + id,jsonString);</span><br><span class="line">            <span class="comment">//设置30s的过期时间</span></span><br><span class="line">            stringRedisTemplate.expire(CACHE_SHOP + id,<span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.如果redis有就返回</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJsonStr, Shop.class);</span><br><span class="line">            <span class="comment">//刷新过期时间</span></span><br><span class="line">            stringRedisTemplate.expire(CACHE_SHOP + id,<span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/05/30/redis%E9%A1%B9%E7%9B%AE-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">redis项目-分布式锁</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-05-30
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="秒杀业务"><a href="#秒杀业务" class="headerlink" title="秒杀业务"></a>秒杀业务</h2><p>秒杀下单应该思考的内容：</p>
<p>下单时需要判断两点：</p>
<ul>
<li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li>
<li>库存是否充足，不足则无法下单</li>
</ul>
<p>下单核心逻辑分析：</p>
<p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p>
<p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p>
<p><img src="/../img/hmdp/img_3.png"></p>
<blockquote>
<p>最基本的逻辑，首先判断时间和库存，再进行库存扣减，如果成功扣减库存就下订单</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 6.2.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 6.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><blockquote>
<p>多线程并发，这样的逻辑当出现最后一张的时候多个线程涌入就会变成负数，无需多言</p>
</blockquote>
<h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><p>几个阶段：</p>
<ul>
<li>最简单逻辑，只要加上一个对于订单的查询就可，查询条件是当前的用户id和秒杀券id</li>
<li>但是发现这样对于两个同用户的线程还是会造成不是一人一单的情况，这个时候我们需要悲观锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>首先是加在方法上，这样粒度有点大，锁的是整个方法，我们考虑细化锁，用代码块，那么这个锁的参数是什么呢<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span>  Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">	<span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对于一个用户的id肯定是可以互相区分的，我们就锁这个id，但是id的tostring方法是一个new的过程，也就是说我们用tostring都是一个新的，这个时候需要用jvm的知识了，直接在字符串常量池里面找到这个对象，这样就确保了是唯一的一个对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (user.getId().toString().intern())&#123;</span><br><span class="line">    <span class="comment">//代理对象是spring在初始化的时候包装在我们类上的另一个类，他会在代理对象中通过trycatch实现事务</span></span><br><span class="line">    <span class="comment">//那么如果我们直接使用了proxy这个类，就可以得到事务的支持</span></span><br><span class="line">    <span class="comment">//通过aop实现，但是要在启动类上暴露aop</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>但是事务是在锁的外面的，也就是说有可能锁释放了但是还没有写入数据库，这样还是有隐患，所以我们需要将锁的范围比事务大，而事务是写在函数上的，那么就需要在调用这个函数的地方上锁，而不是在这个函数里面上锁。</li>
<li>最后需要让事务生效，要用到代理对象，这样就有了一个完整的方案。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一人一单，是同一个用户的并发安全问题，所以加锁的是userId</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分布式锁</span></span><br><span class="line">        <span class="type">SimpleRedisLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleRedisLock</span>(stringRedisTemplate,<span class="string">&quot;order:&quot;</span>+user.getId());</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1200</span>);</span><br><span class="line">        <span class="comment">//这里如果没有获取到锁，说明有一个相同用户id的人已经在下单了，所以直接返回不允许重复</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*synchronized (user.getId().toString().intern())&#123;</span></span><br><span class="line"><span class="comment">            //代理对象是spring在初始化的时候包装在我们类上的另一个类，他会在代理对象中通过trycatch实现事务</span></span><br><span class="line"><span class="comment">            //那么如果我们直接使用了proxy这个类，就可以得到事务的支持</span></span><br><span class="line"><span class="comment">            //通过aop实现，但是要在启动类上暴露aop</span></span><br><span class="line"><span class="comment">            IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();</span></span><br><span class="line"><span class="comment">            return proxy.createVoucherOrder(voucherId);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事务的作用域要小于锁，否则会出现锁释放了而事务没结束，有安全隐患</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voucherId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span>&#123;</span><br><span class="line">        <span class="comment">//一人一单</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> lambdaQuery()</span><br><span class="line">                .eq(VoucherOrder::getUserId,user.getId())</span><br><span class="line">                .eq(VoucherOrder::getVoucherId,voucherId)</span><br><span class="line">                .count();</span><br><span class="line">        <span class="keyword">if</span> (count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经购买过了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新库存</span></span><br><span class="line">        LambdaUpdateWrapper&lt;SeckillVoucher&gt; lambdaUpdateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaUpdateWrapper.setSql(<span class="string">&quot;stock = stock-1&quot;</span>)</span><br><span class="line">                .eq(SeckillVoucher::getVoucherId,voucherId)</span><br><span class="line">                .ge(SeckillVoucher::getStock,<span class="number">0</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update(lambdaUpdateWrapper);</span><br><span class="line">        <span class="keyword">if</span> (!success)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建订单</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        voucherOrder.setUserId(user.getId());</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>几个阶段：</p>
<ul>
<li>分布式锁提出是为了解决锁不可见的问题，有了一个全局的锁就可以进行跨服务器的上锁</li>
<li>主要的实现操作为setnx，也就是set if not exist为什么这个操作能当锁呢？当第一个线程setnx了，那么value就会是自己的那个，并且返回为真。另一个线程到了上锁的这一段，也setnx，此时由于他要的key已经有了另一个值，不满足not exist，所以就返回否；这个的主要原因还是在于setnx是一个原子命令，一次执行一行就能满足并发的需求</li>
<li>第一阶段：我们就用setnx来完成，上锁过程直接将线程号作为值，解锁根据锁名称删除</li>
<li>第二阶段：可能出现这样一种情况，线程拿到锁以后卡了，过了释放时间释放给另一个线程，此时线程1缓过来了，执行到解锁过程就把别人的给解锁了。解决方法很简单，只要判断现在这个锁里面的值是不是自己的就可以</li>
<li>第三阶段：如果线程1在判断完了之后卡了，判断的结果确实是自己的，但是刚好超时了，这个时候又被别人抢走了，最后释放的还是别人的锁，这是因为锁不是原子性的，检查是否一致和释放要变成原子操作。需要用到lua脚本</li>
<li>第四阶段：用到了lua脚本完成了判断<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutsec)</span> &#123;</span><br><span class="line">        <span class="comment">//这里加uuid是因为在不同机器上的线程标识可能一致</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ID_PREFIX+Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(KEY_PREFIX+name, id , timeoutsec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//lua</span></span><br><span class="line">        stringRedisTemplate.execute(UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX+name),ID_PREFIX+Thread.currentThread().getId());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是非原子操作的解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlockNotSafe</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要判断是不是当前线程才能删除，否则会误删</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisValue</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ID_PREFIX+Thread.currentThread().getId();</span><br><span class="line">        <span class="keyword">if</span> (id.equals(redisValue))&#123;</span><br><span class="line">            stringRedisTemplate.delete(KEY_PREFIX+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="手写可重入分布式锁"><a href="#手写可重入分布式锁" class="headerlink" title="手写可重入分布式锁"></a>手写可重入分布式锁</h3><blockquote>
<p>与reentrantLock相似，实现可重入的过程就是一个hash数据结构，小key为线程id，大key为锁名字，值为进入的次数。可重入指的是一个线程可以多次获得这个锁，每次线程进入，value都要+1，同理，出去了就要-1，要保证最后退出的时候为0.</p>
<p>这里使用lua脚本完成，第一次手写遇到了很多困难，主要原因是一个空指针异常，估计是因为我用的模板是stringRedisTemplate，有一个long类型的数据一直报错。</p>
</blockquote>
<p>主要思路是，首先看redis中是否有这个锁，如果没有就直接上锁。如果有的话进一步检查线程号是否是自己的，如果是自己的就+1，不是的话就直接退出。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---key[1]为大key，argv[1]为小key，argv[2]为时间</span></span><br><span class="line"><span class="comment">---如果不存在大key，就直接setnx</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;exists&#x27;</span>,KEYS[<span class="number">1</span>]) == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--- 设置值为1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>],<span class="number">1</span>)</span><br><span class="line">    <span class="comment">--- 设置过期时间</span></span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">---如果没进入前面的判断，那么就是存在这个大key，要进一步判断是不是自己的key</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;hexists&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>]) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>],<span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;pexpire&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--- 如果都没有出去，说明两个条件都不满足，不是自己的锁，需要等待，返回剩余的时间</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>主要思路是判断是否是自己的，如果不是自己的直接退出，如果是自己的在判断是否减到0了，如果减少到0直接删除这个hash</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 判断是否是自己的，然后在判断是否减掉之后为0，为0则删除</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;hexists&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>]) == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">elseif</span> redis.call(<span class="string">&#x27;hincrby&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>],<span class="number">-1</span>) == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>改进后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可重入的分布式上锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Boolean&gt; REENTRANTLOCK;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    REENTRANTLOCK = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    REENTRANTLOCK.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;reentrantLock.lua&quot;</span>));</span><br><span class="line">    REENTRANTLOCK.setResultType(Boolean.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可重入的分布式解锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Boolean&gt; REENTRANTUNLOCK;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    REENTRANTUNLOCK = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    REENTRANTUNLOCK.setResultType(Boolean.class);</span><br><span class="line">    REENTRANTUNLOCK.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;reentrantUnlock.lua&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getId() + <span class="string">&quot;:&quot;</span> + ID_PREFIX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutsec)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">execute</span> <span class="operator">=</span> stringRedisTemplate.execute(REENTRANTLOCK, Collections.singletonList(KEY_PREFIX+lockName), getId(), timeoutsec+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Boolean.TRUE.equals(execute))&#123;</span><br><span class="line">        <span class="comment">//开启看门狗线程</span></span><br><span class="line">        <span class="type">WatchDogThread</span> <span class="variable">watchDogThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatchDogThread</span>(stringRedisTemplate,KEY_PREFIX + lockName);</span><br><span class="line">        watchDogThreadThreadLocal.set(watchDogThread);</span><br><span class="line">        watchDogThread.start();</span><br><span class="line">        log.debug(<span class="string">&quot;开启看门狗进程&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ThreadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">execute</span> <span class="operator">=</span> stringRedisTemplate.execute(REENTRANTUNLOCK, Collections.singletonList(KEY_PREFIX + lockName), getId());</span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(execute)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(<span class="string">&quot;解锁失败，这不是你的锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 停止看门狗</span></span><br><span class="line">    <span class="type">WatchDogThread</span> <span class="variable">watchDogThread</span> <span class="operator">=</span> watchDogThreadThreadLocal.get();</span><br><span class="line">    watchDogThread.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot;停止看门狗进程&quot;</span>);</span><br><span class="line">    watchDogThreadThreadLocal.remove();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="看门狗机制"><a href="#看门狗机制" class="headerlink" title="看门狗机制"></a>看门狗机制</h3><p>开启一个线程监视ttl，如果到了某个阈值程序还没结束就续期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WatchDogThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String watchKey;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    WatchDogThread(StringRedisTemplate redisTemplate, String key) &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = redisTemplate;</span><br><span class="line">        <span class="built_in">this</span>.watchKey = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">expire</span> <span class="operator">=</span> stringRedisTemplate.getExpire(watchKey, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="comment">//5秒钟续2秒</span></span><br><span class="line">                <span class="keyword">if</span> (expire != <span class="literal">null</span> &amp;&amp; expire.intValue() &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                    stringRedisTemplate.expire(watchKey, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RedisSystemException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>剩下的内容我觉得他课程没啥用，自己用消息队列就解决了，没啥技术含量就不写，主要是解耦的操作。<br>改造后就变成了前面校验完全用lua脚本，保证原子性的同时也不用上锁了，因为redis是单线程。有订单的就mq，kafka处理。<br>课程也有可取之处，BlockingQueue是我第一次见，这就是一个简易版本的消息队列，在队列为空的时候会阻塞消费者进程，满的时候会阻塞生产者进程。</p>
</blockquote>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/05/30/redis%E9%A1%B9%E7%9B%AE-%E7%99%BB%E5%BD%95%E9%80%BB%E8%BE%91/">redis项目-登录逻辑</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-05-30
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>毕业设计和各种考试耽搁了快两个月了，突然意识到再不继续学跟我的想法就会越走越远了，遂开始黑马点评的学习</p>
</blockquote>
<h2 id="基于session实现登录"><a href="#基于session实现登录" class="headerlink" title="基于session实现登录"></a>基于session实现登录</h2><p><strong>发送验证码</strong></p>
<p>首先校验手机号，通过正则表达式，然后再随机生成一个长度为6的字符串，保存在session中</p>
<p><strong>登录注册</strong></p>
<p>如果输入的验证码和存在session中的是一样的，那么就通过校验找对应的user实体类，user为空就直接注册（也就是insert），然后将user放在session中</p>
<p><strong>检验登录状态</strong></p>
<p>用户在请求时候，会从cookie中携带者JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行</p>
<p><img src="/../img/hmdp/img.png"></p>
<h3 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码"></a>发送验证码</h3><blockquote>
<p>Todo：后续可以根据Ruoyi那个图片验证码改进，但是逻辑都差不多</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.符合，生成验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.保存验证码到 session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br><span class="line">    <span class="comment">// 5.发送验证码</span></span><br><span class="line">    log.debug(<span class="string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="comment">// 返回ok</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.校验手机号</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验验证码</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">    <span class="keyword">if</span>(cacheCode == <span class="literal">null</span> || !cacheCode.toString().equals(code))&#123;</span><br><span class="line">         <span class="comment">//3.不一致，报错</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一致，根据手机号查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//不存在，则创建</span></span><br><span class="line">        user =  createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h3><blockquote>
<p>初始版本看session中是否有user对象，如果有就把他放到ThreadLocal中，方便后续调用，为什么不每次都在session中取呢？我猜是因为http的request不是随时随地哪个方法都要写的，threadlocal可以比较方便</p>
</blockquote>
<p>先写登录的拦截器，由于要进行处理，就跟aop一样，有一个pre有一个after，实现的是HandlerInterceptor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2.获取session中的用户</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.不存在，拦截，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser((User)user);</span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个拦截器但是还要让他生效，被springmvc管理，需要一个配置文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmdp.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmdp.interceptor.LoginInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.interceptor.RefreshInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// token刷新的拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebMvcConfigurer配置类其实是Spring内部的一种配置方式，采用JavaBean的形式来代替传统的xml配置文件形式进行针对框架个性化定制，可以自定义一些Handler，Interceptor，ViewResolver，MessageConverter。基于java-based方式的spring mvc配置，需要创建一个配置类并实现WebMvcConfigurer 接口；</p>
<p>常用的方法：</p>
<p><strong>addInterceptors：拦截器</strong></p>
<ul>
<li>addInterceptor：需要一个实现HandlerInterceptor接口的拦截器实例</li>
<li>addPathPatterns：用于设置拦截器的过滤路径规则；addPathPatterns(“&#x2F;**”)对所有请求都拦截</li>
<li>excludePathPatterns：用于设置不需要拦截的过滤规则</li>
<li>拦截器主要用途：进行用户登录状态的拦截，日志的拦截等。</li>
</ul>
<p><strong>addViewControllers：页面跳转</strong></p>
<p>拦截到一个路径就跳转到对应的页面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">    registry.addViewController(<span class="string">&quot;/toLogin&quot;</span>).setViewName(<span class="string">&quot;login&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法意思估计就是当&#x2F;toLogin”路径的时候跳转到login页面</p>
<blockquote>
<p>Todo：以后慢慢补充</p>
</blockquote>
<h2 id="Redis代替session的业务"><a href="#Redis代替session的业务" class="headerlink" title="Redis代替session的业务"></a>Redis代替session的业务</h2><blockquote>
<p>code和user都存在session中，而session是本地的，在集群模式下会失效，所以需要一个全局的解决方案。</p>
</blockquote>
<p>基本的解决思路就是把验证码和user都存在redis里面，设定过期时间，拦截器变成续期即可。有一个问题就是以什么数据结构来存。code可以以string类型来存储。<br>user其实也可以，我这里原本想的是用JSON存，但是不够直观，而且存储效率也没有hash好，所以还是跟着他用了hash。</p>
<p><img src="/../img/hmdp/img_1.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//这里用Redis完成</span></span><br><span class="line">        <span class="comment">//session.setAttribute(&quot;code&quot;,code);</span></span><br><span class="line">        redisTemplate.opsForValue().set(redisConstants.LOGINREDISCODE + phone,code, <span class="number">60</span>,TimeUnit.SECONDS);</span><br><span class="line">        log.debug(<span class="string">&quot;验证码为：&quot;</span>+code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(loginForm.getPhone())||RegexUtils.isCodeInvalid(loginForm.getCode()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里改用Redis</span></span><br><span class="line">        <span class="comment">//String sessionCode = session.getAttribute(&quot;code&quot;).toString();</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> redisTemplate.opsForValue().get(redisConstants.LOGINREDISCODE + loginForm.getPhone());</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="literal">null</span> || !loginForm.getCode().equals(code))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.eq(User::getPhone,loginForm.getPhone());</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getOne(lambdaQueryWrapper);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            temp.setPhone(loginForm.getPhone());</span><br><span class="line">            save(temp);</span><br><span class="line">            user = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID(<span class="literal">true</span>).toString();</span><br><span class="line">        <span class="comment">//用json存储</span></span><br><span class="line">        <span class="comment">//String jsonStr = JSONUtil.toJsonStr(user);</span></span><br><span class="line">        <span class="comment">//用hash存储</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">        Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                CopyOptions.create()</span><br><span class="line">                        .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                        .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForHash().putAll(redisConstants.LOGINUSER+token,userMap);</span><br><span class="line">        redisTemplate.expire(redisConstants.LOGINUSER,<span class="number">30</span>,TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主要就是用了redisTemplate的两种方法，string类型的就用opsForValue，hash用opsForHash，值得注意的是这里putAll是将一个map全部存进去，只有两个参数，而put可能指的是<strong>在这个key下的map中的其中一行</strong>，也就是说有三个参数，key，name和value。</p>
<p>这里的beanToMap主要记住setFieldValueEditor是编辑域的，那当然有两个参数，修改对应fieldName下的fieldValue</p>
<p>还有一个是setFieldNameEditor编辑name的，比如你想让name变成大写，就用UpperCase</p>
</blockquote>
<h2 id="解决登录刷新问题"><a href="#解决登录刷新问题" class="headerlink" title="解决登录刷新问题"></a>解决登录刷新问题</h2><blockquote>
<p>我们之前的拦截器会排除一些路径进行刷新，但是我们要这些路径被访问的时候也要刷新，所以选择了连个拦截器的方案，其中第一个完成所有redis的续期，后面一个延续拦截指定路径校验登录状态。</p>
</blockquote>
<p><img src="/../img/hmdp/img_2.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.检验是否有token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span> || token.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//1.1 如果没有token直接放行给下一个拦截器，这样肯定会被拦截</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.检验是否在redis中</span></span><br><span class="line">        <span class="comment">//entries得到的是一个map，get查具体的，所以有两个参数key和fieldName</span></span><br><span class="line">        Map&lt;Object, Object&gt; objectMap = stringRedisTemplate.opsForHash().entries(redisConstants.LOGINUSER + token);</span><br><span class="line">        <span class="keyword">if</span> (objectMap.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">dto</span> <span class="operator">=</span> BeanUtil.mapToBean(objectMap, UserDTO.class, CopyOptions.create());</span><br><span class="line">        <span class="comment">//3.保存在threadLocal中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//UserDTO userDTO = BeanUtil.fillBeanWithMap(objectMap, new UserDTO(), false);</span></span><br><span class="line">        log.debug(dto.toString());</span><br><span class="line">        UserHolder.saveUser(dto);</span><br><span class="line">        <span class="comment">//4.刷新时间</span></span><br><span class="line">        stringRedisTemplate.expire(redisConstants.LOGINUSER + token,<span class="number">30</span>, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;当前用户:&quot;</span>+user.getNickName());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/08/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%8A%EF%BC%89/">java-虚拟机（上）</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-08
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h1><p>按照大的来分可以分为三部分：</p>
<ol>
<li>类加载器，由于java是纯面向对象语言，类加载器会把java类转换成成字节码</li>
<li>运行时数据区（内存分区）：再细分可以分为共享的方法区和堆，线程不共享的虚拟机栈和本地方法栈，还有每个线程的指针</li>
<li>执行引擎：将中间代码转换成机器指令（x86，arm等）</li>
<li>本地库接口</li>
</ol>
<h1 id="运行时数据区详细介绍"><a href="#运行时数据区详细介绍" class="headerlink" title="运行时数据区详细介绍"></a>运行时数据区详细介绍</h1><ul>
<li>堆（线程共享）</li>
<li>方法区（线程共享）</li>
<li>程序计数器（线程独占）</li>
<li>虚拟机栈（线程独占）</li>
<li>本地方法栈（线程独占）</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>就如同cpu中的pc，虚拟机中也有对应代码的pc，为了实现并发，每一个线程程序运行到哪里都不一样，也就需要保存，恢复上下文也方便。所以在jvm中程序计数器是私有的。</p>
<p>注意：pc是唯一一个不会发生OOM的内存区域，估计是因为本来就放一个指针，再怎么样也超不出去。生存周期，随着线程的创建而创建，随着线程死亡而死亡。</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>这里的虚拟机栈跟真实的用c语言编译的栈类似，都是存函数调用的，有返回地址，局部变量，操作数，这里还有一个<strong>动态链接</strong></p>
<ul>
<li>局部变量表：主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</li>
<li>操作数栈：主要是作为方法调用的中间站，比如addi a,b,a（估计不是这么写的，反正就是a+b计算出来的值再赋给a），存放的那个临时变量就a+b就放在操作数栈</li>
<li>动态链接：运行到一定位置的时候可能会需要调用其他的类或者方法，这个时候就要把<strong>符号引用转换为调用方法的直接引用</strong>，因为再编译的时候都是用的常量池，在常量池引用的，一层套一层，这个时候就要把最核心的那个函数给拿出来，变成直接引用<br>虚拟机栈超出会报错的，栈帧数量不能多于一个值。比如无限递归，最后报错报的是栈溢出，而不是堆溢出，因为在爆堆之前就已经爆栈</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>这个跟虚拟机栈很像，但是虚拟机栈是为了java语句服务的，本地方法栈是使用到的本地native方法服务</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><blockquote>
<p>注意，我们在这里说的这五个其实是逻辑部分，就好像计算机组成原理中那五个部分一样，但是实际cpu又是控制器和运算器组合的。</p>
<p>这里也是类似，可以理解为这是jvm的逻辑设计图，具体实现的比如jdk1.7的持久代和1.8的元空间，其实也只是方法区的一个实现罢了</p>
</blockquote>
<h2 id="持久代和元空间"><a href="#持久代和元空间" class="headerlink" title="持久代和元空间"></a>持久代和元空间</h2><p>最大的一块，jdk1.7主要是三块，新生代，老年代和持久代，1.8把持久代取消了，取而代之的是元空间</p>
<p>个人理解，本来在堆中就完成了方法区的设计，在持久区放静态变量，代码块和编译好的代码，但是由于可能会出现oom，以及越来越多的动态类，时的很容易爆堆，这个时候不如把它提出虚拟机吧！放在实际内存下面，这样就有更广阔的空间给你爆了。</p>
<p>于是元空间这个概念就出来了，但是也不是无限扩大，有大小限制的</p>
<p><strong>为什么使用元空间？</strong></p>
<ul>
<li>1）由于 PermGen 内存经常会溢出，引发OutOfMemoryError，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM。</li>
<li>2）移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</li>
<li>3）减轻gc的负担，放在外面的元空间可以不用gc</li>
</ul>
<p>准确来说，Perm 区中的字符串常量池被移到了堆内存中是在 Java7 之后，Java 8 时，PermGen 被元空间代替，其他内容比如<strong>类元信息、字段、静态属性、方法、常量</strong>等都移动到元空间区。比如 java&#x2F;lang&#x2F;Object 类元信息、静态属性 System.out、整型常量等。</p>
<p>元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p>
<h2 id="新生代和老年代"><a href="#新生代和老年代" class="headerlink" title="新生代和老年代"></a>新生代和老年代</h2><ul>
<li>年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区，根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到老年代区间。</li>
<li>老年代主要保存生命周期长的对象，一般是一些老的对象</li>
</ul>
<p>这就涉及到后面的垃圾回收算法了</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>一般来存静态变量，常量以及编译好的代码</p>
<blockquote>
<p>这里要注意，既然方法区里面有常量，那也会有运行时常量池。这里要区分<strong>字符串常量池</strong>，jdk1.7之前，字符串常量池是跟持久代放在一起的，是持久代的一个组成部分，1.7之后，字符串常量池就放在堆空间里了，也就是说提出来了，直到现在也还是在堆空间</p>
<p><strong>为什么？</strong></p>
<p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>
<p>而运行时常量池是放在方法区的，也就是元空间</p>
</blockquote>
<h1 id="类加载器与双亲委派模型"><a href="#类加载器与双亲委派模型" class="headerlink" title="类加载器与双亲委派模型"></a>类加载器与双亲委派模型</h1><blockquote>
<p>这里的加载有点像dns的递归查找</p>
</blockquote>
<ul>
<li>bootstrapClassLoader：根加载器，每个都会从它开始</li>
<li>ExtClassLoader：扩展功能的一些jar包里面的类</li>
<li>AppClassLoader：应用类加载器</li>
<li>自定义，可以重写方法</li>
</ul>
<p><strong>双亲委派模型</strong></p>
<p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就返回成功；只有父类加载器无法完成此加载任务时，才由下一级去加载。 </p>
<p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现两个不同的 Object 类。双亲委派模型可以保证加载的是 JRE 里的那个 Object 类，而不是你写的 Object 类。这是因为 AppClassLoader 在加载你的 Object 类时，会委托给 ExtClassLoader 去加载，而 ExtClassLoader 又会委托给 BootstrapClassLoader，BootstrapClassLoader 发现自己已经加载过了 Object 类，会直接返回，不会去加载你写的 Object 类</p>
<p>好处：</p>
<ul>
<li>防止核心库被篡改</li>
<li>不重复加载类</li>
</ul>
<h1 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h1><p>tomcat，重写了loadClass方法</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/04/07/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%AD/">java-多线程-ThreadLocal和线程池</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-04-07
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</p>
<p>JDK 中自带的ThreadLocal类正是为了解决这样的问题。 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p>如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<p>再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="/../img/Java/img_5.png"></p>
<p>其实不是ThreadLocal有这个数据结构，是Thread持有的，有一个ThreadLocalMap的数组，专门放键值对，K为ThreadLocal的类对象，V为ThreadLocal泛型的数据。</p>
<p>也就是说，在一个线程中，如果有多个ThreadLocal，查找Map键为这个ThreadLocal变量，就可以很轻松拿到存的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h2><p>这个Map里面，Key是弱引用的，也就是说每次gc都会回收key，而value是强引用的。这个时候就会出现，key被gc回收了为null，value还有的情况。这个时候就会产生内存泄露。</p>
<p>解决方法：释放的时候手动remove。</p>
<h1 id="线程池的四个种类"><a href="#线程池的四个种类" class="headerlink" title="线程池的四个种类"></a>线程池的四个种类</h1><ol>
<li>newCachedThreadPool创建一个可缓存的线程池，默认阻塞队列是SynchronousQueue</li>
<li>newFixedThreadPool创建一个定长的线程池，默认阻塞队列是LinkedBlockingQueue</li>
<li>newSingleThreadExecutor创建一个单例线程，默认也是LinkedBlockingQueue</li>
<li>newScheduled创建一个可以设置定时任务的线程</li>
</ol>
<h1 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h1><p>除了上面四种封装好的，还可以自己创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                           )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>七个核心参数：</p>
<ol>
<li>核心线程数量</li>
<li>最大线程数量</li>
<li>过期时间：如果线程池的线程数量大于核心线程数量，如果没有新的任务提交，那么已经到期的线程不会立刻销毁，而是等一段时间销毁</li>
<li>过期时间单位：可以是秒，毫秒</li>
<li>阻塞队列：刚刚提的那些，后面还会说</li>
<li>饱和缩略</li>
<li>线程工厂类：一般都是默认的，可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li>
</ol>
<h1 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h1><p>当阻塞队列满了，而且最大线程数量也满了，就会触发饱和策略</p>
<ol>
<li>抛出异常，不让加了</li>
<li>线程不走线程池，提交线程的那个线程自己来运行</li>
<li>不报错，直接丢弃</li>
<li>丢弃队列最前面那个，然后加进队列</li>
</ol>
<h1 id="如何确定线程数量"><a href="#如何确定线程数量" class="headerlink" title="如何确定线程数量"></a>如何确定线程数量</h1><ul>
<li>io密集型：2n+1</li>
<li>cpu密集型：n+1<br>这里的n都是当前机器的虚拟内核数量，io密集型主要都是io时间多，对于cpu负载并不大</li>
</ul>

    
    
  </div>

  

  

</article>
  
    
  <nav class="pagination">  
      
      <a class="prev" href="/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text">上一页</span>  
      </a>  
      
      
      <a class="next" href="/page/3/">  
        <span class="next-text">下一页</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  
</section>
        </div>
          

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:1050886654@qq.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/yyf1050886654" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2024      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">Yifan Yang</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    

  







<script type="text/javascript" src="/lib/jquery"></script>



<script type="text/javascript" src="/lib/slideout"></script>



<script type="text/javascript" src="/lib/fancybox"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>