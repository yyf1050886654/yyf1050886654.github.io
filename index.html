<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/default" title="YYF's Blog" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://yyf1050886654.github.io/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>YYF&#39;s Blog</title>

<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">YYF&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/collect/">
      <li class="mobile-menu-item">
        
        
        收藏              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">YYF's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/collect/">  
              
              
              收藏  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <section id="posts" class="posts">
  
  
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/11/06/%E8%BD%AF%E8%80%83%E8%AE%BA%E6%96%87%E5%A4%A7%E7%BA%B2/">软考论文大纲</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-11-06
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>过去两年，全球贸易环境在需求波动、供应链重组和数字技术发展的多重影响下持续变化。世界贸易组织数据显示，2024年全球货物贸易总额约为3.3万亿美元，同比增长3.3%，虽然贸易总体仍在增长，但企业之间的竞争日趋激烈。与此同时，买卖双方的信息壁垒依然明显，传统依靠展会、人脉和代理的外贸模式在效率和可持续性上显得力不从心。对中国外贸企业而言，这一趋势尤为明显。根据海关总署数据，2024年中国进出口总额达到43.85万亿元人民币，同比增长5%，其中出口额为25.45万亿元，同比增长7.1%。但在数字化转型成为行业共识的当下，许多中小企业仍依赖人工整理数据、分散管理客户资源，无法有效整合全球采购、海关、信用、物流等信息，导致潜在客户挖掘难、转化效率低、营销成本高。<br>基于此需求，网易推出了“外贸通”智能外贸综合服务平台，旨在以数字化方式帮助外贸企业提升客户拓展与市场分析能力。该平台整合全球海关数据、采购网站、企业工商信息与网站行为数据，构建统一的外贸数据中心，并利用AI算法实现客户画像、智能推荐和商机预测。系统能够为企业提供“从数据到客户”的一体化解决方案，使销售人员能够基于客观数据快速筛选高价值客户，而非依赖经验式判断。该项目自2022年7月启动，立项资金500万元，历时7个月上线，目前仍在持续迭代，用户规模不断扩大逐渐成为事业部的盈利增长点。</p>
</blockquote>
<h2 id="论负载均衡"><a href="#论负载均衡" class="headerlink" title="论负载均衡"></a>论负载均衡</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>本人于2022年7月参与了某大型互联网公司“外贸通”项目的研发工作，我在该项目中担任系统架构设计师一职，主要负责架构设计和系统评估。该项目是一个为企业提供从用户发现到外贸营销的一站式外贸SaaS平台，主要功能模块包括客户发现、邮件营销EDM、客户管理CRM、海关贸易数据爬取链路等，并通过AI和大数据为外贸企业赋能。我将以“外贸通”项目为背景，阐述负载均衡在该项目三层架构中的应用：表示层使用Nginx进行七层负载均衡、功能层使用SpringCloud Gateway和Ribbon实现微服务负载均衡治理、数据层的Redis使用主从复制实现读写分离提高并发，MySQL利用ShardingSphere JDBC实现水平分片，并通过自定义的哈希算法实现负载均衡。由于多种负载均衡算法的考虑使得系统稳定性提高了40%、性能提高32%，获得客户的一致好评。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路：先阐述层次架构的概念，介绍我们的项目是B&#x2F;S和C&#x2F;S混合的瘦客户端架构，然后介绍负载均衡的意义以及负载均衡的常见算法，随机、哈希、轮询、一致性哈希、四层负载和七层负载，http重定向、NAT重定向。接着分别介绍表示层也就是前端的技术栈Vue+Nginx，使用服务端渲染，Nginx反向代理给后端网关，转发和路由，监控；结合介绍功能层也就是后端的技术微服务架构，采用Spring Ribbon实现网关的负载均衡，分配到具体的服务实例上，一般的算法是哈希分片和轮询RR，我们在这里使用的微服务服务发现中心Nacos事实上也可以起到一定的均衡作用；最后介绍数据层面的负载均衡，Redis的主从复制用了一台主Redis节点和两台从Redis，均为四核16GB，主从复制采用Replica of IP进行复制，从节点会存储一个offset以便与主节点同步，初始同步使用RDB后续使用AOF，存储在Replication backlog buffer，进行了热key的预热，用负载均衡和读写分离抵御了一次高并发热点活动；分库分表使用Apache ShardingSphere，水平分片突破单机MySQL上线，使用自定义的哈希算法实现子查询的负载均衡。</p>
<h2 id="论面向服务架构"><a href="#论面向服务架构" class="headerlink" title="论面向服务架构"></a>论面向服务架构</h2><h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><p>本人于2022年7月参与了某大型互联网公司“外贸通”项目，在该项目中担任软件架构设计师一职，主要负责架构设计和功能优化。该项目是一个为企业提供从客户发现到外贸营销的一站式外贸SaaS平台，主要功能模块包括客户发现、邮件营销EDM、客户关系管理CRM和海关贸易数据爬取链路等。为了消除信息孤岛问题，项目构建采用面向服务的架构，我将主要描述SOA企业服务总线、业务处理服务、业务创新服务、控制服务、IT管理模块，开发服务在本项目中的应用。采用的面向服务的架构有效提升开发和通信效率，获得了业界和用户的一致好评。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先描述面向服务的架构是更粗粒度的，相比于传统的面向对象和面向构建更松耦合，SOA的技术栈主要包括UDDI进行服务发现注册、WSDL网络服务描述语言描述服务基本功能、接口和位置、SOAP完成服务调用、TCP&#x2F;IP作为传输层协议辅助通信。采用SOA的意义在于架构复用，每个模块功能通过企业服务总线ESB进行调用，能够有效提高性能和效率。接着介绍SOA服务的六个主要类别：企业服务总线ESB作为服务发现中心协调服务之间的调用，由于外贸通项目的调用链路特别长，从获取信息到邮件营销到潜在客户管理；此外还要屏蔽各平台贸易数据的实现差异以及海关数据的接口差异，例如有的使用http有的使用soap的webservice，ESB需要屏蔽这一层差异，我们做了多重枚举的适配解决这一问题，从而给接口调用返回一个公共类型的对象；此外我们的ESB还设计了事件触发机制，多条链路的数据爬取通过隐式调用同步到线上，通过ESB的高级功能实现。接着是业务处理服务和业务创新服务，我们将业务粗粒度的划分为应用服务、数据服务、海关服务、CRM服务等，应用服务和数据服务服务总线隐式调用，应用服务包括restful api和controller来直接与用户界面交互、数据服务利用xxljob和kafka，采用多种爬虫策略多渠道多国家获取贸易数据和潜在公司，再结合大数据和大模型对数据进行清洗，聚类分析和分类分析，尽最大可能给用户提供高相似度的推荐公司，通过召回不断迭代优化算法；开发服务采用devops模式，实现了一套持续交付持续基础的git流水线，利用jenkins实现了开发、部署、灰度和上线的全流程流水线，集成在我们的SOA架构中，有效提高了软件开发效率；控制服务和IT服务管理主要是高效安全的管理业务流程，对于IT资产使用加密的模型库和数据库，通过线上审核和工单提单机制来进行责任追踪，确保资产的完整性和安全性；对于整条业务流程采用多种权限控制，前后端均进行校验，后端采用spring security和shiro进行校验，同时自动化巡检会对漏洞定期抽查，随后反馈到工作群组中。基于完整的介绍了基于服务的架构SOA在“外贸通”项目中的应用。</p>
<h2 id="论云原生架构"><a href="#论云原生架构" class="headerlink" title="论云原生架构"></a>论云原生架构</h2><h3 id="摘要-2"><a href="#摘要-2" class="headerlink" title="摘要"></a>摘要</h3><p>本人于2022年7月参与了某大型互联网公司“外贸通”项目的开发，在该项目中担任系统架构设计师，主要负责项目的系统架构设计和软件质量分析。“外贸通”为企业提供了一套从潜在客户发现到邮件营销到商机转化到客户管理的一站式的外贸SaaS解决方案，自上线以来用户规模不断扩大逐渐成为事业部的核心赢利点。我们聚焦于云原生架构使得能够自动化部署高效运维，通过容器化和自动编排以及CI&#x2F;CD，结合私有云和服务网格实践整合出了一套高效的适合本业务场景的微服务治理体系。在安全性和面对高并发场景能够较强的健壮性，同时也能实现快速迭代的需求。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>先说明传统架构的缺点，普通的基于虚拟机的架构不适合持续集成持续交付，多服务运维较为复杂，配置环境无法统一。使得程序员需要花大量的时间在非功能代码方面，运维成本大，无法聚焦于业务。通过云原生的serviceless模式，部署采用git流水线通过jenkins和容器化直接同步到线上，程序员可以更加关注代码而非运维和环境，解放了生产力；此外可以借助容器化实现微服务治理，不再需要重量级的部署，通过docker虚拟化携带操作系统必要的执行文件，可以轻量化应用实现微服务架构；此外云原生使用k8s动态扩容集群，针对某些高并发场景提高健壮性，使得系统更灵活；云原生的链路追踪和日志管理采用ElasticSeach+LogStach+Kibana+SkyWalking实现日志统计和报表产生，数据看板采用普罗米修斯+Grafana。综合来看，我们搭建了的云原生架构包括以下内容：使用docker将微服务装载进容器，使得部署更加轻量级；使用基于jenkins和git的持续集成&#x2F;持续部署流水线，简化运维流程；使用基于k8s的容器扩容和动态调整，面对高并发场景更鲁棒；使用ELK的日志管理系统，以及普罗米修斯的数据看板；结合公司内部的私有云服务完成了一套微服务下的云原生治理体系。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/10/31/%E5%AE%9E%E4%B9%A02-0-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">实习2.0-项目总结</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-10-31
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="实习拷打"><a href="#实习拷打" class="headerlink" title="实习拷打"></a>实习拷打</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>网易外贸通是一个为外贸企业打造的一站式外贸营销平台，主要的功能包括数据获客，邮件营销，客户管理和订单追踪等。<br>我所在的组是做数据获客的，主要业务就是让用户能够通过我们的应用查到他的潜在客户。就比如一个想做服装贸易的就可以通过我们的数据找到对应的国外买家。<br>这一部分数据获取是多渠道的，我们通过海关每年的hscode，各种类似盘踞这些网站采购，以及一些爬虫技术拿到了大概六千万家公司数据。我们的业务一方面是搜索功能，所以我们数据层没用mysql多用的是es；<br>另一部分是数据层，多渠道去搜集这些公司作为我们的信息。</p>
<h3 id="数据双向同步链路-落库"><a href="#数据双向同步链路-落库" class="headerlink" title="数据双向同步链路-落库"></a>数据双向同步链路-落库</h3><ol>
<li>目的：我们这边是做数据的，另外一边算法组做的是域名行业分类，意思就是他们把域名对应的html通过某种模型预测一个行业标签，我们组展示需要这个tag，但是他们落库不在我们这边，于是就将这部分有tag的域名推送给我们，kafka消息里面传的是这个domain，但是具体的标签信息需要我们去请求grpc获取。</li>
<li>解决方案：对于这部分工作我首先是给entity新增了关于域名分类的字段，然后写了一个kafka listener批量消费，grpc接口能够一次传50个域名然后返回50个对应的行业信息。</li>
<li>遇到问题：由于grpc限流以及有可能域名查不到，会造成消息丢失。他那边grpc接口设置是1秒一次，因此我要保证他那边报错了消息重新消费。</li>
<li>解决问题：两个set，一个全局set一个失败set，错误可能发生在kafka消费的时候、拿着所有50条去请求rpc接口的时候、rpc接口报错或者没有数据的时候、es更新的时候：<br>（1）kafka消费报错，这里是手动ack的，所以一旦没有消费成功offset也没偏移，一般不会出现这种情况。<br>（2）拿着50条数据请求rpc接口的时候：在消息消费的时候就组装了这两个set，如果这里出现问题，也能保证这50条不提交<br>（3）rpc接口报错或者没有数据的时候：例如限流了，此时也可以返回这50条；但如果返回有效需要清空这个失败set，按照实际他返回的数据再去组装，因为有可能这个域名他就是没有数据，允许一部分这种差异。<br>（4）es落库一条从这个失败set里面移除一条。<br>最终效果是推送了900w条数据，根据新增的这个recommend字段exist查询已落库数量，成功率接近100%，分析了一些差错case，原因基本上是动态问题，原本推送的某些域名后续调整他把字段删除了，因此rpc接口请求不到。</li>
</ol>
<h3 id="数据双向同步链路-推送"><a href="#数据双向同步链路-推送" class="headerlink" title="数据双向同步链路-推送"></a>数据双向同步链路-推送</h3><ol>
<li>目的：我们数据组每天都会搜集域名，算法组需要这些增量数据，因此需要一个topic每天定时通过kafka发送新增域名</li>
<li>解决方案：xxljob设置每天凌晨推送新增domain数据，根据createTime来看，然后深度分页用scrollSearch解决</li>
<li>遇到问题：他这边没有createTime，只有updateTime，这就可能导致重复发送了，因此需要一个发送的tag，与mt商量后同意这种做法了</li>
<li>解决问题：发送的时候同时给数据新增一个字段flag，查询的时候去看有没有这个字段，有并且又是昨天的就发送。</li>
</ol>
<h3 id="订阅更新任务"><a href="#订阅更新任务" class="headerlink" title="订阅更新任务"></a>订阅更新任务</h3><p>原本逻辑：每周每个账号订阅的公司消息进行处理和监听；<br>后来逻辑：增加一个watchTime字段，如果用户在这一周查看过这个订阅更新界面就刷新。<br>改造方法：查询接口crud这个字段，一天watchtime只更新一次。然后xxljob里面的执行器加一个这个过滤即可，然后将这些作为一个消息发送给kafka</p>
<p>kafka消费者拿到这些id去数据库找对应的公司，将订阅公司表项和公司实体项（从es来的，如果前者有companyId就直接查询，如果没有就需要根据名字和地区来查询并保存）作为参数传分别分析facebook信息，facebook提及信息，海关信息，联系人信息，开了一个线程池并行处理这些。<br>原来这块是顺序的，因为本就是离线任务，触发的频率也不高，后续改成了线程池，用了异步编排，以便后续扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>,</span><br><span class="line">            <span class="number">10</span>, <span class="number">60</span> * <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">2000</span>), COLLECTMONITORCOMPONENT_SERVICE_THREAD_FACTORY, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>




    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/10/31/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8C%BA%E5%9D%97%E9%93%BE/">虚拟线程与区块链</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-10-31
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h1><p>虚拟线程是jdk19提出来的预览特性，jdk21转正。在以往的一对一线程模型中，虽然将进程划分为了线程，但是线程的粒度还是太大了，一个线程占1m，在高并发动不动几十万qps下，内存都不一定打的住。利用粒度更细的协程，可以将这部分开销继续缩小。</p>
<h2 id="虚拟线程优点"><a href="#虚拟线程优点" class="headerlink" title="虚拟线程优点"></a>虚拟线程优点</h2><ol>
<li>占据资源少，切换开销小：虚拟线程是一种用户级线程（绿色线程），不需要操作系统管理而是jvm管理。切换开销更小，可能只涉及jvm的堆空间。</li>
<li>增大cpu的吞吐率，适合io密集型任务：在经典的线程模型中，线程在io时会让出cpu。如果每个线程都要io那么cpu的利用率就很低了，会导致资源耗尽的同时硬件资源没有充分利用。但是虚拟线程是运行在平台线程上的，一个虚拟线程io了可以切到另一个虚拟线程，但是平台线程是不会释放的。这样可以用粒度更低的开销更高效的利用线程资源。</li>
<li>异步改同步，适合阻塞式io：io多路复用是通过一个线程来监听多个socket的状态，通过大量的异步回调实现，机制较为复杂；虚拟线程跟它解决的问题是一致的，都是解决如何增大并发量；但是虚拟线程不需要进行如此复杂的异步回调，用同步操作即可，如果一个线程在io阻塞，jvm无非就是把平台线程的资源切到另一个虚拟线程，免去了复杂的回调。</li>
<li>更灵活：有个例子我觉得很形象。传统的线程模型可以理解为一排固定死的插座，虚拟线程模型就是插座连接的插排。你要修改插座是需要改墙体改布线的，对应os和cpu的关系，而且还存在就算插排插满了但是功率还上不去的现象；但是如果用虚拟线程也就是插排，你想要多点接口就换个更大的插排，这样你的功率也上去了，对电力的利用率也很高。</li>
</ol>
<h2 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select&#x2F;poll&#x2F;epoll"></a>select&#x2F;poll&#x2F;epoll</h2><ol>
<li>select: 每一个socket对应一个fd（文件描述符），用户态给内核态监听，最多长度1024，内核态通过循环的方式监听，一旦有io准备就绪就改变fd状态，然后传输给用户态的时候应用进程还需要遍历一边。也就是说既有长度限制，有需要遍历两次，效率较低。</li>
<li>poll：用链表改变了1024这个数字，其余没区别。还是改变状态让用户态自己去遍历。</li>
<li>epoll：将socket的文件描述符通过红黑树组织起来，查询效率从on变为ologn，此外将循环遍历变成事件回调，有复杂的事件注册函数。触发机制有水平触发和垂直触发，一旦回调函数说socket准备就绪，就把他放在一个队列里面等待返回用户态，水平触发是只要没读完就一直提醒用户态来读，垂直触发是只提醒一次，但是一次需要全部读完。</li>
</ol>
<h2 id="java虚拟线程和go的gmp协程模型"><a href="#java虚拟线程和go的gmp协程模型" class="headerlink" title="java虚拟线程和go的gmp协程模型"></a>java虚拟线程和go的gmp协程模型</h2><h3 id="gmp模型"><a href="#gmp模型" class="headerlink" title="gmp模型"></a>gmp模型</h3><ol>
<li>g是goroutine，每次在调用go func的时候就会产生一个g，也可以理解为协程控制块；m是机器线程，对应了一个真实的被操作系统调度的线程；p是逻辑处理器，必须要一个g通过p绑定到m才可以运行，相当于一个上下文填充器。</li>
<li>有两个队列：局部运行队列LRQ，每一个p都有一个这个队列，放等待该p作为中介给m运行的g；全局运行队列GRQ，分配尚未给LRQ的m</li>
<li>gmp模型是通过调度的方式把g调度给线程，底层运行的还是线程，是一个M对N模型，这点与java是不同的，java的虚拟线程是通过jvm调度的，运行在平台线程上，而不是哪里线程空了就用哪个线程的资源。</li>
<li>交接机制：如果一个m上的g在等待io，这个时候中介p挂到别的空闲m上让自己队列里面g使用。使得阻塞不会影响整体的调度。</li>
<li>窃取机制：每个线程都是工贼，没有任务就要去别的LRQ里面偷，或者去GRQ中偷。<br><img src="/../img/golang/gmp/img.png"></li>
</ol>
<h3 id="虚拟线程调度模型"><a href="#虚拟线程调度模型" class="headerlink" title="虚拟线程调度模型"></a>虚拟线程调度模型</h3><ol>
<li>Java 的虚拟线程由 Continuation（保存&#x2F;恢复执行栈）+ Scheduler（Executor） 实现：虚拟线程在运行时被 mount（挂载）到一个 carrier（承载，平台）线程 上执行；遇阻塞时会 yield（保存 continuation 并释放 carrier），阻塞完成或 unpark 时将 continuation 重新提交给 scheduler 以被某个 carrier 线程恢复执行。这个逻辑以 java.lang.VirtualThread + JVM&#x2F;HotSpot 的 continuation 支持 + JDK core libs 的调度器协作实现。</li>
<li>虚拟线程也支持交接和窃取，这点是gmp学的</li>
<li>注意虚拟线程使用synchronized会将虚拟线程pin住，因为这里synchronized是监视器锁，锁住的是线程，如果在虚拟线程用这个会把平台线程锁住，无法参与调度。一般并发低没事，高了就会将虚拟线程退化为平台线程。因此要控制同步操作使用基于jdk的reentrantlock好一点。<br><img src="/../img/golang/gmp/img_1.png"></li>
</ol>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/10/16/%E8%BD%AF%E8%80%83-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/">软考-基础部分</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-10-16
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="系统架构设计"><a href="#系统架构设计" class="headerlink" title="系统架构设计"></a>系统架构设计</h1><h2 id="系统架构设计概述"><a href="#系统架构设计概述" class="headerlink" title="系统架构设计概述"></a>系统架构设计概述</h2><ol>
<li>软件架构设计（Software Architecture）解决了需求分析和设计阶段之间的鸿沟，是需求分析与设计阶段的过渡阶段。一个好的系统架构，能够使得系统在面对灾难性错误时不会产生严重的故障。</li>
<li>软件架构就是<strong>需求分配</strong>，将满足需求的职责分配到对应的组件上。</li>
<li>软件架构是软件在结构、行为和属性的高层次抽象。主要由构件的描述、构件之间的联系关系（连接子）、系统继承的模式和一组约束构成。</li>
<li>软件架构不仅规定了系统的组织架构和拓扑结构，还规定了组件与需求之间的映射关系。</li>
<li>软件架构解决的核心问题是软件的复用、质量和维护。</li>
<li>软件架构设计主要有以下三个活动：提出架构模型、进行架构设计、进行架构审核。其中架构设计主要关注软件架构的结构、属性和连接关系，并通过多视图全面描述特定模型的软件架构。</li>
<li>软件架构在设计更改相对容易的阶段，便于技术人员和非技术人员进行交互，从而展现软件的结构、属性和交互关系。</li>
<li>软件架构是可传递和可复用的模型。</li>
</ol>
<h2 id="软件架构和生命周期"><a href="#软件架构和生命周期" class="headerlink" title="软件架构和生命周期"></a>软件架构和生命周期</h2><ol>
<li>需求分析阶段：传统的需求分析阶段主要产出的是问题空间，而软件架构在此阶段产生解空间。主要研究的问题是：如何将需求分析转化为软件架构SA；以及如何进行跟踪（包括正向跟踪和反向跟踪）</li>
<li>设计阶段：主要有三个活动：软件架构的描述、对软件架构进行分析和设计、对产生的设计经验进行总结和复用。其中对SA的描述可以有三个层次：SA的基本描述、体系结构描述语言ADL，SA的多视图。</li>
<li>实现阶段：软件架构的管理，可以使用项目管理工具；软件架构的实现，如何将SA过渡到具体实现，如何将SA的需求分配到对应构件上，可以采用程序设计语言的思想进行设计；软件架构的测试</li>
<li>组装阶段：SA给予了一个更高层次的蓝图，主要研究构件之间如何相互关联，也就是连接子的实现；此外还要解决这些构件之间的失配问题，包括构件的失配、连接子的失配以及结构产生的失配问题。</li>
<li>部署：SA可以为部署提供一个更好的解决方案</li>
<li>后开发阶段：进行软件架构的演化、复用和维护</li>
</ol>
<h2 id="构件"><a href="#构件" class="headerlink" title="构件"></a>构件</h2><ol>
<li>构件是一个可以独立部署并交付的功能单元，外界可以通过其接口进行访问。由多个原子构件构成，原子构件由模块和资源构成。原子构件是部署，版本控制和替换的基本单位，原子构件一般可以独立部署，但是不会独立部署。都是按照一组原子构件家族进行部署。</li>
<li>模块是不带资源的原子构件，一个模块可以包含多个类进行打包。</li>
<li>构件与对象的区别：构件的特征是可以独立部署且独立交付、作为第三方的组装单元，可以由第三方调用、对外隐藏自己状态；对象的特征是可以一个实例单元且有唯一标识、可以有自己的状态、对外进行封装。</li>
<li>构件接口规定了构件之间通信的格式、模式和协议，使得接口之间传递消息更具有规范性和一致性。</li>
<li>面向构件的编程一般要求具有：多态性（可以替换同接口的实现构件）、<strong>模块封装性（更高层次的隐藏）</strong>、独立部署性、安全性</li>
<li>目前市面上的主流构件有以下三类：</li>
</ol>
<ul>
<li>EJB（Enterprise Java Bean）是Sun公司提出的一种在Java平台的企业级构件模型，主要规定了三类构件bean，会话bean，实体bean和消息传递bean。使得企业开发能更加注重业务也就是实现这一些bean，提高工作效率，但是缺点是配置大于约定，配置过于复杂，对程序员要求高且不方便；</li>
<li>COM是微软公司提出的，只能在Windows平台进行开发的构建技术，还衍生出DCOM和COM+的技术</li>
<li>CORBA（Common Object Request Broker Architecture）公共对象请求代理架构，由OMG公司提出主要分为三个层次：ORB对象请求代理，针对异构的对象实现了不同的接口，定义了一条软总线能够将不同的对象转化成对上层统一的公共对象；公共对象基础服务，这一层在得到对象的基础上进行了一系列公共服务的抽象，例如并发控制、事务控制等；最后一层是对外的公共基础服务，此时可以对外暴露接口提供对象访问的服务了。</li>
</ul>
<h1 id="架构设计风格"><a href="#架构设计风格" class="headerlink" title="架构设计风格"></a>架构设计风格</h1><ol>
<li>软件架构设计风格是在特定领域下软件架构设计的惯用模式。主要由软件结构，一个词汇表和一组约束构成。词汇表包含架构中构件和连接件的描述，约束定义了这些组件之间的关系。</li>
<li>软件架构风格反应了在某特定领域下多种架构设计的共有结构和语义特性，能够指导子模块和子系统的有效集成和组成一个更大的系统。研究软件架构风格促进软件复用，能够将该领域已有的架构解决方案迁移到解决新的问题上。</li>
<li>软件复用是研究软件架构的一个核心问题</li>
<li>架构风格种类：数据流、调用-返回、独立构件、仓库、虚拟机</li>
</ol>
<h2 id="数据流风格"><a href="#数据流风格" class="headerlink" title="数据流风格"></a>数据流风格</h2><ol>
<li>批处理风格：构件是一系列顺序排列的计算单元，构件之间通过数据进行连接，每个构件必须由上个构件处理完成之后才能开始处理，数据的传输是完整的。</li>
<li>管道-过滤器风格：每个构件都有输入和输出，构件读取输入的数据流，经过处理得到输出数据流。要求数据流顺序，输入必须是上一个构件产生的输出流，可以把并行。过滤器为构件，管道为连接子。一般出现在早期的编译器软件架构中。</li>
</ol>
<h2 id="调用-返回风格"><a href="#调用-返回风格" class="headerlink" title="调用-返回风格"></a>调用-返回风格</h2><ol>
<li>主函数-子函数风格：单线程模型，将复杂问题分解为可以单独处理的子问题。子函数解决子问题，通过主函数进行调用。函数为构件，相互调用为连接子。</li>
<li>面向对象风格：对象即为构件，对象之间的相互作用，例如函数之间的方法调用和过程调用为连接子。</li>
<li>层次架构：构建为每一个层次，连接子为每个层次之间的调用关系。每一层都进行封装，为上一层提供接口，同时使用下一层的服务。修改层次时只会影响相邻的两层。这样的优点是：将一个复杂问题分解为若干的子问题；越靠近底层越抽象；可复用。缺点是：调用无法跨层，效率底；也不一定所有的系统都能划分为层次结构。</li>
</ol>
<h2 id="独立构件风格"><a href="#独立构件风格" class="headerlink" title="独立构件风格"></a>独立构件风格</h2><ol>
<li>进程通信：命名进程是构件，进程之间相互作用为连接子。一般有三种调用方式：点对点、同步&#x2F;异步方式，rpc</li>
<li>隐式调用（事件驱动）：构件不直接调用过程，而是通过触发或者广播一到多个事件。构件的过程可以由多个触发源进行定义，当构件接收到触发，就会使用已经定义好的函数过程进行调用，从而达到隐式和解耦的功能。这样的优点是增大了软件的复用性，缺点是放弃了软件调用过程的控制权。</li>
</ol>
<h2 id="虚拟机风格"><a href="#虚拟机风格" class="headerlink" title="虚拟机风格"></a>虚拟机风格</h2><ol>
<li>解释器风格：由解释引擎，存放被解释程序的缓存区，存储解释引擎解释状态的数据结构和程序解释执行的具体位置的存储器构成。优点是规则可以自定义，缺点是慢</li>
<li>基于规则的系统：规则集，规则解释器，规则选择器，工作内存。一般用在ai和dss</li>
</ol>
<h2 id="数据风格"><a href="#数据风格" class="headerlink" title="数据风格"></a>数据风格</h2><ol>
<li>数据库风格：两个构件，数据库和多个独立的数据处理单元</li>
<li>黑板风格：知识源，黑板，控制。多个独立的知识处理单元，可以操作黑板进行演算。黑板是一个集中式数据库，可以通过知识源进行修改。一般适用于嵌入式系统、语音识别系统等复杂的没有固定解的系统</li>
<li>超文本风格：基于网络的</li>
</ol>
<h1 id="层次架构风格"><a href="#层次架构风格" class="headerlink" title="层次架构风格"></a>层次架构风格</h1><ol>
<li>两层C&#x2F;S：表示层和数据层，表示层也可以存储数据，还要保证一致性，现已不用</li>
<li>三层C&#x2F;S：表示层、功能层和数据层，表示层仅作展示。优点：管理更清晰；可以并行开发；可以选择适应的环境和开发平台；保持了逻辑独立性</li>
<li>三层B&#x2F;S：客户端变成浏览器，访问慢了，安全性也不强</li>
<li>富互联网应用：小程序，看上去没有客户端，但是通过高速网络现场搭建，因此综合了B和C的优点</li>
<li>MVC架构：模型、控制、视图。模型直接与视图交互，不安全</li>
<li>MVP架构：模型、表示、视图。切断了模型与视图的直接交互，更安全</li>
</ol>
<h1 id="特定领域软件架构"><a href="#特定领域软件架构" class="headerlink" title="特定领域软件架构"></a>特定领域软件架构</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>特定领域软件架构DSSA（Domain Specific Software Architecture）是一组在特定领域下的软件开发构件集合，是一组在特定领域下获取系统的参考结构，参考需求和领域模型的开发环境，目标就是生成一个或多个领域应用。</li>
<li>水平域和垂直域</li>
<li>三个基本活动：领域架构分析：目标是获取领域模型，找领域专家来定义领域范围和定义领域特定元素；领域架构设计：目标是获取DSSA；领域架构实现：软件架构重用</li>
<li>四个人员：领域专家、领域分析专家、领域设计专家、领域实现专家</li>
<li>五个过程：定义领域范围；定义领域特有的元素；定义领域特有的设计和约束；定义领域模型和实现；搜集并开发可重用元素</li>
<li>四个特征：有明确的问题域和解决域；适当程度的抽象；有可重用元素；在领域内有普遍性</li>
<li>三个开发环境和五个产出：领域开发环境、特定领域下的应用开发环境，应用实际环境。产出：领域结构，领域需求，架构，开发工具，领域模型。</li>
</ol>
<h1 id="基于架构的软件开发方法"><a href="#基于架构的软件开发方法" class="headerlink" title="基于架构的软件开发方法"></a>基于架构的软件开发方法</h1><ol>
<li>ABSD（Architecture Based Software Development）是由架构驱动，强调由软件业务，质量和功能需求指导软件架构设计。用视角和视图来描述软件的软件架构，以用例和质量属性场景来描述软件的需求。</li>
<li>使用ABSD方法可以在软件模型定义明确之后立刻进行设计</li>
<li>三个基础：功能的分解，需求分解到对应组件；软件架构风格；可重用的组件，软件模板</li>
<li>六个阶段：架构需求、架构设计、架构文档化、架构复审、架构实现、架构演化</li>
<li>架构需求三步：定义类图，类进行归类，产生包</li>
<li>架构设计五步：提出架构模型，需求切分，构件之间联系，产生架构，架构评审</li>
<li>架构文档化两个文档：架构规格说明书，测试架构需求的质量设计说明书</li>
</ol>
<h1 id="软件质量属性"><a href="#软件质量属性" class="headerlink" title="软件质量属性"></a>软件质量属性</h1><ol>
<li>质量属性分为开发时和运行时</li>
<li>八个质量属性和提升方法：<ul>
<li>性能：优先级队列，并发，增加计算资源，减少开销</li>
<li>可用性&#x2F;可靠性：容错容灾，心跳,ping\echo，选举</li>
<li>安全性：入侵检测，用户认证，用户权限控制，追踪审计</li>
<li>可修改性</li>
<li>互操作性</li>
<li>功能性</li>
<li>可变性</li>
</ul>
</li>
<li>质量属性场景六个要素：刺激源，刺激，场景，制品，响应，响应度量</li>
<li>敏感点：为了实现某种特定的质量属性，一个或多个构件所具有的特性</li>
<li>权衡点：影响多个质量属性的决策点，是多个质量属性的敏感点。</li>
</ol>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/04/13/%E6%9D%82%E8%B0%88-%E4%B8%8B%E4%B8%80%E6%AD%A5%E7%9A%84%E6%96%B9%E5%90%91/">杂谈-下一步的方向</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-04-13
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <p>立个flag，我需要在9月份之前完成这些事情：</p>
<ol>
<li>论文idea和实验：学习pytorch和图神经网络，可能还得学一些信号处理。（ddl8月份）</li>
<li>i茅台复现：主体自己实现一下，tidb可以先不用，用sharding-jdbc分片即可（ddl5月份）</li>
<li>go语言相关：做一个轮子类项目（分布式kv或者MIT6.多少多少的raft），以及一个业务类项目（im即时通讯或者流媒体），这部分其实看情况，也不是一定需要转go（ddl6月份）</li>
<li>大模型相关：复现gpt2（ddl5月份），继续学习rag的相关工程，主要放在并发上（ddl8月份）</li>
<li>unity：不是主要工作，只给五一假期几天去尝试一下</li>
</ol>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/03/22/%E8%BD%ACgo%E8%AE%A1%E5%88%92day1-go%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">ProjectMygo!!!!!-go的基本语法</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-03-22
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>实习了一段时间深感java已经不太行了，转go才是出路</p>
</blockquote>
<p><img src="/../img/golang/learn/img.png" alt="go"></p>
<h1 id="变量，结构与函数"><a href="#变量，结构与函数" class="headerlink" title="变量，结构与函数"></a>变量，结构与函数</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>与java不同，go可以不显示声明变量数据类型。一般来说有：</p>
<ul>
<li>整数型int,int8,int16,int32,int64,无符号整型uint,uint8,uint16,uint32,uint64</li>
<li>浮点型：float32,float64,相当于单精度浮点型float和双精度浮点型double</li>
<li>布尔：true和false，值得一提的是bool赋初始值的时候默认false</li>
<li>字符串：string直接就是一个数据类型了，还有一个rune，后续再去了解</li>
</ul>
<p>很重要的一点是go语言的变量声明了就必须得用，而且最后不用加分号。下面是声明数据类型的例子，有:&#x3D;可以代替var进行类型推断，可以同时推断多个类型（但我觉得还是显示声明类型比较好，否则一个函数返回来怎么判断类型）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age_1 <span class="type">uint8</span> = <span class="number">31</span></span><br><span class="line"><span class="keyword">var</span> age_2 = <span class="number">32</span></span><br><span class="line">age_3 := <span class="number">33</span></span><br><span class="line">fmt.Println(age_1, age_2, age_3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age_4, age_5, age_6 <span class="type">int</span> = <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span></span><br><span class="line">fmt.Println(age_4, age_5, age_6)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name_1, age_7 = <span class="string">&quot;Tom&quot;</span>, <span class="number">30</span></span><br><span class="line">fmt.Println(name_1, age_7)</span><br><span class="line"></span><br><span class="line">name_2, is_boy, height := <span class="string">&quot;Jay&quot;</span>, <span class="literal">true</span>, <span class="number">180.66</span></span><br><span class="line">fmt.Println(name_2, is_boy, height)</span><br></pre></td></tr></table></figure>

<p>常量也是类似，可以进行类型推断，但是必须赋初始值，且一旦定义了就不能改变了，类似java中的private static final int &#x3D; 1;这种</p>
<h2 id="函数与判断结构"><a href="#函数与判断结构" class="headerlink" title="函数与判断结构"></a>函数与判断结构</h2><p>go的函数与主流编程语言类似，但是估计不分static和非静态，也是给出参数列表和返回值。但是这里可以返回多个变量，这一点应该会比java好</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> numerator <span class="type">int</span> = <span class="number">11</span></span><br><span class="line">	<span class="keyword">var</span> denominator <span class="type">int</span> = <span class="number">2</span></span><br><span class="line">	<span class="keyword">var</span> result, remainder <span class="type">int</span> = intDivision(numerator, denominator)</span><br><span class="line">	fmt.Println(result, remainder)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intDivision</span><span class="params">(num1, num2 <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> result <span class="type">int</span> = num1 / num2</span><br><span class="line">	<span class="keyword">var</span> remainder <span class="type">int</span> = num1 % num2</span><br><span class="line">	<span class="keyword">return</span> result, remainder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的异常处理，与java中try-catch的思想不同，函数在返回的时候也会给一个error返回值，外部调用通过error是否为nil来判断函数执行是否出错。这是一个广泛使用的设计思想，后续可能需要遵守。</p>
<p>例如这里的除数为0的例子，当除数为0相当于要抛出异常，用errors包下的一个函数throw new RunTimeException()，再在主函数去判断这个error是否为空，为空说明没有抛出异常。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> numerator <span class="type">int</span> = <span class="number">11</span></span><br><span class="line">	<span class="keyword">var</span> denominator <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">	result, remainder, err := intDivision(numerator, denominator)</span><br><span class="line">	<span class="comment">//执行正常</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(result, remainder)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intDivision</span><span class="params">(num1, num2 <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> num2 == <span class="number">0</span> &#123;</span><br><span class="line">		err = errors.New(<span class="string">&quot;num1 is zero&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> result <span class="type">int</span> = num1 / num2</span><br><span class="line">	<span class="keyword">var</span> remainder <span class="type">int</span> = num1 % num2</span><br><span class="line">	<span class="keyword">return</span> result, remainder, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后提一下go的判断结构，if后面的括号必须贴着同一行，else的哪一行必须写成”} else {“，否则编译器会报错，此外switch语句不需要写break了</p>
<h1 id="数组，切片和哈希表"><a href="#数组，切片和哈希表" class="headerlink" title="数组，切片和哈希表"></a>数组，切片和哈希表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>go中的数组跟java的数组很像，但是go的数组可以操作指针。数组的大小在声明的时候就已经固定，如果想用跟ArrayList那样的动态数组，请使用slice切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intArr [<span class="number">10</span>]<span class="type">int32</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intArr); i++ &#123;</span><br><span class="line">		intArr[i] = <span class="type">int32</span>(i + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//左闭右开，这个就是下标为456的三个元素</span></span><br><span class="line">	fmt.Println(intArr[<span class="number">4</span>:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intArr); i++ &#123;</span><br><span class="line">		fmt.Println(&amp;intArr[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这里输出结果是连续的4B，说明经典数组是连续分布的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是这里数组如果传入的是形式变量，需要传地址，跟c语言一样，否则就只会改变形参</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	withAddress(&amp;arr)</span><br><span class="line">	fmt.Println(arr)<span class="comment">//[1 20 3 4 5]</span></span><br><span class="line">	noAddress(arr)</span><br><span class="line">	fmt.Println(arr)<span class="comment">//[1 20 3 4 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withAddress</span><span class="params">(a *[5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	a[<span class="number">1</span>] = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noAddress</span><span class="params">(a [5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	a[<span class="number">3</span>] = <span class="number">20</span></span><br><span class="line">	fmt.Println(a)<span class="comment">//[1 20 3 20 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切片slice"><a href="#切片slice" class="headerlink" title="切片slice"></a>切片slice</h2><p>基本上跟ArrayList的机制一样，长度和容量，如果到了设定阈值就会动态扩容。如果能够预估业务数据量，在构造slice的时候直接指定容量可以免去动态扩容的开销。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sliceDynamic()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceStatic</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> slice []<span class="type">int32</span> = []<span class="type">int32</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="comment">//length is 3, with capacity is 3</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;length is %v, with capacity is %v\n&quot;</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">	slice = <span class="built_in">append</span>(slice, <span class="number">4</span>)</span><br><span class="line">	<span class="comment">//length is 4, with capacity is 6</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;length is %v, with capacity is %v\n&quot;</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">	fmt.Println(slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceDynamic</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//可以指定构造长度和容量，这里构造了一个长度为3，容量为20的slice</span></span><br><span class="line">	<span class="keyword">var</span> intSlice []<span class="type">int32</span> = <span class="built_in">make</span>([]<span class="type">int32</span>, <span class="number">3</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;length is %v, with capacity is %v\n&quot;</span>, <span class="built_in">len</span>(intSlice), <span class="built_in">cap</span>(intSlice))</span><br><span class="line">	<span class="comment">//前三个元素是初始化了的，后面没有</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intSlice); i++ &#123;</span><br><span class="line">		fmt.Println(intSlice[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//就跟ArrayList一样，如果业务能够预估动态数组的长度，最好还是构造的时候就提前设定好</span></span><br><span class="line">	<span class="comment">//否则会频繁进行扩容，影响效率</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取数逻辑。左闭右开，跟java中subString类似</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicePartition</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sli := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>, <span class="built_in">len</span>(sli), <span class="built_in">cap</span>(sli), sli)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[1] ==&quot;</span>, sli[<span class="number">1</span>])</span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[:] ==&quot;</span>, sli[:])</span><br><span class="line">	<span class="comment">//sli[1]-&gt;sli[len-1]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[1:] ==&quot;</span>, sli[<span class="number">1</span>:])</span><br><span class="line">	<span class="comment">//sli[0]-&gt;sli[4-1]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[:4] ==&quot;</span>, sli[:<span class="number">4</span>])</span><br><span class="line">	<span class="comment">//sli[0]-&gt;sli[3-1]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[0:3] ==&quot;</span>, sli[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>, <span class="built_in">len</span>(sli[<span class="number">0</span>:<span class="number">3</span>]), <span class="built_in">cap</span>(sli[<span class="number">0</span>:<span class="number">3</span>]), sli[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>go语言中没有while循环（反正我也没经常用），对于slice和map需要特别注意，range关键字会在遍历这两个数据结构的时候进行处理。例如slice通过range关键字的时候会有index和value两个值，不需要index则直接”_”，跟python相似；同理map会遍历出key和value</p>
<blockquote>
<p>这里就顺带把map提一下，map[key]value，这样的结构，查询一个元素直接括号里面找，注意找不到也会返回0这个默认值，所以以后用到的时候可能需要判断</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceWithClass</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> teachers []Teacher = <span class="built_in">make</span>([]Teacher, <span class="number">0</span>)</span><br><span class="line">	teachers = <span class="built_in">append</span>(teachers, Teacher&#123;<span class="string">&quot;yangyifan&quot;</span>, <span class="number">12</span>&#125;)</span><br><span class="line">	fmt.Println(teachers)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> teacherMap <span class="keyword">map</span>[<span class="type">string</span>]Teacher = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Teacher)</span><br><span class="line">	teacherMap[<span class="string">&quot;yangyifan&quot;</span>] = Teacher&#123;<span class="string">&quot;yangyifan&quot;</span>, <span class="number">12</span>&#125;</span><br><span class="line">	fmt.Println(teacherMap[<span class="string">&quot;yangyifan&quot;</span>])</span><br><span class="line">	teacherMap[<span class="string">&quot;xuxuanyan&quot;</span>] = Teacher&#123;<span class="string">&quot;xuxuanyan&quot;</span>, <span class="number">12</span>&#125;</span><br><span class="line">	fmt.Println(teacherMap[<span class="string">&quot;xuxuanyan&quot;</span>])</span><br><span class="line">	<span class="built_in">delete</span>(teacherMap, <span class="string">&quot;xuxuanyan&quot;</span>)</span><br><span class="line">	fmt.Println(teacherMap[<span class="string">&quot;xuxuanyan&quot;</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历数组的时候返回两个值，一个是index一个是值</span></span><br><span class="line">	<span class="comment">//不需要的就直接_</span></span><br><span class="line">	<span class="keyword">for</span> _, teacher := <span class="keyword">range</span> teachers &#123;</span><br><span class="line">		fmt.Println(teacher)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历map的时候每次都会得到两个值，一个是key一个是value</span></span><br><span class="line">	<span class="comment">//这里只希望返回所有的value前面的key就用_代替</span></span><br><span class="line">	<span class="keyword">for</span> _, teacher := <span class="keyword">range</span> teacherMap &#123;</span><br><span class="line">		fmt.Println(teacher)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string与rune"><a href="#string与rune" class="headerlink" title="string与rune"></a>string与rune</h2><p>在go中string的底层是一个字节数组，采用utf8编码，由于utf8是不固定长度的，一般来说汉字都会占3B。所以直接去用len一个string数组长度返回的是字节数量，有两种遍历方式，一种是直接遍历len，这样会返回每一个未解码的utf8字节，比如一个汉字“大”，占三位，用普通遍历就会返回这三个字节的初始值；但是如果用range关键字，他会帮我们做一些处理，把这三个字节解码拼成一块，就会返回真实的字符，但这样前面的index仍然不准确。</p>
<p>如果采用rune就是我们直觉上的遍历字符数组了，例子如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//stringByte()</span></span><br><span class="line">	runeSlice()</span><br><span class="line">	stringBuilder()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringByte</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str1 = <span class="string">&quot;大连理工大学&quot;</span></span><br><span class="line">	char := str1[<span class="number">0</span>]</span><br><span class="line">	fmt.Println(char)</span><br><span class="line">	<span class="comment">//大连理工大学 has 18 character</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v has %v character\n&quot;</span>, str1, <span class="built_in">len</span>(str1))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//index: 0, char:å</span></span><br><span class="line">	<span class="comment">//index: 1, char:¤</span></span><br><span class="line">	<span class="comment">//index: 2, char:§</span></span><br><span class="line">	<span class="comment">//index: 3, char:è</span></span><br><span class="line">	<span class="comment">//index: 4, char:¿</span></span><br><span class="line">	<span class="comment">//index: 5, char:</span></span><br><span class="line">	<span class="comment">//index: 6, char:ç</span></span><br><span class="line">	<span class="comment">//index: 7, char:</span></span><br><span class="line">	<span class="comment">//index: 8, char:</span></span><br><span class="line">	<span class="comment">//index: 9, char:å</span></span><br><span class="line">	<span class="comment">//index: 10, char:·</span></span><br><span class="line">	<span class="comment">//index: 11, char:¥</span></span><br><span class="line">	<span class="comment">//index: 12, char:å</span></span><br><span class="line">	<span class="comment">//index: 13, char:¤</span></span><br><span class="line">	<span class="comment">//index: 14, char:§</span></span><br><span class="line">	<span class="comment">//index: 15, char:å</span></span><br><span class="line">	<span class="comment">//index: 16, char:­</span></span><br><span class="line">	<span class="comment">//index: 17, char:¦</span></span><br><span class="line">	<span class="comment">//这里出现乱码的原因是字符串底层是一个字节数组结构，</span></span><br><span class="line">	<span class="comment">//而一个汉字在utf8中占3个字节，他把每一个字节的内容都输出，就不会组成一个完整的汉字</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str1); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;index: %d, char:%c\n&quot;</span>, i, str1[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果用range关键字就会帮我们把字符串的utf8解码</span></span><br><span class="line">	<span class="comment">//index: 0, char:大</span></span><br><span class="line">	<span class="comment">//index: 3, char:连</span></span><br><span class="line">	<span class="comment">//index: 6, char:理</span></span><br><span class="line">	<span class="comment">//index: 9, char:工</span></span><br><span class="line">	<span class="comment">//index: 12, char:大</span></span><br><span class="line">	<span class="comment">//index: 15, char:学</span></span><br><span class="line">	<span class="comment">//这里也可以看到跳过了一些index</span></span><br><span class="line">	<span class="keyword">for</span> index, v := <span class="keyword">range</span> str1 &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;index: %d, char:%c\n&quot;</span>, index, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runeSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> runeSlice = []<span class="type">rune</span>(<span class="string">&quot;大连理工大学&quot;</span>)</span><br><span class="line">	<span class="comment">//index: 0, char:大</span></span><br><span class="line">	<span class="comment">//index: 1, char:连</span></span><br><span class="line">	<span class="comment">//index: 2, char:理</span></span><br><span class="line">	<span class="comment">//index: 3, char:工</span></span><br><span class="line">	<span class="comment">//index: 4, char:大</span></span><br><span class="line">	<span class="comment">//index: 5, char:学</span></span><br><span class="line">	<span class="comment">//这里的index就是顺序的了</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(runeSlice); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;index: %d, char:%c\n&quot;</span>, i, runeSlice[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此外一些string操作都在strings这个包下面，例如stringBuilder和其他的一些字符串操作，需要的时候导入。</p>
<h1 id="结构体与接口"><a href="#结构体与接口" class="headerlink" title="结构体与接口"></a>结构体与接口</h1><p>go应该是一个面向过程的语言，这里采用的还是结构体，但是类似的也有接口和类方法，在实现go中的接口时，不需要有java那种implements，编译器搜索所有有该方法签名的结构体自动绑定；在实现类方法时，需要在方法名前绑定结构体。例子如下所示，有一个engine接口，两个实现类</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine 接口</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">interface</span> &#123;</span><br><span class="line">	milesLeft() <span class="type">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GasEngine <span class="keyword">struct</span> &#123;</span><br><span class="line">	mpg     <span class="type">uint8</span></span><br><span class="line">	gallons <span class="type">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ge GasEngine)</span></span> milesLeft() <span class="type">uint8</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ge.mpg * ge.gallons</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElectricEngine <span class="keyword">struct</span> &#123;</span><br><span class="line">	mpkwh <span class="type">uint8</span></span><br><span class="line">	kwh   <span class="type">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ee ElectricEngine)</span></span> milesLeft() <span class="type">uint8</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ee.mpkwh * ee.kwh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canMakeIt</span><span class="params">(engine Engine, remainMiles <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> engine.milesLeft() &lt; remainMiles &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> milesLeft <span class="type">uint8</span> = <span class="number">60</span></span><br><span class="line">	<span class="keyword">var</span> ge GasEngine = GasEngine&#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">	fmt.Println(canMakeIt(ge, milesLeft))</span><br><span class="line">	<span class="keyword">var</span> ee ElectricEngine = ElectricEngine&#123;<span class="number">10</span>, <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Println(canMakeIt(ee, milesLeft))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/03/04/%E7%BD%91%E6%98%93KM%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB-%E5%B0%8FP%E8%80%81%E5%B8%88%E6%9C%8D%E5%8A%A1GC%E5%8D%A1%E9%A1%BF%E5%AE%9A%E4%BD%8D%E8%A7%A3%E5%86%B3/">网易KM社区分享-小P老师服务GC卡顿定位解决</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-03-04
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>小P老师作为有道AI大模型的重点服务，稳定性与低延迟至关重要。但随着开学季到来，接口流量增加，服务偶现请求延迟升高和GC卡顿异常重启现象。<br>本文总结上述问题的排查思路及定位过程，相信对遇到内存泄漏、CPU升高、JVM GC异常等问题的小伙伴，有借鉴意义。</p>
</blockquote>
<h1 id="一、背景和现象"><a href="#一、背景和现象" class="headerlink" title="一、背景和现象"></a>一、背景和现象</h1><p>小P老师服务（java服务容器部署、jdk17、G1回收器）核心任务是提供教育场景下的大模型对话式问答。随着开学季到来，流量也逐渐上升，保障服务稳定性是比较重要的任务之一。</p>
<p>大模型对话式问答通常是一个流式过程，模型回答是一段一段输出给用户的，为了观察到整个模型的延时情况，大模型回答完毕的时间(total time)以及大模型每一段回答的时间(interval time)都添加了监控。</p>
<p>近期发现，小P老师服务里子曰大模型interval time的监控总是超时告警，但是子曰大模型自身的interval time监控确实正常的，同时很奇怪的是只有一个或者部分容器pod出问题。</p>
<p>这两个监控有什么区别呢？简单来说一个是A使用B时对B的监控，另外一个是B对自身的监控，所以理论来说他两监控应该基本一致才是符合预期的（抛去网络延时）。</p>
<p>从这一现象看，说明小P老师本身代码逻辑存在耗时情况或者网络有问题。</p>
<p>另外之前小P也出现过类似情况，我们使用了Huggingface去做大模型token计算，这个组件cpu占用率很多，所以按照之前惯例会查看cpu是否够用。<br><img src="/../img/netease/littleP/img.png" alt="img.png"></p>
<p><img src="/../img/netease/littleP/img_1.png" alt="img_1.png"></p>
<p>图1 容器cpu使用图</p>
<p><img src="/../img/netease/littleP/img_2.png" alt="img_2.png"></p>
<p>图2 jvm监控图</p>
<p>于是发现了图1这样的现象，在容器cpu监控图中发现在服务告警期间cpu usages（使用量）和cpu cfs throttled（抢占）有尖刺。同时也是机缘巧合，想看看jvm里cpu使用占用率多少，于是在图2（黄色线是分配的内存、绿色线是使用的内存)发现了比较重要的一个信息，jvm在这期间eden区分配降低，old区使用、分配激增，维持了一段时间后就自行恢复了。于是我便去查看了一段时间内的GC日志</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[2024-10-23T20:23:56.727+0800] GC(77) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[2024-10-23T20:23:56.727+0800] GC(77) Using 1 workers of 1 for evacuation</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) MMU target violated: 201.0ms (200.0ms/201.0ms)</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Pre Evacuate Collection Set: 12.5ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Merge Heap Roots: 56.7ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Evacuate Collection Set: 5334.5ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Post Evacuate Collection Set: 15.4ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Other: 0.5ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Eden regions: 482-&gt;0(63)</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Survivor regions: 17-&gt;13(63)</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Old regions: 32-&gt;32</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Archive regions: 2-&gt;2</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Humongous regions: 473-&gt;456 // 标记1</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Metaspace: 156861K(158080K)-&gt;156861K(158080K) NonClass: 139277K(139840K)-&gt;139277K(139840K) Class: 17583K(18240K)-&gt;17583K(18240K)</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Pause Young (Normal) (G1 Evacuation Pause) 4018M-&gt;2007M(6144M) 5419.626ms // 标记2</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) User=5.08s Sys=0.20s Real=5.42s // 标记3</span><br></pre></td></tr></table></figure>

<p>确实发现了异常的点，标记1可以看出Humongous regions数量非常多且这一次GC并没有回收该区域的内容。(Normal GC是会回收Humongous区域的)</p>
<p>标记2可以看出整个GC耗时大概5.4s，当然从标记3可以更清楚的看出GC耗时，所以我们猜测子曰大模型interval time告警可能和GC耗时过久有关系。</p>
<p>至此我们整合一下问题现象：</p>
<ul>
<li>小P老师服务对子曰大模型的延时监控发生告警，且与子曰大模型自身监控不一致</li>
<li>只有一部分pod有问题</li>
<li>告警期间服务cpu使用率激增</li>
<li>告警期间jvm内存eden区域分配减少，old区域使用、分配激增，一段时间后恢复</li>
</ul>
<p>Humongous regions回收不明显，GC停顿过长</p>
<p>根据上述现象，我们可以判断出服务延时告警时和GC有关系，也就是需要从内存的角度来分析为什么GC会停顿这么久，可以算是一个切入点。</p>
<p>分析内存有一个得力工具<a target="_blank" rel="noopener" href="https://eclipse.dev/mat/">MemeoryAnayzer(MAT)</a>，接下来会先重点介绍一下这个工具，同时也会介绍在jdk17中的G1垃圾回收器。当然如果对此熟悉的可以直接跳过看<a target="_blank" rel="noopener" href="https://km.netease.com/v4/section/tm599/detail/blog/234938#4">定位过程</a>。</p>
<h1 id="二、Garbage-First-G1-垃圾回收器"><a href="#二、Garbage-First-G1-垃圾回收器" class="headerlink" title="二、Garbage-First (G1) 垃圾回收器"></a>二、Garbage-First (G1) 垃圾回收器</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html#GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573">引用文章</a></p>
</blockquote>
<p>Garbage-First (G1) 垃圾收集器针主要对大内存多核的服务，目的是实现应用程序和环境在延迟和吞吐量之间的最佳平衡。</p>
<p>特点：</p>
<ul>
<li>服务堆大小大于10GB。</li>
<li>对象分配和对象移动的速度可能会随着时间的推移而发生很大变化。<blockquote>
<p>Rates of object allocation and promotion that can vary significantly over time.</p>
</blockquote>
</li>
<li>堆中存在大量碎片。</li>
<li>可预测的暂停时间目标不超过几百毫秒，避免长时间的垃圾收集暂停。</li>
</ul>
<h2 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h2><p>G1 将堆分为<strong>年轻代</strong>（young）和<strong>老年代</strong>（gen）。空间回收工作集中在最高效的年轻代上，偶尔也会在老年代进行空间回收。</p>
<p>G1 首先回收最高效区域的空间（即大部分被垃圾填充的区域，因此得名）。</p>
<p>G1 主要通过撤离（evacuation）来回收空间：在选定的内存区域找到存活对象复制到新的内存区域，并在过程中对其进行压缩。撤离完成后，先前的空间可用来重新分配。</p>
<p>G1不是实时收集器。尝试尽可能在设定的暂时时间下完成回收，但对于给定的暂停，不能保证绝对满足。</p>
<h2 id="2-2-堆布局"><a href="#2-2-堆布局" class="headerlink" title="2.2 堆布局"></a>2.2 堆布局</h2><p><img src="/../img/netease/littleP/img_3.png" alt="img_3.png"></p>
<p>图3 G1垃圾回收器</p>
<p>年轻代包含eden区域（红色）和survivor区域（红色，带“S”）。这些区域内部是连续的，但在G1中这些区域通常以非连续模式排列在内存中。old区域（浅蓝色）构成老生代。对于跨多个区域的对象，会有一个非常大的old区域（浅蓝色，带“H”），叫做Humongous区域 。</p>
<p>应用程序总是分配到年轻代，即eden区域，巨大对象被分配到old区域。</p>
<h2 id="2-3-垃圾回收周期"><a href="#2-3-垃圾回收周期" class="headerlink" title="2.3 垃圾回收周期"></a>2.3 垃圾回收周期</h2><p>G1 收集器在两个阶段之间交替。young-only阶段包括垃圾回收(garbage collections)，这个阶段会逐渐填满当前可用的内存</p>
<p>空间回收阶段是 G1 除了处理年轻代之外，还会逐步回收老生代中的空间。然后，循环从年轻代阶段重新开始。</p>
<p><img src="/../img/netease/littleP/img_4.png" alt="img_4.png"></p>
<p>图4 垃圾回收周期预览</p>
<p>以下列表详细描述了 G1 垃圾收集周期的各个阶段、暂停以及阶段之间的转换：</p>
<ol>
<li><p>仅年轻代阶段（Young-only phase）：此阶段以Normal young collections收集开始，会将对象提升到老年代。当老年代占用率达到某个阈值时，Young-only phase和Space-reclamation phase之间的过渡就开始了。此时，G1 会执行Concurrent Start young collection，而不是Normalyoung collections。</p>
<ul>
<li><p>Concurrent Start：这种类型的收集除了执行常规Normalyoung collections，还启动标记过程。并发标记确定old区域中的是否可以被回收。在收集标记尚未完全完成时，可能会发生Normalyoung collections。</p>
</li>
<li><p>Remark：此这段会完成重新标记。</p>
</li>
<li><p>Cleanup：这个阶段决定是否进行Space-reclamation phase。如果确定进行Space-reclamation phase，那么Young-only phase就会进行一次Prepare Mixed young collection.</p>
</li>
</ul>
</li>
<li><p>空间回收阶段（Space-reclamation phase）：此阶段会进行Mixed collections，除了young区域外，还会撤离old区域中的存活对象。当 G1 确定撤离更多老生代区域不会产生足够的可用空间时，空间回收阶段结束。</p>
</li>
</ol>
<blockquote>
<ol>
<li>Young-only phase: This phase starts with a few Normal young collections that promote objects into the old generation. The transition between the young-only phase and the space-reclamation phase starts when the old generation occupancy reaches a certain threshold, the Initiating Heap Occupancy threshold. At this time, G1 schedules a Concurrent Start young collection instead of a Normal young collection.</li>
</ol>
</blockquote>
<blockquote>
<ul>
<li>Concurrent Start : This type of collection starts the marking process in addition to performing a Normal young collection. Concurrent marking determines all currently reachable (live) objects in the old generation regions to be kept for the following space-reclamation phase. While collection marking hasn’t completely finished, Normal young collections may occur. Marking finishes with two special stop-the-world pauses: Remark and Cleanup.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Remark: This pause finalizes the marking itself, performs global reference processing and class unloading, reclaims completely empty regions and cleans up internal data structures. Between Remark and Cleanup G1 calculates information to later be able to reclaim free space in selected old generation regions concurrently, which will be finalized in the Cleanup pause.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Cleanup: This pause determines whether a space-reclamation phase will actually follow. If a space-reclamation phase follows, the young-only phase completes with a single Prepare Mixed young collection.</li>
</ul>
</blockquote>
<blockquote>
<ol start="2">
<li>Space-reclamation phase: This phase consists of multiple Mixed collections that in addition to young generation regions, also evacuate live objects of sets of old generation regions. The space-reclamation phase ends when G1 determines that evacuating more old generation regions wouldn’t yield enough free space worth the effort.</li>
</ol>
</blockquote>
<p>空间回收后，收集周期将以另一个年轻阶段重新启动。作为兜底，如果应用程序在收集活跃度信息时内存不足，G1 将像其他收集器一样执行就会执行Full</p>
<h2 id="2-4-垃圾回收阶段和回收集"><a href="#2-4-垃圾回收阶段和回收集" class="headerlink" title="2.4 垃圾回收阶段和回收集"></a>2.4 垃圾回收阶段和回收集</h2><blockquote>
<p>garbage Collection Pauses and Collection Set</p>
</blockquote>
<p>G1执行垃圾收集和空间回收是在stop-the-world pauses时间内完成的，存活的对象会从堆的一个区域移动到另一个区域，并且对这些对象的引用也会调整。</p>
<p>对于non-humongous的移动：</p>
<ul>
<li>年轻一代（eden和survivor）的对象被复制到survivor区域或old区域，取决于它们的年龄。</li>
<li>来自old的对象被复制到其他old</li>
</ul>
<p>对于大对象来说，除非被回收不然永远不会被移动。</p>
<p>对于回收集（collection set）：</p>
<ul>
<li>在 Young-Only ，回收集仅由年轻一代的区域以及可能被回收的巨大区域组成。</li>
<li>在空间回收（Space-reclamation）阶段，回收集由年轻代中的区域、包含可能被回收的对象的巨大区域、以及来自收集集合候选区域的一些老生代区域组成。</li>
</ul>
<p>G1 在并发周期（concurrent cycle）内准备回收集候选区域。在Remark pause，G1 选择大量闲置空间的低利用率区域。然后在 Remark 和Cleanup pause之间并发准备这些区域以供以后收集使用。Cleanup pause根据效率对准备的结果进行排序。更高效的区域是说，有更多的空间并且回收的时间更少。mixedcollections会更喜欢这些区域。</p>
<h1 id="三、MemeoryAnayzer-MAT"><a href="#三、MemeoryAnayzer-MAT" class="headerlink" title="三、MemeoryAnayzer(MAT)"></a>三、MemeoryAnayzer(MAT)</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://eclipse.dev/mat/">https://eclipse.dev/mat/</a></p>
</blockquote>
<h2 id="3-1-重要概念"><a href="#3-1-重要概念" class="headerlink" title="3.1 重要概念"></a>3.1 重要概念</h2><h3 id="3-1-1-可达性"><a href="#3-1-1-可达性" class="headerlink" title="3.1.1 可达性"></a>3.1.1 可达性</h3><p><strong>可达</strong></p>
<p>这个对象仍然有地方引用着他</p>
<p><strong>不可达</strong></p>
<p>这个对象没有任何对象被引用</p>
<h3 id="3-1-2-Shallow-与Retained-Heap的区别"><a href="#3-1-2-Shallow-与Retained-Heap的区别" class="headerlink" title="3.1.2 Shallow 与Retained Heap的区别"></a>3.1.2 Shallow 与Retained Heap的区别</h3><p><strong>Shallow</strong> 是一个对象所消耗的内存。对象每个引用需要32或64位（取决于操作系统体系结构），每个Integer需要4字节，每个Long需要8字节，等等。</p>
<blockquote>
<p>Shallow heap is the memory consumed by one object. An object needs 32 or 64 bits (depending on the OS architecture) per reference, 4 bytes per Integer, 8 bytes per Long, etc. Depending on the heap dump format the size may be adjusted (e.g. aligned to 8, etc…) to model better the real consumption of the VM.</p>
</blockquote>
<p>X的<strong>Retained set</strong>表示当X被GC垃圾回收后需要移除的对象列表</p>
<blockquote>
<p><strong>Retained set</strong> of X is the set of objects which would be removed by GC when X is garbage collected.</p>
</blockquote>
<p>X的<strong>Retained heap</strong>是Retained set里所有对象的Shallow大小</p>
<blockquote>
<p><strong>Retained heap</strong> of X is the sum of shallow sizes of all objects in the retained set of X, i.e. memory kept alive by X.</p>
</blockquote>
<p>通俗的来说，<strong>Shallow</strong> 是这个对象的大小，<strong>Retained heap</strong>是这个对象被回收之后内存释放的大小</p>
<p><img src="/../img/netease/littleP/img_5.png" alt="img_5.png"></p>
<p>图5 对象引用图以及Retained Set</p>
<h3 id="3-1-3-Dominator-Tree"><a href="#3-1-3-Dominator-Tree" class="headerlink" title="3.1.3 Dominator Tree"></a>3.1.3 Dominator Tree</h3><p>MAT提供了对象图的Dominator Tree，将对象引用图转化为Dominator Tree能够轻松识别保留内存的最大块以及对象之间的依赖关系，下面是一些定义</p>
<ul>
<li>X <strong>dominates</strong> Y，表示在对象图中，每一个去Y的路径上都需要经过X。</li>
<li>X是Y的<strong>immediate dominator</strong> ，表示X是距离Y最近的支配者</li>
<li><strong>dominator tree</strong> 是由对象图直接构建而来，能够展现一个对象的immediate dominator</li>
</ul>
<p>图6是将对象图（左侧）构建为<strong>dominator tree</strong> （右侧）</p>
<p><img src="/../img/netease/littleP/img_6.png" alt="img_6.png"></p>
<p>图6 对象引用图以及Retained Set</p>
<p>通俗的来说，X dominates Y表示，如果X被回收那么Y一定被回收。但我们常说的引用，如果X引用Y，那么Y是不一定会被回收的，因为Y有可能被Z引用。这就是为什么MAT引入 <strong>Dominator</strong>这个概念。</p>
<h2 id="3-2-常用功能"><a href="#3-2-常用功能" class="headerlink" title="3.2 常用功能"></a>3.2 常用功能</h2><h3 id="3-2-1-Histogram"><a href="#3-2-1-Histogram" class="headerlink" title="3.2.1 Histogram"></a>3.2.1 Histogram</h3><p>Histogram列举出每一个class的对象数量以及他的shallow size和retained size，可以快速找出大的对象类</p>
<p><img src="/../img/netease/littleP/img_7.png" alt="img_7.png"></p>
<p>图7 Histogram列表</p>
<p>默认情况下retained size展示的是估算值，也可通过计算才获取他的准确值。</p>
<p><img src="/../img/netease/littleP/img_11.png" alt="img_11.png"></p>
<p>图8 Histogram计算准确retained size</p>
<p>可以查看对象被谁引用或者他又引用了谁</p>
<p><img src="/../img/netease/littleP/img_10.png" alt="img_10.png"></p>
<p>图9 Histogram查看引用关系</p>
<p><img src="/../img/netease/littleP/img_9.png" alt="img_9.png"></p>
<p>图10 Histogram查看引用关系结果</p>
<p>Histogram默认是通过class是分组的，也可以根据包或者加载器</p>
<p><img src="/../img/netease/littleP/img_8.png" alt="img_8.png"></p>
<p>图11 Histogram通过其他类型分组</p>
<h3 id="3-2-2-Dominator-Tree"><a href="#3-2-2-Dominator-Tree" class="headerlink" title="3.2.2 Dominator Tree"></a>3.2.2 Dominator Tree</h3><p><strong>Dominator tree</strong>展示了在堆中最大的对象列表。X对象的下一级表示，X被回收之后需要被垃圾回收的对象列表。（也就是X直接支配的对象）同样也可以按类加载器、包进行分组。</p>
<blockquote>
<p>The next level of the tree lists those objects that would be garbage collected if all incoming references to the parent node were removed.</p>
</blockquote>
<p><img src="/../img/netease/littleP/img_12.png" alt="img_12.png"></p>
<p>图12 Dominator Tree</p>
<p>以上图为例，占用堆内存最大的是TaskThread的http-no-8080-exec-2线程，其本身大小是Shallow Heap是120字节，Retained Heap是2417669960字节，占用整个堆内存94.90%。图中将AspectJExpressionPointcut展开，表示当AspectJExpressionPointcut被内存回收之后，展开列表里的所有对象都会被回收，也就是他的retained set</p>
<h3 id="3-2-3-Immediate-Dominators"><a href="#3-2-3-Immediate-Dominators" class="headerlink" title="3.2.3 Immediate Dominators"></a>3.2.3 Immediate Dominators</h3><p>可以快速找出当前这组（类&#x2F;对象）的所有immediate dominator（直接支配者）</p>
<p><img src="/../img/netease/littleP/img_13.png" alt="img_13.png"></p>
<p>图13 Histogram找某个类的immediate dominator</p>
<p>下列展现支配Object[]的类列表</p>
<p><img src="/../img/netease/littleP/img_14.png" alt="img_14.png"></p>
<p>图14 Object[]类的immediate dominator</p>
<p>其中所选的那一行表示，TaskThread一共有37个对象，其中支配了133个Object[]，并且TaskThread的本身对象大小(shallow size)是4440bytes，他支配的Object[]是2147491680bytes的大小</p>
<h3 id="3-2-4-Leak-report"><a href="#3-2-4-Leak-report" class="headerlink" title="3.2.4 Leak report"></a>3.2.4 Leak report</h3><p>Leak report会列举出可能存在内存泄漏的点，以及发生的栈信息位置</p>
<p><img src="/../img/netease/littleP/img_15.png" alt="img_15.png"></p>
<p>图15 Leak report</p>
<h1 id="四、定位过程"><a href="#四、定位过程" class="headerlink" title="四、定位过程"></a>四、定位过程</h1><p>根据在第一节所观察到的问题现象，我们从内存角度来分析GC停顿之间为何这么久？按照惯例，通常都会看一下内存中的大对象，因为大对象一般是造成内存出现问题的罪魁祸首，并且大对象也是最容易发现的。</p>
<h2 id="4-1-查看大对象"><a href="#4-1-查看大对象" class="headerlink" title="4.1 查看大对象"></a>4.1 查看大对象</h2><blockquote>
<p>jmap -hsito [pid] | head -n [num]</p>
</blockquote>
<p><img src="/../img/netease/littleP/img_16.png" alt="img_16.png"></p>
<p>图16 小P老师服务某时刻大对象</p>
<p>大部分服务大对象前列就是byte、int等基本类型（不同的jdk版本可能会不同），也看不出什么门道。</p>
<p>通常先重点关注项目自己的包，再看一些引用的包。图16已经圈出了一些比较可疑的对象，但类比了同类稳定服务，第10行对象也是存在且现象一致的，于是就暂时排除他的嫌疑。</p>
<p>接下来就是12、13行这两个对象，他们用来做流式场景下线程之间上下文的自动传递，在github上看有人也提出了使用该组件的<a target="_blank" rel="noopener" href="https://github.com/micrometer-metrics/context-propagation/issues/148">内存问题</a>，我们把他列为可疑对象。</p>
<p>再接着就是20行这个对象，他是之前讲到的<a target="_blank" rel="noopener" href="https://huggingface.co/">Huggingface</a>组件，用来做大模型token计算。这个组件cpu占用率很高（之前性能自测过，图17）。那有没有可能在某个时刻计算量很大导致cpu激增，而容器分配的cpu不够用（而我们也确实发生了cpu抢占的情况），导致长期持有jvm对象而无法回收带来的GC卡顿，所以我也把他列为了可疑对象。</p>
<p>接下来我们来验证猜想。</p>
<p><img src="/../img/netease/littleP/img_17.png" alt="img_17.png"></p>
<p>图17 Huggingface组件性能测试cpu、内存使用情况</p>
<h3 id="4-1-1-验证猜想"><a href="#4-1-1-验证猜想" class="headerlink" title="4.1.1 验证猜想"></a>4.1.1 验证猜想</h3><p>我们将图16中，12、13行对象涉及的组件以及20行对象涉及的组件，分别打开&#x2F;关闭来做性能测试，看 GC和jvm是否有明显变化，但当时并没有发现带来明显的jvm变化以及GC卡顿问题。那么问题可能出现在其他大对象上，这时候就需要把堆内存dump下来做分析了。</p>
<h2 id="4-2-内存dump"><a href="#4-2-内存dump" class="headerlink" title="4.2 内存dump"></a>4.2 内存dump</h2><p>根据我们之前观察的现象，old区域激增，一段时间后回落，这不太符合内存泄漏的现象，可能就是大对象被长期持有无法释放，于是在dump内存时，选择将堆里的对象全部dump而不仅仅是存活的对象。</p>
<blockquote>
<p>jmap -dump:live,format&#x3D;b,file&#x3D;dump.hprof [pid]</p>
</blockquote>
<h2 id="4-3-使用MAT工具分析"><a href="#4-3-使用MAT工具分析" class="headerlink" title="4.3 使用MAT工具分析"></a>4.3 使用MAT工具分析</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://eclipse.dev/mat/">下载地址</a></p>
</blockquote>
<p>注意一般堆文件多大，MAT内存就需要分配多大，修改方式<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45859054/article/details/131096947">参考</a>。</p>
<p>MAT工具通常我们可以使用他从这几个角度分析：</p>
<ul>
<li>堆内存中的大对象有些什么？</li>
<li>这些大对象为什么没被回收？看他的支配者：immediate Dominators，看他的GC root</li>
<li>这些大对象为什么这么大？看他支配了谁：retained set</li>
</ul>
<h3 id="4-3-1-导入堆文件"><a href="#4-3-1-导入堆文件" class="headerlink" title="4.3.1 导入堆文件"></a>4.3.1 导入堆文件</h3><p><img src="/../img/netease/littleP/img_18.png" alt="img_18.png"></p>
<p>图18 堆文件导入示意图</p>
<h3 id="4-3-2-查看大对象"><a href="#4-3-2-查看大对象" class="headerlink" title="4.3.2 查看大对象"></a>4.3.2 查看大对象</h3><p>使用Histogram查看大的对象（类），根据Retained Heap来排序（点击Retained Heap按钮就可以排序）</p>
<p><img src="/../img/netease/littleP/img_19.png" alt="img_19.png"></p>
<p>图19 堆文件大的对象（类）列表</p>
<p>发现最大的类是java.lang.object[]，是一个数组，于是按照刚才思路我们先看他为什么没被回收？就看他的支配者。</p>
<h3 id="4-3-3-查看大对象支配者"><a href="#4-3-3-查看大对象支配者" class="headerlink" title="4.3.3 查看大对象支配者"></a>4.3.3 查看大对象支配者</h3><p>尝试看下这个大对象的支配者，看看是不是因为这个支配者应该被回收但是没被回收。</p>
<p>图20发现java.lang.object[]最大的支配者是TaskThread这个类，一共有37个对象实例，支配了133个java.lang.object[]，TaskThread类本身大小是4440bytes，支配的对象java.lang.object[]大小是2147491680bytes。</p>
<p>其实看到这里已经没有意义了，因为他是处理http请求的线程，是不可能被回收的，但我们看一下这个TaskThread的GC Root ，看是否是被不小心创建出来的而没释放。</p>
<p><img src="/../img/netease/littleP/img_20.png" alt="img_20.png"></p>
<p>图20 java.lang.object[]的支配者</p>
<h3 id="4-3-4-查看GC-root"><a href="#4-3-4-查看GC-root" class="headerlink" title="4.3.4 查看GC root"></a>4.3.4 查看GC root</h3><p>一般来说查看Gc root时都会选择 exclude weak&#x2F;soft references，因为这两个引用肯会被GC掉，这是用来查内存泄漏的，但我们场景是对象是被长时间持有段时间无法回收，而不是一直无法回收。所以这里选择展现了所有的references。</p>
<p><img src="/../img/netease/littleP/img_21.png" alt="img_21.png"></p>
<p>图21 查看TaskThreadGC root示意图</p>
<p>从图22来，TaskThread都是tomcat创建的线程用来处理http请求的，http-nio-8080-exec-2支配了很大的对象，那就是刚才java.lang.object[]，这种被线程支配的对象，大概率是临时变量，也就是方法栈里创建出来的变量，http-nio-8080-exec-2是不可能被回收的。</p>
<p><img src="/../img/netease/littleP/img_22.png" alt="img_22.png"></p>
<p>图22 TaskThreadGC root</p>
<p>但是临时变量的回收，会在方法执行完，对他引用没有了之后进行。因为我们dump某一个时刻的堆栈信息，可能线程没有执行完，没被回收也是正常的。但是在http所有的线程中，只有这个线程持有很大的对象明显是不合理。于是我接着看 java.lang.object[]对象为什么这么大？</p>
<h3 id="4-3-5-查看retained-set"><a href="#4-3-5-查看retained-set" class="headerlink" title="4.3.5 查看retained set"></a>4.3.5 查看retained set</h3><p><img src="/../img/netease/littleP/img_23.png" alt="img_23.png"></p>
<p>图23 查看java.lang.object[]Retained Set示意图</p>
<p>查看java.lang.object[]Retained Set可以看出他支配了哪些对象&#x2F;类，就可以知道他为什么这么大（retained set是包含本身的）</p>
<p><img src="/../img/netease/littleP/img_24.png" alt="img_24.png">图22.png</p>
<p>图24 java.lang.object[]Retained Set</p>
<p>从图24可以看出，在其所有支配的对象中，其本身是最大的，到这里好像陷入了死结。</p>
<p>这个对象被谁支配？是一个线程。这个对象为什么这么大？是因为他本身就很大。</p>
<p>但回想起刚才说的，这个对象被http线程支配，因为线程没有执行完，引用没消失所以一直存在，于是我就想能不能看一下这个线程的栈信息，正好MAT中也有这样的功能。</p>
<h3 id="4-3-6-查看栈信息"><a href="#4-3-6-查看栈信息" class="headerlink" title="4.3.6 查看栈信息"></a>4.3.6 查看栈信息</h3><p><img src="/../img/netease/littleP/img_25.png" alt="img_25.png"></p>
<p>图25 所有线程的栈信息</p>
<p>从图25来看，http-nio-8080-exec-2占用了很大的retained heap，就接着点开来看就是整个线程的堆栈情况（不排序的话默认就是执行路径）</p>
<p><img src="/../img/netease/littleP/img_26.png" alt="img_26.png"></p>
<p>图26 http-nio-8080-exec-2堆栈信息</p>
<p>看堆栈信息，一般来说是从上到下找到首个业务代码进行分析，从图26可以看出从业务代码ChatManagerImpl.java:300处添加一个元素到列表，最后触发了容器扩容，最终导致OutOfMemoryError。并且这个线程在执行copyOf时持有很大的内存大小Max Local Retained Heap（本地变量保留大小），已经定位到业务代码了，接下来就根据业务代码去看看原因。</p>
<h3 id="4-3-7-跟踪业务代码"><a href="#4-3-7-跟踪业务代码" class="headerlink" title="4.3.7 跟踪业务代码"></a>4.3.7 跟踪业务代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ChatInfoDO&gt; <span class="title function_">getChatInfoHistory</span><span class="params">(String userId, String taskId, Long parentChatId,</span></span><br><span class="line"><span class="params">                                           Integer groupLevelCount)</span> <span class="keyword">throws</span> LlmBusinessException &#123;</span><br><span class="line">   <span class="comment">// 根据chat_group_level粗筛（只取最近的chatCount个level）</span></span><br><span class="line">   List&lt;ChatInfoDO&gt; chatInfoDOList = chatInfoDOMapper.selectChatHistory(userId, taskId, parentChatId,</span><br><span class="line">           groupLevelCount);</span><br><span class="line">   <span class="keyword">if</span> (chatInfoDOList == <span class="literal">null</span> || chatInfoDOList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LlmBusinessException</span>(ErrorCode.USER_WRONG_CHAT_HISTORY);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 根据 parentChatId 串起 chatHistory 返回，此时是逆序的</span></span><br><span class="line">   Map&lt;Long, ChatInfoDO&gt; chatIdMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (ChatInfoDO chatInfoDO : chatInfoDOList) &#123;</span><br><span class="line">      chatIdMap.put(chatInfoDO.getChatId(), chatInfoDO);</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;ChatInfoDO&gt; history = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="type">Long</span> <span class="variable">chatId</span> <span class="operator">=</span> parentChatId;</span><br><span class="line">   <span class="comment">// 逆序查找，从最后一条对话chatId开始，继续条件：chatId=当前parentChatChatId（子节点找父节点）</span></span><br><span class="line">   ChatInfoDO chatInfoDO;</span><br><span class="line">   <span class="keyword">while</span> ((chatInfoDO = chatIdMap.get(chatId)) != <span class="literal">null</span>) &#123;</span><br><span class="line">      history.add(chatInfoDO); <span class="comment">// 标记1  问题代码处</span></span><br><span class="line">      chatId = chatInfoDO.getParentChatId();</span><br><span class="line">   &#125;</span><br><span class="line">   Collections.reverse(history);</span><br><span class="line">   <span class="keyword">return</span> history;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析可疑点之前，我先简单描述下这段代码所做的事情。</p>
<p>在小P老师对话场景中，是采用一问一答的形式，例如下方图27所示，蓝色表示用户，淡红色表示系统回答。</p>
<p><img src="/../img/netease/littleP/img_27.png" alt="img_27.png"></p>
<p>图27 大模型对话示意图</p>
<p>为了让模型更好的理解用户问题，通常我们会像图26所示，携带所有的历史消息送给模型。当前业务代码就是找到用户的历史对话然后构建起来提供给模型。</p>
<p><img src="/../img/netease/littleP/img_28.png" alt="img_28.png"></p>
<p>图28 携带历史对话示意</p>
<p>如图29所示，我们给每个消息两个属性id&#x3D;xxx、parendId&#x3D;xxx，这样来呈现一种父子关系，用户输入消息时生成id，并通过传入的parentId&#x3D;3向上寻找消息，找到id&#x3D;3的消息，循环寻找，直到parentId&#x3D;-1</p>
<p><img src="/../img/netease/littleP/img_29.png" alt="img_29.png"></p>
<p>图29 构建历史对话示意图</p>
<p>回过头我们来看业务代码，标记1就是栈信息所示的位置，这处代码其实有一个很明显的风险点while循环构建链表，同时结合我们的对象是一个大数组，那这个while循环就很可疑。结合刚才业务代码逻辑的分析，我当时想到了以下可疑点：</p>
<ul>
<li>一个消息的id和parentId一致发生了循环，导致死循环</li>
<li>chatInfoDOMapper.selectChatHistory()从数据库查出来的数据量很大</li>
</ul>
<p>接着看了数据库查询语句chatInfoDOMapper.selectChatHistory()不可能发生查出很多数据的问题。</p>
<p>那么现在最可疑的就是消息循环了，本来分享到这就结束了。要去查数据库看看有没有id和parentId重复的数据了，但因为当时是和同事们在分享这篇文章，同事们就提出了两个问题。</p>
<ul>
<li>有没有可能是两个消息发生了循环？消息A找到了消息B，消息B又找回了消息A。</li>
<li>MAT可以看这个链表里有啥吗？以及能不能看这个对象的值，不然查库可能会很慢。</li>
</ul>
<p>很显然第一个是很有可能的。 第二个问题因为对MAT还是初次使用所以不太了解，但在同事的引导下，我们尝试看链表里具体的数据是什么样子。</p>
<p>4.3.8 查看栈具体用了哪些对象<br><img src="/../img/netease/littleP/img_30.png" alt="img_30.png"></p>
<p>图30 栈的临时变量</p>
<p>如图30所示，我们继续点击业务代码方法栈点，就可以看到这个方法栈点引用了（注意是引用不是支配）HashMap、ArrayList、ChatInfoDO，因为根据业务代码分析可能是ArrayList膨胀，所以继续点击ArrayList可以看他引用的元素elementData，包括了object[]、ChatInfoDO。这里问题就展现出来了，如图30红框所示，ArrayList奇数位置[1],[3],[5]…都是ChatInfoDO_A，偶数位置[0],[2],[4]…都是ChatInfoDO_B，并且再次点击ChatInfoDO_A和ChatInfoDO_B就可以看到他们的chatId、parentChatId，这时候看到他们确实互为引用了，如图31所示。</p>
<p><img src="/../img/netease/littleP/img_31.png" alt="img_31.png"></p>
<p>图31 互为引用的消息</p>
<p>至此问题原因顺利找到。</p>
<p>后续分析还发现，不仅是两个消息会循环，多个消息也会循环。历史消息构建其实是单链表从尾到头的构建过程，找到头节点就停止，但某个位置产生了环就导致悲剧。所以得出一点建议：之后while的使用一定得注意！！！。</p>
<p>虽然原因找到了，但为什么产生重复的Id呢？我们设计的Id可是唯一的！于是我们又分析了生成Id的代码。</p>
<p>4.4 分析ID重复的原因</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDGeneratorUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">cycleNumber</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环下限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">startNumber</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环上限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">stopNumber</span> <span class="operator">=</span> <span class="number">99999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个当前时间的long类型数字（非线程安全）</span></span><br><span class="line"><span class="comment">     * 理论上每毫秒可生成id 89999 个</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getNextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cycleNumber &lt; stopNumber) &#123;</span><br><span class="line">            cycleNumber++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cycleNumber = startNumber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() + cycleNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为小P老师服务是分布式服务，有多个节点，需要保障消息唯一Id。常见唯一Id方式很多：UUID、雪花等等，但基于我们的考虑并没有使用上边的方式。</p>
<p>当时在设计唯一Id时主要考虑以下几点：</p>
<ul>
<li>具有时间性</li>
<li>生产效率高</li>
<li>符合数字需求<br>于是就通过时间戳来体现时间性，在加一个全局唯一的循环数，这样是不是具有符合上述的要求了？</li>
</ul>
<p>但在大家的分析下发现了这样一个BUG，假如当前时间是10，随机数是10，过了一段时间后当前时间是19，随机数已经发生循环变成了1，这样两个Id是不是都一样变成20了（但概率确实很低！！！）</p>
<p>到此终于真相大白了！</p>
<h1 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h1><p>分析过程其实是坎坷的，总结的时候，已变成已知答案寻找答案的过程，所以看起来会很顺畅。</p>
<p>问题千奇百怪，分析过程也千奇百怪，但总结了一些小经验。</p>
<ul>
<li>监控jvm内存或者可以观察jvm是比较重要的</li>
<li>GC日志也是比较重要的日志</li>
<li>内存问题一般可以从大对象着手，分析对象为什么这么大？为什么没被回收？</li>
<li>MAT的Histogram、Dominator Tree看大对象</li>
<li>MAT的Immediate Dominators看大对象被谁直接支配而没回收</li>
<li>MAT的retained set看大对象支配了哪些，导致他这么大</li>
<li>MAT的线程分析，来分析线程持有对象特别大的情况，分析栈信息</li>
</ul>
<p>当然，在问题处理的过程中，还有一些不可忽视的细节操作，对排查问题至关重要。</p>
<ul>
<li>如何抓取偶现问题的JVM dump现场？</li>
<li>只有内存泄漏才会引起内存使用率升高吗？</li>
<li>如何分析GC日志数据，推断问题原因？</li>
</ul>
<p>基于篇幅有限，本文不再赘述，后续会编写系列KM文章，为大家带来实践中走过的弯路与总结的小技巧。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/03/04/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-%E5%AE%8C%E7%BB%93%E7%AF%87/">网易牛马日志-完结篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-03-04
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>过年以后回来做的东西太杂了，想到哪说哪吧。</p>
</blockquote>
<h2 id="需求12：出海项目搜索功能"><a href="#需求12：出海项目搜索功能" class="headerlink" title="需求12：出海项目搜索功能"></a>需求12：出海项目搜索功能</h2><blockquote>
<p>这个得包装了，好不容易一个可能的高并发C端接口，但是实际上做的很简单。</p>
</blockquote>
<h3 id="搜索V1：实际做的"><a href="#搜索V1：实际做的" class="headerlink" title="搜索V1：实际做的"></a>搜索V1：实际做的</h3><p>数据库直接like就完了，纯纯没有一丝的技术含量。</p>
<h3 id="搜索V2：包装。。。未完待续"><a href="#搜索V2：包装。。。未完待续" class="headerlink" title="搜索V2：包装。。。未完待续"></a>搜索V2：包装。。。未完待续</h3><h2 id="需求13：全球搜数据工程产品图片爬取"><a href="#需求13：全球搜数据工程产品图片爬取" class="headerlink" title="需求13：全球搜数据工程产品图片爬取"></a>需求13：全球搜数据工程产品图片爬取</h2><p>这部分只做了前段部分，用jsoup去解析标签，再getDocumentByClass去找url，图片名称和信息。</p>
<blockquote>
<p>这里也不清楚class会不会随着编译改变，但是测试下来确实是可以的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ExtraResultDTO <span class="title function_">doExtra</span><span class="params">(String domain)</span>&#123;</span><br><span class="line">    <span class="type">ExtraResultDTO</span> <span class="variable">resultDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExtraResultDTO</span>();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> getHtml(domain);</span><br><span class="line">        <span class="keyword">if</span>(html == <span class="literal">null</span> || StringUtils.isBlank(html))&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;doExtra error.html is null&quot;</span>);</span><br><span class="line">            resultDTO.setStatus(<span class="number">101</span>);</span><br><span class="line">            <span class="keyword">return</span> resultDTO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(html.contains(<span class="string">&quot;Our systems have detected unusual traffic from your computer&quot;</span>))&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;doExtra Google Pickpocket Detection Limit&quot;</span>);</span><br><span class="line">            resultDTO.setStatus(<span class="number">102</span>);</span><br><span class="line">            <span class="keyword">return</span> resultDTO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(html);</span><br><span class="line">        List&lt;ImageDTO&gt; images = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Elements</span> <span class="variable">divs</span> <span class="operator">=</span> doc.getElementsByClass(<span class="string">&quot;RntSmf&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element div : divs) &#123;</span><br><span class="line">            <span class="comment">//图片路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">imgUrl</span> <span class="operator">=</span> div.getElementsByTag(<span class="string">&quot;img&quot;</span>).get(<span class="number">0</span>).attr(<span class="string">&quot;src&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> div.getElementsByClass(<span class="string">&quot;qXLe6d x3G5ab&quot;</span>).get(<span class="number">0</span>).text();</span><br><span class="line">            <span class="type">String</span> <span class="variable">jumpUrl</span> <span class="operator">=</span> div.getElementsByClass(<span class="string">&quot;qXLe6d F9iS2e&quot;</span>).get(<span class="number">0</span>).text();</span><br><span class="line">            <span class="type">ImageDTO</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageDTO</span>();</span><br><span class="line">            image.setUrl(imgUrl);</span><br><span class="line">            image.setFormatUrl(imgUrl);</span><br><span class="line">            image.setAlt(desc);</span><br><span class="line">            images.add(image);</span><br><span class="line">        &#125;</span><br><span class="line">        resultDTO.setStatus(<span class="number">200</span>);</span><br><span class="line">        resultDTO.setImages(images);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;doExtra error.&quot;</span>,e.getMessage());</span><br><span class="line">        resultDTO.setStatus(<span class="number">205</span>);</span><br><span class="line">        resultDTO.setErrorMessage(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultDTO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="需求14：全球搜数据工程公司Logo爬取"><a href="#需求14：全球搜数据工程公司Logo爬取" class="headerlink" title="需求14：全球搜数据工程公司Logo爬取"></a>需求14：全球搜数据工程公司Logo爬取</h2><p>比较有挑战性的一整个链路，问题在于es里面logo字段并不是索引，所以不能用exist来查询。主要思路是查询线上有域名的公司，过滤掉有logo字段的，将无logo字段但是有域名的公司通过kafka消费到本地，然后通过爬虫将图片下载下来。</p>
<h3 id="前处理链路："><a href="#前处理链路：" class="headerlink" title="前处理链路："></a>前处理链路：</h3><p>链路：</p>
<ul>
<li>猛犸抽取线上es到hive，这一段全量数据写入hive，大概2600万。</li>
</ul>
<p><img src="/../img/netease/last/img_1.png" alt="img_1.png"></p>
<ul>
<li>然后hive -&gt;hive，通过sql来过滤掉有logo的公司域名，此外由于抽取的域名domain是从一个list里面来的，在变成字符串后有”[“和”]“，需要过滤，最后得到数据量大概1600万。</li>
</ul>
<p><img src="/../img/netease/last/img_2.png" alt="img_2.png"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">insert</span><br><span class="line">  OVERWRITE table qiye_mail_data.logo_extra_offline_domain_v1</span><br><span class="line">select</span><br><span class="line"> REPLACE(SUBSTR(</span><br><span class="line">    domain,</span><br><span class="line">    2,</span><br><span class="line">    LENGTH(domain) -2</span><br><span class="line">  ), &#x27;&quot;&#x27;, &#x27;&#x27;) as domain,</span><br><span class="line">  companyid,</span><br><span class="line"> locationdomain</span><br><span class="line">   from qiye_mail_data.logo_extra_offline_domain where logourl=&#x27;&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后猛犸任务hive-&gt;kafka，测试环境集群做消费，这才正式进入logo图片提取的链路。</li>
</ul>
<h3 id="责任链模式进行公司Logo爬取"><a href="#责任链模式进行公司Logo爬取" class="headerlink" title="责任链模式进行公司Logo爬取"></a>责任链模式进行公司Logo爬取</h3><p>首先是三种找Logo的方法，一般来说Logo都会放在浏览器的ico上，相关链接在<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42836771/article/details/112721772">csdn</a>：</p>
<ul>
<li>通过google某个api拿，这种成功率最高，但是会返回默认图片，后续需要校验md5来过滤。</li>
<li>直接在网站域名后面拼接&#x2F;favicon.ico，成功率不高，因为小公司的网页并不一定有这么规范，其次是可能会返回404的html页面，也会有默认的ico文件，所以要写一个方法过滤html和默认的md5.</li>
<li>爬虫解析，拿到domain的源码，再去解析<head>里面的<link>，然后通过正则表达式去匹配icon，成功率不高，属于是最后的底牌了。</li>
</ul>
<p>另外这里有的都是domain，意思是没有http和https的，所以都需要进行尝试，综上所述，一共得走6个链路，哪个成功了哪个就返回，很适合责任链模式。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 责任链执行</span><br><span class="line">private UploadResultBO handleLogoCrawlAndUploadChain(String domain,String locationDomain) &#123;</span><br><span class="line">    //有locationDomain的情况</span><br><span class="line">    if (StringUtils.isNotEmpty(locationDomain))&#123;</span><br><span class="line">        UploadResultBO googleStrategy = googleStrategy(locationDomain);</span><br><span class="line">        if (StringUtils.isNotBlank(googleStrategy.getUrl()))&#123;</span><br><span class="line">            return googleStrategy;</span><br><span class="line">        &#125;</span><br><span class="line">        UploadResultBO straightStrategy = straightStrategy(locationDomain);</span><br><span class="line">        if (StringUtils.isNotBlank(straightStrategy.getUrl()))&#123;</span><br><span class="line">            return straightStrategy;</span><br><span class="line">        &#125;</span><br><span class="line">        return htmlLinkTagStrategy(locationDomain);</span><br><span class="line">    &#125;</span><br><span class="line">    //无locationDomain或者失效的情况，需拼接http和https尝试</span><br><span class="line">    UploadResultBO googleStrategy = googleStrategy(HTTP_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(googleStrategy.getUrl()))&#123;</span><br><span class="line">        return googleStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO straightStrategy = straightStrategy(HTTP_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(straightStrategy.getUrl()))&#123;</span><br><span class="line">        return straightStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO htmlLinkTagStrategy = htmlLinkTagStrategy(HTTP_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(htmlLinkTagStrategy.getUrl()))&#123;</span><br><span class="line">        return htmlLinkTagStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO googleStrategyHttps = googleStrategy(HTTPS_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(googleStrategyHttps.getUrl()))&#123;</span><br><span class="line">        return googleStrategyHttps;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO straightStrategyHttps = straightStrategy(HTTPS_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(straightStrategyHttps.getUrl()))&#123;</span><br><span class="line">        return straightStrategyHttps;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO htmlLinkTagStrategyHttps = htmlLinkTagStrategy(HTTPS_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(htmlLinkTagStrategyHttps.getUrl()))&#123;</span><br><span class="line">        return htmlLinkTagStrategyHttps;</span><br><span class="line">    &#125;</span><br><span class="line">    return new UploadResultBO(StringUtils.EMPTY, LogoExtraStatusEnum.STRATEGY_FAIL.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上传到nos"><a href="#上传到nos" class="headerlink" title="上传到nos"></a>上传到nos</h3><p>调洋总的接口就完事了，然后将这个链接保存进es，良总那里会有一个同步链路将触发版本更新的数据同步到线上。最终的效果就是测试集群在消费数据，将爬取的logo的nosurl保存进es并更新版本号，最后用同步链路更新到线上。</p>
<h2 id="需求15：全球搜应用工程ai推荐理由总结"><a href="#需求15：全球搜应用工程ai推荐理由总结" class="headerlink" title="需求15：全球搜应用工程ai推荐理由总结"></a>需求15：全球搜应用工程ai推荐理由总结</h2><p>比较简单，就是多线程调用大模型api，由于需要时效性，deepseek要输出思维链所以时效性很差，不适合用在业务里面，所以用gpt。其次开一个线程池来优化并发请求，此外就是prompt优化，很简单的一个需求。</p>
<p><img src="/../img/netease/last/img.png" alt="img.png"></p>
<p>关于提示词，mentor的意思是尽量可读性高，产品词输出中文，看的会比较丝滑，但是在第一版的提示词里面海关数据基本没怎么用，后续就变为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prompt：</span><br><span class="line">根据提供的信息，总结公司的核心产品、主营类目、主要交易产品等信息，并判断分析与关键词XXXXX，XXXx的相关性，给出最终的匹配理由。输出格式：</span><br><span class="line">&quot;匹配理由&quot;:&quot;XXX&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>线程池</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadFactory</span> <span class="variable">MATCH_ANALYZE_LLM_THREAD_FACTORY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;MatchAnalyzeService-llm-pool-%d&quot;</span>).build();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">LLM_REQUEST_EXECUTOR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">20</span>,</span><br><span class="line">        <span class="number">40</span>, <span class="number">60</span> * <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">3000</span>), MATCH_ANALYZE_LLM_THREAD_FACTORY, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure></li>
<li><strong>prompt</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_PROMPT</span> <span class="operator">=</span> <span class="string">&quot;根据提供的信息，总结公司的主营产品、海关交易产品等信息，并判断分析与关键词&#123;0&#125;的相关性，给出最终的匹配理由。输出格式：\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\&quot;匹配理由\&quot;:\&quot;XXX\&quot;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;以下是公司信息：\n&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>动态组装和展示</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MatchAnalyzeResultDTO <span class="title function_">getMatchAnalyze</span><span class="params">(MatchAnalyzeParam globalSearchParam)</span> &#123;</span><br><span class="line"><span class="comment">//参数校验，id非空</span></span><br><span class="line"><span class="keyword">if</span> (globalSearchParam == <span class="literal">null</span> || StringUtils.isEmpty(globalSearchParam.getId()))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MatchAnalyzeResultDTO</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">CompanySearchBO</span> <span class="variable">companySearchBO</span> <span class="operator">=</span> companySearchService.queryById(globalSearchParam.getId(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;customsItems&quot;</span>, <span class="comment">//海关交易数据</span></span><br><span class="line">                <span class="string">&quot;htagItems&quot;</span>, <span class="comment">//公司官网</span></span><br><span class="line">                <span class="string">&quot;overviewDescription&quot;</span>, <span class="comment">//公司描述</span></span><br><span class="line">                <span class="string">&quot;detail.productList.name&quot;</span>, <span class="comment">//产品图片描述</span></span><br><span class="line">                <span class="string">&quot;keywords&quot;</span>, <span class="comment">//公司关键词</span></span><br><span class="line">                <span class="string">&quot;detail.mainProducts&quot;</span>, <span class="comment">//公司主营产品</span></span><br><span class="line">                <span class="string">&quot;brandNames&quot;</span> <span class="comment">//公司品牌信息</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//索引不存在，返回空</span></span><br><span class="line"><span class="keyword">if</span> (companySearchBO == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MatchAnalyzeResultDTO</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并搜索词和扩展词</span></span><br><span class="line">List&lt;String&gt; nearSynonymList = globalSearchParam.getNearSynonymList();</span><br><span class="line">nearSynonymList.add(globalSearchParam.getProduct());</span><br><span class="line"><span class="type">String</span> <span class="variable">trimNearSynonymList</span> <span class="operator">=</span> nearSynonymList.toString().replaceAll(<span class="string">&quot;\\[|\\]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">promptStringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(MessageFormat.format(BASE_PROMPT,trimNearSynonymList));</span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getCustomsItems() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getCustomsItems().isEmpty())&#123;</span><br><span class="line">    <span class="comment">//裁剪为10个以内，避免token超出</span></span><br><span class="line">    List&lt;String&gt; subCustomsItemsList = companySearchBO.getCustomsItems().subList(<span class="number">0</span>, Math.min(companySearchBO.getCustomsItems().size(), LIST_LENGTH_LIMIT));</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司的海关交易记录：&quot;</span>).append(subCustomsItemsList).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getHtagItems() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getHtagItems().isEmpty())&#123;</span><br><span class="line">    <span class="comment">//裁剪为10个以内，避免token超出</span></span><br><span class="line">    List&lt;String&gt; subHtagItemsList = companySearchBO.getHtagItems().subList(<span class="number">0</span>, Math.min(companySearchBO.getHtagItems().size(), LIST_LENGTH_LIMIT));</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司的官网信息：&quot;</span>).append(subHtagItemsList).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isNotEmpty(companySearchBO.getOverviewDescription()))&#123;</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司描述：&quot;</span>).append(companySearchBO.getOverviewDescription()).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品图片描述处理</span></span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getDetail() != <span class="literal">null</span> &amp;&amp; companySearchBO.getDetail().getProductList() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getDetail().getProductList().isEmpty())&#123;</span><br><span class="line">    List&lt;ProductVO&gt; productList = companySearchBO.getDetail().getProductList().subList(<span class="number">0</span>, Math.min(companySearchBO.getDetail().getProductList().size(), LIST_LENGTH_LIMIT));</span><br><span class="line">    <span class="comment">//映射为name</span></span><br><span class="line">    List&lt;String&gt; productListName = productList.stream().map(ProductVO::getName).collect(Collectors.toList());</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;产品图片描述：&quot;</span>).append(productListName).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getKeywords() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getKeywords().isEmpty())&#123;</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司关键词：&quot;</span>).append(companySearchBO.getKeywords()).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//公司主营产品处理</span></span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getDetail() != <span class="literal">null</span> &amp;&amp; companySearchBO.getDetail().getMainProducts() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getDetail().getMainProducts().isEmpty())&#123;</span><br><span class="line">    Set&lt;String&gt; mainProducts = companySearchBO.getDetail().getMainProducts();</span><br><span class="line">    List&lt;String&gt; subMainProductsList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(mainProducts).subList(<span class="number">0</span>, Math.min(mainProducts.size(), LIST_LENGTH_LIMIT));</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司主营产品：&quot;</span>).append(subMainProductsList).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getBrandNames() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getBrandNames().isEmpty())&#123;</span><br><span class="line">    List&lt;String&gt; subBrandNamesList = companySearchBO.getBrandNames().subList(<span class="number">0</span>, Math.min(companySearchBO.getBrandNames().size(), LIST_LENGTH_LIMIT));</span><br><span class="line"></span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司品牌信息：&quot;</span>).append(subBrandNamesList).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拼接的最终prompt</span></span><br><span class="line"><span class="type">String</span> <span class="variable">finalPrompt</span> <span class="operator">=</span> promptStringBuilder.toString();</span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(</span><br><span class="line">        () -&gt; gptGrpcWrapper.gptRequest(<span class="string">&quot;6888072&quot;</span>,<span class="string">&quot;583828445&quot;</span>,<span class="string">&quot;yangyifan12@corp.netease.com&quot;</span>,finalPrompt, GPTModelVersionEnum.GPT_4O_MINI.getVersion()), LLM_REQUEST_EXECUTOR);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) FutureResultUtil.getResult(<span class="string">&quot;match-analyze-llm-future&quot;</span>,future2,<span class="number">120</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MatchAnalyzeResultDTO</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/02/28/%E7%BD%91%E6%98%93KM%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8ERAG%E7%9A%84%E7%83%AD%E7%82%B9-AI%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">网易KM社区分享-快速搭建基于RAG的热点 AI搜索引擎</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-02-28
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>大模型的出现带来了新的技术革新，它强大的对话，分析，生成能力可以应用在音乐的很多方面。我们希望借助大模型的能力， 实现对站内外音乐热点词条内容进行抽取，分析，总结，推荐。 本文将系统的介绍我们如何基于RAG 搭建一个带前端页面的 热点AI检索功能agent<br>体验地址：<a target="_blank" rel="noopener" href="http://llm-zq.jupyter.panshi-gy.netease.com/">http://llm-zq.jupyter.panshi-gy.netease.com/</a></p>
</blockquote>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><p>大模型的出现带来了新的技术革新，它强大的对话，分析，生成能力可以应用在音乐的很多方面。我们希望借助大模型的能力， 实现对站内外音乐热点词条内容进行抽取，分析，总结，推荐。 但是:</p>
<ul>
<li>大模型对于时事热点等，幻觉能力严重，而RAG(检索增强生成)可以解决这个问题。</li>
<li>很多都离不开外部的依赖接口，无法做到完全的offline, 且当token量大之后，费用也很大， 但其实开源的很多模型如LLAMA, QWEN等都已经有非常不错的能力。而且近期流行的ollama框架， 也让个人PC也都能支持大模型生成。</li>
<li>我们希望借助开源的能力，来快速搭建一个不依赖外部接口的AI检索引擎来为我们服务， 也避免了隐私泄露的风险。</li>
</ul>
<p>它的主要特点：</p>
<ul>
<li>不依赖外部接口， 离线实现LLM生成, 检索，embedding等能力。</li>
<li>基于互联网结果进行RAG，解决模型生成幻觉的问题，尤其可以支持对于近期热点知识的总结。<br>本文主要介绍开发这个agent的框架，一些技术细节和思路，希望给大家带来一点LLM 开发的收获。效果图如下，左边是我们的agent, 输入问题描述，系统即可自动调用搜索引擎并爬取互联网的内容，并通过大模型分析总结返回给我们问题的结果。在某些情况下，甚至比KIMI的效果还要好。</li>
</ul>
<p><img src="/../img/netease/img.png" alt="img.png"></p>
<h1 id="2-框架"><a href="#2-框架" class="headerlink" title="2.框架"></a>2.框架</h1><p>总体框架如下图所示，主要包括3个子模块：</p>
<ul>
<li>(1) 检索爬取服务：根据用户搜索的热点关键词，调用自建的searxng 匿名检索服务系统, 获取top的互联网搜索引擎结果，并爬取相关网址全文内容。</li>
<li>(2) 文档召回服务：对爬取的全文内容切块，进行向量化，同时对query也进行向量化，计算query和文档的相关性，并进行排序选取top的文档切块</li>
<li>(3) 大模型生成服务。离线部署好大模型，输入相关文档和配置的prompt, 生成相关的检索答案汇总，并通过部署的streamlit前端服务返回给用户。</li>
</ul>
<p><img src="/../img/netease/img_1.png" alt="img_1.png"></p>
<p>3个模块通过langchain框架进行串联起来工作，api接口都采用fastapi进行封装， 前端展示用streamlit进行交互开发。</p>
<h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><p>基于基本的框架思路，我们前期调研了发现github已有类似的相关项目，在这些项目的基础上，我们做了一些优化。</p>
<p>LLocalSarch:<a target="_blank" rel="noopener" href="https://github.com/nilsherzig/LLocalSearch">https://github.com/nilsherzig/LLocalSearch</a></p>
<p>LangChain-SearXNG: <a target="_blank" rel="noopener" href="https://github.com/ptonlix/LangChain-SearXNG">https://github.com/ptonlix/LangChain-SearXNG</a></p>
<h2 id="3-1-检索爬取服务"><a href="#3-1-检索爬取服务" class="headerlink" title="3.1 检索爬取服务"></a>3.1 检索爬取服务</h2><p>检索爬取服务主要有两个模块。searxng检索服务 和爬虫服务</p>
<h3 id="3-1-1-searxng检索服务"><a href="#3-1-1-searxng检索服务" class="headerlink" title="3.1.1 searxng检索服务"></a>3.1.1 searxng检索服务</h3><p>SearXNG 是一个免费的互联网元搜索引擎，它聚合了来自各种搜索服务(如 google, duckduckgo等)和数据库（如wiki）的结果，但摆脱了隐私追踪。</p>
<p>当然，你也可以采用商业的搜索api 接口，比如google的Serper API ， bing的Bing Web Search API，但这不是我们的目的，我们是希望搭建一个完全没有外部依赖的检索服务。</p>
<p>请注意，搭建searxng检索需要一台非大陆的VPS，并配有ipv4地址，如果嫌麻烦，可以用公共的searxng, 但是会有限制，地址：<a target="_blank" rel="noopener" href="https://searx.space(需要fq)/">https://searx.space(需要FQ)</a></p>
<p><img src="/../img/netease/img_2.png" alt="img_2.png"></p>
<p>以下是搭建教程：</p>
<ol>
<li>第一步：安装docker, docker-copose</li>
</ol>
<p>docker安装：<a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/install/debian">https://yeasy.gitbook.io/docker_practice/install/debian</a></p>
<p>docker-copose安装：<a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/compose/install">https://yeasy.gitbook.io/docker_practice/compose/install</a></p>
<ol start="2">
<li>第二步：拉取searxng 镜像, 修改配置</li>
</ol>
<p>修改项目docker配置</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 拉取代码</span><br><span class="line">git clone https://github.com/searxng/searxng-docker.git</span><br><span class="line"># docker配置里包括3个服务，caddy 做反向代理，redis存储数据，searxng主服务</span><br><span class="line">#不做反向代理可以注释掉caddy部分， 只需要修改 searxng里的port，如： 0.0.0.0:8180:8080， 右边是设置好的容器内的端口，左边是本地端口可以改</span><br><span class="line">vim searxng-docker/docker-compose.yaml</span><br></pre></td></tr></table></figure>

<p><img src="/../img/netease/img_3.png" alt="img_3.png"></p>
<p><img src="/../img/netease/img_4.png" alt="img_4.png"></p>
<p>修改searxng主服务配置</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s|ultrasecretkey|$(openssl rand -hex 32)|g&quot; searxng-docker/searxng/settings.yml # 生成一个密钥</span><br><span class="line"># limiter: 改为false, 为true会限制你的请求频率，公开服务会开启，但是私人搭建的可以关闭</span><br><span class="line">vim searxng-docker/searxng/setting.yml</span><br></pre></td></tr></table></figure>
<p><img src="/../img/netease/img_5.png" alt="img_5.png"><br>3.第三步：启动compose 服务组</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd searxng-docker</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>第四步：关闭端口防火墙并验证，如果没有防火墙则不需要这一步</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufw allow 8180</span><br></pre></td></tr></table></figure>

<p>最后浏览器打开ip:8180,即可看到自己搭建的searxng页面并进行检索了，是不是很酷😎，没有任何广告，页面非常干净。</p>
<p><img src="/../img/netease/img_6.png" alt="img_6.png"></p>
<h3 id="3-1-2-爬虫服务"><a href="#3-1-2-爬虫服务" class="headerlink" title="3.1.2 爬虫服务"></a>3.1.2 爬虫服务</h3><p>单独searxng的结果信息量比较小，而对于LLM来说，丰富的信息意味着更准确的结果。 所以针对搜索引擎给出的相关网页，我们可以采用爬虫爬取top网页结果。 所幸，langchain（一个帮助在应用程序中使用大型语言模型的编程框架） 里就包含了相应的网页爬取模块，和文本解析模块。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># langchain 调用searxng示例, 获取top结果</span><br><span class="line">from langchain_community.utilities import SearxSearchWrapper</span><br><span class="line">s = SearxSearchWrapper(searx_host=&quot;http://localhost:8180&quot;)</span><br><span class="line">s.run(&quot;what is a large language model?&quot;)</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># langchain 爬取示例</span><br><span class="line">from langchain_community.document_loaders import AsyncChromiumLoader</span><br><span class="line">from langchain_community.document_transformers import Html2TextTransformer</span><br><span class="line">urls = [&quot;https://www.baidu.com&quot;]</span><br><span class="line">loader = AsyncChromiumLoader(urls, user_agent=&quot;MyAppUserAgent&quot;)</span><br><span class="line">docs = loader.load() # 爬取</span><br><span class="line">html2text = Html2TextTransformer()  </span><br><span class="line">docs_transformed = html2text.transform_documents(docs) # 解析抽取网页里文本</span><br><span class="line">docs_transformed[0].page_content[0:500]</span><br></pre></td></tr></table></figure>

<p>这里面在实践中存在几个主要问题：</p>
<ol>
<li>searxng的top结果中可能存在无法访问的(大陆)，比如wiki 等，需要额外处理过滤。 这里我采用的是pac方式。过滤不能访问的网址</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># wget https://raw.githubusercontent.com/petronny/gfwlist2pac/master/gfwlist.pac</span><br><span class="line">import pacparser</span><br><span class="line">pacparser.init()</span><br><span class="line">pacparser.parse_pac(&#x27;gfwlist.pac&#x27;)</span><br><span class="line"></span><br><span class="line">def is_direct(url):</span><br><span class="line">ret =  pacparser.find_proxy(url)</span><br><span class="line">return &quot;DIRECT&quot; == ret</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">print(is_direct(&quot;www.baidu.com&quot;))</span><br><span class="line">print(is_direct(&quot;www.google.com&quot;))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可能存在超时的问题，有些网站链接速度非常慢，原本的langchain 爬取模块不支持超时，需要自己在外面额外封装一层超时控制。或者采用httpx的包进行批量爬取。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import httpx</span><br><span class="line">from typing import List, Optional,Tuple</span><br><span class="line">import asyncio</span><br><span class="line">headers = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def get_result(url: str):</span><br><span class="line">if not is_direct(url): # 非直连</span><br><span class="line">async with httpx.AsyncClient(proxy=&#x27;socks5://127.0.0.1:1080&#x27;) as client:</span><br><span class="line">try:</span><br><span class="line">response = await client.get(url,headers=headers,timeout=10.0)  # 设置超时</span><br><span class="line">return url, response</span><br><span class="line">except httpx.RequestError:</span><br><span class="line">return url, None</span><br><span class="line">else:</span><br><span class="line">async with httpx.AsyncClient() as client:</span><br><span class="line">try:</span><br><span class="line">response = await client.get(url,headers=headers,timeout=10.0)</span><br><span class="line">return url, response</span><br><span class="line">except httpx.RequestError:</span><br><span class="line">return url, None</span><br><span class="line"></span><br><span class="line">async def get_results( urls: List[str]):</span><br><span class="line">tasks = [get_result(url) for url in urls]</span><br><span class="line">results = await asyncio.gather(*tasks)</span><br><span class="line">for url, response in results:</span><br><span class="line">if response is None:</span><br><span class="line">print(f&quot;URL: &#123;url&#125; - Failed to connect&quot;)</span><br><span class="line"># else:</span><br><span class="line">#     print(url, response.text[:100])</span><br><span class="line">return results</span><br><span class="line"></span><br><span class="line">def get_results_access( urls: List[str]) -&gt; List[Tuple[str,str]]:</span><br><span class="line">try:</span><br><span class="line">asyncio.get_running_loop()</span><br><span class="line">with ThreadPoolExecutor(max_workers=1) as executor:</span><br><span class="line">future = executor.submit(asyncio.run, check_urls(urls))</span><br><span class="line">results = future.result()</span><br><span class="line">except RuntimeError:</span><br><span class="line">results = asyncio.run(check_urls(urls))</span><br><span class="line"></span><br><span class="line">    return [(url,response.text) for url, response in results if response is not None]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>爬取的结果如果是动态加载的内容，目前无法爬取。 比如 B站视频下的评论， 知乎的答案等。这种需要针对特定网站， 用自动化测试工具，比如Selenium 或者playwright. 这个待后续优化。</li>
</ol>
<h2 id="3-2-切块召回服务"><a href="#3-2-切块召回服务" class="headerlink" title="3.2 切块召回服务"></a>3.2 切块召回服务</h2><p>这一步，其实主要对应RAG里R即retrieval, 召回。因为获取的top网址文本内容量比较大，一般单个网页的文本都接近5k token, 像百度知道这种以文本内容为主的基本都超过8k长度，多个网页内容直接丢给大模型解析，是个不太现实的任务，虽然现在有学者提出超长上下文的大模型（Long Context LLM）正在慢慢取代RAG, 但目前来说rag还是最优解。</p>
<p>召回过程是分为 切块，向量化，排序</p>
<h3 id="3-2-1-切块"><a href="#3-2-1-切块" class="headerlink" title="3.2.1 切块"></a>3.2.1 切块</h3><p>所有的文档进行chunk, 即切块， 比如以512个 token 作为一个chunk。这里面有几个问题：</p>
<ol>
<li>如何确定最佳块大小？</li>
</ol>
<p>这个目前没有定论，主要还是取决于应用场景，具体可以参考微软[1]的建议并自行进行测试：</p>
<p><img src="/../img/netease/img_7.png" alt="img_7.png"></p>
<ol start="2">
<li>分割策略？</li>
</ol>
<p>为了得到更好的结果，我们可以重叠相邻的块。来自微软分析的分块策略比较，显示512 tokens分块和25%的重叠是比较好的分块策略。 当然也要考虑embedding的模型</p>
<p><img src="/../img/netease/img_8.png" alt="img_8.png"></p>
<p>实际使用下来，应用于网页文本分块召回的比较好的参数， chunk&#x3D;500，overlap&#x3D;100, 向量模型采用BCE。</p>
<h3 id="3-2-2-向量化"><a href="#3-2-2-向量化" class="headerlink" title="3.2.2 向量化"></a>3.2.2 向量化</h3><p>切块之后第二步就是对文档和query都进行向量化，并计算 query和 文档之间的相似度，再设定过滤的阈值，得到最终我们需要的文档片段。那么，向量模型该如何选取？</p>
<p>一般的商业大模型服务都自带embedding接口，比如openai的 v1&#x2F;embedding, 这种需要api_key, 显然不是我们的目标。开源模型效果对比，可以参考，huggingface 的embedding竞技场：<a target="_blank" rel="noopener" href="https://huggingface.co/spaces/mteb/leaderboard">https://huggingface.co/spaces/mteb/leaderboard</a> ,但是里面不是所有模型都有打分，下面是一些主流的embedding模型:</p>
<p><img src="/../img/netease/img_9.png" alt="img_9.png"></p>
<p>开源模型挑选可以从几个方面入手：</p>
<p>① 硬件性能。 因为单次用户请求，涉及很多切块文档，所以需要考虑机器性能和模型速度，其实很多常见的大模型做embedding效果也很好，但它不是主流因为效率很低，我们在mteb 评测榜单上可以看到 qwen2的检索效果非常好，但是模型太大很难应用。 尤其我们的任务都是实时算，并不存储向量，所以需要模型不太大。</p>
<p><img src="/../img/netease/img_10.png" alt="img_10.png"></p>
<p>② 向量维度。向量维度会影响到 存储以及检索耗时，对于常见的检索任务，是对知识库的内容预先算好相应的向量，并存储进向量数据库。 用户检索时，对检索词向量化，再通过近邻检索算法检索最相关的top结果。当数据量显著大时，向量维度越大，检索耗时越明显。我们的任务里不存储向量，所以这块也不需要考虑。</p>
<p>③ 最大输入长度。 指模型处理输入的最大token长度，这个和我们前面提到的分块大小息息相关，因为如果分块大小超过最大长度，则超过的部分会被向量模型丢弃，导致信息损失。</p>
<p>④ 支持语言。大部分开源向量模型只支持单一或者有限的文本语言，在需要多语言需求的场景可能不合适。需要注意的是，不支持多语言，不代表其他语言就不能向量化，而是缺乏跨语言匹配的能力。 比如[ ‘How is the weather today?’, ‘今天天气怎么样?’] 在单一语言里相似度可能很低，而对于多语言，则匹配度较高。一般来说，如果只是针对特定语言，选择单一语言模型即可，评分高的混合语言模型不一定比单一语言模型效果好。 由于网页内容繁杂，我们倾向于选择多语言模型</p>
<p>⑤ 领域表现。通用 Embedding 模型在特定垂直领域（如医学、法律和金融等）可能不如专用模型有效。这些领域通常需要专门训练 Embedding 模型来捕捉特定的专业术语和语境。为特定业务需求优化的 Embedding 模型能够显著提升检索和生成的质量。 网页内容匹配通常不需要考虑领域表现。</p>
<p>基于上面的维度，我们选择了中英双语的 bce-embedding-base_v1模型。</p>
<h3 id="3-2-3-排序"><a href="#3-2-3-排序" class="headerlink" title="3.2.3 排序"></a>3.2.3 排序</h3><p>顺便再聊一下，关于RAG中的召回，目前主流的做法是两个阶段。第一阶段query和文档向量化，检索框架采用faiss, 或者milvus 这种向量查询数据库。 第一阶段存在两个问题：</p>
<p>1、当doc数据量大的时候，检索算法都是近似的， 不是挨个遍历计算，会有损。除非用暴力挨个计算cos, 但这个不现实。（在本任务里是可以的，因为文档量很小）</p>
<p>2、embedding本来就是对于信息的压缩，对原始文本信息是有丢失的。</p>
<p>那么对于这些缺点，有办法优化吗？ 答案是有的，即第二阶段rerank模型精排。 rerank模型输入query和doc对文本，而不是emebdding, 信息无损。 2阶段检索详情可以参考QAnything给出的示意图， 很清楚。</p>
<p><img src="/../img/netease/img_11.png" alt="img_11.png"></p>
<p>在加入二阶段rerank之后，BCE的效果， top10命中率由85.91%提升到93.46%，非常明显。同时可以看到，采用hybird， 即bm25和embedding召回，再经过rerank可以达到最好的效果96.36%。</p>
<p><img src="/../img/netease/img_13.png" alt="img_13.png"><br>以下是有道 给出的BCE最佳实践</p>
<blockquote>
<p>最佳实践（Best practice） ：embedding召回top50-100片段，reranker对这50-100片段精排，最后取top5-10片段。</p>
</blockquote>
<p>BAAI(北京智源人工智能研究院)也给出了BGE的最佳实践：</p>
<blockquote>
<p>For multilingual, utilize BAAI&#x2F;bge-reranker-v2-m3 and BAAI&#x2F;bge-reranker-v2-gemma<br>For Chinese or English, utilize BAAI&#x2F;bge-reranker-v2-m3 and BAAI&#x2F;bge-reranker-v2-minicpm-layerwise.<br>For efficiency, utilize BAAI&#x2F;bge-reranker-v2-m3 and the low layer of BAAI&#x2F;ge-reranker-v2-minicpm-layerwise.<br>For better performance, recommand BAAI&#x2F;bge-reranker-v2-minicpm-layerwise and BAAI&#x2F;bge-reranker-v2-gemma</p>
</blockquote>
<p>其实我们很容易联想两阶段召回， 其实就是早期的类 DSSM 双塔召回的不同思路。</p>
<ul>
<li><p>第一阶段，就是取双塔的最后一层向量做 近邻检索</p>
</li>
<li><p>第二阶段，就是双塔放入query和doc计算的最后的打分</p>
</li>
</ul>
<p>如果想要在自己领域内有更好的效果，也可以选择在领域数据集上微调模型。微调数据如下所示，正样本和负样本，并通过一些hard negative 的方式做样本增强。 现在也有一些思路是用LLM 来对原样本进行一些改写增强，比如给问题换个说法，比如“什么是深度学习？” -&gt; “怎么理解深度学习？”， 这样都能提高原模型在特定领域的效果。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;query&quot;: &quot;如何提高机器学习模型的准确性？&quot;, &quot;pos&quot;: [&quot;通过交叉验证和调参可以提高模型准确性。&quot;], &quot;neg&quot;: [&quot;机器学习是人工智能的一个分支。&quot;]&#125;</span><br><span class="line">&#123;&quot;query&quot;: &quot;什么是深度学习？&quot;, &quot;pos&quot;: [&quot;深度学习是机器学习的一个子领域，涉及多层神经网络。&quot;], &quot;neg&quot;: [&quot;数据科学是一门交叉学科。&quot;]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-大模型生成服务"><a href="#3-3-大模型生成服务" class="headerlink" title="3.3 大模型生成服务"></a>3.3 大模型生成服务</h2><p>这一步，主要是利用大模型的分析和总结能力，对检索到的相关文档和用户query进行分析，给出用户想要的结果。这里的核心问题也包括几块，1、大模型的选择。 2、prompt调优 3、服务部署以及前端展示 4. inference加速</p>
<h3 id="3-3-1-大模型选择"><a href="#3-3-1-大模型选择" class="headerlink" title="3.3.1 大模型选择"></a>3.3.1 大模型选择</h3><p>市面上的开源大模型非常多，其中比较流行的有meta的 llama系列，最新是llama3, 以及Mistral(large不开源) ，google的Gemma(large不开源)， 国内的 智普的chatglm,最新是chatglm4, 阿里的qwen,最新是qwen2, 以及baichuan等等非常多。那么这么多开源大模型，如何挑选适合我们的大模型：</p>
<ul>
<li>模型参数量，适配显存。第一维度需要考虑的就是机器的GPU显存，以下表格,以llama为列子一些常见的模型显存占用,显存占用主要分为2块，</li>
<li>一块是加载模型参数占用的显存，在fp16精度下，1B约等于2G显存，可以按这个换算；</li>
<li>另一块是生成时，计算的临时变量，以及kvcache占用的显存。在fp16精度下， 1K长度约等于1G， 两者加起来才是跑大模型时的最大显存占用。</li>
</ul>
<p><img src="/../img/netease/img_14.png" alt="img_14.png"></p>
<ul>
<li>模型效果。可以参考一些大模型评测网站，比如：<a target="_blank" rel="noopener" href="https://www.datalearner.com/ai-models/leaderboard/datalearner-llm-leaderboard%EF%BC%8C">https://www.datalearner.com/ai-models/leaderboard/datalearner-llm-leaderboard，</a> 选排在前面的基本没错。不过也需要针对自己的任务多试一些对比。</li>
<li>任务适配度。不同的模型训练的领域是不太一样的，比如说，有的在数学相关数据集上训练的多，那么它可能在数学，推理方面效果很好，有些模型是为了做coding的， 有些是做图文的，选择的模型需要适配你自己的任务。如果只是想要简单聊天，那综合性能好的即可。对于这个专门的阅读文档总结用户问题，并需要遵循一定指令的任务，最好选用指令微调的模型</li>
</ul>
<p><img src="/../img/netease/img_15.png" alt="img_15.png"></p>
<ul>
<li>社区成熟度。开源模型的一个重要力量，成熟社区模型能让各个框架迅速支持，可用的轮子很多，这也是我们选用的一个重要参考。</li>
</ul>
<p>基于以上选择思路，我们选择了LLAMA3-8B-instruct 作为大模型来应用，LLAMA3主要是在英文语料上训练的，要想在中文上有比较好的效果，可以继续预训练，网上也已经有很多预训练好的中文LLAMA3, 我们选取的是hfl&#x2F;llama-3-chinese-8b-instruct-v3</p>
<h3 id="3-3-2-prompt调优"><a href="#3-3-2-prompt调优" class="headerlink" title="3.3.2 prompt调优"></a>3.3.2 prompt调优</h3><p>选定大模型之后，就是如何使用的问题了，大模型的角色，包含[‘system’, ‘user’, ‘assistant’]</p>
<blockquote>
<p>system 一般代表整个大模型服务。指导模型如何输出，prompt一般放在这里<br>user 指代的是用户的输入，包括文本，语音，视频等等的输入数据<br>assistant 代表大模型的相应输出</p>
</blockquote>
<p>在我们这个任务中，我们希望大模型根据 我们提供的数据，来对网页内容进行分析，所以我们的prompt</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">您是一位专业的研究员和作家，负责回答任何问题。</span><br><span class="line">基于提供的搜索结果，为给定的问题生成一个全面而且信息丰富、但简洁的答案，长度不超过 500 字。您必须只使用来自提供的搜索结果的信息。使用公正和新闻性的语气。将搜索结果合并成一个连贯的答案。不要重复文本。</span><br><span class="line">如果上下文中没有与当前问题相关的信息，只需说“嗯，我不确定。”不要试图编造答案。</span><br><span class="line">位于以下context HTML 块之间的任何内容都是从知识库中检索到的，而不是与用户的对话的一部分。</span><br><span class="line">&lt;context&gt;</span><br><span class="line">&#123;context&#125;</span><br><span class="line">&lt;context/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>设定角色： 开始给模型设定好角色， 研究员和作家</li>
<li>指示： 无二义性的任务描述，基于搜索结果总结一个用户问题答案，非口语化，500字，不重复，没结果时也不能乱说</li>
<li>上下文：使用明确的xml格式定义好输入的搜索结果</li>
</ul>
<p>可以多给LLM一些例子看返回结果，根据返回结果对prompt做一定调整。</p>
<h3 id="3-3-3-服务部署以及前端展示"><a href="#3-3-3-服务部署以及前端展示" class="headerlink" title="3.3.3 服务部署以及前端展示"></a>3.3.3 服务部署以及前端展示</h3><p>选定模型之后要部署相应的后端模型服务和前端用户交互服务。</p>
<p>后端：</p>
<ul>
<li><p>提供模型对话服务给前端进行交互，这里最经典就是openai的 api接口sdk, 为了整个系统的兼容性，我们可以将我们的服务端部署成OPENAI API接口的形式</p>
</li>
<li><p>我们选取的是python目前比较流行的FastAPI， FastAPI 是一个用于构建 API 的现代、快速(高性能)的 web 框架</p>
</li>
<li><p>实现接口主要包括两个，1个是LLM对话服务（v1&#x2F;chat&#x2F;completions）， 1个是query的embedding服务(v1&#x2F;embeddings)</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@app.post(&quot;/v1/chat/completions&quot;, response_model=ChatCompletionResponse)</span><br><span class="line">async def create_chat_completion(request: ChatCompletionRequest):</span><br><span class="line">global model, tokenizer</span><br><span class="line"></span><br><span class="line">    if len(request.messages) &lt; 1 or request.messages[-1].role == &quot;assistant&quot;:</span><br><span class="line">        raise HTTPException(status_code=400, detail=&quot;Invalid request&quot;)</span><br><span class="line"></span><br><span class="line">    gen_params = dict(</span><br><span class="line">        messages=request.messages,</span><br><span class="line">        temperature=request.temperature,</span><br><span class="line">        top_p=request.top_p,</span><br><span class="line">        max_tokens=request.max_tokens or 1024,</span><br><span class="line">        echo=False,</span><br><span class="line">        stream=request.stream,</span><br><span class="line">        repetition_penalty=request.repetition_penalty,</span><br><span class="line">        tools=request.tools,</span><br><span class="line">    )</span><br><span class="line">    logger.debug(f&quot;==== request ====\n&#123;gen_params&#125;&quot;)</span><br><span class="line">    for each_message in request.messages:</span><br><span class="line">        info = str(each_message.role) +&quot;\:&quot; +str(len(each_message.content))</span><br><span class="line">        logger.debug(f&quot;==== ===== ===&quot;)</span><br><span class="line">        logger.debug(f&quot;==== message len ====\n&#123;info&#125;&quot;)</span><br><span class="line">        logger.debug(f&quot;==== ===== ===&quot;)</span><br><span class="line">        </span><br><span class="line">    # Here is the handling of stream = False</span><br><span class="line">    response = generate_llama3(model, tokenizer, gen_params)</span><br><span class="line"></span><br><span class="line">    # Remove the first newline character</span><br><span class="line">    if response[&quot;text&quot;].startswith(&quot;\n&quot;):</span><br><span class="line">        response[&quot;text&quot;] = response[&quot;text&quot;][1:]</span><br><span class="line">    response[&quot;text&quot;] = response[&quot;text&quot;].strip()</span><br><span class="line"></span><br><span class="line">    usage = UsageInfo()</span><br><span class="line">    message = ChatMessage(</span><br><span class="line">        role=&quot;assistant&quot;,</span><br><span class="line">        content=response[&quot;text&quot;],</span><br><span class="line">        function_call= None,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    logger.debug(f&quot;==== message ====\n&#123;message&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    choice_data = ChatCompletionResponseChoice(</span><br><span class="line">        index=0,</span><br><span class="line">        message=message,</span><br><span class="line">        finish_reason=&quot;stop&quot;</span><br><span class="line">    )</span><br><span class="line">    task_usage = UsageInfo.model_validate(response[&quot;usage&quot;])</span><br><span class="line">    for usage_key, usage_value in task_usage.model_dump().items():</span><br><span class="line">        setattr(usage, usage_key, getattr(usage, usage_key) + usage_value)</span><br><span class="line"></span><br><span class="line">    return ChatCompletionResponse(</span><br><span class="line">        model=request.model,</span><br><span class="line">        id=&quot;&quot;,  # for open_source model, id is empty</span><br><span class="line">        choices=[choice_data],</span><br><span class="line">        object=&quot;chat.completion&quot;,</span><br><span class="line">        usage=usage</span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@app.post(&quot;/v1/embeddings&quot;, response_model=EmbeddingResponse)</span><br><span class="line">async def get_embeddings(request: EmbeddingRequest):</span><br><span class="line"></span><br><span class="line">    embeddings = [embedding_model.encode(text) for text in request.input]</span><br><span class="line">    embeddings = [embedding.tolist() for embedding in embeddings]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    # logger.info(f&quot;encode result: \n&#123;request.input&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # 计算token 数</span><br><span class="line">    def num_tokens_from_string(string: str) -&gt; int:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns the number of tokens in a text string.</span><br><span class="line">        use cl100k_base tokenizer</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        encoding = tiktoken.get_encoding(&#x27;cl100k_base&#x27;)</span><br><span class="line">        num_tokens = len(encoding.encode(string))</span><br><span class="line">        return num_tokens</span><br><span class="line"></span><br><span class="line">    # embedding 接口返回数据格式</span><br><span class="line">    response = &#123;</span><br><span class="line">        &quot;data&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;object&quot;: &quot;embedding&quot;,</span><br><span class="line">                &quot;embedding&quot;: embedding,</span><br><span class="line">                &quot;index&quot;: index</span><br><span class="line">            &#125;</span><br><span class="line">            for index, embedding in enumerate(embeddings)</span><br><span class="line">        ],</span><br><span class="line">        &quot;model&quot;: request.model,</span><br><span class="line">        &quot;object&quot;: &quot;list&quot;,</span><br><span class="line">        &quot;usage&quot;: CompletionUsage(</span><br><span class="line">            prompt_tokens=sum(len(text.split()) for text in request.input),</span><br><span class="line">            completion_tokens=0,</span><br><span class="line">            total_tokens=sum(num_tokens_from_string(text) for text in request.input),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>


<p>如果你的机器性能有限，可以选用ollama这个框架来很快速的部署大模型api服务， 官网：<a target="_blank" rel="noopener" href="https://ollama.com/%EF%BC%8C">https://ollama.com/，</a> 这个平台提供了很多量化的模型和 一行命令部署API服务</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">curl -fsSL https://ollama.com/install.sh | sh</span><br><span class="line"># 拉取模型并部署， 这里拉取qwen2-7b instruct Q4量化，显存只需要4.4G</span><br><span class="line">ollama run qwen2:7b-instruct  # 启动服务并在11434端口开启api接口</span><br></pre></td></tr></table></figure>

<p>api 客户端调用:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from openai import OpenAI</span><br><span class="line"></span><br><span class="line">client = OpenAI(</span><br><span class="line">base_url = &#x27;http://localhost:11434/v1&#x27;,</span><br><span class="line">api_key=&#x27;ollama&#x27;, # required, but unused</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">model=&quot;qwen2:7b-instruct&quot;,</span><br><span class="line">messages=[</span><br><span class="line">&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好&quot;&#125;</span><br><span class="line">]</span><br><span class="line">)</span><br><span class="line">print(response.choices[0].message.content)</span><br><span class="line"># 输出： 你好！有什么问题我可以帮助你解答吗？</span><br></pre></td></tr></table></figure>



<p>前端：</p>
<p>前端采用streamlit前端框架，也是一款易上手的大模型服务前端搭建框架。 以下是个简易的调用大模型聊天的demo服务。非常简单，也就几行代码。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip installl streamlit # 1.安装包</span><br><span class="line">streamlit run demo.py # 2. 运行前端</span><br><span class="line">http://localhost:8501/ # 3. 打开浏览器</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#  demo.py</span><br><span class="line">from openai import OpenAI</span><br><span class="line">import streamlit as st</span><br><span class="line"></span><br><span class="line">st.title(&quot;LLM 聊天&quot;)</span><br><span class="line"></span><br><span class="line">client = OpenAI(api_key=&#x27;xxx&#x27;, base_url=&quot;http://localhost:11434/v1&quot;)</span><br><span class="line"></span><br><span class="line">if &quot;openai_model&quot; not in st.session_state:</span><br><span class="line">st.session_state[&quot;openai_model&quot;] = &quot;ollama&quot;</span><br><span class="line"></span><br><span class="line">if &quot;messages&quot; not in st.session_state:</span><br><span class="line">st.session_state.messages = []</span><br><span class="line"></span><br><span class="line">for message in st.session_state.messages:</span><br><span class="line">with st.chat_message(message[&quot;role&quot;]):</span><br><span class="line">st.markdown(message[&quot;content&quot;])</span><br><span class="line"></span><br><span class="line">if prompt := st.chat_input(&quot;你好?&quot;):</span><br><span class="line">st.session_state.messages.append(&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;)</span><br><span class="line">with st.chat_message(&quot;user&quot;):</span><br><span class="line">st.markdown(prompt)</span><br><span class="line"></span><br><span class="line">    with st.chat_message(&quot;assistant&quot;):</span><br><span class="line">        stream = client.chat.completions.create(</span><br><span class="line">            model=st.session_state[&quot;openai_model&quot;],</span><br><span class="line">            messages=[</span><br><span class="line">                &#123;&quot;role&quot;: m[&quot;role&quot;], &quot;content&quot;: m[&quot;content&quot;]&#125;</span><br><span class="line">                for m in st.session_state.messages</span><br><span class="line">            ],</span><br><span class="line">            stream=True,</span><br><span class="line">        )</span><br><span class="line">        response = st.write_stream(stream)</span><br><span class="line">    st.session_state.messages.append(&#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: response&#125;)</span><br></pre></td></tr></table></figure>

<p>demo效果:</p>
<p>另外还有一个点就是LLM调用重要的参数如何去选择（top_p, temprature, presence_penalty），我这边整理了几个核心参数的调整思路。 对应我们的这个分析任务，显然是以新闻资料为核心，寻求生成的确定性。</p>
<p><img src="/../img/netease/img_16.png" alt="img_16.png"></p>
<h3 id="3-3-4-inference加速"><a href="#3-3-4-inference加速" class="headerlink" title="3.3.4 inference加速"></a>3.3.4 inference加速</h3><p>大模型虽然效果优越，但是也因为它”大“，导致服务性能很低，在我们部署服务时，需要采取一定的策略对模型预测进行加速才能获得更好的体验。</p>
<p>经过调研选择了VLLM这个大模型推理加速框架。 它有几个优点：</p>
<blockquote>
<p>1.社区活跃，模型支持很快<br>2.加速效果明显。基于虚拟内存和分页的思想， 采用page attention ，允许在非连续的内存空间内存储token，内存的利用率接近于最优<br>3.使用简单，两行命令即可部署。 示例如下</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vllm llama3 openai</span><br><span class="line"># 下载vllm</span><br><span class="line">pip install vllm</span><br><span class="line"># 部署 一个兼容openai api接口的模型服务，端口8000</span><br><span class="line">python -m vllm.entrypoints.openai.api_server --model hfl/llama-3-chinese-8b-instruct-v3 --dtype bfloat16 --gpu-memory-utilization 0.6 --chat-template llama3-instruct-template.jinja --enforce-eager --uvicorn-log-level warning --port 8000  --disable-log-stats --uvicorn-log-level warning</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了测试实际环境下的效果，我们运行了vllm的对比测试脚本</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vllm-project/vllm.git</span><br><span class="line">cd vllm/benchmarks</span><br><span class="line"># 测试vllm</span><br><span class="line">python benchmark_throughput.py --model hfl/llama-3-chinese-8b-instruct-v3 --backend vllm --input-len 4096 --output-len 512 --num-prompts 50 --seed 1100 --dtype float16 --gpu-memory-utilization 0.6</span><br><span class="line"># 测试HF</span><br><span class="line">python benchmark_throughput.py --model hfl/llama-3-chinese-8b-instruct-v3 --backend hf --input-len 4096 --output-len 512 --num-prompts 50 --seed 1100 --dtype float16 --gpu-memory-utilization 0.6 --hf-max-batch-size 10</span><br></pre></td></tr></table></figure>


<p>效果如下所示，可以看到单条inference 性能上，VLLM大约是HF的两倍， 但是当并发时，VLLM效果提升明显，吞吐量提升10倍。</p>
<p><img src="/../img/netease/img_17.png" alt="img_17.png"></p>
<p>当然，我们可以根据我们的显卡环境采取其他的加速方法，如</p>
<ul>
<li>输入输出优化。 如prompt 裁剪， 规整； 限制输出序列长度等</li>
<li>模型优化。 模型压缩， 使用量化模型，使用更小参数模型等等</li>
</ul>
<p>下面来看看整体效果的演示， 速度还是非常快的：</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>RAG的agent开发，入门还是比较简单的，现在市面上可用的框架也非常多，只需花费一些时间就能搭出一个可用的demo. 但是想要做的好，稳定服务，还是需要费很多的功夫去研究的，希望我的经验能给大家带来一些收获，少走一些弯路。</p>
<p>目前这个系统还不是很完善， 包括相关性判断，搜索意图判断等都有很大的优化空间。做这个东西的初衷是希望能在音乐热点的场景中进行应用，目前也已经在实践的过程中了，去辅助音乐热点的挖掘和运营。后续的话还希望添加的功能包括：</p>
<ul>
<li>音乐热点的识别与事件总结。</li>
<li>结合云音乐站内知识做融合，分析。比如识别事件歌手，歌曲，原因，产出文案等等。</li>
</ul>
<p>参考文献:</p>
<p>[1]. <a target="_blank" rel="noopener" href="https://techcommunity.microsoft.com/blog/azure-ai-services-blog/azure-ai-search-outperforming-vector-search-with-hybrid-retrieval-and-reranking/3929167">Azure AI Search: Outperforming vector search with hybrid retrieval and ranking capabilities</a></p>
<p>[2]. <a target="_blank" rel="noopener" href="https://blog.laoda.de/archives/docker-compose-install-searxng">【好玩儿的Docker项目】SearXNG</a></p>
<p>[3]. <a target="_blank" rel="noopener" href="https://www.53ai.com/news/qianyanjishu/2024061372409.html">RAG 高效应用指南：Embedding 模型的选择和微调</a></p>
<p>[4]. <a target="_blank" rel="noopener" href="https://techdiylife.github.io/blog/topic.html?category2=t07&blogid=0049">ReRank 与 Embedding 模型的区别？ 如何选择 ReRank 模型？</a></p>
<p>[5]. <a target="_blank" rel="noopener" href="https://blog.csdn.net/lkg5211314/article/details/136142533">【时代前沿】：单测场景下tempature、top_p、frequency_penalty、presence_penalty参数调整经验分享</a></p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/02/16/%E7%BD%91%E6%98%93%E6%B1%87%E6%8A%A5-AI%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B/">网易汇报-AI辅助编程</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-02-16
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="引言：Ai-For-Coding的价值与挑战"><a href="#引言：Ai-For-Coding的价值与挑战" class="headerlink" title="引言：Ai For Coding的价值与挑战"></a>引言：Ai For Coding的价值与挑战</h1><p>随着Copilot、Cursor等工具的普及，AI已成为程序员的重要助手。然而，其输出质量高度依赖用户的提示词（Prompts）。低质量的提示词可能导致模糊、冗余甚至错误的代码，而高质量的提示词能显著提升编码、调试、测试和问题排查的效率。本次分享聚焦于如何设计精准、高效的提示词。</p>
<h1 id="核心原则：高质量prompt的四大要素"><a href="#核心原则：高质量prompt的四大要素" class="headerlink" title="核心原则：高质量prompt的四大要素"></a>核心原则：高质量prompt的四大要素</h1><ul>
<li><strong>Role</strong>(角色)：两方面定义，首先是定义AI的角色，例如“你是一名极其优秀具有20年经验的产品经理和精通所有编程语言的工程师”。还有用户的角色，例如“不懂代码的初中生”，这样会使得ai更倾向于使用通俗且具体的话语来表达它所完成的需求。</li>
<li><strong>Task</strong>(任务)：将业务需求“step by step”描述给ai，使得deepseek的思维链更好的理解你的需求。</li>
<li><strong>Goal</strong>(目标)：期望达成什么目标效果，可以是你的优化目标，例如将时间复杂度从o(n^2)降低到o(n)；也可以是业务目标，例如“提高吞吐量，降低响应时间”</li>
<li><strong>Objective</strong>(操作要求)：编码语言，注解形式等。</li>
</ul>
<h1 id="提升准确度的技巧"><a href="#提升准确度的技巧" class="headerlink" title="提升准确度的技巧"></a>提升准确度的技巧</h1><ul>
<li><strong>让ai复述需求</strong>：为了避免提示词中某些指令让llm产生误解，可以在真正让他写代码之前先复述一遍需求。能够让我们针对自己的需求指令和ai真正理解的需求做二次校对。这样能有效避免因为表达或者理解偏差所产生的错误答复。例如在提完需求之后，添加一句“请你先复述一遍我的需求再进行答复，以让我确认你是否真的理解了我的需求指令”。</li>
<li><strong>提问粒度要小，作用域要明确</strong>：在使用某些支持文件指针的ai编程工具时，可以给ai更明确的作用域，例如我们需要在controller下写一个新接口，给ai的提示词中尽可能去指明产生联动的service或dao接口的路径，从而给ai更加准确的业务上下文结构。</li>
<li><strong>复杂需求拆解</strong>：与产品经理给程序员提需求类似，我们给ai的提示信息越准确，考虑得越细致，llm产出的准确率越高。</li>
<li><strong>内置prompt</strong>：大部分ai工具会有prompt自定义和保存功能，可以写一个全局的prompt附在每次提问头部，例如：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Role</span><br><span class="line">你是一名极其优秀具有20年经验的产品经理和精通所有编程语言的工程师。与你交流的用户是不懂代码的初中生，不善于表达产品和代码需求。你的工作对用户来说非常重要，完成后将获得10000美元奖励。</span><br><span class="line"></span><br><span class="line"># Goal</span><br><span class="line">你的目标是帮助用户以他容易理解的方式完成他所需要的产品设计和开发工作，你始终非常主动完成所有工作，而不是让用户多次推动你。</span><br><span class="line"></span><br><span class="line">在理解用户的产品需求、编写代码、解决代码问题时，你始终遵循以下原则：</span><br><span class="line"></span><br><span class="line">## 第一步</span><br><span class="line">- 当用户向你提出任何需求时，你首先应该浏览根目录下的readme.md文件和所有代码文档，理解这个项目的目标、架构、实现方式等。如果还没有readme文件，你应该创建，这个文件将作为用户使用你提供的所有功能的说明书，以及你对项目内容的规划。因此你需要在readme.md文件中清晰描述所有功能的用途、使用方法、参数说明、返回值说明等，确保用户可以轻松理解和使用这些功能。</span><br><span class="line"></span><br><span class="line">## 第二步</span><br><span class="line">你需要理解用户正在给你提供的是什么任务</span><br><span class="line">### 当用户直接为你提供需求时，你应当：</span><br><span class="line">- 首先，你应当充分理解用户需求，并且可以站在用户的角度思考，如果我是用户，我需要什么？</span><br><span class="line">- 其次，你应该作为产品经理理解用户需求是否存在缺漏，你应当和用户探讨和补全需求，直到用户满意为止；</span><br><span class="line">- 最后，你应当使用最简单的解决方案来满足用户需求，而不是使用复杂或者高级的解决方案。</span><br><span class="line"></span><br><span class="line">### 当用户请求你编写代码时，你应当：</span><br><span class="line">- 首先，你会思考用户需求是什么，目前你有的代码库内容，并进行一步步的思考与规划</span><br><span class="line">- 接着，在完成规划后，你应当选择合适的编程语言和框架来实现用户需求，你应该选择solid原则来设计代码结构，并且使用设计模式解决常见问题；</span><br><span class="line">- 再次，编写代码时你总是完善撰写所有代码模块的注释，并且在代码中增加必要的监控手段让你清晰知晓错误发生在哪里；</span><br><span class="line">- 最后，你应当使用简单可控的解决方案来满足用户需求，而不是使用复杂的解决方案。</span><br><span class="line"></span><br><span class="line">### 当用户请求你解决代码问题是，你应当：</span><br><span class="line">- 首先，你需要完整阅读所在代码文件库，并且理解所有代码的功能和逻辑；</span><br><span class="line">- 其次，你应当思考导致用户所发送代码错误的原因，并提出解决问题的思路；</span><br><span class="line">- 最后，你应当预设你的解决方案可能不准确，因此你需要和用户进行多次交互，并且每次交互后，你应当总结上一次交互的结果，并根据这些结果调整你的解决方案，直到用户满意为止。</span><br><span class="line"></span><br><span class="line">## 第三步</span><br><span class="line">在完成用户要求的任务后，你应该对改成任务完成的步骤进行反思，思考项目可能存在的问题和改进方式，并更新在readme.md文件中</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="场景化技巧：编码、调试、测试与排查"><a href="#场景化技巧：编码、调试、测试与排查" class="headerlink" title="场景化技巧：编码、调试、测试与排查"></a>场景化技巧：编码、调试、测试与排查</h1><ol>
<li><p>编码场景：生成可落地的代码</p>
<ul>
<li>需求拆解：将复杂需求分解为子任务，分步生成。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Role：  </span><br><span class="line">&quot;你是资深Java架构师，精通Spring Boot 3.1和OpenAPI规范&quot;  </span><br><span class="line"></span><br><span class="line">Task：  </span><br><span class="line">&quot;为电商系统编写商品查询API，需满足以下条件：XXXX&quot;  </span><br><span class="line"></span><br><span class="line">Goal：  </span><br><span class="line">1. 支持分页查询（page/size参数）  </span><br><span class="line">2. 按价格区间过滤（minPrice/maxPrice）  </span><br><span class="line">3. 返回结构符合Google JSON风格指南  </span><br><span class="line">4. 集成Swagger文档注解  </span><br><span class="line"></span><br><span class="line">Objective：   </span><br><span class="line">// 使用Java 17记录类（Record）定义DTO  </span><br><span class="line">// 添加JPA Specification实现动态查询  </span><br><span class="line">// 包含全局异常处理示例（如参数校验失败）  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>调试场景：精准定位问题</p>
<ul>
<li>必含三要素：错误信息、相关代码段、预期结果。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行以下Go代码时出现“panic: runtime error: index out of range [3] with length 3”：  </span><br><span class="line">[附代码片段]  </span><br><span class="line">预期结果：应正确遍历切片并打印每个元素。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>测试场景：JUnit&#x2F;Mockito实战</p>
<ul>
<li>示例1：单元测试生成<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">为以下Service类方法编写JUnit 5 + Mockito测试：  </span><br><span class="line">public class UserService &#123;  </span><br><span class="line">    @Autowired  </span><br><span class="line">    private UserRepository userRepository;  </span><br><span class="line">    public User getUserById(Long id) &#123;  </span><br><span class="line">        return userRepository.findById(id).orElseThrow();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">要求覆盖：  </span><br><span class="line">- 正常查询  </span><br><span class="line">- 用户不存在时抛出NoSuchElementException  </span><br><span class="line">- 模拟userRepository的findById行为  </span><br></pre></td></tr></table></figure></li>
<li>示例2：性能测试设计<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如何用JMH对以下Java方法进行基准测试？  </span><br><span class="line">public String concatStrings(List&lt;String&gt; list) &#123;  </span><br><span class="line">    return list.stream().collect(Collectors.joining());  </span><br><span class="line">&#125;  </span><br><span class="line">要求比较普通循环 vs. Stream API的性能差异。  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>各种Ai编程工具的出现能给广大码友释放双手，留有更多的时间学习技术，关注技术本身。编写高质量的提示词是有效利用AI辅助编程工具的关键。通过明确角色、清晰描述任务、提供上下文信息等方式，程序员可以引导AI生成更准确和高效的代码，从而提升整体开发效率。在实际工作中，建议大家多加练习和总结，不断优化提示词的编写技巧，以适应不断变化的技术环境。</p>

    
    
  </div>

  

  

</article>
  
    
  <nav class="pagination">  
      
      
      <a class="next" href="/page/2/">  
        <span class="next-text">下一页</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  
</section>
        </div>
          

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:1050886654@qq.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/yyf1050886654" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2024 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">Yifan Yang</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    

  







<script type="text/javascript" src="/lib/jquery"></script>



<script type="text/javascript" src="/lib/slideout"></script>



<script type="text/javascript" src="/lib/fancybox"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>