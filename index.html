<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/default" title="YYF's Blog" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://yyf1050886654.github.io/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>YYF&#39;s Blog</title>

<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">YYF&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/collect/">
      <li class="mobile-menu-item">
        
        
        收藏              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">YYF's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/collect/">  
              
              
              收藏  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <section id="posts" class="posts">
  
  
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/10/31/%E5%AE%9E%E4%B9%A02-0-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">实习2.0-项目总结</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-10-31
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="实习拷打"><a href="#实习拷打" class="headerlink" title="实习拷打"></a>实习拷打</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>网易外贸通是一个为外贸企业打造的一站式外贸营销平台，主要的功能包括数据获客，邮件营销，客户管理和订单追踪等。<br>我所在的组是做数据获客的，主要业务就是让用户能够通过我们的应用查到他的潜在客户。就比如一个想做服装贸易的就可以通过我们的数据找到对应的国外买家。<br>这一部分数据获取是多渠道的，我们通过海关每年的hscode，各种类似盘踞这些网站采购，以及一些爬虫技术拿到了大概六千万家公司数据。我们的业务一方面是搜索功能，所以我们数据层没用mysql多用的是es；<br>另一部分是数据层，多渠道去搜集这些公司作为我们的信息。</p>
<h3 id="数据双向同步链路-落库"><a href="#数据双向同步链路-落库" class="headerlink" title="数据双向同步链路-落库"></a>数据双向同步链路-落库</h3><ol>
<li>目的：我们这边是做数据的，另外一边算法组做的是域名行业分类，意思就是他们把域名对应的html通过某种模型预测一个行业标签，我们组展示需要这个tag，但是他们落库不在我们这边，于是就将这部分有tag的域名推送给我们，kafka消息里面传的是这个domain，但是具体的标签信息需要我们去请求grpc获取。</li>
<li>解决方案：对于这部分工作我首先是给entity新增了关于域名分类的字段，然后写了一个kafka listener批量消费，grpc接口能够一次传50个域名然后返回50个对应的行业信息。</li>
<li>遇到问题：由于grpc限流以及有可能域名查不到，会造成消息丢失。他那边grpc接口设置是1秒一次，因此我要保证他那边报错了消息重新消费。</li>
<li>解决问题：两个set，一个全局set一个失败set，错误可能发生在kafka消费的时候、拿着所有50条去请求rpc接口的时候、rpc接口报错或者没有数据的时候、es更新的时候：<br>（1）kafka消费报错，这里是手动ack的，所以一旦没有消费成功offset也没偏移，一般不会出现这种情况。<br>（2）拿着50条数据请求rpc接口的时候：在消息消费的时候就组装了这两个set，如果这里出现问题，也能保证这50条不提交<br>（3）rpc接口报错或者没有数据的时候：例如限流了，此时也可以返回这50条；但如果返回有效需要清空这个失败set，按照实际他返回的数据再去组装，因为有可能这个域名他就是没有数据，允许一部分这种差异。<br>（4）es落库一条从这个失败set里面移除一条。<br>最终效果是推送了900w条数据，根据新增的这个recommend字段exist查询已落库数量，成功率接近100%，分析了一些差错case，原因基本上是动态问题，原本推送的某些域名后续调整他把字段删除了，因此rpc接口请求不到。</li>
</ol>
<h3 id="数据双向同步链路-推送"><a href="#数据双向同步链路-推送" class="headerlink" title="数据双向同步链路-推送"></a>数据双向同步链路-推送</h3><ol>
<li>目的：我们数据组每天都会搜集域名，算法组需要这些增量数据，因此需要一个topic每天定时通过kafka发送新增域名</li>
<li>解决方案：xxljob设置每天凌晨推送新增domain数据，根据createTime来看，然后深度分页用scrollSearch解决</li>
<li>遇到问题：他这边没有createTime，只有updateTime，这就可能导致重复发送了，因此需要一个发送的tag，与mt商量后同意这种做法了</li>
<li>解决问题：发送的时候同时给数据新增一个字段flag，查询的时候去看有没有这个字段，有并且又是昨天的就发送。</li>
</ol>
<h3 id="订阅更新任务"><a href="#订阅更新任务" class="headerlink" title="订阅更新任务"></a>订阅更新任务</h3><p>原本逻辑：每周每个账号订阅的公司消息进行处理和监听；<br>后来逻辑：增加一个watchTime字段，如果用户在这一周查看过这个订阅更新界面就刷新。<br>改造方法：查询接口crud这个字段，一天watchtime只更新一次。然后xxljob里面的执行器加一个这个过滤即可，然后将这些作为一个消息发送给kafka</p>
<p>kafka消费者拿到这些id去数据库找对应的公司，将订阅公司表项和公司实体项（从es来的，如果前者有companyId就直接查询，如果没有就需要根据名字和地区来查询并保存）作为参数传分别分析facebook信息，facebook提及信息，海关信息，联系人信息，开了一个线程池并行处理这些。<br>原来这块是顺序的，因为本就是离线任务，触发的频率也不高，后续改成了线程池，用了异步编排，以便后续扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>,</span><br><span class="line">            <span class="number">10</span>, <span class="number">60</span> * <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">2000</span>), COLLECTMONITORCOMPONENT_SERVICE_THREAD_FACTORY, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>




    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/10/31/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8C%BA%E5%9D%97%E9%93%BE/">虚拟线程与区块链</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-10-31
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h1><p>虚拟线程是jdk19提出来的预览特性，jdk21转正。在以往的一对一线程模型中，虽然将进程划分为了线程，但是线程的粒度还是太大了，一个线程占1m，在高并发动不动几十万qps下，内存都不一定打的住。利用粒度更细的协程，可以将这部分开销继续缩小。</p>
<h2 id="虚拟线程优点"><a href="#虚拟线程优点" class="headerlink" title="虚拟线程优点"></a>虚拟线程优点</h2><ol>
<li>占据资源少，切换开销小：虚拟线程是一种用户级线程（绿色线程），不需要操作系统管理而是jvm管理。切换开销更小，可能只涉及jvm的堆空间。</li>
<li>增大cpu的吞吐率，适合io密集型任务：在经典的线程模型中，线程在io时会让出cpu。如果每个线程都要io那么cpu的利用率就很低了，会导致资源耗尽的同时硬件资源没有充分利用。但是虚拟线程是运行在平台线程上的，一个虚拟线程io了可以切到另一个虚拟线程，但是平台线程是不会释放的。这样可以用粒度更低的开销更高效的利用线程资源。</li>
<li>异步改同步，适合阻塞式io：io多路复用是通过一个线程来监听多个socket的状态，通过大量的异步回调实现，机制较为复杂；虚拟线程跟它解决的问题是一致的，都是解决如何增大并发量；但是虚拟线程不需要进行如此复杂的异步回调，用同步操作即可，如果一个线程在io阻塞，jvm无非就是把平台线程的资源切到另一个虚拟线程，免去了复杂的回调。</li>
<li>更灵活：有个例子我觉得很形象。传统的线程模型可以理解为一排固定死的插座，虚拟线程模型就是插座连接的插排。你要修改插座是需要改墙体改布线的，对应os和cpu的关系，而且还存在就算插排插满了但是功率还上不去的现象；但是如果用虚拟线程也就是插排，你想要多点接口就换个更大的插排，这样你的功率也上去了，对电力的利用率也很高。</li>
</ol>
<h2 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select&#x2F;poll&#x2F;epoll"></a>select&#x2F;poll&#x2F;epoll</h2><ol>
<li>select: 每一个socket对应一个fd（文件描述符），用户态给内核态监听，最多长度1024，内核态通过循环的方式监听，一旦有io准备就绪就改变fd状态，然后传输给用户态的时候应用进程还需要遍历一边。也就是说既有长度限制，有需要遍历两次，效率较低。</li>
<li>poll：用链表改变了1024这个数字，其余没区别。还是改变状态让用户态自己去遍历。</li>
<li>epoll：将socket的文件描述符通过红黑树组织起来，查询效率从on变为ologn，此外将循环遍历变成事件回调，有复杂的事件注册函数。触发机制有水平触发和垂直触发，一旦回调函数说socket准备就绪，就把他放在一个队列里面等待返回用户态，水平触发是只要没读完就一直提醒用户态来读，垂直触发是只提醒一次，但是一次需要全部读完。</li>
</ol>
<h2 id="java虚拟线程和go的gmp协程模型"><a href="#java虚拟线程和go的gmp协程模型" class="headerlink" title="java虚拟线程和go的gmp协程模型"></a>java虚拟线程和go的gmp协程模型</h2><h3 id="gmp模型"><a href="#gmp模型" class="headerlink" title="gmp模型"></a>gmp模型</h3><ol>
<li>g是goroutine，每次在调用go func的时候就会产生一个g，也可以理解为协程控制块；m是机器线程，对应了一个真实的被操作系统调度的线程；p是逻辑处理器，必须要一个g通过p绑定到m才可以运行，相当于一个上下文填充器。</li>
<li>有两个队列：局部运行队列LRQ，每一个p都有一个这个队列，放等待该p作为中介给m运行的g；全局运行队列GRQ，分配尚未给LRQ的m</li>
<li>gmp模型是通过调度的方式把g调度给线程，底层运行的还是线程，是一个M对N模型，这点与java是不同的，java的虚拟线程是通过jvm调度的，运行在平台线程上，而不是哪里线程空了就用哪个线程的资源。</li>
<li>交接机制：如果一个m上的g在等待io，这个时候中介p挂到别的空闲m上让自己队列里面g使用。使得阻塞不会影响整体的调度。</li>
<li>窃取机制：每个线程都是工贼，没有任务就要去别的LRQ里面偷，或者去GRQ中偷。<br><img src="/../img/golang/gmp/img.png"></li>
</ol>
<h3 id="虚拟线程调度模型"><a href="#虚拟线程调度模型" class="headerlink" title="虚拟线程调度模型"></a>虚拟线程调度模型</h3><ol>
<li>Java 的虚拟线程由 Continuation（保存&#x2F;恢复执行栈）+ Scheduler（Executor） 实现：虚拟线程在运行时被 mount（挂载）到一个 carrier（承载，平台）线程 上执行；遇阻塞时会 yield（保存 continuation 并释放 carrier），阻塞完成或 unpark 时将 continuation 重新提交给 scheduler 以被某个 carrier 线程恢复执行。这个逻辑以 java.lang.VirtualThread + JVM&#x2F;HotSpot 的 continuation 支持 + JDK core libs 的调度器协作实现。</li>
<li>虚拟线程也支持交接和窃取，这点是gmp学的</li>
<li>注意虚拟线程使用synchronized会将虚拟线程pin住，因为这里synchronized是监视器锁，锁住的是线程，如果在虚拟线程用这个会把平台线程锁住，无法参与调度。一般并发低没事，高了就会将虚拟线程退化为平台线程。因此要控制同步操作使用基于jdk的reentrantlock好一点。<br><img src="/../img/golang/gmp/img_1.png"></li>
</ol>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/10/16/%E8%BD%AF%E8%80%83-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/">软考-基础部分</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-10-16
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="系统架构设计"><a href="#系统架构设计" class="headerlink" title="系统架构设计"></a>系统架构设计</h1><h2 id="系统架构设计概述"><a href="#系统架构设计概述" class="headerlink" title="系统架构设计概述"></a>系统架构设计概述</h2><ol>
<li>软件架构设计（Software Architecture）解决了需求分析和设计阶段之间的鸿沟，是需求分析与设计阶段的过渡阶段。一个好的系统架构，能够使得系统在面对灾难性错误时不会产生严重的故障。</li>
<li>软件架构就是<strong>需求分配</strong>，将满足需求的职责分配到对应的组件上。</li>
<li>软件架构是软件在结构、行为和属性的高层次抽象。主要由构件的描述、构件之间的联系关系（连接子）、系统继承的模式和一组约束构成。</li>
<li>软件架构不仅规定了系统的组织架构和拓扑结构，还规定了组件与需求之间的映射关系。</li>
<li>软件架构解决的核心问题是软件的复用、质量和维护。</li>
<li>软件架构设计主要有以下三个活动：提出架构模型、进行架构设计、进行架构审核。其中架构设计主要关注软件架构的结构、属性和连接关系，并通过多视图全面描述特定模型的软件架构。</li>
<li>软件架构在设计更改相对容易的阶段，便于技术人员和非技术人员进行交互，从而展现软件的结构、属性和交互关系。</li>
<li>软件架构是可传递和可复用的模型。</li>
</ol>
<h2 id="软件架构和生命周期"><a href="#软件架构和生命周期" class="headerlink" title="软件架构和生命周期"></a>软件架构和生命周期</h2><ol>
<li>需求分析阶段：传统的需求分析阶段主要产出的是问题空间，而软件架构在此阶段产生解空间。主要研究的问题是：如何将需求分析转化为软件架构SA；以及如何进行跟踪（包括正向跟踪和反向跟踪）</li>
<li>设计阶段：主要有三个活动：软件架构的描述、对软件架构进行分析和设计、对产生的设计经验进行总结和复用。其中对SA的描述可以有三个层次：SA的基本描述、体系结构描述语言ADL，SA的多视图。</li>
<li>实现阶段：软件架构的管理，可以使用项目管理工具；软件架构的实现，如何将SA过渡到具体实现，如何将SA的需求分配到对应构件上，可以采用程序设计语言的思想进行设计；软件架构的测试</li>
<li>组装阶段：SA给予了一个更高层次的蓝图，主要研究构件之间如何相互关联，也就是连接子的实现；此外还要解决这些构件之间的失配问题，包括构件的失配、连接子的失配以及结构产生的失配问题。</li>
<li>部署：SA可以为部署提供一个更好的解决方案</li>
<li>后开发阶段：进行软件架构的演化、复用和维护</li>
</ol>
<h2 id="构件"><a href="#构件" class="headerlink" title="构件"></a>构件</h2><ol>
<li>构件是一个可以独立部署并交付的功能单元，外界可以通过其接口进行访问。由多个原子构件构成，原子构件由模块和资源构成。原子构件是部署，版本控制和替换的基本单位，原子构件一般可以独立部署，但是不会独立部署。都是按照一组原子构件家族进行部署。</li>
<li>模块是不带资源的原子构件，一个模块可以包含多个类进行打包。</li>
<li>构件与对象的区别：构件的特征是可以独立部署且独立交付、作为第三方的组装单元，可以由第三方调用、对外隐藏自己状态；对象的特征是可以一个实例单元且有唯一标识、可以有自己的状态、对外进行封装。</li>
<li>构件接口规定了构件之间通信的格式、模式和协议，使得接口之间传递消息更具有规范性和一致性。</li>
<li>面向构件的编程一般要求具有：多态性（可以替换同接口的实现构件）、<strong>模块封装性（更高层次的隐藏）</strong>、独立部署性、安全性</li>
<li>目前市面上的主流构件有以下三类：</li>
</ol>
<ul>
<li>EJB（Enterprise Java Bean）是Sun公司提出的一种在Java平台的企业级构件模型，主要规定了三类构件bean，会话bean，实体bean和消息传递bean。使得企业开发能更加注重业务也就是实现这一些bean，提高工作效率，但是缺点是配置大于约定，配置过于复杂，对程序员要求高且不方便；</li>
<li>COM是微软公司提出的，只能在Windows平台进行开发的构建技术，还衍生出DCOM和COM+的技术</li>
<li>CORBA（Common Object Request Broker Architecture）公共对象请求代理架构，由OMG公司提出主要分为三个层次：ORB对象请求代理，针对异构的对象实现了不同的接口，定义了一条软总线能够将不同的对象转化成对上层统一的公共对象；公共对象基础服务，这一层在得到对象的基础上进行了一系列公共服务的抽象，例如并发控制、事务控制等；最后一层是对外的公共基础服务，此时可以对外暴露接口提供对象访问的服务了。</li>
</ul>
<h1 id="架构设计风格"><a href="#架构设计风格" class="headerlink" title="架构设计风格"></a>架构设计风格</h1><ol>
<li>软件架构设计风格是在特定领域下软件架构设计的惯用模式。主要由软件结构，一个词汇表和一组约束构成。词汇表包含架构中构件和连接件的描述，约束定义了这些组件之间的关系。</li>
<li>软件架构风格反应了在某特定领域下多种架构设计的共有结构和语义特性，能够指导子模块和子系统的有效集成和组成一个更大的系统。研究软件架构风格促进软件复用，能够将该领域已有的架构解决方案迁移到解决新的问题上。</li>
<li>软件复用是研究软件架构的一个核心问题</li>
<li>架构风格种类：数据流、调用-返回、独立构件、仓库、虚拟机</li>
</ol>
<h2 id="数据流风格"><a href="#数据流风格" class="headerlink" title="数据流风格"></a>数据流风格</h2><ol>
<li>批处理风格：构件是一系列顺序排列的计算单元，构件之间通过数据进行连接，每个构件必须由上个构件处理完成之后才能开始处理，数据的传输是完整的。</li>
<li>管道-过滤器风格：每个构件都有输入和输出，构件读取输入的数据流，经过处理得到输出数据流。要求数据流顺序，输入必须是上一个构件产生的输出流，可以把并行。过滤器为构件，管道为连接子。一般出现在早期的编译器软件架构中。</li>
</ol>
<h2 id="调用-返回风格"><a href="#调用-返回风格" class="headerlink" title="调用-返回风格"></a>调用-返回风格</h2><ol>
<li>主函数-子函数风格：单线程模型，将复杂问题分解为可以单独处理的子问题。子函数解决子问题，通过主函数进行调用。函数为构件，相互调用为连接子。</li>
<li>面向对象风格：对象即为构件，对象之间的相互作用，例如函数之间的方法调用和过程调用为连接子。</li>
<li>层次架构：构建为每一个层次，连接子为每个层次之间的调用关系。每一层都进行封装，为上一层提供接口，同时使用下一层的服务。修改层次时只会影响相邻的两层。这样的优点是：将一个复杂问题分解为若干的子问题；越靠近底层越抽象；可复用。缺点是：调用无法跨层，效率底；也不一定所有的系统都能划分为层次结构。</li>
</ol>
<h2 id="独立构件风格"><a href="#独立构件风格" class="headerlink" title="独立构件风格"></a>独立构件风格</h2><ol>
<li>进程通信：命名进程是构件，进程之间相互作用为连接子。一般有三种调用方式：点对点、同步&#x2F;异步方式，rpc</li>
<li>隐式调用（事件驱动）：构件不直接调用过程，而是通过触发或者广播一到多个事件。构件的过程可以由多个触发源进行定义，当构件接收到触发，就会使用已经定义好的函数过程进行调用，从而达到隐式和解耦的功能。这样的优点是增大了软件的复用性，缺点是放弃了软件调用过程的控制权。</li>
</ol>
<h2 id="虚拟机风格"><a href="#虚拟机风格" class="headerlink" title="虚拟机风格"></a>虚拟机风格</h2><ol>
<li>解释器风格：由解释引擎，存放被解释程序的缓存区，存储解释引擎解释状态的数据结构和程序解释执行的具体位置的存储器构成。优点是规则可以自定义，缺点是慢</li>
<li>基于规则的系统：规则集，规则解释器，规则选择器，工作内存。一般用在ai和dss</li>
</ol>
<h2 id="数据风格"><a href="#数据风格" class="headerlink" title="数据风格"></a>数据风格</h2><ol>
<li>数据库风格：两个构件，数据库和多个独立的数据处理单元</li>
<li>黑板风格：知识源，黑板，控制。多个独立的知识处理单元，可以操作黑板进行演算。黑板是一个集中式数据库，可以通过知识源进行修改。一般适用于嵌入式系统、语音识别系统等复杂的没有固定解的系统</li>
<li>超文本风格：基于网络的</li>
</ol>
<h1 id="层次架构风格"><a href="#层次架构风格" class="headerlink" title="层次架构风格"></a>层次架构风格</h1><ol>
<li>两层C&#x2F;S：表示层和数据层，表示层也可以存储数据，还要保证一致性，现已不用</li>
<li>三层C&#x2F;S：表示层、功能层和数据层，表示层仅作展示。优点：管理更清晰；可以并行开发；可以选择适应的环境和开发平台；保持了逻辑独立性</li>
<li>三层B&#x2F;S：客户端变成浏览器，访问慢了，安全性也不强</li>
<li>富互联网应用：小程序，看上去没有客户端，但是通过高速网络现场搭建，因此综合了B和C的优点</li>
<li>MVC架构：模型、控制、视图。模型直接与视图交互，不安全</li>
<li>MVP架构：模型、表示、视图。切断了模型与视图的直接交互，更安全</li>
</ol>
<h1 id="特定领域软件架构"><a href="#特定领域软件架构" class="headerlink" title="特定领域软件架构"></a>特定领域软件架构</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>特定领域软件架构DSSA（Domain Specific Software Architecture）是一组在特定领域下的软件开发构件集合，是一组在特定领域下获取系统的参考结构，参考需求和领域模型的开发环境，目标就是生成一个或多个领域应用。</li>
<li>水平域和垂直域</li>
<li>三个基本活动：领域架构分析：目标是获取领域模型，找领域专家来定义领域范围和定义领域特定元素；领域架构设计：目标是获取DSSA；领域架构实现：软件架构重用</li>
<li>四个人员：领域专家、领域分析专家、领域设计专家、领域实现专家</li>
<li>五个过程：定义领域范围；定义领域特有的元素；定义领域特有的设计和约束；定义领域模型和实现；搜集并开发可重用元素</li>
<li>四个特征：有明确的问题域和解决域；适当程度的抽象；有可重用元素；在领域内有普遍性</li>
<li>三个开发环境和五个产出：领域开发环境、特定领域下的应用开发环境，应用实际环境。产出：领域结构，领域需求，架构，开发工具，领域模型。</li>
</ol>
<h1 id="基于架构的软件开发方法"><a href="#基于架构的软件开发方法" class="headerlink" title="基于架构的软件开发方法"></a>基于架构的软件开发方法</h1><ol>
<li>ABSD（Architecture Based Software Development）是由架构驱动，强调由软件业务，质量和功能需求指导软件架构设计。用视角和视图来描述软件的软件架构，以用例和质量属性场景来描述软件的需求。</li>
<li>使用ABSD方法可以在软件模型定义明确之后立刻进行设计</li>
<li>三个基础：功能的分解，需求分解到对应组件；软件架构风格；可重用的组件，软件模板</li>
<li>六个阶段：架构需求、架构设计、架构文档化、架构复审、架构实现、架构演化</li>
<li>架构需求三步：定义类图，类进行归类，产生包</li>
<li>架构设计五步：提出架构模型，需求切分，构件之间联系，产生架构，架构评审</li>
<li>架构文档化两个文档：架构规格说明书，测试架构需求的质量设计说明书</li>
</ol>
<h1 id="软件质量属性"><a href="#软件质量属性" class="headerlink" title="软件质量属性"></a>软件质量属性</h1><ol>
<li>质量属性分为开发时和运行时</li>
<li>八个质量属性和提升方法：<ul>
<li>性能：优先级队列，并发，增加计算资源，减少开销</li>
<li>可用性&#x2F;可靠性：容错容灾，心跳,ping\echo，选举</li>
<li>安全性：入侵检测，用户认证，用户权限控制，追踪审计</li>
<li>可修改性</li>
<li>互操作性</li>
<li>功能性</li>
<li>可变性</li>
</ul>
</li>
<li>质量属性场景六个要素：刺激源，刺激，场景，制品，响应，响应度量</li>
<li>敏感点：为了实现某种特定的质量属性，一个或多个构件所具有的特性</li>
<li>权衡点：影响多个质量属性的决策点，是多个质量属性的敏感点。</li>
</ol>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/04/13/%E6%9D%82%E8%B0%88-%E4%B8%8B%E4%B8%80%E6%AD%A5%E7%9A%84%E6%96%B9%E5%90%91/">杂谈-下一步的方向</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-04-13
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <p>立个flag，我需要在9月份之前完成这些事情：</p>
<ol>
<li>论文idea和实验：学习pytorch和图神经网络，可能还得学一些信号处理。（ddl8月份）</li>
<li>i茅台复现：主体自己实现一下，tidb可以先不用，用sharding-jdbc分片即可（ddl5月份）</li>
<li>go语言相关：做一个轮子类项目（分布式kv或者MIT6.多少多少的raft），以及一个业务类项目（im即时通讯或者流媒体），这部分其实看情况，也不是一定需要转go（ddl6月份）</li>
<li>大模型相关：复现gpt2（ddl5月份），继续学习rag的相关工程，主要放在并发上（ddl8月份）</li>
<li>unity：不是主要工作，只给五一假期几天去尝试一下</li>
</ol>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/03/22/%E8%BD%ACgo%E8%AE%A1%E5%88%92day1-go%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">ProjectMygo!!!!!-go的基本语法</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-03-22
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>实习了一段时间深感java已经不太行了，转go才是出路</p>
</blockquote>
<p><img src="/../img/golang/learn/img.png" alt="go"></p>
<h1 id="变量，结构与函数"><a href="#变量，结构与函数" class="headerlink" title="变量，结构与函数"></a>变量，结构与函数</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>与java不同，go可以不显示声明变量数据类型。一般来说有：</p>
<ul>
<li>整数型int,int8,int16,int32,int64,无符号整型uint,uint8,uint16,uint32,uint64</li>
<li>浮点型：float32,float64,相当于单精度浮点型float和双精度浮点型double</li>
<li>布尔：true和false，值得一提的是bool赋初始值的时候默认false</li>
<li>字符串：string直接就是一个数据类型了，还有一个rune，后续再去了解</li>
</ul>
<p>很重要的一点是go语言的变量声明了就必须得用，而且最后不用加分号。下面是声明数据类型的例子，有:&#x3D;可以代替var进行类型推断，可以同时推断多个类型（但我觉得还是显示声明类型比较好，否则一个函数返回来怎么判断类型）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age_1 <span class="type">uint8</span> = <span class="number">31</span></span><br><span class="line"><span class="keyword">var</span> age_2 = <span class="number">32</span></span><br><span class="line">age_3 := <span class="number">33</span></span><br><span class="line">fmt.Println(age_1, age_2, age_3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age_4, age_5, age_6 <span class="type">int</span> = <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span></span><br><span class="line">fmt.Println(age_4, age_5, age_6)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name_1, age_7 = <span class="string">&quot;Tom&quot;</span>, <span class="number">30</span></span><br><span class="line">fmt.Println(name_1, age_7)</span><br><span class="line"></span><br><span class="line">name_2, is_boy, height := <span class="string">&quot;Jay&quot;</span>, <span class="literal">true</span>, <span class="number">180.66</span></span><br><span class="line">fmt.Println(name_2, is_boy, height)</span><br></pre></td></tr></table></figure>

<p>常量也是类似，可以进行类型推断，但是必须赋初始值，且一旦定义了就不能改变了，类似java中的private static final int &#x3D; 1;这种</p>
<h2 id="函数与判断结构"><a href="#函数与判断结构" class="headerlink" title="函数与判断结构"></a>函数与判断结构</h2><p>go的函数与主流编程语言类似，但是估计不分static和非静态，也是给出参数列表和返回值。但是这里可以返回多个变量，这一点应该会比java好</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> numerator <span class="type">int</span> = <span class="number">11</span></span><br><span class="line">	<span class="keyword">var</span> denominator <span class="type">int</span> = <span class="number">2</span></span><br><span class="line">	<span class="keyword">var</span> result, remainder <span class="type">int</span> = intDivision(numerator, denominator)</span><br><span class="line">	fmt.Println(result, remainder)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intDivision</span><span class="params">(num1, num2 <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> result <span class="type">int</span> = num1 / num2</span><br><span class="line">	<span class="keyword">var</span> remainder <span class="type">int</span> = num1 % num2</span><br><span class="line">	<span class="keyword">return</span> result, remainder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的异常处理，与java中try-catch的思想不同，函数在返回的时候也会给一个error返回值，外部调用通过error是否为nil来判断函数执行是否出错。这是一个广泛使用的设计思想，后续可能需要遵守。</p>
<p>例如这里的除数为0的例子，当除数为0相当于要抛出异常，用errors包下的一个函数throw new RunTimeException()，再在主函数去判断这个error是否为空，为空说明没有抛出异常。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> numerator <span class="type">int</span> = <span class="number">11</span></span><br><span class="line">	<span class="keyword">var</span> denominator <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">	result, remainder, err := intDivision(numerator, denominator)</span><br><span class="line">	<span class="comment">//执行正常</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(result, remainder)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intDivision</span><span class="params">(num1, num2 <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> num2 == <span class="number">0</span> &#123;</span><br><span class="line">		err = errors.New(<span class="string">&quot;num1 is zero&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> result <span class="type">int</span> = num1 / num2</span><br><span class="line">	<span class="keyword">var</span> remainder <span class="type">int</span> = num1 % num2</span><br><span class="line">	<span class="keyword">return</span> result, remainder, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后提一下go的判断结构，if后面的括号必须贴着同一行，else的哪一行必须写成”} else {“，否则编译器会报错，此外switch语句不需要写break了</p>
<h1 id="数组，切片和哈希表"><a href="#数组，切片和哈希表" class="headerlink" title="数组，切片和哈希表"></a>数组，切片和哈希表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>go中的数组跟java的数组很像，但是go的数组可以操作指针。数组的大小在声明的时候就已经固定，如果想用跟ArrayList那样的动态数组，请使用slice切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intArr [<span class="number">10</span>]<span class="type">int32</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intArr); i++ &#123;</span><br><span class="line">		intArr[i] = <span class="type">int32</span>(i + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//左闭右开，这个就是下标为456的三个元素</span></span><br><span class="line">	fmt.Println(intArr[<span class="number">4</span>:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intArr); i++ &#123;</span><br><span class="line">		fmt.Println(&amp;intArr[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这里输出结果是连续的4B，说明经典数组是连续分布的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是这里数组如果传入的是形式变量，需要传地址，跟c语言一样，否则就只会改变形参</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	withAddress(&amp;arr)</span><br><span class="line">	fmt.Println(arr)<span class="comment">//[1 20 3 4 5]</span></span><br><span class="line">	noAddress(arr)</span><br><span class="line">	fmt.Println(arr)<span class="comment">//[1 20 3 4 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withAddress</span><span class="params">(a *[5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	a[<span class="number">1</span>] = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noAddress</span><span class="params">(a [5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	a[<span class="number">3</span>] = <span class="number">20</span></span><br><span class="line">	fmt.Println(a)<span class="comment">//[1 20 3 20 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切片slice"><a href="#切片slice" class="headerlink" title="切片slice"></a>切片slice</h2><p>基本上跟ArrayList的机制一样，长度和容量，如果到了设定阈值就会动态扩容。如果能够预估业务数据量，在构造slice的时候直接指定容量可以免去动态扩容的开销。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sliceDynamic()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceStatic</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> slice []<span class="type">int32</span> = []<span class="type">int32</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="comment">//length is 3, with capacity is 3</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;length is %v, with capacity is %v\n&quot;</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">	slice = <span class="built_in">append</span>(slice, <span class="number">4</span>)</span><br><span class="line">	<span class="comment">//length is 4, with capacity is 6</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;length is %v, with capacity is %v\n&quot;</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">	fmt.Println(slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceDynamic</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//可以指定构造长度和容量，这里构造了一个长度为3，容量为20的slice</span></span><br><span class="line">	<span class="keyword">var</span> intSlice []<span class="type">int32</span> = <span class="built_in">make</span>([]<span class="type">int32</span>, <span class="number">3</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;length is %v, with capacity is %v\n&quot;</span>, <span class="built_in">len</span>(intSlice), <span class="built_in">cap</span>(intSlice))</span><br><span class="line">	<span class="comment">//前三个元素是初始化了的，后面没有</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intSlice); i++ &#123;</span><br><span class="line">		fmt.Println(intSlice[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//就跟ArrayList一样，如果业务能够预估动态数组的长度，最好还是构造的时候就提前设定好</span></span><br><span class="line">	<span class="comment">//否则会频繁进行扩容，影响效率</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取数逻辑。左闭右开，跟java中subString类似</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicePartition</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sli := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>, <span class="built_in">len</span>(sli), <span class="built_in">cap</span>(sli), sli)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[1] ==&quot;</span>, sli[<span class="number">1</span>])</span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[:] ==&quot;</span>, sli[:])</span><br><span class="line">	<span class="comment">//sli[1]-&gt;sli[len-1]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[1:] ==&quot;</span>, sli[<span class="number">1</span>:])</span><br><span class="line">	<span class="comment">//sli[0]-&gt;sli[4-1]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[:4] ==&quot;</span>, sli[:<span class="number">4</span>])</span><br><span class="line">	<span class="comment">//sli[0]-&gt;sli[3-1]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[0:3] ==&quot;</span>, sli[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>, <span class="built_in">len</span>(sli[<span class="number">0</span>:<span class="number">3</span>]), <span class="built_in">cap</span>(sli[<span class="number">0</span>:<span class="number">3</span>]), sli[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>go语言中没有while循环（反正我也没经常用），对于slice和map需要特别注意，range关键字会在遍历这两个数据结构的时候进行处理。例如slice通过range关键字的时候会有index和value两个值，不需要index则直接”_”，跟python相似；同理map会遍历出key和value</p>
<blockquote>
<p>这里就顺带把map提一下，map[key]value，这样的结构，查询一个元素直接括号里面找，注意找不到也会返回0这个默认值，所以以后用到的时候可能需要判断</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceWithClass</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> teachers []Teacher = <span class="built_in">make</span>([]Teacher, <span class="number">0</span>)</span><br><span class="line">	teachers = <span class="built_in">append</span>(teachers, Teacher&#123;<span class="string">&quot;yangyifan&quot;</span>, <span class="number">12</span>&#125;)</span><br><span class="line">	fmt.Println(teachers)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> teacherMap <span class="keyword">map</span>[<span class="type">string</span>]Teacher = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Teacher)</span><br><span class="line">	teacherMap[<span class="string">&quot;yangyifan&quot;</span>] = Teacher&#123;<span class="string">&quot;yangyifan&quot;</span>, <span class="number">12</span>&#125;</span><br><span class="line">	fmt.Println(teacherMap[<span class="string">&quot;yangyifan&quot;</span>])</span><br><span class="line">	teacherMap[<span class="string">&quot;xuxuanyan&quot;</span>] = Teacher&#123;<span class="string">&quot;xuxuanyan&quot;</span>, <span class="number">12</span>&#125;</span><br><span class="line">	fmt.Println(teacherMap[<span class="string">&quot;xuxuanyan&quot;</span>])</span><br><span class="line">	<span class="built_in">delete</span>(teacherMap, <span class="string">&quot;xuxuanyan&quot;</span>)</span><br><span class="line">	fmt.Println(teacherMap[<span class="string">&quot;xuxuanyan&quot;</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历数组的时候返回两个值，一个是index一个是值</span></span><br><span class="line">	<span class="comment">//不需要的就直接_</span></span><br><span class="line">	<span class="keyword">for</span> _, teacher := <span class="keyword">range</span> teachers &#123;</span><br><span class="line">		fmt.Println(teacher)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历map的时候每次都会得到两个值，一个是key一个是value</span></span><br><span class="line">	<span class="comment">//这里只希望返回所有的value前面的key就用_代替</span></span><br><span class="line">	<span class="keyword">for</span> _, teacher := <span class="keyword">range</span> teacherMap &#123;</span><br><span class="line">		fmt.Println(teacher)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="string与rune"><a href="#string与rune" class="headerlink" title="string与rune"></a>string与rune</h2><p>在go中string的底层是一个字节数组，采用utf8编码，由于utf8是不固定长度的，一般来说汉字都会占3B。所以直接去用len一个string数组长度返回的是字节数量，有两种遍历方式，一种是直接遍历len，这样会返回每一个未解码的utf8字节，比如一个汉字“大”，占三位，用普通遍历就会返回这三个字节的初始值；但是如果用range关键字，他会帮我们做一些处理，把这三个字节解码拼成一块，就会返回真实的字符，但这样前面的index仍然不准确。</p>
<p>如果采用rune就是我们直觉上的遍历字符数组了，例子如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//stringByte()</span></span><br><span class="line">	runeSlice()</span><br><span class="line">	stringBuilder()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringByte</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str1 = <span class="string">&quot;大连理工大学&quot;</span></span><br><span class="line">	char := str1[<span class="number">0</span>]</span><br><span class="line">	fmt.Println(char)</span><br><span class="line">	<span class="comment">//大连理工大学 has 18 character</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v has %v character\n&quot;</span>, str1, <span class="built_in">len</span>(str1))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//index: 0, char:å</span></span><br><span class="line">	<span class="comment">//index: 1, char:¤</span></span><br><span class="line">	<span class="comment">//index: 2, char:§</span></span><br><span class="line">	<span class="comment">//index: 3, char:è</span></span><br><span class="line">	<span class="comment">//index: 4, char:¿</span></span><br><span class="line">	<span class="comment">//index: 5, char:</span></span><br><span class="line">	<span class="comment">//index: 6, char:ç</span></span><br><span class="line">	<span class="comment">//index: 7, char:</span></span><br><span class="line">	<span class="comment">//index: 8, char:</span></span><br><span class="line">	<span class="comment">//index: 9, char:å</span></span><br><span class="line">	<span class="comment">//index: 10, char:·</span></span><br><span class="line">	<span class="comment">//index: 11, char:¥</span></span><br><span class="line">	<span class="comment">//index: 12, char:å</span></span><br><span class="line">	<span class="comment">//index: 13, char:¤</span></span><br><span class="line">	<span class="comment">//index: 14, char:§</span></span><br><span class="line">	<span class="comment">//index: 15, char:å</span></span><br><span class="line">	<span class="comment">//index: 16, char:­</span></span><br><span class="line">	<span class="comment">//index: 17, char:¦</span></span><br><span class="line">	<span class="comment">//这里出现乱码的原因是字符串底层是一个字节数组结构，</span></span><br><span class="line">	<span class="comment">//而一个汉字在utf8中占3个字节，他把每一个字节的内容都输出，就不会组成一个完整的汉字</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str1); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;index: %d, char:%c\n&quot;</span>, i, str1[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果用range关键字就会帮我们把字符串的utf8解码</span></span><br><span class="line">	<span class="comment">//index: 0, char:大</span></span><br><span class="line">	<span class="comment">//index: 3, char:连</span></span><br><span class="line">	<span class="comment">//index: 6, char:理</span></span><br><span class="line">	<span class="comment">//index: 9, char:工</span></span><br><span class="line">	<span class="comment">//index: 12, char:大</span></span><br><span class="line">	<span class="comment">//index: 15, char:学</span></span><br><span class="line">	<span class="comment">//这里也可以看到跳过了一些index</span></span><br><span class="line">	<span class="keyword">for</span> index, v := <span class="keyword">range</span> str1 &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;index: %d, char:%c\n&quot;</span>, index, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runeSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> runeSlice = []<span class="type">rune</span>(<span class="string">&quot;大连理工大学&quot;</span>)</span><br><span class="line">	<span class="comment">//index: 0, char:大</span></span><br><span class="line">	<span class="comment">//index: 1, char:连</span></span><br><span class="line">	<span class="comment">//index: 2, char:理</span></span><br><span class="line">	<span class="comment">//index: 3, char:工</span></span><br><span class="line">	<span class="comment">//index: 4, char:大</span></span><br><span class="line">	<span class="comment">//index: 5, char:学</span></span><br><span class="line">	<span class="comment">//这里的index就是顺序的了</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(runeSlice); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;index: %d, char:%c\n&quot;</span>, i, runeSlice[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此外一些string操作都在strings这个包下面，例如stringBuilder和其他的一些字符串操作，需要的时候导入。</p>
<h1 id="结构体与接口"><a href="#结构体与接口" class="headerlink" title="结构体与接口"></a>结构体与接口</h1><p>go应该是一个面向过程的语言，这里采用的还是结构体，但是类似的也有接口和类方法，在实现go中的接口时，不需要有java那种implements，编译器搜索所有有该方法签名的结构体自动绑定；在实现类方法时，需要在方法名前绑定结构体。例子如下所示，有一个engine接口，两个实现类</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine 接口</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">interface</span> &#123;</span><br><span class="line">	milesLeft() <span class="type">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GasEngine <span class="keyword">struct</span> &#123;</span><br><span class="line">	mpg     <span class="type">uint8</span></span><br><span class="line">	gallons <span class="type">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ge GasEngine)</span></span> milesLeft() <span class="type">uint8</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ge.mpg * ge.gallons</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElectricEngine <span class="keyword">struct</span> &#123;</span><br><span class="line">	mpkwh <span class="type">uint8</span></span><br><span class="line">	kwh   <span class="type">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ee ElectricEngine)</span></span> milesLeft() <span class="type">uint8</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ee.mpkwh * ee.kwh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canMakeIt</span><span class="params">(engine Engine, remainMiles <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> engine.milesLeft() &lt; remainMiles &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> milesLeft <span class="type">uint8</span> = <span class="number">60</span></span><br><span class="line">	<span class="keyword">var</span> ge GasEngine = GasEngine&#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">	fmt.Println(canMakeIt(ge, milesLeft))</span><br><span class="line">	<span class="keyword">var</span> ee ElectricEngine = ElectricEngine&#123;<span class="number">10</span>, <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Println(canMakeIt(ee, milesLeft))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/03/04/%E7%BD%91%E6%98%93KM%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB-%E5%B0%8FP%E8%80%81%E5%B8%88%E6%9C%8D%E5%8A%A1GC%E5%8D%A1%E9%A1%BF%E5%AE%9A%E4%BD%8D%E8%A7%A3%E5%86%B3/">网易KM社区分享-小P老师服务GC卡顿定位解决</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-03-04
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>小P老师作为有道AI大模型的重点服务，稳定性与低延迟至关重要。但随着开学季到来，接口流量增加，服务偶现请求延迟升高和GC卡顿异常重启现象。<br>本文总结上述问题的排查思路及定位过程，相信对遇到内存泄漏、CPU升高、JVM GC异常等问题的小伙伴，有借鉴意义。</p>
</blockquote>
<h1 id="一、背景和现象"><a href="#一、背景和现象" class="headerlink" title="一、背景和现象"></a>一、背景和现象</h1><p>小P老师服务（java服务容器部署、jdk17、G1回收器）核心任务是提供教育场景下的大模型对话式问答。随着开学季到来，流量也逐渐上升，保障服务稳定性是比较重要的任务之一。</p>
<p>大模型对话式问答通常是一个流式过程，模型回答是一段一段输出给用户的，为了观察到整个模型的延时情况，大模型回答完毕的时间(total time)以及大模型每一段回答的时间(interval time)都添加了监控。</p>
<p>近期发现，小P老师服务里子曰大模型interval time的监控总是超时告警，但是子曰大模型自身的interval time监控确实正常的，同时很奇怪的是只有一个或者部分容器pod出问题。</p>
<p>这两个监控有什么区别呢？简单来说一个是A使用B时对B的监控，另外一个是B对自身的监控，所以理论来说他两监控应该基本一致才是符合预期的（抛去网络延时）。</p>
<p>从这一现象看，说明小P老师本身代码逻辑存在耗时情况或者网络有问题。</p>
<p>另外之前小P也出现过类似情况，我们使用了Huggingface去做大模型token计算，这个组件cpu占用率很多，所以按照之前惯例会查看cpu是否够用。<br><img src="/../img/netease/littleP/img.png" alt="img.png"></p>
<p><img src="/../img/netease/littleP/img_1.png" alt="img_1.png"></p>
<p>图1 容器cpu使用图</p>
<p><img src="/../img/netease/littleP/img_2.png" alt="img_2.png"></p>
<p>图2 jvm监控图</p>
<p>于是发现了图1这样的现象，在容器cpu监控图中发现在服务告警期间cpu usages（使用量）和cpu cfs throttled（抢占）有尖刺。同时也是机缘巧合，想看看jvm里cpu使用占用率多少，于是在图2（黄色线是分配的内存、绿色线是使用的内存)发现了比较重要的一个信息，jvm在这期间eden区分配降低，old区使用、分配激增，维持了一段时间后就自行恢复了。于是我便去查看了一段时间内的GC日志</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[2024-10-23T20:23:56.727+0800] GC(77) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[2024-10-23T20:23:56.727+0800] GC(77) Using 1 workers of 1 for evacuation</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) MMU target violated: 201.0ms (200.0ms/201.0ms)</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Pre Evacuate Collection Set: 12.5ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Merge Heap Roots: 56.7ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Evacuate Collection Set: 5334.5ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Post Evacuate Collection Set: 15.4ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Other: 0.5ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Eden regions: 482-&gt;0(63)</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Survivor regions: 17-&gt;13(63)</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Old regions: 32-&gt;32</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Archive regions: 2-&gt;2</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Humongous regions: 473-&gt;456 // 标记1</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Metaspace: 156861K(158080K)-&gt;156861K(158080K) NonClass: 139277K(139840K)-&gt;139277K(139840K) Class: 17583K(18240K)-&gt;17583K(18240K)</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Pause Young (Normal) (G1 Evacuation Pause) 4018M-&gt;2007M(6144M) 5419.626ms // 标记2</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) User=5.08s Sys=0.20s Real=5.42s // 标记3</span><br></pre></td></tr></table></figure>

<p>确实发现了异常的点，标记1可以看出Humongous regions数量非常多且这一次GC并没有回收该区域的内容。(Normal GC是会回收Humongous区域的)</p>
<p>标记2可以看出整个GC耗时大概5.4s，当然从标记3可以更清楚的看出GC耗时，所以我们猜测子曰大模型interval time告警可能和GC耗时过久有关系。</p>
<p>至此我们整合一下问题现象：</p>
<ul>
<li>小P老师服务对子曰大模型的延时监控发生告警，且与子曰大模型自身监控不一致</li>
<li>只有一部分pod有问题</li>
<li>告警期间服务cpu使用率激增</li>
<li>告警期间jvm内存eden区域分配减少，old区域使用、分配激增，一段时间后恢复</li>
</ul>
<p>Humongous regions回收不明显，GC停顿过长</p>
<p>根据上述现象，我们可以判断出服务延时告警时和GC有关系，也就是需要从内存的角度来分析为什么GC会停顿这么久，可以算是一个切入点。</p>
<p>分析内存有一个得力工具<a target="_blank" rel="noopener" href="https://eclipse.dev/mat/">MemeoryAnayzer(MAT)</a>，接下来会先重点介绍一下这个工具，同时也会介绍在jdk17中的G1垃圾回收器。当然如果对此熟悉的可以直接跳过看<a target="_blank" rel="noopener" href="https://km.netease.com/v4/section/tm599/detail/blog/234938#4">定位过程</a>。</p>
<h1 id="二、Garbage-First-G1-垃圾回收器"><a href="#二、Garbage-First-G1-垃圾回收器" class="headerlink" title="二、Garbage-First (G1) 垃圾回收器"></a>二、Garbage-First (G1) 垃圾回收器</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html#GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573">引用文章</a></p>
</blockquote>
<p>Garbage-First (G1) 垃圾收集器针主要对大内存多核的服务，目的是实现应用程序和环境在延迟和吞吐量之间的最佳平衡。</p>
<p>特点：</p>
<ul>
<li>服务堆大小大于10GB。</li>
<li>对象分配和对象移动的速度可能会随着时间的推移而发生很大变化。<blockquote>
<p>Rates of object allocation and promotion that can vary significantly over time.</p>
</blockquote>
</li>
<li>堆中存在大量碎片。</li>
<li>可预测的暂停时间目标不超过几百毫秒，避免长时间的垃圾收集暂停。</li>
</ul>
<h2 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h2><p>G1 将堆分为<strong>年轻代</strong>（young）和<strong>老年代</strong>（gen）。空间回收工作集中在最高效的年轻代上，偶尔也会在老年代进行空间回收。</p>
<p>G1 首先回收最高效区域的空间（即大部分被垃圾填充的区域，因此得名）。</p>
<p>G1 主要通过撤离（evacuation）来回收空间：在选定的内存区域找到存活对象复制到新的内存区域，并在过程中对其进行压缩。撤离完成后，先前的空间可用来重新分配。</p>
<p>G1不是实时收集器。尝试尽可能在设定的暂时时间下完成回收，但对于给定的暂停，不能保证绝对满足。</p>
<h2 id="2-2-堆布局"><a href="#2-2-堆布局" class="headerlink" title="2.2 堆布局"></a>2.2 堆布局</h2><p><img src="/../img/netease/littleP/img_3.png" alt="img_3.png"></p>
<p>图3 G1垃圾回收器</p>
<p>年轻代包含eden区域（红色）和survivor区域（红色，带“S”）。这些区域内部是连续的，但在G1中这些区域通常以非连续模式排列在内存中。old区域（浅蓝色）构成老生代。对于跨多个区域的对象，会有一个非常大的old区域（浅蓝色，带“H”），叫做Humongous区域 。</p>
<p>应用程序总是分配到年轻代，即eden区域，巨大对象被分配到old区域。</p>
<h2 id="2-3-垃圾回收周期"><a href="#2-3-垃圾回收周期" class="headerlink" title="2.3 垃圾回收周期"></a>2.3 垃圾回收周期</h2><p>G1 收集器在两个阶段之间交替。young-only阶段包括垃圾回收(garbage collections)，这个阶段会逐渐填满当前可用的内存</p>
<p>空间回收阶段是 G1 除了处理年轻代之外，还会逐步回收老生代中的空间。然后，循环从年轻代阶段重新开始。</p>
<p><img src="/../img/netease/littleP/img_4.png" alt="img_4.png"></p>
<p>图4 垃圾回收周期预览</p>
<p>以下列表详细描述了 G1 垃圾收集周期的各个阶段、暂停以及阶段之间的转换：</p>
<ol>
<li><p>仅年轻代阶段（Young-only phase）：此阶段以Normal young collections收集开始，会将对象提升到老年代。当老年代占用率达到某个阈值时，Young-only phase和Space-reclamation phase之间的过渡就开始了。此时，G1 会执行Concurrent Start young collection，而不是Normalyoung collections。</p>
<ul>
<li><p>Concurrent Start：这种类型的收集除了执行常规Normalyoung collections，还启动标记过程。并发标记确定old区域中的是否可以被回收。在收集标记尚未完全完成时，可能会发生Normalyoung collections。</p>
</li>
<li><p>Remark：此这段会完成重新标记。</p>
</li>
<li><p>Cleanup：这个阶段决定是否进行Space-reclamation phase。如果确定进行Space-reclamation phase，那么Young-only phase就会进行一次Prepare Mixed young collection.</p>
</li>
</ul>
</li>
<li><p>空间回收阶段（Space-reclamation phase）：此阶段会进行Mixed collections，除了young区域外，还会撤离old区域中的存活对象。当 G1 确定撤离更多老生代区域不会产生足够的可用空间时，空间回收阶段结束。</p>
</li>
</ol>
<blockquote>
<ol>
<li>Young-only phase: This phase starts with a few Normal young collections that promote objects into the old generation. The transition between the young-only phase and the space-reclamation phase starts when the old generation occupancy reaches a certain threshold, the Initiating Heap Occupancy threshold. At this time, G1 schedules a Concurrent Start young collection instead of a Normal young collection.</li>
</ol>
</blockquote>
<blockquote>
<ul>
<li>Concurrent Start : This type of collection starts the marking process in addition to performing a Normal young collection. Concurrent marking determines all currently reachable (live) objects in the old generation regions to be kept for the following space-reclamation phase. While collection marking hasn’t completely finished, Normal young collections may occur. Marking finishes with two special stop-the-world pauses: Remark and Cleanup.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Remark: This pause finalizes the marking itself, performs global reference processing and class unloading, reclaims completely empty regions and cleans up internal data structures. Between Remark and Cleanup G1 calculates information to later be able to reclaim free space in selected old generation regions concurrently, which will be finalized in the Cleanup pause.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Cleanup: This pause determines whether a space-reclamation phase will actually follow. If a space-reclamation phase follows, the young-only phase completes with a single Prepare Mixed young collection.</li>
</ul>
</blockquote>
<blockquote>
<ol start="2">
<li>Space-reclamation phase: This phase consists of multiple Mixed collections that in addition to young generation regions, also evacuate live objects of sets of old generation regions. The space-reclamation phase ends when G1 determines that evacuating more old generation regions wouldn’t yield enough free space worth the effort.</li>
</ol>
</blockquote>
<p>空间回收后，收集周期将以另一个年轻阶段重新启动。作为兜底，如果应用程序在收集活跃度信息时内存不足，G1 将像其他收集器一样执行就会执行Full</p>
<h2 id="2-4-垃圾回收阶段和回收集"><a href="#2-4-垃圾回收阶段和回收集" class="headerlink" title="2.4 垃圾回收阶段和回收集"></a>2.4 垃圾回收阶段和回收集</h2><blockquote>
<p>garbage Collection Pauses and Collection Set</p>
</blockquote>
<p>G1执行垃圾收集和空间回收是在stop-the-world pauses时间内完成的，存活的对象会从堆的一个区域移动到另一个区域，并且对这些对象的引用也会调整。</p>
<p>对于non-humongous的移动：</p>
<ul>
<li>年轻一代（eden和survivor）的对象被复制到survivor区域或old区域，取决于它们的年龄。</li>
<li>来自old的对象被复制到其他old</li>
</ul>
<p>对于大对象来说，除非被回收不然永远不会被移动。</p>
<p>对于回收集（collection set）：</p>
<ul>
<li>在 Young-Only ，回收集仅由年轻一代的区域以及可能被回收的巨大区域组成。</li>
<li>在空间回收（Space-reclamation）阶段，回收集由年轻代中的区域、包含可能被回收的对象的巨大区域、以及来自收集集合候选区域的一些老生代区域组成。</li>
</ul>
<p>G1 在并发周期（concurrent cycle）内准备回收集候选区域。在Remark pause，G1 选择大量闲置空间的低利用率区域。然后在 Remark 和Cleanup pause之间并发准备这些区域以供以后收集使用。Cleanup pause根据效率对准备的结果进行排序。更高效的区域是说，有更多的空间并且回收的时间更少。mixedcollections会更喜欢这些区域。</p>
<h1 id="三、MemeoryAnayzer-MAT"><a href="#三、MemeoryAnayzer-MAT" class="headerlink" title="三、MemeoryAnayzer(MAT)"></a>三、MemeoryAnayzer(MAT)</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://eclipse.dev/mat/">https://eclipse.dev/mat/</a></p>
</blockquote>
<h2 id="3-1-重要概念"><a href="#3-1-重要概念" class="headerlink" title="3.1 重要概念"></a>3.1 重要概念</h2><h3 id="3-1-1-可达性"><a href="#3-1-1-可达性" class="headerlink" title="3.1.1 可达性"></a>3.1.1 可达性</h3><p><strong>可达</strong></p>
<p>这个对象仍然有地方引用着他</p>
<p><strong>不可达</strong></p>
<p>这个对象没有任何对象被引用</p>
<h3 id="3-1-2-Shallow-与Retained-Heap的区别"><a href="#3-1-2-Shallow-与Retained-Heap的区别" class="headerlink" title="3.1.2 Shallow 与Retained Heap的区别"></a>3.1.2 Shallow 与Retained Heap的区别</h3><p><strong>Shallow</strong> 是一个对象所消耗的内存。对象每个引用需要32或64位（取决于操作系统体系结构），每个Integer需要4字节，每个Long需要8字节，等等。</p>
<blockquote>
<p>Shallow heap is the memory consumed by one object. An object needs 32 or 64 bits (depending on the OS architecture) per reference, 4 bytes per Integer, 8 bytes per Long, etc. Depending on the heap dump format the size may be adjusted (e.g. aligned to 8, etc…) to model better the real consumption of the VM.</p>
</blockquote>
<p>X的<strong>Retained set</strong>表示当X被GC垃圾回收后需要移除的对象列表</p>
<blockquote>
<p><strong>Retained set</strong> of X is the set of objects which would be removed by GC when X is garbage collected.</p>
</blockquote>
<p>X的<strong>Retained heap</strong>是Retained set里所有对象的Shallow大小</p>
<blockquote>
<p><strong>Retained heap</strong> of X is the sum of shallow sizes of all objects in the retained set of X, i.e. memory kept alive by X.</p>
</blockquote>
<p>通俗的来说，<strong>Shallow</strong> 是这个对象的大小，<strong>Retained heap</strong>是这个对象被回收之后内存释放的大小</p>
<p><img src="/../img/netease/littleP/img_5.png" alt="img_5.png"></p>
<p>图5 对象引用图以及Retained Set</p>
<h3 id="3-1-3-Dominator-Tree"><a href="#3-1-3-Dominator-Tree" class="headerlink" title="3.1.3 Dominator Tree"></a>3.1.3 Dominator Tree</h3><p>MAT提供了对象图的Dominator Tree，将对象引用图转化为Dominator Tree能够轻松识别保留内存的最大块以及对象之间的依赖关系，下面是一些定义</p>
<ul>
<li>X <strong>dominates</strong> Y，表示在对象图中，每一个去Y的路径上都需要经过X。</li>
<li>X是Y的<strong>immediate dominator</strong> ，表示X是距离Y最近的支配者</li>
<li><strong>dominator tree</strong> 是由对象图直接构建而来，能够展现一个对象的immediate dominator</li>
</ul>
<p>图6是将对象图（左侧）构建为<strong>dominator tree</strong> （右侧）</p>
<p><img src="/../img/netease/littleP/img_6.png" alt="img_6.png"></p>
<p>图6 对象引用图以及Retained Set</p>
<p>通俗的来说，X dominates Y表示，如果X被回收那么Y一定被回收。但我们常说的引用，如果X引用Y，那么Y是不一定会被回收的，因为Y有可能被Z引用。这就是为什么MAT引入 <strong>Dominator</strong>这个概念。</p>
<h2 id="3-2-常用功能"><a href="#3-2-常用功能" class="headerlink" title="3.2 常用功能"></a>3.2 常用功能</h2><h3 id="3-2-1-Histogram"><a href="#3-2-1-Histogram" class="headerlink" title="3.2.1 Histogram"></a>3.2.1 Histogram</h3><p>Histogram列举出每一个class的对象数量以及他的shallow size和retained size，可以快速找出大的对象类</p>
<p><img src="/../img/netease/littleP/img_7.png" alt="img_7.png"></p>
<p>图7 Histogram列表</p>
<p>默认情况下retained size展示的是估算值，也可通过计算才获取他的准确值。</p>
<p><img src="/../img/netease/littleP/img_11.png" alt="img_11.png"></p>
<p>图8 Histogram计算准确retained size</p>
<p>可以查看对象被谁引用或者他又引用了谁</p>
<p><img src="/../img/netease/littleP/img_10.png" alt="img_10.png"></p>
<p>图9 Histogram查看引用关系</p>
<p><img src="/../img/netease/littleP/img_9.png" alt="img_9.png"></p>
<p>图10 Histogram查看引用关系结果</p>
<p>Histogram默认是通过class是分组的，也可以根据包或者加载器</p>
<p><img src="/../img/netease/littleP/img_8.png" alt="img_8.png"></p>
<p>图11 Histogram通过其他类型分组</p>
<h3 id="3-2-2-Dominator-Tree"><a href="#3-2-2-Dominator-Tree" class="headerlink" title="3.2.2 Dominator Tree"></a>3.2.2 Dominator Tree</h3><p><strong>Dominator tree</strong>展示了在堆中最大的对象列表。X对象的下一级表示，X被回收之后需要被垃圾回收的对象列表。（也就是X直接支配的对象）同样也可以按类加载器、包进行分组。</p>
<blockquote>
<p>The next level of the tree lists those objects that would be garbage collected if all incoming references to the parent node were removed.</p>
</blockquote>
<p><img src="/../img/netease/littleP/img_12.png" alt="img_12.png"></p>
<p>图12 Dominator Tree</p>
<p>以上图为例，占用堆内存最大的是TaskThread的http-no-8080-exec-2线程，其本身大小是Shallow Heap是120字节，Retained Heap是2417669960字节，占用整个堆内存94.90%。图中将AspectJExpressionPointcut展开，表示当AspectJExpressionPointcut被内存回收之后，展开列表里的所有对象都会被回收，也就是他的retained set</p>
<h3 id="3-2-3-Immediate-Dominators"><a href="#3-2-3-Immediate-Dominators" class="headerlink" title="3.2.3 Immediate Dominators"></a>3.2.3 Immediate Dominators</h3><p>可以快速找出当前这组（类&#x2F;对象）的所有immediate dominator（直接支配者）</p>
<p><img src="/../img/netease/littleP/img_13.png" alt="img_13.png"></p>
<p>图13 Histogram找某个类的immediate dominator</p>
<p>下列展现支配Object[]的类列表</p>
<p><img src="/../img/netease/littleP/img_14.png" alt="img_14.png"></p>
<p>图14 Object[]类的immediate dominator</p>
<p>其中所选的那一行表示，TaskThread一共有37个对象，其中支配了133个Object[]，并且TaskThread的本身对象大小(shallow size)是4440bytes，他支配的Object[]是2147491680bytes的大小</p>
<h3 id="3-2-4-Leak-report"><a href="#3-2-4-Leak-report" class="headerlink" title="3.2.4 Leak report"></a>3.2.4 Leak report</h3><p>Leak report会列举出可能存在内存泄漏的点，以及发生的栈信息位置</p>
<p><img src="/../img/netease/littleP/img_15.png" alt="img_15.png"></p>
<p>图15 Leak report</p>
<h1 id="四、定位过程"><a href="#四、定位过程" class="headerlink" title="四、定位过程"></a>四、定位过程</h1><p>根据在第一节所观察到的问题现象，我们从内存角度来分析GC停顿之间为何这么久？按照惯例，通常都会看一下内存中的大对象，因为大对象一般是造成内存出现问题的罪魁祸首，并且大对象也是最容易发现的。</p>
<h2 id="4-1-查看大对象"><a href="#4-1-查看大对象" class="headerlink" title="4.1 查看大对象"></a>4.1 查看大对象</h2><blockquote>
<p>jmap -hsito [pid] | head -n [num]</p>
</blockquote>
<p><img src="/../img/netease/littleP/img_16.png" alt="img_16.png"></p>
<p>图16 小P老师服务某时刻大对象</p>
<p>大部分服务大对象前列就是byte、int等基本类型（不同的jdk版本可能会不同），也看不出什么门道。</p>
<p>通常先重点关注项目自己的包，再看一些引用的包。图16已经圈出了一些比较可疑的对象，但类比了同类稳定服务，第10行对象也是存在且现象一致的，于是就暂时排除他的嫌疑。</p>
<p>接下来就是12、13行这两个对象，他们用来做流式场景下线程之间上下文的自动传递，在github上看有人也提出了使用该组件的<a target="_blank" rel="noopener" href="https://github.com/micrometer-metrics/context-propagation/issues/148">内存问题</a>，我们把他列为可疑对象。</p>
<p>再接着就是20行这个对象，他是之前讲到的<a target="_blank" rel="noopener" href="https://huggingface.co/">Huggingface</a>组件，用来做大模型token计算。这个组件cpu占用率很高（之前性能自测过，图17）。那有没有可能在某个时刻计算量很大导致cpu激增，而容器分配的cpu不够用（而我们也确实发生了cpu抢占的情况），导致长期持有jvm对象而无法回收带来的GC卡顿，所以我也把他列为了可疑对象。</p>
<p>接下来我们来验证猜想。</p>
<p><img src="/../img/netease/littleP/img_17.png" alt="img_17.png"></p>
<p>图17 Huggingface组件性能测试cpu、内存使用情况</p>
<h3 id="4-1-1-验证猜想"><a href="#4-1-1-验证猜想" class="headerlink" title="4.1.1 验证猜想"></a>4.1.1 验证猜想</h3><p>我们将图16中，12、13行对象涉及的组件以及20行对象涉及的组件，分别打开&#x2F;关闭来做性能测试，看 GC和jvm是否有明显变化，但当时并没有发现带来明显的jvm变化以及GC卡顿问题。那么问题可能出现在其他大对象上，这时候就需要把堆内存dump下来做分析了。</p>
<h2 id="4-2-内存dump"><a href="#4-2-内存dump" class="headerlink" title="4.2 内存dump"></a>4.2 内存dump</h2><p>根据我们之前观察的现象，old区域激增，一段时间后回落，这不太符合内存泄漏的现象，可能就是大对象被长期持有无法释放，于是在dump内存时，选择将堆里的对象全部dump而不仅仅是存活的对象。</p>
<blockquote>
<p>jmap -dump:live,format&#x3D;b,file&#x3D;dump.hprof [pid]</p>
</blockquote>
<h2 id="4-3-使用MAT工具分析"><a href="#4-3-使用MAT工具分析" class="headerlink" title="4.3 使用MAT工具分析"></a>4.3 使用MAT工具分析</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://eclipse.dev/mat/">下载地址</a></p>
</blockquote>
<p>注意一般堆文件多大，MAT内存就需要分配多大，修改方式<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45859054/article/details/131096947">参考</a>。</p>
<p>MAT工具通常我们可以使用他从这几个角度分析：</p>
<ul>
<li>堆内存中的大对象有些什么？</li>
<li>这些大对象为什么没被回收？看他的支配者：immediate Dominators，看他的GC root</li>
<li>这些大对象为什么这么大？看他支配了谁：retained set</li>
</ul>
<h3 id="4-3-1-导入堆文件"><a href="#4-3-1-导入堆文件" class="headerlink" title="4.3.1 导入堆文件"></a>4.3.1 导入堆文件</h3><p><img src="/../img/netease/littleP/img_18.png" alt="img_18.png"></p>
<p>图18 堆文件导入示意图</p>
<h3 id="4-3-2-查看大对象"><a href="#4-3-2-查看大对象" class="headerlink" title="4.3.2 查看大对象"></a>4.3.2 查看大对象</h3><p>使用Histogram查看大的对象（类），根据Retained Heap来排序（点击Retained Heap按钮就可以排序）</p>
<p><img src="/../img/netease/littleP/img_19.png" alt="img_19.png"></p>
<p>图19 堆文件大的对象（类）列表</p>
<p>发现最大的类是java.lang.object[]，是一个数组，于是按照刚才思路我们先看他为什么没被回收？就看他的支配者。</p>
<h3 id="4-3-3-查看大对象支配者"><a href="#4-3-3-查看大对象支配者" class="headerlink" title="4.3.3 查看大对象支配者"></a>4.3.3 查看大对象支配者</h3><p>尝试看下这个大对象的支配者，看看是不是因为这个支配者应该被回收但是没被回收。</p>
<p>图20发现java.lang.object[]最大的支配者是TaskThread这个类，一共有37个对象实例，支配了133个java.lang.object[]，TaskThread类本身大小是4440bytes，支配的对象java.lang.object[]大小是2147491680bytes。</p>
<p>其实看到这里已经没有意义了，因为他是处理http请求的线程，是不可能被回收的，但我们看一下这个TaskThread的GC Root ，看是否是被不小心创建出来的而没释放。</p>
<p><img src="/../img/netease/littleP/img_20.png" alt="img_20.png"></p>
<p>图20 java.lang.object[]的支配者</p>
<h3 id="4-3-4-查看GC-root"><a href="#4-3-4-查看GC-root" class="headerlink" title="4.3.4 查看GC root"></a>4.3.4 查看GC root</h3><p>一般来说查看Gc root时都会选择 exclude weak&#x2F;soft references，因为这两个引用肯会被GC掉，这是用来查内存泄漏的，但我们场景是对象是被长时间持有段时间无法回收，而不是一直无法回收。所以这里选择展现了所有的references。</p>
<p><img src="/../img/netease/littleP/img_21.png" alt="img_21.png"></p>
<p>图21 查看TaskThreadGC root示意图</p>
<p>从图22来，TaskThread都是tomcat创建的线程用来处理http请求的，http-nio-8080-exec-2支配了很大的对象，那就是刚才java.lang.object[]，这种被线程支配的对象，大概率是临时变量，也就是方法栈里创建出来的变量，http-nio-8080-exec-2是不可能被回收的。</p>
<p><img src="/../img/netease/littleP/img_22.png" alt="img_22.png"></p>
<p>图22 TaskThreadGC root</p>
<p>但是临时变量的回收，会在方法执行完，对他引用没有了之后进行。因为我们dump某一个时刻的堆栈信息，可能线程没有执行完，没被回收也是正常的。但是在http所有的线程中，只有这个线程持有很大的对象明显是不合理。于是我接着看 java.lang.object[]对象为什么这么大？</p>
<h3 id="4-3-5-查看retained-set"><a href="#4-3-5-查看retained-set" class="headerlink" title="4.3.5 查看retained set"></a>4.3.5 查看retained set</h3><p><img src="/../img/netease/littleP/img_23.png" alt="img_23.png"></p>
<p>图23 查看java.lang.object[]Retained Set示意图</p>
<p>查看java.lang.object[]Retained Set可以看出他支配了哪些对象&#x2F;类，就可以知道他为什么这么大（retained set是包含本身的）</p>
<p><img src="/../img/netease/littleP/img_24.png" alt="img_24.png">图22.png</p>
<p>图24 java.lang.object[]Retained Set</p>
<p>从图24可以看出，在其所有支配的对象中，其本身是最大的，到这里好像陷入了死结。</p>
<p>这个对象被谁支配？是一个线程。这个对象为什么这么大？是因为他本身就很大。</p>
<p>但回想起刚才说的，这个对象被http线程支配，因为线程没有执行完，引用没消失所以一直存在，于是我就想能不能看一下这个线程的栈信息，正好MAT中也有这样的功能。</p>
<h3 id="4-3-6-查看栈信息"><a href="#4-3-6-查看栈信息" class="headerlink" title="4.3.6 查看栈信息"></a>4.3.6 查看栈信息</h3><p><img src="/../img/netease/littleP/img_25.png" alt="img_25.png"></p>
<p>图25 所有线程的栈信息</p>
<p>从图25来看，http-nio-8080-exec-2占用了很大的retained heap，就接着点开来看就是整个线程的堆栈情况（不排序的话默认就是执行路径）</p>
<p><img src="/../img/netease/littleP/img_26.png" alt="img_26.png"></p>
<p>图26 http-nio-8080-exec-2堆栈信息</p>
<p>看堆栈信息，一般来说是从上到下找到首个业务代码进行分析，从图26可以看出从业务代码ChatManagerImpl.java:300处添加一个元素到列表，最后触发了容器扩容，最终导致OutOfMemoryError。并且这个线程在执行copyOf时持有很大的内存大小Max Local Retained Heap（本地变量保留大小），已经定位到业务代码了，接下来就根据业务代码去看看原因。</p>
<h3 id="4-3-7-跟踪业务代码"><a href="#4-3-7-跟踪业务代码" class="headerlink" title="4.3.7 跟踪业务代码"></a>4.3.7 跟踪业务代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ChatInfoDO&gt; <span class="title function_">getChatInfoHistory</span><span class="params">(String userId, String taskId, Long parentChatId,</span></span><br><span class="line"><span class="params">                                           Integer groupLevelCount)</span> <span class="keyword">throws</span> LlmBusinessException &#123;</span><br><span class="line">   <span class="comment">// 根据chat_group_level粗筛（只取最近的chatCount个level）</span></span><br><span class="line">   List&lt;ChatInfoDO&gt; chatInfoDOList = chatInfoDOMapper.selectChatHistory(userId, taskId, parentChatId,</span><br><span class="line">           groupLevelCount);</span><br><span class="line">   <span class="keyword">if</span> (chatInfoDOList == <span class="literal">null</span> || chatInfoDOList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LlmBusinessException</span>(ErrorCode.USER_WRONG_CHAT_HISTORY);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 根据 parentChatId 串起 chatHistory 返回，此时是逆序的</span></span><br><span class="line">   Map&lt;Long, ChatInfoDO&gt; chatIdMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (ChatInfoDO chatInfoDO : chatInfoDOList) &#123;</span><br><span class="line">      chatIdMap.put(chatInfoDO.getChatId(), chatInfoDO);</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;ChatInfoDO&gt; history = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="type">Long</span> <span class="variable">chatId</span> <span class="operator">=</span> parentChatId;</span><br><span class="line">   <span class="comment">// 逆序查找，从最后一条对话chatId开始，继续条件：chatId=当前parentChatChatId（子节点找父节点）</span></span><br><span class="line">   ChatInfoDO chatInfoDO;</span><br><span class="line">   <span class="keyword">while</span> ((chatInfoDO = chatIdMap.get(chatId)) != <span class="literal">null</span>) &#123;</span><br><span class="line">      history.add(chatInfoDO); <span class="comment">// 标记1  问题代码处</span></span><br><span class="line">      chatId = chatInfoDO.getParentChatId();</span><br><span class="line">   &#125;</span><br><span class="line">   Collections.reverse(history);</span><br><span class="line">   <span class="keyword">return</span> history;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析可疑点之前，我先简单描述下这段代码所做的事情。</p>
<p>在小P老师对话场景中，是采用一问一答的形式，例如下方图27所示，蓝色表示用户，淡红色表示系统回答。</p>
<p><img src="/../img/netease/littleP/img_27.png" alt="img_27.png"></p>
<p>图27 大模型对话示意图</p>
<p>为了让模型更好的理解用户问题，通常我们会像图26所示，携带所有的历史消息送给模型。当前业务代码就是找到用户的历史对话然后构建起来提供给模型。</p>
<p><img src="/../img/netease/littleP/img_28.png" alt="img_28.png"></p>
<p>图28 携带历史对话示意</p>
<p>如图29所示，我们给每个消息两个属性id&#x3D;xxx、parendId&#x3D;xxx，这样来呈现一种父子关系，用户输入消息时生成id，并通过传入的parentId&#x3D;3向上寻找消息，找到id&#x3D;3的消息，循环寻找，直到parentId&#x3D;-1</p>
<p><img src="/../img/netease/littleP/img_29.png" alt="img_29.png"></p>
<p>图29 构建历史对话示意图</p>
<p>回过头我们来看业务代码，标记1就是栈信息所示的位置，这处代码其实有一个很明显的风险点while循环构建链表，同时结合我们的对象是一个大数组，那这个while循环就很可疑。结合刚才业务代码逻辑的分析，我当时想到了以下可疑点：</p>
<ul>
<li>一个消息的id和parentId一致发生了循环，导致死循环</li>
<li>chatInfoDOMapper.selectChatHistory()从数据库查出来的数据量很大</li>
</ul>
<p>接着看了数据库查询语句chatInfoDOMapper.selectChatHistory()不可能发生查出很多数据的问题。</p>
<p>那么现在最可疑的就是消息循环了，本来分享到这就结束了。要去查数据库看看有没有id和parentId重复的数据了，但因为当时是和同事们在分享这篇文章，同事们就提出了两个问题。</p>
<ul>
<li>有没有可能是两个消息发生了循环？消息A找到了消息B，消息B又找回了消息A。</li>
<li>MAT可以看这个链表里有啥吗？以及能不能看这个对象的值，不然查库可能会很慢。</li>
</ul>
<p>很显然第一个是很有可能的。 第二个问题因为对MAT还是初次使用所以不太了解，但在同事的引导下，我们尝试看链表里具体的数据是什么样子。</p>
<p>4.3.8 查看栈具体用了哪些对象<br><img src="/../img/netease/littleP/img_30.png" alt="img_30.png"></p>
<p>图30 栈的临时变量</p>
<p>如图30所示，我们继续点击业务代码方法栈点，就可以看到这个方法栈点引用了（注意是引用不是支配）HashMap、ArrayList、ChatInfoDO，因为根据业务代码分析可能是ArrayList膨胀，所以继续点击ArrayList可以看他引用的元素elementData，包括了object[]、ChatInfoDO。这里问题就展现出来了，如图30红框所示，ArrayList奇数位置[1],[3],[5]…都是ChatInfoDO_A，偶数位置[0],[2],[4]…都是ChatInfoDO_B，并且再次点击ChatInfoDO_A和ChatInfoDO_B就可以看到他们的chatId、parentChatId，这时候看到他们确实互为引用了，如图31所示。</p>
<p><img src="/../img/netease/littleP/img_31.png" alt="img_31.png"></p>
<p>图31 互为引用的消息</p>
<p>至此问题原因顺利找到。</p>
<p>后续分析还发现，不仅是两个消息会循环，多个消息也会循环。历史消息构建其实是单链表从尾到头的构建过程，找到头节点就停止，但某个位置产生了环就导致悲剧。所以得出一点建议：之后while的使用一定得注意！！！。</p>
<p>虽然原因找到了，但为什么产生重复的Id呢？我们设计的Id可是唯一的！于是我们又分析了生成Id的代码。</p>
<p>4.4 分析ID重复的原因</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDGeneratorUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">cycleNumber</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环下限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">startNumber</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环上限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">stopNumber</span> <span class="operator">=</span> <span class="number">99999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个当前时间的long类型数字（非线程安全）</span></span><br><span class="line"><span class="comment">     * 理论上每毫秒可生成id 89999 个</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getNextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cycleNumber &lt; stopNumber) &#123;</span><br><span class="line">            cycleNumber++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cycleNumber = startNumber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() + cycleNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为小P老师服务是分布式服务，有多个节点，需要保障消息唯一Id。常见唯一Id方式很多：UUID、雪花等等，但基于我们的考虑并没有使用上边的方式。</p>
<p>当时在设计唯一Id时主要考虑以下几点：</p>
<ul>
<li>具有时间性</li>
<li>生产效率高</li>
<li>符合数字需求<br>于是就通过时间戳来体现时间性，在加一个全局唯一的循环数，这样是不是具有符合上述的要求了？</li>
</ul>
<p>但在大家的分析下发现了这样一个BUG，假如当前时间是10，随机数是10，过了一段时间后当前时间是19，随机数已经发生循环变成了1，这样两个Id是不是都一样变成20了（但概率确实很低！！！）</p>
<p>到此终于真相大白了！</p>
<h1 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h1><p>分析过程其实是坎坷的，总结的时候，已变成已知答案寻找答案的过程，所以看起来会很顺畅。</p>
<p>问题千奇百怪，分析过程也千奇百怪，但总结了一些小经验。</p>
<ul>
<li>监控jvm内存或者可以观察jvm是比较重要的</li>
<li>GC日志也是比较重要的日志</li>
<li>内存问题一般可以从大对象着手，分析对象为什么这么大？为什么没被回收？</li>
<li>MAT的Histogram、Dominator Tree看大对象</li>
<li>MAT的Immediate Dominators看大对象被谁直接支配而没回收</li>
<li>MAT的retained set看大对象支配了哪些，导致他这么大</li>
<li>MAT的线程分析，来分析线程持有对象特别大的情况，分析栈信息</li>
</ul>
<p>当然，在问题处理的过程中，还有一些不可忽视的细节操作，对排查问题至关重要。</p>
<ul>
<li>如何抓取偶现问题的JVM dump现场？</li>
<li>只有内存泄漏才会引起内存使用率升高吗？</li>
<li>如何分析GC日志数据，推断问题原因？</li>
</ul>
<p>基于篇幅有限，本文不再赘述，后续会编写系列KM文章，为大家带来实践中走过的弯路与总结的小技巧。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/03/04/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-%E5%AE%8C%E7%BB%93%E7%AF%87/">网易牛马日志-完结篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-03-04
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>过年以后回来做的东西太杂了，想到哪说哪吧。</p>
</blockquote>
<h2 id="需求12：出海项目搜索功能"><a href="#需求12：出海项目搜索功能" class="headerlink" title="需求12：出海项目搜索功能"></a>需求12：出海项目搜索功能</h2><blockquote>
<p>这个得包装了，好不容易一个可能的高并发C端接口，但是实际上做的很简单。</p>
</blockquote>
<h3 id="搜索V1：实际做的"><a href="#搜索V1：实际做的" class="headerlink" title="搜索V1：实际做的"></a>搜索V1：实际做的</h3><p>数据库直接like就完了，纯纯没有一丝的技术含量。</p>
<h3 id="搜索V2：包装。。。未完待续"><a href="#搜索V2：包装。。。未完待续" class="headerlink" title="搜索V2：包装。。。未完待续"></a>搜索V2：包装。。。未完待续</h3><h2 id="需求13：全球搜数据工程产品图片爬取"><a href="#需求13：全球搜数据工程产品图片爬取" class="headerlink" title="需求13：全球搜数据工程产品图片爬取"></a>需求13：全球搜数据工程产品图片爬取</h2><p>这部分只做了前段部分，用jsoup去解析标签，再getDocumentByClass去找url，图片名称和信息。</p>
<blockquote>
<p>这里也不清楚class会不会随着编译改变，但是测试下来确实是可以的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ExtraResultDTO <span class="title function_">doExtra</span><span class="params">(String domain)</span>&#123;</span><br><span class="line">    <span class="type">ExtraResultDTO</span> <span class="variable">resultDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExtraResultDTO</span>();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> getHtml(domain);</span><br><span class="line">        <span class="keyword">if</span>(html == <span class="literal">null</span> || StringUtils.isBlank(html))&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;doExtra error.html is null&quot;</span>);</span><br><span class="line">            resultDTO.setStatus(<span class="number">101</span>);</span><br><span class="line">            <span class="keyword">return</span> resultDTO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(html.contains(<span class="string">&quot;Our systems have detected unusual traffic from your computer&quot;</span>))&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;doExtra Google Pickpocket Detection Limit&quot;</span>);</span><br><span class="line">            resultDTO.setStatus(<span class="number">102</span>);</span><br><span class="line">            <span class="keyword">return</span> resultDTO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(html);</span><br><span class="line">        List&lt;ImageDTO&gt; images = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Elements</span> <span class="variable">divs</span> <span class="operator">=</span> doc.getElementsByClass(<span class="string">&quot;RntSmf&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element div : divs) &#123;</span><br><span class="line">            <span class="comment">//图片路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">imgUrl</span> <span class="operator">=</span> div.getElementsByTag(<span class="string">&quot;img&quot;</span>).get(<span class="number">0</span>).attr(<span class="string">&quot;src&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> div.getElementsByClass(<span class="string">&quot;qXLe6d x3G5ab&quot;</span>).get(<span class="number">0</span>).text();</span><br><span class="line">            <span class="type">String</span> <span class="variable">jumpUrl</span> <span class="operator">=</span> div.getElementsByClass(<span class="string">&quot;qXLe6d F9iS2e&quot;</span>).get(<span class="number">0</span>).text();</span><br><span class="line">            <span class="type">ImageDTO</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageDTO</span>();</span><br><span class="line">            image.setUrl(imgUrl);</span><br><span class="line">            image.setFormatUrl(imgUrl);</span><br><span class="line">            image.setAlt(desc);</span><br><span class="line">            images.add(image);</span><br><span class="line">        &#125;</span><br><span class="line">        resultDTO.setStatus(<span class="number">200</span>);</span><br><span class="line">        resultDTO.setImages(images);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;doExtra error.&quot;</span>,e.getMessage());</span><br><span class="line">        resultDTO.setStatus(<span class="number">205</span>);</span><br><span class="line">        resultDTO.setErrorMessage(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultDTO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="需求14：全球搜数据工程公司Logo爬取"><a href="#需求14：全球搜数据工程公司Logo爬取" class="headerlink" title="需求14：全球搜数据工程公司Logo爬取"></a>需求14：全球搜数据工程公司Logo爬取</h2><p>比较有挑战性的一整个链路，问题在于es里面logo字段并不是索引，所以不能用exist来查询。主要思路是查询线上有域名的公司，过滤掉有logo字段的，将无logo字段但是有域名的公司通过kafka消费到本地，然后通过爬虫将图片下载下来。</p>
<h3 id="前处理链路："><a href="#前处理链路：" class="headerlink" title="前处理链路："></a>前处理链路：</h3><p>链路：</p>
<ul>
<li>猛犸抽取线上es到hive，这一段全量数据写入hive，大概2600万。</li>
</ul>
<p><img src="/../img/netease/last/img_1.png" alt="img_1.png"></p>
<ul>
<li>然后hive -&gt;hive，通过sql来过滤掉有logo的公司域名，此外由于抽取的域名domain是从一个list里面来的，在变成字符串后有”[“和”]“，需要过滤，最后得到数据量大概1600万。</li>
</ul>
<p><img src="/../img/netease/last/img_2.png" alt="img_2.png"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">insert</span><br><span class="line">  OVERWRITE table qiye_mail_data.logo_extra_offline_domain_v1</span><br><span class="line">select</span><br><span class="line"> REPLACE(SUBSTR(</span><br><span class="line">    domain,</span><br><span class="line">    2,</span><br><span class="line">    LENGTH(domain) -2</span><br><span class="line">  ), &#x27;&quot;&#x27;, &#x27;&#x27;) as domain,</span><br><span class="line">  companyid,</span><br><span class="line"> locationdomain</span><br><span class="line">   from qiye_mail_data.logo_extra_offline_domain where logourl=&#x27;&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后猛犸任务hive-&gt;kafka，测试环境集群做消费，这才正式进入logo图片提取的链路。</li>
</ul>
<h3 id="责任链模式进行公司Logo爬取"><a href="#责任链模式进行公司Logo爬取" class="headerlink" title="责任链模式进行公司Logo爬取"></a>责任链模式进行公司Logo爬取</h3><p>首先是三种找Logo的方法，一般来说Logo都会放在浏览器的ico上，相关链接在<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42836771/article/details/112721772">csdn</a>：</p>
<ul>
<li>通过google某个api拿，这种成功率最高，但是会返回默认图片，后续需要校验md5来过滤。</li>
<li>直接在网站域名后面拼接&#x2F;favicon.ico，成功率不高，因为小公司的网页并不一定有这么规范，其次是可能会返回404的html页面，也会有默认的ico文件，所以要写一个方法过滤html和默认的md5.</li>
<li>爬虫解析，拿到domain的源码，再去解析<head>里面的<link>，然后通过正则表达式去匹配icon，成功率不高，属于是最后的底牌了。</li>
</ul>
<p>另外这里有的都是domain，意思是没有http和https的，所以都需要进行尝试，综上所述，一共得走6个链路，哪个成功了哪个就返回，很适合责任链模式。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 责任链执行</span><br><span class="line">private UploadResultBO handleLogoCrawlAndUploadChain(String domain,String locationDomain) &#123;</span><br><span class="line">    //有locationDomain的情况</span><br><span class="line">    if (StringUtils.isNotEmpty(locationDomain))&#123;</span><br><span class="line">        UploadResultBO googleStrategy = googleStrategy(locationDomain);</span><br><span class="line">        if (StringUtils.isNotBlank(googleStrategy.getUrl()))&#123;</span><br><span class="line">            return googleStrategy;</span><br><span class="line">        &#125;</span><br><span class="line">        UploadResultBO straightStrategy = straightStrategy(locationDomain);</span><br><span class="line">        if (StringUtils.isNotBlank(straightStrategy.getUrl()))&#123;</span><br><span class="line">            return straightStrategy;</span><br><span class="line">        &#125;</span><br><span class="line">        return htmlLinkTagStrategy(locationDomain);</span><br><span class="line">    &#125;</span><br><span class="line">    //无locationDomain或者失效的情况，需拼接http和https尝试</span><br><span class="line">    UploadResultBO googleStrategy = googleStrategy(HTTP_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(googleStrategy.getUrl()))&#123;</span><br><span class="line">        return googleStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO straightStrategy = straightStrategy(HTTP_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(straightStrategy.getUrl()))&#123;</span><br><span class="line">        return straightStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO htmlLinkTagStrategy = htmlLinkTagStrategy(HTTP_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(htmlLinkTagStrategy.getUrl()))&#123;</span><br><span class="line">        return htmlLinkTagStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO googleStrategyHttps = googleStrategy(HTTPS_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(googleStrategyHttps.getUrl()))&#123;</span><br><span class="line">        return googleStrategyHttps;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO straightStrategyHttps = straightStrategy(HTTPS_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(straightStrategyHttps.getUrl()))&#123;</span><br><span class="line">        return straightStrategyHttps;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO htmlLinkTagStrategyHttps = htmlLinkTagStrategy(HTTPS_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(htmlLinkTagStrategyHttps.getUrl()))&#123;</span><br><span class="line">        return htmlLinkTagStrategyHttps;</span><br><span class="line">    &#125;</span><br><span class="line">    return new UploadResultBO(StringUtils.EMPTY, LogoExtraStatusEnum.STRATEGY_FAIL.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上传到nos"><a href="#上传到nos" class="headerlink" title="上传到nos"></a>上传到nos</h3><p>调洋总的接口就完事了，然后将这个链接保存进es，良总那里会有一个同步链路将触发版本更新的数据同步到线上。最终的效果就是测试集群在消费数据，将爬取的logo的nosurl保存进es并更新版本号，最后用同步链路更新到线上。</p>
<h2 id="需求15：全球搜应用工程ai推荐理由总结"><a href="#需求15：全球搜应用工程ai推荐理由总结" class="headerlink" title="需求15：全球搜应用工程ai推荐理由总结"></a>需求15：全球搜应用工程ai推荐理由总结</h2><p>比较简单，就是多线程调用大模型api，由于需要时效性，deepseek要输出思维链所以时效性很差，不适合用在业务里面，所以用gpt。其次开一个线程池来优化并发请求，此外就是prompt优化，很简单的一个需求。</p>
<p><img src="/../img/netease/last/img.png" alt="img.png"></p>
<p>关于提示词，mentor的意思是尽量可读性高，产品词输出中文，看的会比较丝滑，但是在第一版的提示词里面海关数据基本没怎么用，后续就变为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prompt：</span><br><span class="line">根据提供的信息，总结公司的核心产品、主营类目、主要交易产品等信息，并判断分析与关键词XXXXX，XXXx的相关性，给出最终的匹配理由。输出格式：</span><br><span class="line">&quot;匹配理由&quot;:&quot;XXX&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>线程池</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadFactory</span> <span class="variable">MATCH_ANALYZE_LLM_THREAD_FACTORY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;MatchAnalyzeService-llm-pool-%d&quot;</span>).build();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">LLM_REQUEST_EXECUTOR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">20</span>,</span><br><span class="line">        <span class="number">40</span>, <span class="number">60</span> * <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">3000</span>), MATCH_ANALYZE_LLM_THREAD_FACTORY, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure></li>
<li><strong>prompt</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_PROMPT</span> <span class="operator">=</span> <span class="string">&quot;根据提供的信息，总结公司的主营产品、海关交易产品等信息，并判断分析与关键词&#123;0&#125;的相关性，给出最终的匹配理由。输出格式：\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\&quot;匹配理由\&quot;:\&quot;XXX\&quot;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;以下是公司信息：\n&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>动态组装和展示</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MatchAnalyzeResultDTO <span class="title function_">getMatchAnalyze</span><span class="params">(MatchAnalyzeParam globalSearchParam)</span> &#123;</span><br><span class="line"><span class="comment">//参数校验，id非空</span></span><br><span class="line"><span class="keyword">if</span> (globalSearchParam == <span class="literal">null</span> || StringUtils.isEmpty(globalSearchParam.getId()))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MatchAnalyzeResultDTO</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">CompanySearchBO</span> <span class="variable">companySearchBO</span> <span class="operator">=</span> companySearchService.queryById(globalSearchParam.getId(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;customsItems&quot;</span>, <span class="comment">//海关交易数据</span></span><br><span class="line">                <span class="string">&quot;htagItems&quot;</span>, <span class="comment">//公司官网</span></span><br><span class="line">                <span class="string">&quot;overviewDescription&quot;</span>, <span class="comment">//公司描述</span></span><br><span class="line">                <span class="string">&quot;detail.productList.name&quot;</span>, <span class="comment">//产品图片描述</span></span><br><span class="line">                <span class="string">&quot;keywords&quot;</span>, <span class="comment">//公司关键词</span></span><br><span class="line">                <span class="string">&quot;detail.mainProducts&quot;</span>, <span class="comment">//公司主营产品</span></span><br><span class="line">                <span class="string">&quot;brandNames&quot;</span> <span class="comment">//公司品牌信息</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//索引不存在，返回空</span></span><br><span class="line"><span class="keyword">if</span> (companySearchBO == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MatchAnalyzeResultDTO</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并搜索词和扩展词</span></span><br><span class="line">List&lt;String&gt; nearSynonymList = globalSearchParam.getNearSynonymList();</span><br><span class="line">nearSynonymList.add(globalSearchParam.getProduct());</span><br><span class="line"><span class="type">String</span> <span class="variable">trimNearSynonymList</span> <span class="operator">=</span> nearSynonymList.toString().replaceAll(<span class="string">&quot;\\[|\\]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">promptStringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(MessageFormat.format(BASE_PROMPT,trimNearSynonymList));</span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getCustomsItems() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getCustomsItems().isEmpty())&#123;</span><br><span class="line">    <span class="comment">//裁剪为10个以内，避免token超出</span></span><br><span class="line">    List&lt;String&gt; subCustomsItemsList = companySearchBO.getCustomsItems().subList(<span class="number">0</span>, Math.min(companySearchBO.getCustomsItems().size(), LIST_LENGTH_LIMIT));</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司的海关交易记录：&quot;</span>).append(subCustomsItemsList).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getHtagItems() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getHtagItems().isEmpty())&#123;</span><br><span class="line">    <span class="comment">//裁剪为10个以内，避免token超出</span></span><br><span class="line">    List&lt;String&gt; subHtagItemsList = companySearchBO.getHtagItems().subList(<span class="number">0</span>, Math.min(companySearchBO.getHtagItems().size(), LIST_LENGTH_LIMIT));</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司的官网信息：&quot;</span>).append(subHtagItemsList).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isNotEmpty(companySearchBO.getOverviewDescription()))&#123;</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司描述：&quot;</span>).append(companySearchBO.getOverviewDescription()).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品图片描述处理</span></span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getDetail() != <span class="literal">null</span> &amp;&amp; companySearchBO.getDetail().getProductList() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getDetail().getProductList().isEmpty())&#123;</span><br><span class="line">    List&lt;ProductVO&gt; productList = companySearchBO.getDetail().getProductList().subList(<span class="number">0</span>, Math.min(companySearchBO.getDetail().getProductList().size(), LIST_LENGTH_LIMIT));</span><br><span class="line">    <span class="comment">//映射为name</span></span><br><span class="line">    List&lt;String&gt; productListName = productList.stream().map(ProductVO::getName).collect(Collectors.toList());</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;产品图片描述：&quot;</span>).append(productListName).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getKeywords() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getKeywords().isEmpty())&#123;</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司关键词：&quot;</span>).append(companySearchBO.getKeywords()).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//公司主营产品处理</span></span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getDetail() != <span class="literal">null</span> &amp;&amp; companySearchBO.getDetail().getMainProducts() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getDetail().getMainProducts().isEmpty())&#123;</span><br><span class="line">    Set&lt;String&gt; mainProducts = companySearchBO.getDetail().getMainProducts();</span><br><span class="line">    List&lt;String&gt; subMainProductsList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(mainProducts).subList(<span class="number">0</span>, Math.min(mainProducts.size(), LIST_LENGTH_LIMIT));</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司主营产品：&quot;</span>).append(subMainProductsList).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getBrandNames() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getBrandNames().isEmpty())&#123;</span><br><span class="line">    List&lt;String&gt; subBrandNamesList = companySearchBO.getBrandNames().subList(<span class="number">0</span>, Math.min(companySearchBO.getBrandNames().size(), LIST_LENGTH_LIMIT));</span><br><span class="line"></span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司品牌信息：&quot;</span>).append(subBrandNamesList).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拼接的最终prompt</span></span><br><span class="line"><span class="type">String</span> <span class="variable">finalPrompt</span> <span class="operator">=</span> promptStringBuilder.toString();</span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(</span><br><span class="line">        () -&gt; gptGrpcWrapper.gptRequest(<span class="string">&quot;6888072&quot;</span>,<span class="string">&quot;583828445&quot;</span>,<span class="string">&quot;yangyifan12@corp.netease.com&quot;</span>,finalPrompt, GPTModelVersionEnum.GPT_4O_MINI.getVersion()), LLM_REQUEST_EXECUTOR);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) FutureResultUtil.getResult(<span class="string">&quot;match-analyze-llm-future&quot;</span>,future2,<span class="number">120</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MatchAnalyzeResultDTO</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/02/28/%E7%BD%91%E6%98%93KM%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8ERAG%E7%9A%84%E7%83%AD%E7%82%B9-AI%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">网易KM社区分享-快速搭建基于RAG的热点 AI搜索引擎</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-02-28
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>大模型的出现带来了新的技术革新，它强大的对话，分析，生成能力可以应用在音乐的很多方面。我们希望借助大模型的能力， 实现对站内外音乐热点词条内容进行抽取，分析，总结，推荐。 本文将系统的介绍我们如何基于RAG 搭建一个带前端页面的 热点AI检索功能agent<br>体验地址：<a target="_blank" rel="noopener" href="http://llm-zq.jupyter.panshi-gy.netease.com/">http://llm-zq.jupyter.panshi-gy.netease.com/</a></p>
</blockquote>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><p>大模型的出现带来了新的技术革新，它强大的对话，分析，生成能力可以应用在音乐的很多方面。我们希望借助大模型的能力， 实现对站内外音乐热点词条内容进行抽取，分析，总结，推荐。 但是:</p>
<ul>
<li>大模型对于时事热点等，幻觉能力严重，而RAG(检索增强生成)可以解决这个问题。</li>
<li>很多都离不开外部的依赖接口，无法做到完全的offline, 且当token量大之后，费用也很大， 但其实开源的很多模型如LLAMA, QWEN等都已经有非常不错的能力。而且近期流行的ollama框架， 也让个人PC也都能支持大模型生成。</li>
<li>我们希望借助开源的能力，来快速搭建一个不依赖外部接口的AI检索引擎来为我们服务， 也避免了隐私泄露的风险。</li>
</ul>
<p>它的主要特点：</p>
<ul>
<li>不依赖外部接口， 离线实现LLM生成, 检索，embedding等能力。</li>
<li>基于互联网结果进行RAG，解决模型生成幻觉的问题，尤其可以支持对于近期热点知识的总结。<br>本文主要介绍开发这个agent的框架，一些技术细节和思路，希望给大家带来一点LLM 开发的收获。效果图如下，左边是我们的agent, 输入问题描述，系统即可自动调用搜索引擎并爬取互联网的内容，并通过大模型分析总结返回给我们问题的结果。在某些情况下，甚至比KIMI的效果还要好。</li>
</ul>
<p><img src="/../img/netease/img.png" alt="img.png"></p>
<h1 id="2-框架"><a href="#2-框架" class="headerlink" title="2.框架"></a>2.框架</h1><p>总体框架如下图所示，主要包括3个子模块：</p>
<ul>
<li>(1) 检索爬取服务：根据用户搜索的热点关键词，调用自建的searxng 匿名检索服务系统, 获取top的互联网搜索引擎结果，并爬取相关网址全文内容。</li>
<li>(2) 文档召回服务：对爬取的全文内容切块，进行向量化，同时对query也进行向量化，计算query和文档的相关性，并进行排序选取top的文档切块</li>
<li>(3) 大模型生成服务。离线部署好大模型，输入相关文档和配置的prompt, 生成相关的检索答案汇总，并通过部署的streamlit前端服务返回给用户。</li>
</ul>
<p><img src="/../img/netease/img_1.png" alt="img_1.png"></p>
<p>3个模块通过langchain框架进行串联起来工作，api接口都采用fastapi进行封装， 前端展示用streamlit进行交互开发。</p>
<h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><p>基于基本的框架思路，我们前期调研了发现github已有类似的相关项目，在这些项目的基础上，我们做了一些优化。</p>
<p>LLocalSarch:<a target="_blank" rel="noopener" href="https://github.com/nilsherzig/LLocalSearch">https://github.com/nilsherzig/LLocalSearch</a></p>
<p>LangChain-SearXNG: <a target="_blank" rel="noopener" href="https://github.com/ptonlix/LangChain-SearXNG">https://github.com/ptonlix/LangChain-SearXNG</a></p>
<h2 id="3-1-检索爬取服务"><a href="#3-1-检索爬取服务" class="headerlink" title="3.1 检索爬取服务"></a>3.1 检索爬取服务</h2><p>检索爬取服务主要有两个模块。searxng检索服务 和爬虫服务</p>
<h3 id="3-1-1-searxng检索服务"><a href="#3-1-1-searxng检索服务" class="headerlink" title="3.1.1 searxng检索服务"></a>3.1.1 searxng检索服务</h3><p>SearXNG 是一个免费的互联网元搜索引擎，它聚合了来自各种搜索服务(如 google, duckduckgo等)和数据库（如wiki）的结果，但摆脱了隐私追踪。</p>
<p>当然，你也可以采用商业的搜索api 接口，比如google的Serper API ， bing的Bing Web Search API，但这不是我们的目的，我们是希望搭建一个完全没有外部依赖的检索服务。</p>
<p>请注意，搭建searxng检索需要一台非大陆的VPS，并配有ipv4地址，如果嫌麻烦，可以用公共的searxng, 但是会有限制，地址：<a target="_blank" rel="noopener" href="https://searx.space(需要fq)/">https://searx.space(需要FQ)</a></p>
<p><img src="/../img/netease/img_2.png" alt="img_2.png"></p>
<p>以下是搭建教程：</p>
<ol>
<li>第一步：安装docker, docker-copose</li>
</ol>
<p>docker安装：<a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/install/debian">https://yeasy.gitbook.io/docker_practice/install/debian</a></p>
<p>docker-copose安装：<a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/compose/install">https://yeasy.gitbook.io/docker_practice/compose/install</a></p>
<ol start="2">
<li>第二步：拉取searxng 镜像, 修改配置</li>
</ol>
<p>修改项目docker配置</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 拉取代码</span><br><span class="line">git clone https://github.com/searxng/searxng-docker.git</span><br><span class="line"># docker配置里包括3个服务，caddy 做反向代理，redis存储数据，searxng主服务</span><br><span class="line">#不做反向代理可以注释掉caddy部分， 只需要修改 searxng里的port，如： 0.0.0.0:8180:8080， 右边是设置好的容器内的端口，左边是本地端口可以改</span><br><span class="line">vim searxng-docker/docker-compose.yaml</span><br></pre></td></tr></table></figure>

<p><img src="/../img/netease/img_3.png" alt="img_3.png"></p>
<p><img src="/../img/netease/img_4.png" alt="img_4.png"></p>
<p>修改searxng主服务配置</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s|ultrasecretkey|$(openssl rand -hex 32)|g&quot; searxng-docker/searxng/settings.yml # 生成一个密钥</span><br><span class="line"># limiter: 改为false, 为true会限制你的请求频率，公开服务会开启，但是私人搭建的可以关闭</span><br><span class="line">vim searxng-docker/searxng/setting.yml</span><br></pre></td></tr></table></figure>
<p><img src="/../img/netease/img_5.png" alt="img_5.png"><br>3.第三步：启动compose 服务组</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd searxng-docker</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>第四步：关闭端口防火墙并验证，如果没有防火墙则不需要这一步</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufw allow 8180</span><br></pre></td></tr></table></figure>

<p>最后浏览器打开ip:8180,即可看到自己搭建的searxng页面并进行检索了，是不是很酷😎，没有任何广告，页面非常干净。</p>
<p><img src="/../img/netease/img_6.png" alt="img_6.png"></p>
<h3 id="3-1-2-爬虫服务"><a href="#3-1-2-爬虫服务" class="headerlink" title="3.1.2 爬虫服务"></a>3.1.2 爬虫服务</h3><p>单独searxng的结果信息量比较小，而对于LLM来说，丰富的信息意味着更准确的结果。 所以针对搜索引擎给出的相关网页，我们可以采用爬虫爬取top网页结果。 所幸，langchain（一个帮助在应用程序中使用大型语言模型的编程框架） 里就包含了相应的网页爬取模块，和文本解析模块。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># langchain 调用searxng示例, 获取top结果</span><br><span class="line">from langchain_community.utilities import SearxSearchWrapper</span><br><span class="line">s = SearxSearchWrapper(searx_host=&quot;http://localhost:8180&quot;)</span><br><span class="line">s.run(&quot;what is a large language model?&quot;)</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># langchain 爬取示例</span><br><span class="line">from langchain_community.document_loaders import AsyncChromiumLoader</span><br><span class="line">from langchain_community.document_transformers import Html2TextTransformer</span><br><span class="line">urls = [&quot;https://www.baidu.com&quot;]</span><br><span class="line">loader = AsyncChromiumLoader(urls, user_agent=&quot;MyAppUserAgent&quot;)</span><br><span class="line">docs = loader.load() # 爬取</span><br><span class="line">html2text = Html2TextTransformer()  </span><br><span class="line">docs_transformed = html2text.transform_documents(docs) # 解析抽取网页里文本</span><br><span class="line">docs_transformed[0].page_content[0:500]</span><br></pre></td></tr></table></figure>

<p>这里面在实践中存在几个主要问题：</p>
<ol>
<li>searxng的top结果中可能存在无法访问的(大陆)，比如wiki 等，需要额外处理过滤。 这里我采用的是pac方式。过滤不能访问的网址</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># wget https://raw.githubusercontent.com/petronny/gfwlist2pac/master/gfwlist.pac</span><br><span class="line">import pacparser</span><br><span class="line">pacparser.init()</span><br><span class="line">pacparser.parse_pac(&#x27;gfwlist.pac&#x27;)</span><br><span class="line"></span><br><span class="line">def is_direct(url):</span><br><span class="line">ret =  pacparser.find_proxy(url)</span><br><span class="line">return &quot;DIRECT&quot; == ret</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">print(is_direct(&quot;www.baidu.com&quot;))</span><br><span class="line">print(is_direct(&quot;www.google.com&quot;))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可能存在超时的问题，有些网站链接速度非常慢，原本的langchain 爬取模块不支持超时，需要自己在外面额外封装一层超时控制。或者采用httpx的包进行批量爬取。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import httpx</span><br><span class="line">from typing import List, Optional,Tuple</span><br><span class="line">import asyncio</span><br><span class="line">headers = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def get_result(url: str):</span><br><span class="line">if not is_direct(url): # 非直连</span><br><span class="line">async with httpx.AsyncClient(proxy=&#x27;socks5://127.0.0.1:1080&#x27;) as client:</span><br><span class="line">try:</span><br><span class="line">response = await client.get(url,headers=headers,timeout=10.0)  # 设置超时</span><br><span class="line">return url, response</span><br><span class="line">except httpx.RequestError:</span><br><span class="line">return url, None</span><br><span class="line">else:</span><br><span class="line">async with httpx.AsyncClient() as client:</span><br><span class="line">try:</span><br><span class="line">response = await client.get(url,headers=headers,timeout=10.0)</span><br><span class="line">return url, response</span><br><span class="line">except httpx.RequestError:</span><br><span class="line">return url, None</span><br><span class="line"></span><br><span class="line">async def get_results( urls: List[str]):</span><br><span class="line">tasks = [get_result(url) for url in urls]</span><br><span class="line">results = await asyncio.gather(*tasks)</span><br><span class="line">for url, response in results:</span><br><span class="line">if response is None:</span><br><span class="line">print(f&quot;URL: &#123;url&#125; - Failed to connect&quot;)</span><br><span class="line"># else:</span><br><span class="line">#     print(url, response.text[:100])</span><br><span class="line">return results</span><br><span class="line"></span><br><span class="line">def get_results_access( urls: List[str]) -&gt; List[Tuple[str,str]]:</span><br><span class="line">try:</span><br><span class="line">asyncio.get_running_loop()</span><br><span class="line">with ThreadPoolExecutor(max_workers=1) as executor:</span><br><span class="line">future = executor.submit(asyncio.run, check_urls(urls))</span><br><span class="line">results = future.result()</span><br><span class="line">except RuntimeError:</span><br><span class="line">results = asyncio.run(check_urls(urls))</span><br><span class="line"></span><br><span class="line">    return [(url,response.text) for url, response in results if response is not None]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>爬取的结果如果是动态加载的内容，目前无法爬取。 比如 B站视频下的评论， 知乎的答案等。这种需要针对特定网站， 用自动化测试工具，比如Selenium 或者playwright. 这个待后续优化。</li>
</ol>
<h2 id="3-2-切块召回服务"><a href="#3-2-切块召回服务" class="headerlink" title="3.2 切块召回服务"></a>3.2 切块召回服务</h2><p>这一步，其实主要对应RAG里R即retrieval, 召回。因为获取的top网址文本内容量比较大，一般单个网页的文本都接近5k token, 像百度知道这种以文本内容为主的基本都超过8k长度，多个网页内容直接丢给大模型解析，是个不太现实的任务，虽然现在有学者提出超长上下文的大模型（Long Context LLM）正在慢慢取代RAG, 但目前来说rag还是最优解。</p>
<p>召回过程是分为 切块，向量化，排序</p>
<h3 id="3-2-1-切块"><a href="#3-2-1-切块" class="headerlink" title="3.2.1 切块"></a>3.2.1 切块</h3><p>所有的文档进行chunk, 即切块， 比如以512个 token 作为一个chunk。这里面有几个问题：</p>
<ol>
<li>如何确定最佳块大小？</li>
</ol>
<p>这个目前没有定论，主要还是取决于应用场景，具体可以参考微软[1]的建议并自行进行测试：</p>
<p><img src="/../img/netease/img_7.png" alt="img_7.png"></p>
<ol start="2">
<li>分割策略？</li>
</ol>
<p>为了得到更好的结果，我们可以重叠相邻的块。来自微软分析的分块策略比较，显示512 tokens分块和25%的重叠是比较好的分块策略。 当然也要考虑embedding的模型</p>
<p><img src="/../img/netease/img_8.png" alt="img_8.png"></p>
<p>实际使用下来，应用于网页文本分块召回的比较好的参数， chunk&#x3D;500，overlap&#x3D;100, 向量模型采用BCE。</p>
<h3 id="3-2-2-向量化"><a href="#3-2-2-向量化" class="headerlink" title="3.2.2 向量化"></a>3.2.2 向量化</h3><p>切块之后第二步就是对文档和query都进行向量化，并计算 query和 文档之间的相似度，再设定过滤的阈值，得到最终我们需要的文档片段。那么，向量模型该如何选取？</p>
<p>一般的商业大模型服务都自带embedding接口，比如openai的 v1&#x2F;embedding, 这种需要api_key, 显然不是我们的目标。开源模型效果对比，可以参考，huggingface 的embedding竞技场：<a target="_blank" rel="noopener" href="https://huggingface.co/spaces/mteb/leaderboard">https://huggingface.co/spaces/mteb/leaderboard</a> ,但是里面不是所有模型都有打分，下面是一些主流的embedding模型:</p>
<p><img src="/../img/netease/img_9.png" alt="img_9.png"></p>
<p>开源模型挑选可以从几个方面入手：</p>
<p>① 硬件性能。 因为单次用户请求，涉及很多切块文档，所以需要考虑机器性能和模型速度，其实很多常见的大模型做embedding效果也很好，但它不是主流因为效率很低，我们在mteb 评测榜单上可以看到 qwen2的检索效果非常好，但是模型太大很难应用。 尤其我们的任务都是实时算，并不存储向量，所以需要模型不太大。</p>
<p><img src="/../img/netease/img_10.png" alt="img_10.png"></p>
<p>② 向量维度。向量维度会影响到 存储以及检索耗时，对于常见的检索任务，是对知识库的内容预先算好相应的向量，并存储进向量数据库。 用户检索时，对检索词向量化，再通过近邻检索算法检索最相关的top结果。当数据量显著大时，向量维度越大，检索耗时越明显。我们的任务里不存储向量，所以这块也不需要考虑。</p>
<p>③ 最大输入长度。 指模型处理输入的最大token长度，这个和我们前面提到的分块大小息息相关，因为如果分块大小超过最大长度，则超过的部分会被向量模型丢弃，导致信息损失。</p>
<p>④ 支持语言。大部分开源向量模型只支持单一或者有限的文本语言，在需要多语言需求的场景可能不合适。需要注意的是，不支持多语言，不代表其他语言就不能向量化，而是缺乏跨语言匹配的能力。 比如[ ‘How is the weather today?’, ‘今天天气怎么样?’] 在单一语言里相似度可能很低，而对于多语言，则匹配度较高。一般来说，如果只是针对特定语言，选择单一语言模型即可，评分高的混合语言模型不一定比单一语言模型效果好。 由于网页内容繁杂，我们倾向于选择多语言模型</p>
<p>⑤ 领域表现。通用 Embedding 模型在特定垂直领域（如医学、法律和金融等）可能不如专用模型有效。这些领域通常需要专门训练 Embedding 模型来捕捉特定的专业术语和语境。为特定业务需求优化的 Embedding 模型能够显著提升检索和生成的质量。 网页内容匹配通常不需要考虑领域表现。</p>
<p>基于上面的维度，我们选择了中英双语的 bce-embedding-base_v1模型。</p>
<h3 id="3-2-3-排序"><a href="#3-2-3-排序" class="headerlink" title="3.2.3 排序"></a>3.2.3 排序</h3><p>顺便再聊一下，关于RAG中的召回，目前主流的做法是两个阶段。第一阶段query和文档向量化，检索框架采用faiss, 或者milvus 这种向量查询数据库。 第一阶段存在两个问题：</p>
<p>1、当doc数据量大的时候，检索算法都是近似的， 不是挨个遍历计算，会有损。除非用暴力挨个计算cos, 但这个不现实。（在本任务里是可以的，因为文档量很小）</p>
<p>2、embedding本来就是对于信息的压缩，对原始文本信息是有丢失的。</p>
<p>那么对于这些缺点，有办法优化吗？ 答案是有的，即第二阶段rerank模型精排。 rerank模型输入query和doc对文本，而不是emebdding, 信息无损。 2阶段检索详情可以参考QAnything给出的示意图， 很清楚。</p>
<p><img src="/../img/netease/img_11.png" alt="img_11.png"></p>
<p>在加入二阶段rerank之后，BCE的效果， top10命中率由85.91%提升到93.46%，非常明显。同时可以看到，采用hybird， 即bm25和embedding召回，再经过rerank可以达到最好的效果96.36%。</p>
<p><img src="/../img/netease/img_13.png" alt="img_13.png"><br>以下是有道 给出的BCE最佳实践</p>
<blockquote>
<p>最佳实践（Best practice） ：embedding召回top50-100片段，reranker对这50-100片段精排，最后取top5-10片段。</p>
</blockquote>
<p>BAAI(北京智源人工智能研究院)也给出了BGE的最佳实践：</p>
<blockquote>
<p>For multilingual, utilize BAAI&#x2F;bge-reranker-v2-m3 and BAAI&#x2F;bge-reranker-v2-gemma<br>For Chinese or English, utilize BAAI&#x2F;bge-reranker-v2-m3 and BAAI&#x2F;bge-reranker-v2-minicpm-layerwise.<br>For efficiency, utilize BAAI&#x2F;bge-reranker-v2-m3 and the low layer of BAAI&#x2F;ge-reranker-v2-minicpm-layerwise.<br>For better performance, recommand BAAI&#x2F;bge-reranker-v2-minicpm-layerwise and BAAI&#x2F;bge-reranker-v2-gemma</p>
</blockquote>
<p>其实我们很容易联想两阶段召回， 其实就是早期的类 DSSM 双塔召回的不同思路。</p>
<ul>
<li><p>第一阶段，就是取双塔的最后一层向量做 近邻检索</p>
</li>
<li><p>第二阶段，就是双塔放入query和doc计算的最后的打分</p>
</li>
</ul>
<p>如果想要在自己领域内有更好的效果，也可以选择在领域数据集上微调模型。微调数据如下所示，正样本和负样本，并通过一些hard negative 的方式做样本增强。 现在也有一些思路是用LLM 来对原样本进行一些改写增强，比如给问题换个说法，比如“什么是深度学习？” -&gt; “怎么理解深度学习？”， 这样都能提高原模型在特定领域的效果。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;query&quot;: &quot;如何提高机器学习模型的准确性？&quot;, &quot;pos&quot;: [&quot;通过交叉验证和调参可以提高模型准确性。&quot;], &quot;neg&quot;: [&quot;机器学习是人工智能的一个分支。&quot;]&#125;</span><br><span class="line">&#123;&quot;query&quot;: &quot;什么是深度学习？&quot;, &quot;pos&quot;: [&quot;深度学习是机器学习的一个子领域，涉及多层神经网络。&quot;], &quot;neg&quot;: [&quot;数据科学是一门交叉学科。&quot;]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-大模型生成服务"><a href="#3-3-大模型生成服务" class="headerlink" title="3.3 大模型生成服务"></a>3.3 大模型生成服务</h2><p>这一步，主要是利用大模型的分析和总结能力，对检索到的相关文档和用户query进行分析，给出用户想要的结果。这里的核心问题也包括几块，1、大模型的选择。 2、prompt调优 3、服务部署以及前端展示 4. inference加速</p>
<h3 id="3-3-1-大模型选择"><a href="#3-3-1-大模型选择" class="headerlink" title="3.3.1 大模型选择"></a>3.3.1 大模型选择</h3><p>市面上的开源大模型非常多，其中比较流行的有meta的 llama系列，最新是llama3, 以及Mistral(large不开源) ，google的Gemma(large不开源)， 国内的 智普的chatglm,最新是chatglm4, 阿里的qwen,最新是qwen2, 以及baichuan等等非常多。那么这么多开源大模型，如何挑选适合我们的大模型：</p>
<ul>
<li>模型参数量，适配显存。第一维度需要考虑的就是机器的GPU显存，以下表格,以llama为列子一些常见的模型显存占用,显存占用主要分为2块，</li>
<li>一块是加载模型参数占用的显存，在fp16精度下，1B约等于2G显存，可以按这个换算；</li>
<li>另一块是生成时，计算的临时变量，以及kvcache占用的显存。在fp16精度下， 1K长度约等于1G， 两者加起来才是跑大模型时的最大显存占用。</li>
</ul>
<p><img src="/../img/netease/img_14.png" alt="img_14.png"></p>
<ul>
<li>模型效果。可以参考一些大模型评测网站，比如：<a target="_blank" rel="noopener" href="https://www.datalearner.com/ai-models/leaderboard/datalearner-llm-leaderboard%EF%BC%8C">https://www.datalearner.com/ai-models/leaderboard/datalearner-llm-leaderboard，</a> 选排在前面的基本没错。不过也需要针对自己的任务多试一些对比。</li>
<li>任务适配度。不同的模型训练的领域是不太一样的，比如说，有的在数学相关数据集上训练的多，那么它可能在数学，推理方面效果很好，有些模型是为了做coding的， 有些是做图文的，选择的模型需要适配你自己的任务。如果只是想要简单聊天，那综合性能好的即可。对于这个专门的阅读文档总结用户问题，并需要遵循一定指令的任务，最好选用指令微调的模型</li>
</ul>
<p><img src="/../img/netease/img_15.png" alt="img_15.png"></p>
<ul>
<li>社区成熟度。开源模型的一个重要力量，成熟社区模型能让各个框架迅速支持，可用的轮子很多，这也是我们选用的一个重要参考。</li>
</ul>
<p>基于以上选择思路，我们选择了LLAMA3-8B-instruct 作为大模型来应用，LLAMA3主要是在英文语料上训练的，要想在中文上有比较好的效果，可以继续预训练，网上也已经有很多预训练好的中文LLAMA3, 我们选取的是hfl&#x2F;llama-3-chinese-8b-instruct-v3</p>
<h3 id="3-3-2-prompt调优"><a href="#3-3-2-prompt调优" class="headerlink" title="3.3.2 prompt调优"></a>3.3.2 prompt调优</h3><p>选定大模型之后，就是如何使用的问题了，大模型的角色，包含[‘system’, ‘user’, ‘assistant’]</p>
<blockquote>
<p>system 一般代表整个大模型服务。指导模型如何输出，prompt一般放在这里<br>user 指代的是用户的输入，包括文本，语音，视频等等的输入数据<br>assistant 代表大模型的相应输出</p>
</blockquote>
<p>在我们这个任务中，我们希望大模型根据 我们提供的数据，来对网页内容进行分析，所以我们的prompt</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">您是一位专业的研究员和作家，负责回答任何问题。</span><br><span class="line">基于提供的搜索结果，为给定的问题生成一个全面而且信息丰富、但简洁的答案，长度不超过 500 字。您必须只使用来自提供的搜索结果的信息。使用公正和新闻性的语气。将搜索结果合并成一个连贯的答案。不要重复文本。</span><br><span class="line">如果上下文中没有与当前问题相关的信息，只需说“嗯，我不确定。”不要试图编造答案。</span><br><span class="line">位于以下context HTML 块之间的任何内容都是从知识库中检索到的，而不是与用户的对话的一部分。</span><br><span class="line">&lt;context&gt;</span><br><span class="line">&#123;context&#125;</span><br><span class="line">&lt;context/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>设定角色： 开始给模型设定好角色， 研究员和作家</li>
<li>指示： 无二义性的任务描述，基于搜索结果总结一个用户问题答案，非口语化，500字，不重复，没结果时也不能乱说</li>
<li>上下文：使用明确的xml格式定义好输入的搜索结果</li>
</ul>
<p>可以多给LLM一些例子看返回结果，根据返回结果对prompt做一定调整。</p>
<h3 id="3-3-3-服务部署以及前端展示"><a href="#3-3-3-服务部署以及前端展示" class="headerlink" title="3.3.3 服务部署以及前端展示"></a>3.3.3 服务部署以及前端展示</h3><p>选定模型之后要部署相应的后端模型服务和前端用户交互服务。</p>
<p>后端：</p>
<ul>
<li><p>提供模型对话服务给前端进行交互，这里最经典就是openai的 api接口sdk, 为了整个系统的兼容性，我们可以将我们的服务端部署成OPENAI API接口的形式</p>
</li>
<li><p>我们选取的是python目前比较流行的FastAPI， FastAPI 是一个用于构建 API 的现代、快速(高性能)的 web 框架</p>
</li>
<li><p>实现接口主要包括两个，1个是LLM对话服务（v1&#x2F;chat&#x2F;completions）， 1个是query的embedding服务(v1&#x2F;embeddings)</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@app.post(&quot;/v1/chat/completions&quot;, response_model=ChatCompletionResponse)</span><br><span class="line">async def create_chat_completion(request: ChatCompletionRequest):</span><br><span class="line">global model, tokenizer</span><br><span class="line"></span><br><span class="line">    if len(request.messages) &lt; 1 or request.messages[-1].role == &quot;assistant&quot;:</span><br><span class="line">        raise HTTPException(status_code=400, detail=&quot;Invalid request&quot;)</span><br><span class="line"></span><br><span class="line">    gen_params = dict(</span><br><span class="line">        messages=request.messages,</span><br><span class="line">        temperature=request.temperature,</span><br><span class="line">        top_p=request.top_p,</span><br><span class="line">        max_tokens=request.max_tokens or 1024,</span><br><span class="line">        echo=False,</span><br><span class="line">        stream=request.stream,</span><br><span class="line">        repetition_penalty=request.repetition_penalty,</span><br><span class="line">        tools=request.tools,</span><br><span class="line">    )</span><br><span class="line">    logger.debug(f&quot;==== request ====\n&#123;gen_params&#125;&quot;)</span><br><span class="line">    for each_message in request.messages:</span><br><span class="line">        info = str(each_message.role) +&quot;\:&quot; +str(len(each_message.content))</span><br><span class="line">        logger.debug(f&quot;==== ===== ===&quot;)</span><br><span class="line">        logger.debug(f&quot;==== message len ====\n&#123;info&#125;&quot;)</span><br><span class="line">        logger.debug(f&quot;==== ===== ===&quot;)</span><br><span class="line">        </span><br><span class="line">    # Here is the handling of stream = False</span><br><span class="line">    response = generate_llama3(model, tokenizer, gen_params)</span><br><span class="line"></span><br><span class="line">    # Remove the first newline character</span><br><span class="line">    if response[&quot;text&quot;].startswith(&quot;\n&quot;):</span><br><span class="line">        response[&quot;text&quot;] = response[&quot;text&quot;][1:]</span><br><span class="line">    response[&quot;text&quot;] = response[&quot;text&quot;].strip()</span><br><span class="line"></span><br><span class="line">    usage = UsageInfo()</span><br><span class="line">    message = ChatMessage(</span><br><span class="line">        role=&quot;assistant&quot;,</span><br><span class="line">        content=response[&quot;text&quot;],</span><br><span class="line">        function_call= None,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    logger.debug(f&quot;==== message ====\n&#123;message&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    choice_data = ChatCompletionResponseChoice(</span><br><span class="line">        index=0,</span><br><span class="line">        message=message,</span><br><span class="line">        finish_reason=&quot;stop&quot;</span><br><span class="line">    )</span><br><span class="line">    task_usage = UsageInfo.model_validate(response[&quot;usage&quot;])</span><br><span class="line">    for usage_key, usage_value in task_usage.model_dump().items():</span><br><span class="line">        setattr(usage, usage_key, getattr(usage, usage_key) + usage_value)</span><br><span class="line"></span><br><span class="line">    return ChatCompletionResponse(</span><br><span class="line">        model=request.model,</span><br><span class="line">        id=&quot;&quot;,  # for open_source model, id is empty</span><br><span class="line">        choices=[choice_data],</span><br><span class="line">        object=&quot;chat.completion&quot;,</span><br><span class="line">        usage=usage</span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@app.post(&quot;/v1/embeddings&quot;, response_model=EmbeddingResponse)</span><br><span class="line">async def get_embeddings(request: EmbeddingRequest):</span><br><span class="line"></span><br><span class="line">    embeddings = [embedding_model.encode(text) for text in request.input]</span><br><span class="line">    embeddings = [embedding.tolist() for embedding in embeddings]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    # logger.info(f&quot;encode result: \n&#123;request.input&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # 计算token 数</span><br><span class="line">    def num_tokens_from_string(string: str) -&gt; int:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns the number of tokens in a text string.</span><br><span class="line">        use cl100k_base tokenizer</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        encoding = tiktoken.get_encoding(&#x27;cl100k_base&#x27;)</span><br><span class="line">        num_tokens = len(encoding.encode(string))</span><br><span class="line">        return num_tokens</span><br><span class="line"></span><br><span class="line">    # embedding 接口返回数据格式</span><br><span class="line">    response = &#123;</span><br><span class="line">        &quot;data&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;object&quot;: &quot;embedding&quot;,</span><br><span class="line">                &quot;embedding&quot;: embedding,</span><br><span class="line">                &quot;index&quot;: index</span><br><span class="line">            &#125;</span><br><span class="line">            for index, embedding in enumerate(embeddings)</span><br><span class="line">        ],</span><br><span class="line">        &quot;model&quot;: request.model,</span><br><span class="line">        &quot;object&quot;: &quot;list&quot;,</span><br><span class="line">        &quot;usage&quot;: CompletionUsage(</span><br><span class="line">            prompt_tokens=sum(len(text.split()) for text in request.input),</span><br><span class="line">            completion_tokens=0,</span><br><span class="line">            total_tokens=sum(num_tokens_from_string(text) for text in request.input),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>


<p>如果你的机器性能有限，可以选用ollama这个框架来很快速的部署大模型api服务， 官网：<a target="_blank" rel="noopener" href="https://ollama.com/%EF%BC%8C">https://ollama.com/，</a> 这个平台提供了很多量化的模型和 一行命令部署API服务</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">curl -fsSL https://ollama.com/install.sh | sh</span><br><span class="line"># 拉取模型并部署， 这里拉取qwen2-7b instruct Q4量化，显存只需要4.4G</span><br><span class="line">ollama run qwen2:7b-instruct  # 启动服务并在11434端口开启api接口</span><br></pre></td></tr></table></figure>

<p>api 客户端调用:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from openai import OpenAI</span><br><span class="line"></span><br><span class="line">client = OpenAI(</span><br><span class="line">base_url = &#x27;http://localhost:11434/v1&#x27;,</span><br><span class="line">api_key=&#x27;ollama&#x27;, # required, but unused</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">model=&quot;qwen2:7b-instruct&quot;,</span><br><span class="line">messages=[</span><br><span class="line">&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好&quot;&#125;</span><br><span class="line">]</span><br><span class="line">)</span><br><span class="line">print(response.choices[0].message.content)</span><br><span class="line"># 输出： 你好！有什么问题我可以帮助你解答吗？</span><br></pre></td></tr></table></figure>



<p>前端：</p>
<p>前端采用streamlit前端框架，也是一款易上手的大模型服务前端搭建框架。 以下是个简易的调用大模型聊天的demo服务。非常简单，也就几行代码。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip installl streamlit # 1.安装包</span><br><span class="line">streamlit run demo.py # 2. 运行前端</span><br><span class="line">http://localhost:8501/ # 3. 打开浏览器</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#  demo.py</span><br><span class="line">from openai import OpenAI</span><br><span class="line">import streamlit as st</span><br><span class="line"></span><br><span class="line">st.title(&quot;LLM 聊天&quot;)</span><br><span class="line"></span><br><span class="line">client = OpenAI(api_key=&#x27;xxx&#x27;, base_url=&quot;http://localhost:11434/v1&quot;)</span><br><span class="line"></span><br><span class="line">if &quot;openai_model&quot; not in st.session_state:</span><br><span class="line">st.session_state[&quot;openai_model&quot;] = &quot;ollama&quot;</span><br><span class="line"></span><br><span class="line">if &quot;messages&quot; not in st.session_state:</span><br><span class="line">st.session_state.messages = []</span><br><span class="line"></span><br><span class="line">for message in st.session_state.messages:</span><br><span class="line">with st.chat_message(message[&quot;role&quot;]):</span><br><span class="line">st.markdown(message[&quot;content&quot;])</span><br><span class="line"></span><br><span class="line">if prompt := st.chat_input(&quot;你好?&quot;):</span><br><span class="line">st.session_state.messages.append(&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;)</span><br><span class="line">with st.chat_message(&quot;user&quot;):</span><br><span class="line">st.markdown(prompt)</span><br><span class="line"></span><br><span class="line">    with st.chat_message(&quot;assistant&quot;):</span><br><span class="line">        stream = client.chat.completions.create(</span><br><span class="line">            model=st.session_state[&quot;openai_model&quot;],</span><br><span class="line">            messages=[</span><br><span class="line">                &#123;&quot;role&quot;: m[&quot;role&quot;], &quot;content&quot;: m[&quot;content&quot;]&#125;</span><br><span class="line">                for m in st.session_state.messages</span><br><span class="line">            ],</span><br><span class="line">            stream=True,</span><br><span class="line">        )</span><br><span class="line">        response = st.write_stream(stream)</span><br><span class="line">    st.session_state.messages.append(&#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: response&#125;)</span><br></pre></td></tr></table></figure>

<p>demo效果:</p>
<p>另外还有一个点就是LLM调用重要的参数如何去选择（top_p, temprature, presence_penalty），我这边整理了几个核心参数的调整思路。 对应我们的这个分析任务，显然是以新闻资料为核心，寻求生成的确定性。</p>
<p><img src="/../img/netease/img_16.png" alt="img_16.png"></p>
<h3 id="3-3-4-inference加速"><a href="#3-3-4-inference加速" class="headerlink" title="3.3.4 inference加速"></a>3.3.4 inference加速</h3><p>大模型虽然效果优越，但是也因为它”大“，导致服务性能很低，在我们部署服务时，需要采取一定的策略对模型预测进行加速才能获得更好的体验。</p>
<p>经过调研选择了VLLM这个大模型推理加速框架。 它有几个优点：</p>
<blockquote>
<p>1.社区活跃，模型支持很快<br>2.加速效果明显。基于虚拟内存和分页的思想， 采用page attention ，允许在非连续的内存空间内存储token，内存的利用率接近于最优<br>3.使用简单，两行命令即可部署。 示例如下</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vllm llama3 openai</span><br><span class="line"># 下载vllm</span><br><span class="line">pip install vllm</span><br><span class="line"># 部署 一个兼容openai api接口的模型服务，端口8000</span><br><span class="line">python -m vllm.entrypoints.openai.api_server --model hfl/llama-3-chinese-8b-instruct-v3 --dtype bfloat16 --gpu-memory-utilization 0.6 --chat-template llama3-instruct-template.jinja --enforce-eager --uvicorn-log-level warning --port 8000  --disable-log-stats --uvicorn-log-level warning</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了测试实际环境下的效果，我们运行了vllm的对比测试脚本</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vllm-project/vllm.git</span><br><span class="line">cd vllm/benchmarks</span><br><span class="line"># 测试vllm</span><br><span class="line">python benchmark_throughput.py --model hfl/llama-3-chinese-8b-instruct-v3 --backend vllm --input-len 4096 --output-len 512 --num-prompts 50 --seed 1100 --dtype float16 --gpu-memory-utilization 0.6</span><br><span class="line"># 测试HF</span><br><span class="line">python benchmark_throughput.py --model hfl/llama-3-chinese-8b-instruct-v3 --backend hf --input-len 4096 --output-len 512 --num-prompts 50 --seed 1100 --dtype float16 --gpu-memory-utilization 0.6 --hf-max-batch-size 10</span><br></pre></td></tr></table></figure>


<p>效果如下所示，可以看到单条inference 性能上，VLLM大约是HF的两倍， 但是当并发时，VLLM效果提升明显，吞吐量提升10倍。</p>
<p><img src="/../img/netease/img_17.png" alt="img_17.png"></p>
<p>当然，我们可以根据我们的显卡环境采取其他的加速方法，如</p>
<ul>
<li>输入输出优化。 如prompt 裁剪， 规整； 限制输出序列长度等</li>
<li>模型优化。 模型压缩， 使用量化模型，使用更小参数模型等等</li>
</ul>
<p>下面来看看整体效果的演示， 速度还是非常快的：</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>RAG的agent开发，入门还是比较简单的，现在市面上可用的框架也非常多，只需花费一些时间就能搭出一个可用的demo. 但是想要做的好，稳定服务，还是需要费很多的功夫去研究的，希望我的经验能给大家带来一些收获，少走一些弯路。</p>
<p>目前这个系统还不是很完善， 包括相关性判断，搜索意图判断等都有很大的优化空间。做这个东西的初衷是希望能在音乐热点的场景中进行应用，目前也已经在实践的过程中了，去辅助音乐热点的挖掘和运营。后续的话还希望添加的功能包括：</p>
<ul>
<li>音乐热点的识别与事件总结。</li>
<li>结合云音乐站内知识做融合，分析。比如识别事件歌手，歌曲，原因，产出文案等等。</li>
</ul>
<p>参考文献:</p>
<p>[1]. <a target="_blank" rel="noopener" href="https://techcommunity.microsoft.com/blog/azure-ai-services-blog/azure-ai-search-outperforming-vector-search-with-hybrid-retrieval-and-reranking/3929167">Azure AI Search: Outperforming vector search with hybrid retrieval and ranking capabilities</a></p>
<p>[2]. <a target="_blank" rel="noopener" href="https://blog.laoda.de/archives/docker-compose-install-searxng">【好玩儿的Docker项目】SearXNG</a></p>
<p>[3]. <a target="_blank" rel="noopener" href="https://www.53ai.com/news/qianyanjishu/2024061372409.html">RAG 高效应用指南：Embedding 模型的选择和微调</a></p>
<p>[4]. <a target="_blank" rel="noopener" href="https://techdiylife.github.io/blog/topic.html?category2=t07&blogid=0049">ReRank 与 Embedding 模型的区别？ 如何选择 ReRank 模型？</a></p>
<p>[5]. <a target="_blank" rel="noopener" href="https://blog.csdn.net/lkg5211314/article/details/136142533">【时代前沿】：单测场景下tempature、top_p、frequency_penalty、presence_penalty参数调整经验分享</a></p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/02/16/%E7%BD%91%E6%98%93%E6%B1%87%E6%8A%A5-AI%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B/">网易汇报-AI辅助编程</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-02-16
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="引言：Ai-For-Coding的价值与挑战"><a href="#引言：Ai-For-Coding的价值与挑战" class="headerlink" title="引言：Ai For Coding的价值与挑战"></a>引言：Ai For Coding的价值与挑战</h1><p>随着Copilot、Cursor等工具的普及，AI已成为程序员的重要助手。然而，其输出质量高度依赖用户的提示词（Prompts）。低质量的提示词可能导致模糊、冗余甚至错误的代码，而高质量的提示词能显著提升编码、调试、测试和问题排查的效率。本次分享聚焦于如何设计精准、高效的提示词。</p>
<h1 id="核心原则：高质量prompt的四大要素"><a href="#核心原则：高质量prompt的四大要素" class="headerlink" title="核心原则：高质量prompt的四大要素"></a>核心原则：高质量prompt的四大要素</h1><ul>
<li><strong>Role</strong>(角色)：两方面定义，首先是定义AI的角色，例如“你是一名极其优秀具有20年经验的产品经理和精通所有编程语言的工程师”。还有用户的角色，例如“不懂代码的初中生”，这样会使得ai更倾向于使用通俗且具体的话语来表达它所完成的需求。</li>
<li><strong>Task</strong>(任务)：将业务需求“step by step”描述给ai，使得deepseek的思维链更好的理解你的需求。</li>
<li><strong>Goal</strong>(目标)：期望达成什么目标效果，可以是你的优化目标，例如将时间复杂度从o(n^2)降低到o(n)；也可以是业务目标，例如“提高吞吐量，降低响应时间”</li>
<li><strong>Objective</strong>(操作要求)：编码语言，注解形式等。</li>
</ul>
<h1 id="提升准确度的技巧"><a href="#提升准确度的技巧" class="headerlink" title="提升准确度的技巧"></a>提升准确度的技巧</h1><ul>
<li><strong>让ai复述需求</strong>：为了避免提示词中某些指令让llm产生误解，可以在真正让他写代码之前先复述一遍需求。能够让我们针对自己的需求指令和ai真正理解的需求做二次校对。这样能有效避免因为表达或者理解偏差所产生的错误答复。例如在提完需求之后，添加一句“请你先复述一遍我的需求再进行答复，以让我确认你是否真的理解了我的需求指令”。</li>
<li><strong>提问粒度要小，作用域要明确</strong>：在使用某些支持文件指针的ai编程工具时，可以给ai更明确的作用域，例如我们需要在controller下写一个新接口，给ai的提示词中尽可能去指明产生联动的service或dao接口的路径，从而给ai更加准确的业务上下文结构。</li>
<li><strong>复杂需求拆解</strong>：与产品经理给程序员提需求类似，我们给ai的提示信息越准确，考虑得越细致，llm产出的准确率越高。</li>
<li><strong>内置prompt</strong>：大部分ai工具会有prompt自定义和保存功能，可以写一个全局的prompt附在每次提问头部，例如：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Role</span><br><span class="line">你是一名极其优秀具有20年经验的产品经理和精通所有编程语言的工程师。与你交流的用户是不懂代码的初中生，不善于表达产品和代码需求。你的工作对用户来说非常重要，完成后将获得10000美元奖励。</span><br><span class="line"></span><br><span class="line"># Goal</span><br><span class="line">你的目标是帮助用户以他容易理解的方式完成他所需要的产品设计和开发工作，你始终非常主动完成所有工作，而不是让用户多次推动你。</span><br><span class="line"></span><br><span class="line">在理解用户的产品需求、编写代码、解决代码问题时，你始终遵循以下原则：</span><br><span class="line"></span><br><span class="line">## 第一步</span><br><span class="line">- 当用户向你提出任何需求时，你首先应该浏览根目录下的readme.md文件和所有代码文档，理解这个项目的目标、架构、实现方式等。如果还没有readme文件，你应该创建，这个文件将作为用户使用你提供的所有功能的说明书，以及你对项目内容的规划。因此你需要在readme.md文件中清晰描述所有功能的用途、使用方法、参数说明、返回值说明等，确保用户可以轻松理解和使用这些功能。</span><br><span class="line"></span><br><span class="line">## 第二步</span><br><span class="line">你需要理解用户正在给你提供的是什么任务</span><br><span class="line">### 当用户直接为你提供需求时，你应当：</span><br><span class="line">- 首先，你应当充分理解用户需求，并且可以站在用户的角度思考，如果我是用户，我需要什么？</span><br><span class="line">- 其次，你应该作为产品经理理解用户需求是否存在缺漏，你应当和用户探讨和补全需求，直到用户满意为止；</span><br><span class="line">- 最后，你应当使用最简单的解决方案来满足用户需求，而不是使用复杂或者高级的解决方案。</span><br><span class="line"></span><br><span class="line">### 当用户请求你编写代码时，你应当：</span><br><span class="line">- 首先，你会思考用户需求是什么，目前你有的代码库内容，并进行一步步的思考与规划</span><br><span class="line">- 接着，在完成规划后，你应当选择合适的编程语言和框架来实现用户需求，你应该选择solid原则来设计代码结构，并且使用设计模式解决常见问题；</span><br><span class="line">- 再次，编写代码时你总是完善撰写所有代码模块的注释，并且在代码中增加必要的监控手段让你清晰知晓错误发生在哪里；</span><br><span class="line">- 最后，你应当使用简单可控的解决方案来满足用户需求，而不是使用复杂的解决方案。</span><br><span class="line"></span><br><span class="line">### 当用户请求你解决代码问题是，你应当：</span><br><span class="line">- 首先，你需要完整阅读所在代码文件库，并且理解所有代码的功能和逻辑；</span><br><span class="line">- 其次，你应当思考导致用户所发送代码错误的原因，并提出解决问题的思路；</span><br><span class="line">- 最后，你应当预设你的解决方案可能不准确，因此你需要和用户进行多次交互，并且每次交互后，你应当总结上一次交互的结果，并根据这些结果调整你的解决方案，直到用户满意为止。</span><br><span class="line"></span><br><span class="line">## 第三步</span><br><span class="line">在完成用户要求的任务后，你应该对改成任务完成的步骤进行反思，思考项目可能存在的问题和改进方式，并更新在readme.md文件中</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="场景化技巧：编码、调试、测试与排查"><a href="#场景化技巧：编码、调试、测试与排查" class="headerlink" title="场景化技巧：编码、调试、测试与排查"></a>场景化技巧：编码、调试、测试与排查</h1><ol>
<li><p>编码场景：生成可落地的代码</p>
<ul>
<li>需求拆解：将复杂需求分解为子任务，分步生成。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Role：  </span><br><span class="line">&quot;你是资深Java架构师，精通Spring Boot 3.1和OpenAPI规范&quot;  </span><br><span class="line"></span><br><span class="line">Task：  </span><br><span class="line">&quot;为电商系统编写商品查询API，需满足以下条件：XXXX&quot;  </span><br><span class="line"></span><br><span class="line">Goal：  </span><br><span class="line">1. 支持分页查询（page/size参数）  </span><br><span class="line">2. 按价格区间过滤（minPrice/maxPrice）  </span><br><span class="line">3. 返回结构符合Google JSON风格指南  </span><br><span class="line">4. 集成Swagger文档注解  </span><br><span class="line"></span><br><span class="line">Objective：   </span><br><span class="line">// 使用Java 17记录类（Record）定义DTO  </span><br><span class="line">// 添加JPA Specification实现动态查询  </span><br><span class="line">// 包含全局异常处理示例（如参数校验失败）  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>调试场景：精准定位问题</p>
<ul>
<li>必含三要素：错误信息、相关代码段、预期结果。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行以下Go代码时出现“panic: runtime error: index out of range [3] with length 3”：  </span><br><span class="line">[附代码片段]  </span><br><span class="line">预期结果：应正确遍历切片并打印每个元素。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>测试场景：JUnit&#x2F;Mockito实战</p>
<ul>
<li>示例1：单元测试生成<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">为以下Service类方法编写JUnit 5 + Mockito测试：  </span><br><span class="line">public class UserService &#123;  </span><br><span class="line">    @Autowired  </span><br><span class="line">    private UserRepository userRepository;  </span><br><span class="line">    public User getUserById(Long id) &#123;  </span><br><span class="line">        return userRepository.findById(id).orElseThrow();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">要求覆盖：  </span><br><span class="line">- 正常查询  </span><br><span class="line">- 用户不存在时抛出NoSuchElementException  </span><br><span class="line">- 模拟userRepository的findById行为  </span><br></pre></td></tr></table></figure></li>
<li>示例2：性能测试设计<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如何用JMH对以下Java方法进行基准测试？  </span><br><span class="line">public String concatStrings(List&lt;String&gt; list) &#123;  </span><br><span class="line">    return list.stream().collect(Collectors.joining());  </span><br><span class="line">&#125;  </span><br><span class="line">要求比较普通循环 vs. Stream API的性能差异。  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>各种Ai编程工具的出现能给广大码友释放双手，留有更多的时间学习技术，关注技术本身。编写高质量的提示词是有效利用AI辅助编程工具的关键。通过明确角色、清晰描述任务、提供上下文信息等方式，程序员可以引导AI生成更准确和高效的代码，从而提升整体开发效率。在实际工作中，建议大家多加练习和总结，不断优化提示词的编写技巧，以适应不断变化的技术环境。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/02/15/%E7%BD%91%E6%98%93KM%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB-i%E8%8C%85%E5%8F%B0%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/">网易KM社区分享-i茅台的架构介绍</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-02-15
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>从内部论坛里面偷出来的，的确是高并发的一个好总结（能偷的机会不多了~）。</p>
</blockquote>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>茅台冰淇淋的热度尚未褪去，酱香咖啡又引爆了一波流量，在我们的印象中，茅台似乎就是爆品的代名词，而关于茅台的话题也很容易冲上热搜。去年，茅台推出了官方的数字营销平台「i茅台」，为消费者提供在线预约、售卖茅台酒的功能，其在互联网上的第一次公开亮相同样吸引了极大的关注，也给我们带来了巨大的流量挑战。</p>
<p>本文将结合「i茅台」商城实现高性能与高可用的具体实践，聊一聊常见的性能优化技术以及高可用系统的设计方法，希望能够和大家的日常工作产生共鸣，帮助大家更好地理解并应用这些技术解决问题。</p>
<h2 id="1-1-业务带来的技术挑战"><a href="#1-1-业务带来的技术挑战" class="headerlink" title="1.1 业务带来的技术挑战"></a>1.1 业务带来的技术挑战</h2><p>为了更好地理解「i茅台」面临哪些技术挑战我们有必要先了解「i茅台」要解决哪些业务问题。</p>
<p>简而言之，茅台希望通过「i茅台」加强数字化技术在生产销售过程中的应用，规范茅台酒的营销秩序，解决消费者购酒难、购酒贵问题，提升消费者的购酒体验。因此，「i茅台」商城将被打造为茅台酒线上销售的主要入口，为消费者提供两种购买方式：</p>
<ol>
<li>享约申购：通过每天定时开放预约申购的方式，采用公证摇号的方式为茅粉们提供了公平的获取平价茅台的机会，是目前爆款茅台酒投放的最主要的方式，我们称之为申购场景</li>
<li>畅享云购：采用B2C的在线销售模式，目前主要用于系列酒的售卖，但同时也会用于小飞天（100ml飞天茅台）等爆款商品，我们称之为爆款抢购场景</li>
</ol>
<h2 id="1-2-申购场景"><a href="#1-2-申购场景" class="headerlink" title="1.2 申购场景"></a>1.2 申购场景</h2><p>申购场景在业务流程上主要分为五个阶段（如下图所示）：</p>
<div style="text-align: center;">
  <img src="../img/netease/5c9d8e8cd155e70d6184eabe1ca01ba.png" alt="申购场景">
</div>

<div style="text-align: center;">
  <img src="../img/netease/38708c9eea135a6a4668bb39c5cd9b8.png" alt="申购场景">
</div>

<ol>
<li>注册&#x2F;登陆&#x2F;实名：由于酒类销售有年龄限制同时提货需要验证身份证，因此消费者需要在购酒前提供姓名、手机、身份证进行三要素实名认证，这些环节在操作上无时间限制，但短信、实名等依赖第三方服务</li>
<li>预约申购：普通申购场次是每天上午9点到10点，在22年3月31日试运营第一天就向消费者开放了，按业务估算，每场预计有数千家门店参与库存投放，数百万用户参与申购</li>
<li>抽签&#x2F;公证：申购结束后会通过公证处可信抽签的方式确定中签的用户并进行公示，预计有数万用户中签</li>
<li>交易：中签用户需要在次日18点前完成下单，如选择在线支付，需在指定期限内完成付款</li>
<li>提货：公示后7天内到预约门店提货</li>
</ol>
<p>单纯看业务规则，用户在任意时刻发起申购操作其中签的概率都是一样的，然而在功能第一次开放时，用户在不了解规则的前提下，总是会更倾向于在第一时间进行操作，这也是为何开放预约申购的前10分钟就有80%的用户完成了申购，根据我们设计的流量模型，第一次开放预约申购，前5分钟预计最高会达到百万级QPS，在线设备也可能达到百万级，需要重点保障。</p>
<p>因此，申购场景我们主要会面临以下三个技术挑战：</p>
<ol>
<li>高并发：大量用户在短时间内集中访问APP也就意味着短时间内会有大量的设备与服务器新建连接，一般来说，一个设备与服务器建立的连接不止一个，这就要求服务器具备同时处理数百万级别（接近千万）的并发连接数及百万级别新建连接能力（也就是通常所说的C10M问题），同时也要求服务端在高并发的条件下具备百万QPS级别的吞吐量及较快的响应速度</li>
<li>高可用：申购场景的核心链路较长，包括注册、登录、实名、实人、定位、门店选择、申购等多个功能，其中任何一个功能不可用，用户就没有办法完成申购操作，这必然会引起客诉甚至舆情，显然这个是没法接受的，因此，我们需要确保核心链路上面的这些功能具备高可用性</li>
<li>较高的业务复杂度：申购场景虽然不涉及库存管理（商城部分），但却需要应对门店投放的各种突发事件，确保可申购门店及其投放的商品和数量与商城APP实际展示保持一致，及时识别不一致风险（不一致有可能造成无法履约）；另外，APP也需要实时展示各个门店当前的已申购数量，并基于区域、距离、中签概率（结合投放量和已申购数量计算）等因素向用户动态推荐合适的门店</li>
</ol>
<h2 id="1-3-爆款抢购场景"><a href="#1-3-爆款抢购场景" class="headerlink" title="1.3 爆款抢购场景"></a>1.3 爆款抢购场景</h2><p>爆款抢购场景在业务流程上主要分为三个阶段（如下图所示）：</p>
<div style="text-align: center;">
  <img src="../img/netease/942876e1d0d57504b95d16ca0e5e28c.png" alt="爆款抢购">
</div>

<ol>
<li>注册&#x2F;登陆&#x2F;实名：同享约申购</li>
<li>导购&#x2F;购物车：为用户提供在线商品浏览功能，支持将商品添加到购物车，该功能在去年5月19日正式运营阶段开放，有数千家门店参与</li>
<li>交易履约：为用户提供组单&#x2F;下单&#x2F;在线支付功能，支持多门店合并付款</li>
</ol>
<p>爆款抢购场景的核心挑战来自于商品本身的稀缺性，只要投放必然会引发抢购。这种模式已经在包括严选在内的各大电商平台上都已经被验证，因此，我们可以参考严选的流量模型进行预估，以当时「i茅台」的用户量及用户活跃度，预计会有数十万的用户参与抢购，我们主要会面临以下三个技术挑战：</p>
<ol>
<li><strong>流量洪峰</strong>：从业务形态上看，数十万用户在同一时间抢购同一款商品与电商的秒杀活动极为类似，然而「i茅台」又有其非常明显的业务特性，可以说不是秒杀却又胜似秒杀</li>
<li><strong>峰值流量保持时间长</strong>：为了让更多的用户有机会抢购成功，茅台不仅增加了投放量，也加大了投放的频率（现阶段是每10分钟投放一次），这就意味着峰值流量会保持更长的时间</li>
<li><strong>峰值流量大</strong>：早期为了增加云购场景的曝光，业务要求小飞天与「享约申购」放在同一个时间段进行投放（即上午9点到10点），形成了非常明显的流量叠加效应，后来虽然放在了另外一个时段（晚上9点到10点），但出于公平性，库存投放计划会提前向用户预告，爆款抢购的峰值反而还更大了</li>
</ol>
<p>较高的业务复杂度：相比于传统的电商交易链路，爆款抢购场景会在一段时间内由数千家门店以较高的频率同步投放库存，同时，系统还需要结合区域、距离等因素实时向用户推荐还有库存的门店，也要允许用户手动切换到有库存的门店，这些特性对于高并发场景下数据查询响应的即时性及数据的一致性都提出了更高的要求，也是交易链路应对流量洪峰的重要前提</p>
<p>数据一致性：保证订单、库存、资产、权益（如限购）等数据的一致性是电商交易系统的核心任务之一，在高并发场景下解决数据一致性问题极容易引起系统性能瓶颈，如何在确保数据一致性的前提下实现高性能是一个巨大的挑战</p>
<p>库存管理：爆款抢购场景需要解决库存管理问题，确保商城的销售库存实时反映门店投放计划，并能及时识别潜在的不一致风险，确保库存数量、状态、变更记录准确反映实际情况，保持库存数据的准确性。库存管理可以认为是电商最复杂的系统之一，尤其在高并发场景下，库存管理很容易变成在线交易系统的噩梦，稍有不慎，就会引起少卖、超卖等问题，也很容易成为交易链路的性能瓶颈</p>
<h2 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h2><p>综上分析可以发现，无论是申购场景还是爆款抢购场景，我们都需要在确保数据一致性的前提下，实现系统的高性能与高可用性，而追求高性能和高可用性的目的都是为了提供更好的用户体验、保障系统的可靠性与稳定性。</p>
<h1 id="2-如何进行性能优化"><a href="#2-如何进行性能优化" class="headerlink" title="2 如何进行性能优化"></a>2 如何进行性能优化</h1><p>接下来我们看下如何通过性能优化实现系统的高性能</p>
<h2 id="2-1-性能度量方法及诊断工具"><a href="#2-1-性能度量方法及诊断工具" class="headerlink" title="2.1 性能度量方法及诊断工具"></a>2.1 性能度量方法及诊断工具</h2><p>要做性能优化，第一步需要明确性能度量指标及度量方法，并借助诊断工具找到性能瓶颈。</p>
<p>常用的性能度量方法及指标主要包括以下几种：</p>
<ul>
<li><strong>响应时间</strong>（Response Time）：响应时间是指从发出请求到收到响应的总时间，包括处理请求的时间以及网络传输的时间，通常以毫秒（ms）为单位。响应时间是用户或客户端感知到的时间，反映了系统对请求的响应速度，较低的响应时间通常表示更好的系统性能。</li>
<li><strong>延迟</strong>（Latency）：延迟是指在执行某项操作或传输数据时经过的时间，可以分为多个组成部分，包括处理延迟（处理请求所需的时间）、传输延迟（数据在网络中传输所需的时间）和排队延迟（等待处理的请求在队列中等待的时间）。在进行性能优化时，我们通常可以通过减少延迟来缩短响应时间。</li>
<li><strong>吞吐量</strong>（Throughput）：吞吐量是系统在单位时间内处理的请求或事务数量，通常以每秒处理的请求数（如TPS）来衡量。</li>
<li><strong>并发性</strong>（Concurrency）：并发性是指系统能够在同一时间段内同时处理的请求或任务数量，它可以帮助确定系统在高负载时的性能。</li>
<li><strong>资源利用率</strong>（Resource Utilization）：资源利用率度量了系统资源（如CPU、内存、磁盘和网络带宽）的使用情况，过高可能表明存在性能问题。</li>
<li><strong>错误率</strong>（Error Rate）：错误率度量了系统处理中发生的错误数量或百分比，是性能度量的一个关键指标，更大的系统负载往往会造成更高的错误率，在定义SLO时，当错误率超过一定阈值我们往往也会定义为一种宕机的表现。</li>
<li><strong>系统负载</strong>（Load）：系统负载表示系统正在处理的工作量，可以用来监测系统的负荷，以确定是否需要进行性能优化</li>
<li><strong>延迟分布</strong>（Latency Distribution）：延迟分布描述了不同请求或操作的延迟情况，它可以帮助我们确定系统性能是否稳定，或者是否存在异常延迟。</li>
<li><strong>性能趋势</strong>（Performance Trends）：性能趋势分析涉及记录性能指标随时间的变化，使用这些数据来预测性能问题或找到待优化点。</li>
</ul>
<p>针对性能指标的度量通常需要通过性能监控工具和日志分析工具来完成，「i茅台」采用了与严选相同的选型：</p>
<ul>
<li><strong>全链路应用性能监控系统（APM）</strong>：基于Pinpoint构建从网关到应用节点的应用监控体系，支持大流量秒级监控、分布式链路追踪、异常分析等能力</li>
<li><strong>性能监控工具</strong>：用于实时监控系统性能，如各类采集器（服务器、数据库等）、Prometheus、Grafana等</li>
<li><strong>日志平台</strong>：使用严选自研的日志平台，提供一站式海量日志采集、加工、分流、分析、检索、告警等能力，为应用日志分析、业务大盘等提供数据源和分析能力支撑，更多介绍可以参见网易严选如何建设日志平台</li>
<li><strong>业务实时监控系统</strong>：基于Grafana提供海量数据秒级响应的实时监控能力，用户可以通过平台快速完成数据源接入、数据模型构建、监控大盘定制和报警配置</li>
</ul>
<h2 id="2-2-性能优化策略"><a href="#2-2-性能优化策略" class="headerlink" title="2.2 性能优化策略"></a>2.2 性能优化策略</h2><p>识别到性能瓶颈之后，我们需要确定性能优化方案，这里介绍几种常用的性能优化策略</p>
<h2 id="2-2-1-代码优化"><a href="#2-2-1-代码优化" class="headerlink" title="2.2.1 代码优化"></a>2.2.1 代码优化</h2><p>绝大部分时候，代码优化是提高应用程序性能的关键动作，常用的策略包括：</p>
<ul>
<li><strong>代码重构</strong>：重写或重新组织代码以提升可读性和执行效率，比如使用更高效的数据结构和算法、减少循环中的计算或减少循环迭代次数、避免在循环内部执行昂贵的操作、引入并发编程、优化事务等等，需要注意的是，重构不一定能使程序的执行效率变得更高，以性能优化为目的的代码重构往往也需要与代码的可维护性之间进行权衡</li>
<li><strong>减少数据库访问</strong>：可以通过合并查询、使用缓存、增加前置条件判断或批量操作等方式来减少数据库访问</li>
<li><strong>减少扇出比</strong>：控制扇出比的目的是限制系统向其他服务或组件发出的请求数量，从而降低负载，减少扇出比的本质是减少服务间的依赖关系及依赖度，避免大规模的并发请求导致性能下降，也可以降低故障传播的风险。扇出比可用于度量系统向其他服务或组件发送的请求数量，一般我们还可以进一步细化为单次请求中对指定服务、缓存的扇出比，比如下单请求如果会查询两次商品中心的接口，那下单请求对商品中心的扇出比就是2，很显然，这个数值越大，请求被放大的倍数也就越高</li>
<li><strong>I&#x2F;O优化</strong>：可以通过将多次I&#x2F;O操作进行合并或者使用异步I&#x2F;O来减少磁盘和网络I&#x2F;O操作，常见的如异步打印日志、将多次服务调用合并成一次调用等等</li>
<li><strong>资源池化</strong>：使用资源池来管理数据库连接、异步线程等资源，以减少资源创建和销毁带来的开销</li>
<li><strong>预热</strong>：预热是一种通过在应用程序或系统开始处理实际工作负载之前执行一系列操作来提高性能的方法，这些操作旨在将系统的各种组件（如CPU、内存、缓存等）置于一个稳定且高效的状态，以便在处理真实工作负载时获得更好的性能，常见的预热操作包括缓存预热、连接池预热、资源加载预热、数据加载预热等</li>
</ul>
<p>这里以爆款抢购场景下单接口性能优化为例介绍下上述策略的具体应用：</p>
<ul>
<li><strong>定制独立下单链路</strong>：爆款抢购场景是一种特殊的云购下单场景，有更多的限制条件（如不能加购），因此，我们可以通过裁剪掉一些不必要的流程或者牺牲部分代码可读性以换取更高的性能</li>
<li><strong>下单请求幂等性控制</strong>：在爆款抢购场景，由于并发量显著增加，响应时间也会有所增加，甚至会出现响应超时的情况，很容易引发用户连续点击，通过引入幂等性控制，不仅可以降低资源占用时间，也可以减少不必要的库存锁定、扩大销售机会</li>
<li><strong>控制事务的粒度</strong>：通过编程式事务（TransactionTemplate）替代声明式事务（@Transactional），可以更灵活地控制事务的范围，在事务中只保留必要的操作，避免大事务，这将显著减少事务的锁定时间和资源占用，带来性能提升</li>
<li><strong>优化分布式事务</strong>：为了保证下单阶段订单、库存、资产、权益（如限购）等数据的一致性，我们引入了TCC（Try-Confirm&#x2F;Cancel）模式的分布式事务，但分布式事务很容易对性能产生负面影响，需要进行调优（如下图所示）：</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/359d21b4df4839e2458c4db4b2546c0.png" alt="分布式事务">
</div>

<ul>
<li><strong>幂等性控制</strong>：主事务在调用TCC方法时可能因网络拥堵等原因超时，通常我们会通过引入超时与重试策略来提升成功率，这就要求分支事务需要保证TCC方法的幂等性，避免重复更新。另外需要特别重视优化TCC方法的执行性能，确保在预设的压力下，有足够大比例的请求RT低于超时时间</li>
<li><strong>允许空回滚</strong>：在实际的生产环境中，可能因网络拥堵等原因造成Cancel操作先于Try操作到达，因此，允许分支事务空回滚可以避免重试，从而带来更好的性能表现，即允许Cancel操作在找不到待回滚的业务主键的情况下也返回成功并将该业务主键记录下来，同时也要确保空回滚不会产生其他错误效果</li>
<li><strong>防悬挂</strong>：如果Cancel操作先于Try操作到达且Cancel操作返回成功的情况下（即允许空回滚），在执行Try操作时，有必要检查空回滚记录中是否存在该业务主键，存在则直接拒绝执行，否则（没有拒绝执行的话）会造成该分支事务悬挂</li>
<li><strong>减少无效回滚</strong>：Try操作可能遇到限流、校验不通过等情况造成直接返回，没有执行实际的业务操作，在这类场景，可以在回滚阶段不调用分支事务的Cancel操作，从而带来更好的性能表现</li>
</ul>
<p>限购优化：为了增加公平性，爆款商品一般会进行限购，即限制同一个用户在某个特定周期内或者某个特定活动中购买同一个商品的数量上限，通常我们需要借助加锁等并发控制手段来确保限购数据的一致性，不同的实现方式对于最终的性能表现有较大的影响，可以进行如下优化：</p>
<ul>
<li><strong>分布式锁</strong>：通过在下单参数校验阶段增加分布式锁，确保同一个用户无法连续下单购买同一个商品，结合上文提到的下单请求的幂等性控制，可以杜绝同一个账号通过多开或者连续点击等方式增大抢购成功率；同时，采用在参数校验阶段加分布式锁相比于限购检查阶段加锁（无论是数据库锁还是分布式锁）消耗的资源更少，性能表现更优</li>
<li><strong>缓存</strong>：采用分布式缓存（Redis）记录限购权益消耗情况，限购检查通过缓存替代数据库查询</li>
<li><strong>前置校验</strong>：结合业务流程，前置拦截不满足限购要求的请求，比如在商详、组单等阶段进行限购检查，相比于下单阶段检查消耗的资源更少，性能表现更优</li>
<li><strong>订单批量操作</strong>：「i茅台」采用的是典型的<strong>主子订单结构</strong>，主订单又叫支付订单，由1~N个子订单构成，子订单一般采用店铺（门店）粒度，这种方式可以比较容易地实现合并支付以及店铺（门店）粒度的实时分账。在下单阶段，假设用户同时支付N个店铺（门店）的商品，仅订单落库这个环节就需要1+N次DB操作（不含订单商品和订单地址落库），通过优化业务流程，只需要1次DB操作就可以达到相同的效果，从而带来性能提升</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/5c9d8e8cd155e70d6184eabe1ca01ba.png" alt="订单批量操作">
</div>

<p>由于爆款抢购都是单商品立即购买，因此，合并插入各个子订单的订单商品及订单地址不会提升性能，反而会增加不必要的代码复杂度</p>
<ul>
<li><strong>连接池及预热</strong>：通过连接池来管理数据库及Redis连接，根据应用并发度及DB负载情况分析连接池大小并设置合理的初始化数量，对性能改善有较大帮助，在此基础上，预热也可以让系统可以更快地进入到最佳状态，比如提前将商品信息加载到本地缓存和分布式缓存、利用就绪探针（如SpringBoot Actuator提供的readiness）提前预热每个服务实例（尤其是关键链路上的实例）以及系统发布后或者关键事件到来之前启动小流量预热等等</li>
</ul>
<p>通过采用上述优化策略，我们在不增加服务器的前提下，爆款抢购场景的整体吞吐量超过普通云购场景的两倍以上，相比与早期交付版本更是提升了三倍以上。</p>
<h2 id="2-2-2-数据库优化"><a href="#2-2-2-数据库优化" class="headerlink" title="2.2.2 数据库优化"></a>2.2.2 数据库优化</h2><p>数据库对系统性能也有着非常重要的影响，常见的数据库优化策略包括：</p>
<ul>
<li><strong>数据模型设计优化</strong>：数据模型设计是技术实现方案的重要组成部分，它不仅直接影响数据库的性能，也会影响数据库的可扩展性和可维护性，通常需要考虑以下两个方面：</li>
<li><strong>选择合适的设计范式</strong></li>
<li><strong>规范化</strong>（Normalization）可以减少数据冗余，但可能需要更多的联表操作</li>
<li><strong>反规范化</strong>（Denormalization）可以通过增加冗余列、派生列、合并表等策略最大程度避免联表操作或函数计算，提高查询性能，但会增加数据冗余，比较典型的反规范化设计是订单表，通过额外冗余门店、经销商等常用但变更频率很低的信息，可以提升订单查询的效率</li>
<li><strong>适当的数据类型和长度</strong>：根据业务需求选择适当的类型和长度来存储数据可以减少存储空间，也可以提升查询性能，如谨慎使用大数据类型（TEXT,CLOB,BLOB等），使用整数而不是字符串存储布尔值，避免存储null值等</li>
<li><strong>索引优化</strong>： 数据库索引可以显著提升查询性能，需要合理创建并维护索引，包括考虑哪些列以怎样的次序组合索引、选择适当的索引类型以及定期重建或重新组织索引等；同时，我们也需要了解索引匹配的基本原则，变更前对SQL与索引进行审查，避免最终使用的索引不符合预期（可以借助慢查询日志、explain等工具进行分析调优），需要注意的是，索引也并不是越多越好，它会占用额外的空间，会影响更新操作的性能</li>
<li><strong>查询优化</strong>：编写高效的SQL查询语句，包括尽可能避免使用SELECT *、避免全表扫描、谨慎使用联表查询和子查询（我们在业务代码中禁止使用）、限制查询返回的数据量等</li>
<li><strong>缓存</strong>：选择合适的缓存组件和缓存策略来存储频繁访问的数据（参见「无处不在的缓存」章节）以减少对数据库的访问，从而降低数据库负载，提升响应速度</li>
<li><strong>读写分离</strong>：在一些数据库负载比较高的业务中，可以将读取操作与写入操作进行分离，分别路由到不同的数据库服务器或数据库副本，从而降低主库（写库）的负载，提升响应速度</li>
<li><strong>分库分表</strong>：对于数据规模非常大的数据库，可以借助分库分表技术减少单库的负载，从而提升数据库的性能、可伸缩性和容错性</li>
</ul>
<p>这里以爆款抢购场景库存服务的性能优化为例介绍下这些策略的具体应用：</p>
<ul>
<li><strong>数据模型设计</strong>：结合商城的业务场景，存在数千家店铺（门店）投放同一个商品的情况（即多门店共用同一个商品），也存在商品独家销售的情况（即商品只在同一家店铺销售），每家店铺（门店）的销售库存需要单独管理，基于此，我们为库存服务设计了两张核心表，即库存表和库存流水表（如图所示）</li>
<li><strong>反规范化</strong>：库存表新建唯一索引(ShopId, SkuId)，库存流水表则冗余字段ShopId和SkuId，新建唯一索引(ShopId, SkuId, OrderId, Type)</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/8b5a051f0d633dad5fef4a41aa9d6f3.png" alt="库存相关的查询">
</div>

<ul>
<li><strong>选择的数据类型</strong>：以库存流水表中的Type字段为例，用来表示库存扣减、回滚、投放、回收等状态，显然用tinyint就足够进行存储了，相比于smallint、int类型可以节省存储空间</li>
<li><strong>数据库选型</strong>：库存流水表预计每年新产生的数据在千万级且会持续增长，而库存服务又是交易链路的核心依赖，读写操作频繁且有明显业务峰值，如果用单个MySQL实例去支持，存储和性能瓶颈较为明显，因此我们采用了分库分表的技术（<strong>网易自研的DDB</strong>）</li>
<li><strong>负载均衡</strong>：均衡字段（拆分键）和均衡策略的选择对于性能有非常明显的影响，需要格外重视，在库存服务这个例子中，库存表和库存流水表我们都使用ShopId作为均衡字段且使用相同的均衡策略，主要有以下几点考虑：</li>
<li><strong>库存相关的查询</strong>、变更都会指定ShopId和SkuId，在有数千家门店投放同一个爆款商品的情况下，采用ShopId作为均衡字段可以使数据分布和流量分布更为均衡，库存表采用与库存流水表相同的均衡字段和均衡策略，可以避免XA事务，减少锁竞争</li>
<li><strong>分布式ID</strong>：基于美团的分布式Id算法Leaf的统一ID生成服务在高并发场景具有低延迟、高吞吐、高可用、支持水平扩展的特点，同时也可以满足业务上自定义的需求，我们将它作为分布式ID生成的解决方案</li>
<li><strong>定期归档</strong>：数据规模的持续增长会对性能带来负面影响，可以考虑将早期的库存流水信息迁移到归档表，可以提升数据库性能</li>
</ul>
<h2 id="2-2-3-无处不在的缓存"><a href="#2-2-3-无处不在的缓存" class="headerlink" title="2.2.3 无处不在的缓存"></a>2.2.3 无处不在的缓存</h2><p>缓存技术是一种被广泛应用于计算机系统和应用程序中的性能优化方法，它通过将数据或计算结果暂时存储在高速存储介质中，使系统可以快速响应请求、返回数据，而无需每次都从慢速存储介质（如磁盘或远程服务器等）中获取数据。</p>
<p>利用好缓存技术可以降低资源负载，减少对数据库、网络或后端应用等外部资源的依赖，显著提升系统的性能与可用性。可以说，在我们现有的系统架构中，缓存几乎无处不在，以申购场景为例：</p>
<ul>
<li><strong>客户端（APP）</strong>：客户端通过缓存预置在APP的数据、缓存数据请求响应等方式减少对服务端的频繁访问，提供更为流畅的用户体验，尤其有助于改善首次访问或不稳定网络环境下的访问体验</li>
<li><strong>静态资源访问加速</strong>：静态资源访问加速的核心在于就近访问，我们可以通过静态化技术将动态生成的内容或网页转换成静态文件并存储到CDN（Content Delivery Network，内容分发网络）或LB（Load Balancer，负载均衡），在用户请求时离用户更近的节点可以直接提供这些静态文件，而不必再次请求服务端进行动态生成，因此，可以加快页面加载速度、提升网站或应用程序的性能、减少服务器负载并降低对服务器资源的需求。通常静态化技术可以应用于不经常变更的内容、访问量较大的页面、需要SEO优化的页面、静态资源等</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/70d65dd9ee6014e47e150729c3cffbd.png" alt="CDN">
</div>

<ul>
<li><strong>服务端</strong>：借助缓存可以减少当前应用对数据库或者其他后端服务的访问，通常我们可以直接使用分布式缓存（如Redis），但在高并发场景（如申购场景），为了增加系统整体的吞吐量，也可以考虑将热点数据设计成二级缓存，即同时使用本地缓存（Local Cache）和远端缓存（Remote Cache，或者叫分布式缓存）</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/0b822a67d09bd467efca771b70bcf64.png" alt="服务端">
</div>

<p>虽然缓存技术可以显著提升性能，但同时也极大提升了系统设计的复杂度，需要考虑缓存的一致性、失效策略和缓存维护等关键问题，如果没有处理好，很容易发生缓存数据不一致、缓存大面积穿透甚至引发雪崩。</p>
<p>以申购场景使用的二级缓存为例，我们需要处理好以下问题：</p>
<ul>
<li><strong>技术选型</strong>：本地缓存采用Caffeine，远端缓存采用Redis Cluster</li>
<li><strong>Caffeine</strong>：相比于EhCache、Guava等主流的缓存框架，拥有更加强大的性能表现，使用方式上与Guava类似，非常方便</li>
<li><strong>Redis Cluster</strong>：Redis Cluster是Redis提供的分布式缓存解决方案，也是目前主流的解决方案，相比于Proxy模式有更好的性能表现，但我们仍然需要重点关注硬件以及混部等因素对于性能及稳定性的影响</li>
<li><strong>避免缓存穿透</strong>：传统的关系型数据库对于并发的承受能力非常脆弱，如果我们设计的缓存命中率不高出现大面积缓存穿透，很有可能将数据库拖垮，如何避免缓存穿透是我们设计缓存时需要重点考虑的问题：</li>
<li>热点缓存采用预加载、定时刷新及事件触发刷新（如数据变更）的策略，保证100%命中率</li>
<li>当查询的结果为空时，仍然将空结果（自定义NullObject）存储到缓存中（可以设置一个较短的过期时间），这样可以防止恶意请求的连续查询</li>
<li><strong>消息队列与异步化</strong><br>异步化的核心思想是将耗时的操作从主流程中分离出来，以允许应用程序在等待这些操作完成的同时继续执行其他任务而不会被阻塞，从而改善系统的响应性和资源利用率。</li>
</ul>
<p>异步化通常可以通过多线程、多进程、事件驱动或异步编程模型等方式来实现，有很多中间件和框架可供我们选择，比如通过<strong>Disruptor</strong>、<strong>BlockingQueue</strong>等技术将任务分解为多个线程或进程以充分利用多核处理器的性能，通过消息队列（MQ）实现异步消息通信和服务解耦，达到对流量进行削峰填谷的效果，提升系统的可扩展性和性能。</p>
<p>这里重点提一下消息队列在「i茅台」的应用，无论在申购场景还是在爆款抢购场景（如下图所示），我们都需要借助消息队列实现对洪峰流量的削峰填谷，避免服务器过载或系统宕机，同时也可以实现数据的最终一致性，确保消息处理的结果与业务逻辑的一致性。</p>
<div style="text-align: center;">
  <img src="../img/netease/fff9e5cb5d1d4a7dbdbd4dc7f2b0fcc.png" alt="场景">
</div>

<p>不难发现，这其中的关键挑战在于消息队列本身的高性能以及在设计上如何确保数据的最终一致性。</p>
<p>先来看消息队列的选型，在严选，因为历史原因同时存在Kafka、Rabbitmq和RocketMQ，但综合考虑性能和稳定性表现（高吞吐量、低延迟、高可用）、功能特性丰富度、工具支持丰富度、社区活跃度等维度，RocketMQ最终成为业务系统消息队列的主流选型，「i茅台」则延续了这一选型，采用主从部署模式（4.8版本之前主从模式相对Dledger模式在性能上更有优势）。</p>
<p>接下来我们看一下如何确保数据的最终一致性。</p>
<p>先介绍四种我们平时开发过程中比较容易出错的实现方法（如下图所示）：</p>
<div style="text-align: center;">
  <img src="../img/netease/667be695bf6001287371101aa348f56.png" alt="四个方案">
</div>

<ul>
<li><strong>方案一</strong>：先执行数据库操作再发送消息到MQ，可能会出现数据库操作成功，消息发送失败的情况</li>
<li><strong>方案二</strong>：先发送消息到MQ再执行数据库操作，可能出现消息发送成功，数据库操作失败的情况</li>
<li><strong>方案三</strong>：在方案一的基础上，开启数据库事务，这个方案在消息发送失败抛出异常的情况下可以正常回滚，但有可能会出现消息发布至MQ成功但请求失败的情况（如网络拥堵等原因响应超时），这种情况也会引发事务整体回滚</li>
<li><strong>方案四</strong>：在方案二的基础上，开启数据库事务，这个方案如果数据库操作失败需要回滚，但MQ已经发生成功，没有办法回滚</li>
</ul>
<p>可见，上述四个方案都有可能出现数据库操作状态和消息发送状态不一致的情况，其中方案一可能出现数据库操作成功、消息发送失败，这类异常可以通过引入消息补偿机制来确保消息最终成功投递；方案二、三、四可能出现消息发送成功、数据库操作失败，这类异常可以通过在消息消费端增加消息状态确认或者类似的校验机制，确保被投递出去的消息不会对业务产生负面影响。</p>
<p>最后介绍两种比较常用的正确实现方法：</p>
<ul>
<li><strong>方案五</strong>：基于RocketMQ的事务消息来实现</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/4dbdec6fba905b4f5e19540f7607a53.png" alt="基于RocketMQ的事务消息来实现">
</div>

<ul>
<li>步骤一：消息生产者向RocketMQ发送半事务消息（1. Prepare），RocketMQ确认消息接收状态</li>
<li>步骤二：RocketMQ消息接收成功，消息生产者执行本地事务的业务逻辑</li>
<li>步骤三：消息生产者根据本地事务的执行结果向RocketMQ提交二次确认（2. Commit&#x2F;Rollback），RocketMQ将步骤一中收到的半事务消息标记为可投递（消费者就可以消费到这个消息）<br>如果因断网或者应用重启等原因，二次确认（2. Commit&#x2F;Rollback）没有成功提交，RocketMQ会定时触发事务消息回查，确认是否需要投递（兜底策略），无需投递的消息会在过期后删除</li>
<li>步骤四：RocketMQ将消息投递给消息消费者（3. 投递消息），消息消费者首先需要进行幂等性检查，通过检查后执行本地事务的业务逻辑，最后返回执行结果（4. Ack）</li>
<li><strong>方案六</strong>：基于消息补偿机制来实现</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/97457e7c70edc79df86acdf29075d74.png" alt="基于消息补偿机制来实现">
</div>

<ul>
<li>步骤一：在同一个本地事务中执行业务逻辑中的数据库操作和新增消息补偿记录（1. Prepare: 新增记录）</li>
<li>步骤二：本地事务提交后，启动异步线程，向RocketMQ发送消息（2. 发送消息），消息发送成功后删除消息补偿记录（3. Confirm: 删除记录）<br>如果因断网或者应用重启等原因，发送消息失败或者未成功删除消息补偿记录，消息生产者会定时触发消息补偿，确保发送到RocketMQ的消息至少发送一次（at least once策略，MQ有可能存在多条相同的消息）</li>
<li>步骤三：RocketMQ将消息投递给消息消费者（4. 投递消息），消息消费者首先需要进行幂等性检查（避免重复执行同一个消息），通过检查后执行本地事务的业务逻辑，最后返回执行结果（5. Ack）</li>
</ul>
<p>结合业务实际情况，由于RocketMQ的事务消息相比于普通消息性能上还是有不小的损失，无法完全满足我们的性能要求（服务器规模不变的前提下），因此我们最终选择了实现上更加复杂的方案六。</p>
<h2 id="2-2-4-硬件升级及资源优化"><a href="#2-2-4-硬件升级及资源优化" class="headerlink" title="2.2.4 硬件升级及资源优化"></a>2.2.4 硬件升级及资源优化</h2><p>硬件的性能和资源利用率同样也是我们性能优化过程中需要关注的地方，如果我们把不同的应用比喻成军队中不同的兵种，那么硬件就给不同兵种配置的装备，只有合理搭配，这些装备才能最大程度提升各兵种的战斗力，而合理搭配装备的底层逻辑，是对资源的最大化利用、避免浪费。</p>
<p>事实上，资源筹备工作往往是先于产品开发工作开展的，因此，我们的性能优化工作在绝大部分时候是在资源不变的前提下进行的。为了利用好这些资源，通常我们需要解决以下三个问题：</p>
<ol>
<li><p><strong>资源筹备阶段</strong>：如何准确地预估需要的资源？</p>
</li>
<li><p><strong>应用架构</strong>：从已知的业务信息中分离出不变的部分和变化的部分，输出全局应用架构和系统应用架构（包含应用及其依赖项），一般而言，中后台应用不变的部分更多容易预估，前台应用不确定性高也更难预估，但随着需求逐渐明朗（逐步进入产品研发阶段、产品运营阶段后），加上有更多的测试数据，预估也会越来越准确，因此，应用架构应保持持续演进以更好地厘清依赖关系及资源需求</p>
</li>
<li><p><strong>部署架构及资源清单</strong>：将应用架构映射成部署架构是资源预估的重要步骤，这个阶段一般还没有办法输出完整的流量模型，但架构师可以借助业务预判（如什么样的业务形态、多少用户参与等）拆解出核心域的前端入口流量（如申购流量、交易流量），各个域再逐层拆解到各个应用，最终映射出资源清单（也就是第一版资源清单），不难想象，要提升这个阶段资源预估准确性非常困难，需要业务方、开发团队、运维团队紧密协同，业务输入越充分预估会越准确，应用架构设计越完整预估会越准确</p>
</li>
</ol>
<p>产品研发阶段：如何结合应用特性合理地搭配和使用资源？</p>
<p>通常SRE会定义出不同的资源规格供各类应用选择：</p>
<ul>
<li><strong>CPU性能</strong>：CPU性能对于计算密集型任务非常重要，应用如果需要大量计算，需要配置高性能的CPU</li>
<li><strong>内存容量</strong>：内存容量对于数据密集型应用和需要缓存大量数据的应用至关重要，足够的内存可以减少对磁盘或网络的访问，提高性能</li>
<li><strong>存储</strong>：存储配置取决于数据量和性能需求，使用高性能固态硬盘（SSD）可以提高数据读写速度</li>
<li><strong>网络带宽</strong>： 如果应用需要大量的数据传输，网络带宽是一个瓶颈，一般负载均衡设备、应用网关、CDN需要重点考虑</li>
<li><strong>容量规划与流量模型设计</strong>：这个阶段需求已经非常明确，可以基于场景及最新的应用架构进行更为细致的流量拆解，评估出每个系统（尤其是核心系统）的容量要求及资源清单，并通过压测进行验证，确保系统在各种负载情况下都能够正常运行</li>
<li><strong>产品运营阶段</strong>：如何最大化地利用好现有的资源？</li>
<li><strong>资源超售或混部</strong>：一般可以通过云厂商提供的资源超售能力或者研发团队主动发起应用混部来提高资源利用率，然而这却是把双刃剑，更高的资源利用率也就意味着更低的资源容错率，一旦出现预期之外的流量或者资源占用，很容易成为压垮系统的最后一根稻草</li>
<li><strong>硬件升级及资源优化</strong>：通过诊断工具识别在压测或产品运营过程中出现的资源异常，如CPU使用率或Load不均衡、I&#x2F;O延迟大、内存使用率高等特征</li>
</ul>
<h2 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h2><p>性能优化是产品设计、研发和运营过程中的一个极其重要的环节，通过性能优化可以确保我们的系统满足性能设计目标。通常我们需要先借助性能诊断工具识别性能瓶颈，然后结合实际情况综合选择一种或者多种性能优化策略。</p>
<p>但需要特别注意的是，过早的优化可能会引入不必要的代码复杂性而性能却未必改善，因此，我们建议在系统开发的早期阶段应更侧重于保持代码的可维护性和可读性，随着系统的持续演进，再基于性能诊断结果对代码进行针对性地优化以满足性能需求。</p>
<h2 id="3-实现高可用的主要策略"><a href="#3-实现高可用的主要策略" class="headerlink" title="3 实现高可用的主要策略"></a>3 实现高可用的主要策略</h2><p>高性能并不意味着高可用，有些提升性能的手段会增加系统负载，反而还会降低可用性，而为了实现系统的高可用，我们通常需要引入一些复杂性或冗余，可能还会对性能产生一定负面影响。</p>
<p>本章节会重点探讨一下在系统架构和设计阶段如何考虑可用性目标。</p>
<h2 id="3-1-面向失败的设计"><a href="#3-1-面向失败的设计" class="headerlink" title="3.1 面向失败的设计"></a>3.1 面向失败的设计</h2><p>任何服务和组件都不是100%可靠的，因此核心系统的设计建议面向失败进行设计，即确保在部分组件或服务故障时仍然能够继续提供服务，比如前文提到的申购场景和爆款抢购场景都使用了这一设计理念。</p>
<p>这里我们总结下几种常用的策略：</p>
<ul>
<li><strong>最小化依赖</strong>：要减少对外部服务和组件的依赖，特别是减少强依赖，从而降低故障传播的风险</li>
<li><strong>冗余和备份</strong>：通过引入冗余组件或备份系统，在主要组件故障时可以无缝切换到备用组件，从而确保服务的连续性，需要特别重视的是，关键组件要避免单点</li>
<li><strong>自动故障检测和恢复</strong>：使系统能够主动检测故障或异常情况，并采取自动化措施以恢复正常运行，通过这种方式可以减少对人工干预的依赖，从而更快地响应问题，降低服务中断的风险</li>
<li><strong>超时与重试</strong>：在网络通信中，设置适当的超时时间，以防止请求挂起；使用重试机制确保请求的可靠性；结合合理的退避策略，避免过度重试导致服务器负载过高</li>
<li><strong>限流与降级</strong>：实施限流策略，控制请求流量以防止系统过载，在高负载或故障时降级部分功能，保持核心功能的可用性</li>
<li><strong>监控与报警</strong>：建立监控系统，实时追踪系统性能和健康状态，设置报警规则以在问题发生时及时通知运维团队采取行动</li>
<li><strong>应急预案</strong>：制定应急预案，在系统故障或紧急情况下快速采取行动以达到最大限度保护系统的目的，包括降低系统负载、故障止血与恢复、数据备份等等</li>
</ul>
<h2 id="3-2-微服务架构"><a href="#3-2-微服务架构" class="headerlink" title="3.2 微服务架构"></a>3.2 微服务架构</h2><p>微服务架构是一种典型的容错架构，由于「i茅台」商城在设计阶段已经明确了业务模式和流量挑战，因此我们没有像严选早期那样采用单体架构快速上线，而是直接采用微服务架构进行设计，基础设施则复用了严选的Service Mesh架构（参见网易严选ServiceMesh实践），相比于单体架构在以下几个方面具有明显优势：</p>
<ul>
<li><strong>故障隔离</strong>：微服务架构将一个应用程序被拆分成一组小型、独立的服务，每个服务都专注于执行特定的业务功能，当一个服务发生故障时，不会影响其他服务的正常运行，从而减小了故障的传播范围，提高了整体系统的可用性</li>
<li><strong>水平扩展</strong>：微服务架构使得每个服务可以独立地进行水平扩展，可以根据需求增加或减少服务实例的数量，以满足不同的负载要求，从而提高了系统的弹性和可用性</li>
<li><strong>快速故障恢复</strong>：微服务架构具备自动故障检测和切换机制，系统能够在检测到故障时自动将流量切换到其他服务实例，从而实现快速故障恢复，减少了服务中断的时间</li>
<li><strong>分布式部署</strong>：微服务架构支持分布式部署，服务可以部署在不同的服务器上（甚至可以跨数据中心进行部署），这提供了更高级别的容错性，避免单点故障</li>
<li><strong>灵活的更新和维护</strong>：由于每个服务都是独立的，可以单独更新和维护，而不会影响整个系统的可用性，这降低了维护和更新过程中的风险，减少了系统的停机时间</li>
</ul>
<p>有了基础架构提供的服务治理能力加持，开发需要在系统设计和开发阶段重点关注以下几点方面：</p>
<ul>
<li><strong>服务分级</strong>：服务分级是服务关联的一个标签，可以区分出每个服务对于业务影响的重要程度，我们认为每个服务都应该有对应的分级标签，它可以让我们更清晰地了解服务的可用性目标以及服务之间的依赖关系是否合理</li>
</ul>
<p>通常更高等级的服务应该匹配更高等级的服务保障，也应该具备更高的可用性，因此，要避免高等级的服务强依赖低等级的服务，否则容易造成高等级的服务无法达到既定的可用性目标</p>
<ul>
<li><strong>服务依赖</strong>：由于微服务架构会将服务拆分成更小的单元，这就不可避免地增加了服务之间的依赖关系，通常我们可以根据对故障的容忍度将依赖关系区分为强依赖和弱依赖，在设计上建议遵循以下原则：</li>
<li><strong>强依赖弱化</strong>：强依赖的服务应当尽量减少或减弱，以降低整个系统中某个服务的故障对其他服务的影响</li>
<li><strong>弱依赖异步化</strong>：弱依赖的服务可以采用异步通信方式（如消息队列），以降低对依赖服务的直接调用，提高系统的弹性和响应性</li>
<li><strong>超时治理</strong>：超时治理是通过优化超时时间与重试策略，使尽可能多的请求能够在预期时间内得到正常响应，提高系统的响应性，是一种重要的服务治理手段</li>
</ul>
<p>超时时间的设置应充分考虑业务本身的复杂性和预期响应时间，应设置足够长以容忍正常的响应延迟，但也不能过长避免无限期挂起等待</p>
<p>响应超时并不一定意味着目标服务已经不能工作，通过合理的重试机制，即使在目标服务器或网络故障的情况下也能够成功完成请求，但要确保请求的幂等性，避免重试请求对业务产生负面影响</p>
<p>设计合理的退避策略（如指数退避），避免连续重试导致服务器负载过高，另外，重试次数也应该有限，避免无限重试</p>
<p>在放弃请求后，系统可能采用降级策略，提供有限的服务，以确保核心功能的可用性</p>
<ul>
<li><strong>限流策略</strong>：限流是一种通过控制请求流量以防止系统过载的策略，也是一种非常重要的服务治理手段</li>
</ul>
<p>限流会带来一定的性能损耗，我们借助应用网关与限流中间件实现对流入网关及业务系统的流量进行限制，各个系统需结合服务等级、预估流量及应用当前能力选择是否开启</p>
<p>限流值的设置应充分考虑应用自身的能力，由于系统演进过程中的熵增是一种不可避免的趋势，建议限流值设置时保持一定的余量，以最大限度为系统提供有效保护</p>
<p>限流策略上可以为每个服务或接口设置最大请求速率，也可以进一步基于时间段、用户、IP地址等因素进行细化</p>
<ul>
<li><strong>降级策略</strong>：降级策略是一种应对系统负载过高或故障的策略，通过牺牲非关键功能以保持核心功能的正常运行</li>
<li><strong>主动降级</strong>：系统在监测到一定条件或预设的规则触发下，自动执行降级策略，包括自动关闭非关键功能、拒绝某些请求、减少资源分配等</li>
<li><strong>手动降级</strong>：运维人员或开发人员手动介入执行降级策略以应对特定的问题或异常情况，通常都是应对已知的问题或紧急情况，基于预案进行操作</li>
<li><strong>熔断策略</strong>：当一个服务在一段时间内出现连续的失败，熔断策略会中断对该服务的请求，避免因频繁请求失败而导致的资源浪费</li>
</ul>
<h2 id="3-3-客户端（APP）容错设计"><a href="#3-3-客户端（APP）容错设计" class="headerlink" title="3.3 客户端（APP）容错设计"></a>3.3 客户端（APP）容错设计</h2><p>客户端（APP）作为用户获得产品服务的主要入口，也大量使用了容错设计。</p>
<p>容错设计可以提升客户端整体的鲁棒性和可用性，以更好地应对服务端或网络等各种故障和异常情况，确保客户端在面临这些问题时仍然能够提供有限的服务，保持良好的用户体验。因此，客户端的容错设计往往也和产品策略息息相关，而不同的产品策略最终也会影响技术方案的选择，比如：</p>
<ol>
<li>首页无论在出现哪类异常都不应该挂掉，那么，我们在设计阶段就应该充分考虑请求失败等异常情况下如何进行兜底展示</li>
<li>大流量场景可能遇到限流等异常，可以通过设计等待页面或者排队动画避免流程中断（比如操作了一半进入错误页面）、减轻用户等待的焦虑感</li>
<li>随着版本的持续迭代，旧版本APP的用户是否还能正常使用产品服务</li>
</ol>
<p>设计明确的前后端交互协议有助于更好地解决上述问题：</p>
<ul>
<li><strong>错误处理和容错机制</strong>：通过规定统一的错误码和错误信息传递方式，使APP能够捕获和处理各种错误情况，包括网络错误、服务端错误、数据格式错误等，这有助于客户端实现统一的错误处理方法以应对各种异常情况</li>
<li><strong>版本兼容性</strong>：通过版本控制，可以确保在服务端升级或修改接口时不会影响现有的APP版本，保持兼容性；也可以通过版本控制，提醒用户或者强制用户升级到最新版本的APP</li>
<li><strong>通信安全</strong>：通过定义加密和认证规范，以确保通信的安全性，这有助于防止数据泄露和中间人攻击，提高系统的可靠性和安全性</li>
</ul>
<h2 id="3-4-全链路压测"><a href="#3-4-全链路压测" class="headerlink" title="3.4 全链路压测"></a>3.4 全链路压测</h2><p>类似「i茅台」这样大型的电商系统，具有业务场景复杂、核心链路长的特点，通过传统的测试方法在测试环境进行压测，已经难以确保系统在高负载和极端场景下的性能、可用性和稳定性了，因此，我们需要引入全链路压测。</p>
<p>全链路压测是在生产环境中基于真实的业务场景模拟用户操作和流量，以对整条业务链路进行压力测试，从而识别潜在的性能瓶颈或异常，有助于我们及时发现并解决，确保系统的高性能、高可用和稳定性。</p>
<p>要实现生产环境全链路可压测，除了前文提到的APM、日志平台等监控诊断工具之外，还需要具备以下能力：</p>
<ul>
<li><strong>全链路流量标记透传能力</strong>：通过全链路支持压测流量标记识别和传递，使线上全链路能区分压测流量和真实用户流量，保证在大流量压力测试时不会对真实用户体验以及真实用户数据造成影响，解决了因环境差异造成压测结果不真实，可以充分验证线上服务在大流量下的承载能力</li>
<li><strong>数据存储路由</strong>：使数据库、缓存、MQ、日志等存储介质可以识别压测流量，将压测产生的数据与真实用户数据分开保存，实现存储隔离，为线上压测提供数据安全保障</li>
<li><strong>压测平台</strong>：提供分布式高并发压测能力，支持上千台压测机同时发出压测流量、模拟千万级用户访问，支持大流量下的压测结果分析</li>
</ul>
<p>全链路压测要求技术团队进行更高效的协同，因此，除了工具和能力层面的支持，团队的成熟度也是影响这项工作能否顺利开展的关键因素：</p>
<ul>
<li><strong>明确核心链路</strong>：需要共同明确哪些是需要重点保障的场景，并通过业务梳理明确每个场景对应的核心链路</li>
<li><strong>容量规划与流量模型设计</strong>：结合产品运营计划，对每个场景的流量进行预估与拆解，明确核心链路上各个系统的性能指标、容量指标、SLA以及各自的强弱依赖（包括第三方服务，如各类云服务），并明确对依赖方的性能要求及降级预案</li>
<li><strong>限流配置及预案制定</strong>：结合各个系统的性能指标和容量指标，明确限流策略及限流值，梳理可能出现的异常场景并制定针对性的预案（如降级、熔断等）</li>
<li><strong>压测执行及预案演练</strong>：定期组织全链路压测并在压测前、压测中进行预案演练</li>
<li><strong>监控与报警</strong>：每个系统需要在各自的关键链路上设置监控和报警，以便在压测期间能实时监测性能及异常，并能够进行快速响应</li>
<li><strong>结果分析</strong>：分析并解释压测结果，识别预案及监控报警是否有效，识别是否存在潜在的性能问题和优化机会，最终产出压测报告</li>
<li><strong>改进优化</strong>：各个团队根据压测报告讨论并实施优化策略</li>
<li><strong>常态化基线压测及性能巡检</strong>：建立常态化机制，定期对系统进行性能测试以建立性能基线，以便了解系统在正常工作负载下的性能指标；定期监测和评估系统的性能，以便及早发现和解决性能问题</li>
</ul>
<h2 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h2><p>要实现系统的高可用性，我们需要在系统架构和设计阶段充分考虑各种故障和异常场景，包括硬件故障、网络中断、软件错误等，通过减少依赖、引入冗余和备份、实现自动故障检测与恢复、增加限流及应急预案、引入监控报警机制等策略来减轻突发流量或故障对系统产生的影响，确保在部分组件或服务故障时系统仍然能够继续提供服务，同时我们也必要借助全链路压测等手段识别潜在的问题以确保上述策略是持续有效的。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>「i茅台」商城作为茅台酒线上销售的主要入口，从诞生的第一天开始就需要考虑如何有效地应对大流量高并发的考验，这要求我们在保证数据一致性的前提下，实现系统的高性能和高可用，其中高性能意味着更快的响应时间和更大的吞吐量，可以同时为更多的用户提供流畅的服务，而高可用则意味着系统需要在面临故障或异常情况时仍然保持可用性。</p>
<p>为了实现系统的高性能和高可用，我们需要结合业务诉求、产品运营情况及系统现状进行分析，综合选取一些性能优化技术与高可用系统的设计方法，使系统在性能、可用性、安全性、可维护性等方面保持一种最佳的平衡状态。</p>
<p>本质上，系统的架构和设计就是权衡和取舍的过程，权衡性能与可用性、成本与性能、安全性与便利性、扩展性与复杂性，不同的系统可能需要不同的权衡，本文希望通过这些实际的案例帮助大家更好地理解这些技术和策略以及背后的权衡过程，从而可以更好地应用在我们日常的设计与开发过程中。</p>

    
    
  </div>

  

  

</article>
  
    
  <nav class="pagination">  
      
      
      <a class="next" href="/page/2/">  
        <span class="next-text">下一页</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  
</section>
        </div>
          

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:1050886654@qq.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/yyf1050886654" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2024 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">Yifan Yang</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    

  







<script type="text/javascript" src="/lib/jquery"></script>



<script type="text/javascript" src="/lib/slideout"></script>



<script type="text/javascript" src="/lib/fancybox"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>