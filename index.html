<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/default" title="YYF's Blog" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://yyf1050886654.github.io/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>YYF&#39;s Blog</title>

<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">YYF&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/collect/">
      <li class="mobile-menu-item">
        
        
        收藏              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">YYF's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/collect/">  
              
              
              收藏  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <section id="posts" class="posts">
  
  
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/03/22/%E8%BD%ACgo%E8%AE%A1%E5%88%92day1-go%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">ProjectMygo!!!!!-go的基本语法</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-03-22
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>实习了一段时间深感java已经不太行了，转go才是出路</p>
</blockquote>
<p><img src="/../img/golang/learn/img.png" alt="go"></p>
<h1 id="变量，结构与函数"><a href="#变量，结构与函数" class="headerlink" title="变量，结构与函数"></a>变量，结构与函数</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>与java不同，go可以不显示声明变量数据类型。一般来说有：</p>
<ul>
<li>整数型int,int8,int16,int32,int64,无符号整型uint,uint8,uint16,uint32,uint64</li>
<li>浮点型：float32,float64,相当于单精度浮点型float和双精度浮点型double</li>
<li>布尔：true和false，值得一提的是bool赋初始值的时候默认false</li>
<li>字符串：string直接就是一个数据类型了，还有一个rune，后续再去了解</li>
</ul>
<p>很重要的一点是go语言的变量声明了就必须得用，而且最后不用加分号。下面是声明数据类型的例子，有:&#x3D;可以代替var进行类型推断，可以同时推断多个类型（但我觉得还是显示声明类型比较好，否则一个函数返回来怎么判断类型）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age_1 <span class="type">uint8</span> = <span class="number">31</span></span><br><span class="line"><span class="keyword">var</span> age_2 = <span class="number">32</span></span><br><span class="line">age_3 := <span class="number">33</span></span><br><span class="line">fmt.Println(age_1, age_2, age_3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age_4, age_5, age_6 <span class="type">int</span> = <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span></span><br><span class="line">fmt.Println(age_4, age_5, age_6)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name_1, age_7 = <span class="string">&quot;Tom&quot;</span>, <span class="number">30</span></span><br><span class="line">fmt.Println(name_1, age_7)</span><br><span class="line"></span><br><span class="line">name_2, is_boy, height := <span class="string">&quot;Jay&quot;</span>, <span class="literal">true</span>, <span class="number">180.66</span></span><br><span class="line">fmt.Println(name_2, is_boy, height)</span><br></pre></td></tr></table></figure>

<p>常量也是类似，可以进行类型推断，但是必须赋初始值，且一旦定义了就不能改变了，类似java中的private static final int &#x3D; 1;这种</p>
<h2 id="函数与判断结构"><a href="#函数与判断结构" class="headerlink" title="函数与判断结构"></a>函数与判断结构</h2><p>go的函数与主流编程语言类似，但是估计不分static和非静态，也是给出参数列表和返回值。但是这里可以返回多个变量，这一点应该会比java好</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> numerator <span class="type">int</span> = <span class="number">11</span></span><br><span class="line">	<span class="keyword">var</span> denominator <span class="type">int</span> = <span class="number">2</span></span><br><span class="line">	<span class="keyword">var</span> result, remainder <span class="type">int</span> = intDivision(numerator, denominator)</span><br><span class="line">	fmt.Println(result, remainder)</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intDivision</span><span class="params">(num1, num2 <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> result <span class="type">int</span> = num1 / num2</span><br><span class="line">	<span class="keyword">var</span> remainder <span class="type">int</span> = num1 % num2</span><br><span class="line">	<span class="keyword">return</span> result, remainder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的异常处理，与java中try-catch的思想不同，函数在返回的时候也会给一个error返回值，外部调用通过error是否为nil来判断函数执行是否出错。这是一个广泛使用的设计思想，后续可能需要遵守。</p>
<p>例如这里的除数为0的例子，当除数为0相当于要抛出异常，用errors包下的一个函数throw new RunTimeException()，再在主函数去判断这个error是否为空，为空说明没有抛出异常。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> numerator <span class="type">int</span> = <span class="number">11</span></span><br><span class="line">	<span class="keyword">var</span> denominator <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">	result, remainder, err := intDivision(numerator, denominator)</span><br><span class="line">	<span class="comment">//执行正常</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(result, remainder)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intDivision</span><span class="params">(num1, num2 <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">if</span> num2 == <span class="number">0</span> &#123;</span><br><span class="line">		err = errors.New(<span class="string">&quot;num1 is zero&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> result <span class="type">int</span> = num1 / num2</span><br><span class="line">	<span class="keyword">var</span> remainder <span class="type">int</span> = num1 % num2</span><br><span class="line">	<span class="keyword">return</span> result, remainder, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后提一下go的判断结构，if后面的括号必须贴着同一行，else的哪一行必须写成”} else {“，否则编译器会报错，此外switch语句不需要写break了</p>
<h1 id="数组，切片和哈希表"><a href="#数组，切片和哈希表" class="headerlink" title="数组，切片和哈希表"></a>数组，切片和哈希表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>go中的数组跟java的数组很像，但是go的数组可以操作指针。数组的大小在声明的时候就已经固定，如果想用跟ArrayList那样的动态数组，请使用slice切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> intArr [<span class="number">10</span>]<span class="type">int32</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intArr); i++ &#123;</span><br><span class="line">		intArr[i] = <span class="type">int32</span>(i + <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//左闭右开，这个就是下标为456的三个元素</span></span><br><span class="line">	fmt.Println(intArr[<span class="number">4</span>:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">//地址</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intArr); i++ &#123;</span><br><span class="line">		fmt.Println(&amp;intArr[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这里输出结果是连续的4B，说明经典数组是连续分布的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是这里数组如果传入的是形式变量，需要传地址，跟c语言一样，否则就只会改变形参</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	withAddress(&amp;arr)</span><br><span class="line">	fmt.Println(arr)<span class="comment">//[1 20 3 4 5]</span></span><br><span class="line">	noAddress(arr)</span><br><span class="line">	fmt.Println(arr)<span class="comment">//[1 20 3 4 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withAddress</span><span class="params">(a *[5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	a[<span class="number">1</span>] = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noAddress</span><span class="params">(a [5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	a[<span class="number">3</span>] = <span class="number">20</span></span><br><span class="line">	fmt.Println(a)<span class="comment">//[1 20 3 20 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切片slice"><a href="#切片slice" class="headerlink" title="切片slice"></a>切片slice</h2><p>基本上跟ArrayList的机制一样，长度和容量，如果到了设定阈值就会动态扩容。如果能够预估业务数据量，在构造slice的时候直接指定容量可以免去动态扩容的开销。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sliceDynamic()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceStatic</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> slice []<span class="type">int32</span> = []<span class="type">int32</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="comment">//length is 3, with capacity is 3</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;length is %v, with capacity is %v\n&quot;</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">	slice = <span class="built_in">append</span>(slice, <span class="number">4</span>)</span><br><span class="line">	<span class="comment">//length is 4, with capacity is 6</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;length is %v, with capacity is %v\n&quot;</span>, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">	fmt.Println(slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态方法创建</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceDynamic</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//可以指定构造长度和容量，这里构造了一个长度为3，容量为20的slice</span></span><br><span class="line">	<span class="keyword">var</span> intSlice []<span class="type">int32</span> = <span class="built_in">make</span>([]<span class="type">int32</span>, <span class="number">3</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;length is %v, with capacity is %v\n&quot;</span>, <span class="built_in">len</span>(intSlice), <span class="built_in">cap</span>(intSlice))</span><br><span class="line">	<span class="comment">//前三个元素是初始化了的，后面没有</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intSlice); i++ &#123;</span><br><span class="line">		fmt.Println(intSlice[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//就跟ArrayList一样，如果业务能够预估动态数组的长度，最好还是构造的时候就提前设定好</span></span><br><span class="line">	<span class="comment">//否则会频繁进行扩容，影响效率</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取数逻辑。左闭右开，跟java中subString类似</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicePartition</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sli := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>, <span class="built_in">len</span>(sli), <span class="built_in">cap</span>(sli), sli)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[1] ==&quot;</span>, sli[<span class="number">1</span>])</span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[:] ==&quot;</span>, sli[:])</span><br><span class="line">	<span class="comment">//sli[1]-&gt;sli[len-1]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[1:] ==&quot;</span>, sli[<span class="number">1</span>:])</span><br><span class="line">	<span class="comment">//sli[0]-&gt;sli[4-1]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[:4] ==&quot;</span>, sli[:<span class="number">4</span>])</span><br><span class="line">	<span class="comment">//sli[0]-&gt;sli[3-1]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;sli[0:3] ==&quot;</span>, sli[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>, <span class="built_in">len</span>(sli[<span class="number">0</span>:<span class="number">3</span>]), <span class="built_in">cap</span>(sli[<span class="number">0</span>:<span class="number">3</span>]), sli[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/03/04/%E7%BD%91%E6%98%93KM%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB-%E5%B0%8FP%E8%80%81%E5%B8%88%E6%9C%8D%E5%8A%A1GC%E5%8D%A1%E9%A1%BF%E5%AE%9A%E4%BD%8D%E8%A7%A3%E5%86%B3/">网易KM社区分享-小P老师服务GC卡顿定位解决</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-03-04
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>小P老师作为有道AI大模型的重点服务，稳定性与低延迟至关重要。但随着开学季到来，接口流量增加，服务偶现请求延迟升高和GC卡顿异常重启现象。<br>本文总结上述问题的排查思路及定位过程，相信对遇到内存泄漏、CPU升高、JVM GC异常等问题的小伙伴，有借鉴意义。</p>
</blockquote>
<h1 id="一、背景和现象"><a href="#一、背景和现象" class="headerlink" title="一、背景和现象"></a>一、背景和现象</h1><p>小P老师服务（java服务容器部署、jdk17、G1回收器）核心任务是提供教育场景下的大模型对话式问答。随着开学季到来，流量也逐渐上升，保障服务稳定性是比较重要的任务之一。</p>
<p>大模型对话式问答通常是一个流式过程，模型回答是一段一段输出给用户的，为了观察到整个模型的延时情况，大模型回答完毕的时间(total time)以及大模型每一段回答的时间(interval time)都添加了监控。</p>
<p>近期发现，小P老师服务里子曰大模型interval time的监控总是超时告警，但是子曰大模型自身的interval time监控确实正常的，同时很奇怪的是只有一个或者部分容器pod出问题。</p>
<p>这两个监控有什么区别呢？简单来说一个是A使用B时对B的监控，另外一个是B对自身的监控，所以理论来说他两监控应该基本一致才是符合预期的（抛去网络延时）。</p>
<p>从这一现象看，说明小P老师本身代码逻辑存在耗时情况或者网络有问题。</p>
<p>另外之前小P也出现过类似情况，我们使用了Huggingface去做大模型token计算，这个组件cpu占用率很多，所以按照之前惯例会查看cpu是否够用。<br><img src="/../img/netease/littleP/img.png" alt="img.png"></p>
<p><img src="/../img/netease/littleP/img_1.png" alt="img_1.png"></p>
<p>图1 容器cpu使用图</p>
<p><img src="/../img/netease/littleP/img_2.png" alt="img_2.png"></p>
<p>图2 jvm监控图</p>
<p>于是发现了图1这样的现象，在容器cpu监控图中发现在服务告警期间cpu usages（使用量）和cpu cfs throttled（抢占）有尖刺。同时也是机缘巧合，想看看jvm里cpu使用占用率多少，于是在图2（黄色线是分配的内存、绿色线是使用的内存)发现了比较重要的一个信息，jvm在这期间eden区分配降低，old区使用、分配激增，维持了一段时间后就自行恢复了。于是我便去查看了一段时间内的GC日志</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[2024-10-23T20:23:56.727+0800] GC(77) Pause Young (Normal) (G1 Evacuation Pause)</span><br><span class="line">[2024-10-23T20:23:56.727+0800] GC(77) Using 1 workers of 1 for evacuation</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) MMU target violated: 201.0ms (200.0ms/201.0ms)</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Pre Evacuate Collection Set: 12.5ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Merge Heap Roots: 56.7ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Evacuate Collection Set: 5334.5ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Post Evacuate Collection Set: 15.4ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77)   Other: 0.5ms</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Eden regions: 482-&gt;0(63)</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Survivor regions: 17-&gt;13(63)</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Old regions: 32-&gt;32</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Archive regions: 2-&gt;2</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Humongous regions: 473-&gt;456 // 标记1</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Metaspace: 156861K(158080K)-&gt;156861K(158080K) NonClass: 139277K(139840K)-&gt;139277K(139840K) Class: 17583K(18240K)-&gt;17583K(18240K)</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) Pause Young (Normal) (G1 Evacuation Pause) 4018M-&gt;2007M(6144M) 5419.626ms // 标记2</span><br><span class="line">[2024-10-23T20:24:02.147+0800] GC(77) User=5.08s Sys=0.20s Real=5.42s // 标记3</span><br></pre></td></tr></table></figure>

<p>确实发现了异常的点，标记1可以看出Humongous regions数量非常多且这一次GC并没有回收该区域的内容。(Normal GC是会回收Humongous区域的)</p>
<p>标记2可以看出整个GC耗时大概5.4s，当然从标记3可以更清楚的看出GC耗时，所以我们猜测子曰大模型interval time告警可能和GC耗时过久有关系。</p>
<p>至此我们整合一下问题现象：</p>
<ul>
<li>小P老师服务对子曰大模型的延时监控发生告警，且与子曰大模型自身监控不一致</li>
<li>只有一部分pod有问题</li>
<li>告警期间服务cpu使用率激增</li>
<li>告警期间jvm内存eden区域分配减少，old区域使用、分配激增，一段时间后恢复</li>
</ul>
<p>Humongous regions回收不明显，GC停顿过长</p>
<p>根据上述现象，我们可以判断出服务延时告警时和GC有关系，也就是需要从内存的角度来分析为什么GC会停顿这么久，可以算是一个切入点。</p>
<p>分析内存有一个得力工具<a target="_blank" rel="noopener" href="https://eclipse.dev/mat/">MemeoryAnayzer(MAT)</a>，接下来会先重点介绍一下这个工具，同时也会介绍在jdk17中的G1垃圾回收器。当然如果对此熟悉的可以直接跳过看<a target="_blank" rel="noopener" href="https://km.netease.com/v4/section/tm599/detail/blog/234938#4">定位过程</a>。</p>
<h1 id="二、Garbage-First-G1-垃圾回收器"><a href="#二、Garbage-First-G1-垃圾回收器" class="headerlink" title="二、Garbage-First (G1) 垃圾回收器"></a>二、Garbage-First (G1) 垃圾回收器</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html#GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573">引用文章</a></p>
</blockquote>
<p>Garbage-First (G1) 垃圾收集器针主要对大内存多核的服务，目的是实现应用程序和环境在延迟和吞吐量之间的最佳平衡。</p>
<p>特点：</p>
<ul>
<li>服务堆大小大于10GB。</li>
<li>对象分配和对象移动的速度可能会随着时间的推移而发生很大变化。<blockquote>
<p>Rates of object allocation and promotion that can vary significantly over time.</p>
</blockquote>
</li>
<li>堆中存在大量碎片。</li>
<li>可预测的暂停时间目标不超过几百毫秒，避免长时间的垃圾收集暂停。</li>
</ul>
<h2 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h2><p>G1 将堆分为<strong>年轻代</strong>（young）和<strong>老年代</strong>（gen）。空间回收工作集中在最高效的年轻代上，偶尔也会在老年代进行空间回收。</p>
<p>G1 首先回收最高效区域的空间（即大部分被垃圾填充的区域，因此得名）。</p>
<p>G1 主要通过撤离（evacuation）来回收空间：在选定的内存区域找到存活对象复制到新的内存区域，并在过程中对其进行压缩。撤离完成后，先前的空间可用来重新分配。</p>
<p>G1不是实时收集器。尝试尽可能在设定的暂时时间下完成回收，但对于给定的暂停，不能保证绝对满足。</p>
<h2 id="2-2-堆布局"><a href="#2-2-堆布局" class="headerlink" title="2.2 堆布局"></a>2.2 堆布局</h2><p><img src="/../img/netease/littleP/img_3.png" alt="img_3.png"></p>
<p>图3 G1垃圾回收器</p>
<p>年轻代包含eden区域（红色）和survivor区域（红色，带“S”）。这些区域内部是连续的，但在G1中这些区域通常以非连续模式排列在内存中。old区域（浅蓝色）构成老生代。对于跨多个区域的对象，会有一个非常大的old区域（浅蓝色，带“H”），叫做Humongous区域 。</p>
<p>应用程序总是分配到年轻代，即eden区域，巨大对象被分配到old区域。</p>
<h2 id="2-3-垃圾回收周期"><a href="#2-3-垃圾回收周期" class="headerlink" title="2.3 垃圾回收周期"></a>2.3 垃圾回收周期</h2><p>G1 收集器在两个阶段之间交替。young-only阶段包括垃圾回收(garbage collections)，这个阶段会逐渐填满当前可用的内存</p>
<p>空间回收阶段是 G1 除了处理年轻代之外，还会逐步回收老生代中的空间。然后，循环从年轻代阶段重新开始。</p>
<p><img src="/../img/netease/littleP/img_4.png" alt="img_4.png"></p>
<p>图4 垃圾回收周期预览</p>
<p>以下列表详细描述了 G1 垃圾收集周期的各个阶段、暂停以及阶段之间的转换：</p>
<ol>
<li><p>仅年轻代阶段（Young-only phase）：此阶段以Normal young collections收集开始，会将对象提升到老年代。当老年代占用率达到某个阈值时，Young-only phase和Space-reclamation phase之间的过渡就开始了。此时，G1 会执行Concurrent Start young collection，而不是Normalyoung collections。</p>
<ul>
<li><p>Concurrent Start：这种类型的收集除了执行常规Normalyoung collections，还启动标记过程。并发标记确定old区域中的是否可以被回收。在收集标记尚未完全完成时，可能会发生Normalyoung collections。</p>
</li>
<li><p>Remark：此这段会完成重新标记。</p>
</li>
<li><p>Cleanup：这个阶段决定是否进行Space-reclamation phase。如果确定进行Space-reclamation phase，那么Young-only phase就会进行一次Prepare Mixed young collection.</p>
</li>
</ul>
</li>
<li><p>空间回收阶段（Space-reclamation phase）：此阶段会进行Mixed collections，除了young区域外，还会撤离old区域中的存活对象。当 G1 确定撤离更多老生代区域不会产生足够的可用空间时，空间回收阶段结束。</p>
</li>
</ol>
<blockquote>
<ol>
<li>Young-only phase: This phase starts with a few Normal young collections that promote objects into the old generation. The transition between the young-only phase and the space-reclamation phase starts when the old generation occupancy reaches a certain threshold, the Initiating Heap Occupancy threshold. At this time, G1 schedules a Concurrent Start young collection instead of a Normal young collection.</li>
</ol>
</blockquote>
<blockquote>
<ul>
<li>Concurrent Start : This type of collection starts the marking process in addition to performing a Normal young collection. Concurrent marking determines all currently reachable (live) objects in the old generation regions to be kept for the following space-reclamation phase. While collection marking hasn’t completely finished, Normal young collections may occur. Marking finishes with two special stop-the-world pauses: Remark and Cleanup.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Remark: This pause finalizes the marking itself, performs global reference processing and class unloading, reclaims completely empty regions and cleans up internal data structures. Between Remark and Cleanup G1 calculates information to later be able to reclaim free space in selected old generation regions concurrently, which will be finalized in the Cleanup pause.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Cleanup: This pause determines whether a space-reclamation phase will actually follow. If a space-reclamation phase follows, the young-only phase completes with a single Prepare Mixed young collection.</li>
</ul>
</blockquote>
<blockquote>
<ol start="2">
<li>Space-reclamation phase: This phase consists of multiple Mixed collections that in addition to young generation regions, also evacuate live objects of sets of old generation regions. The space-reclamation phase ends when G1 determines that evacuating more old generation regions wouldn’t yield enough free space worth the effort.</li>
</ol>
</blockquote>
<p>空间回收后，收集周期将以另一个年轻阶段重新启动。作为兜底，如果应用程序在收集活跃度信息时内存不足，G1 将像其他收集器一样执行就会执行Full</p>
<h2 id="2-4-垃圾回收阶段和回收集"><a href="#2-4-垃圾回收阶段和回收集" class="headerlink" title="2.4 垃圾回收阶段和回收集"></a>2.4 垃圾回收阶段和回收集</h2><blockquote>
<p>garbage Collection Pauses and Collection Set</p>
</blockquote>
<p>G1执行垃圾收集和空间回收是在stop-the-world pauses时间内完成的，存活的对象会从堆的一个区域移动到另一个区域，并且对这些对象的引用也会调整。</p>
<p>对于non-humongous的移动：</p>
<ul>
<li>年轻一代（eden和survivor）的对象被复制到survivor区域或old区域，取决于它们的年龄。</li>
<li>来自old的对象被复制到其他old</li>
</ul>
<p>对于大对象来说，除非被回收不然永远不会被移动。</p>
<p>对于回收集（collection set）：</p>
<ul>
<li>在 Young-Only ，回收集仅由年轻一代的区域以及可能被回收的巨大区域组成。</li>
<li>在空间回收（Space-reclamation）阶段，回收集由年轻代中的区域、包含可能被回收的对象的巨大区域、以及来自收集集合候选区域的一些老生代区域组成。</li>
</ul>
<p>G1 在并发周期（concurrent cycle）内准备回收集候选区域。在Remark pause，G1 选择大量闲置空间的低利用率区域。然后在 Remark 和Cleanup pause之间并发准备这些区域以供以后收集使用。Cleanup pause根据效率对准备的结果进行排序。更高效的区域是说，有更多的空间并且回收的时间更少。mixedcollections会更喜欢这些区域。</p>
<h1 id="三、MemeoryAnayzer-MAT"><a href="#三、MemeoryAnayzer-MAT" class="headerlink" title="三、MemeoryAnayzer(MAT)"></a>三、MemeoryAnayzer(MAT)</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://eclipse.dev/mat/">https://eclipse.dev/mat/</a></p>
</blockquote>
<h2 id="3-1-重要概念"><a href="#3-1-重要概念" class="headerlink" title="3.1 重要概念"></a>3.1 重要概念</h2><h3 id="3-1-1-可达性"><a href="#3-1-1-可达性" class="headerlink" title="3.1.1 可达性"></a>3.1.1 可达性</h3><p><strong>可达</strong></p>
<p>这个对象仍然有地方引用着他</p>
<p><strong>不可达</strong></p>
<p>这个对象没有任何对象被引用</p>
<h3 id="3-1-2-Shallow-与Retained-Heap的区别"><a href="#3-1-2-Shallow-与Retained-Heap的区别" class="headerlink" title="3.1.2 Shallow 与Retained Heap的区别"></a>3.1.2 Shallow 与Retained Heap的区别</h3><p><strong>Shallow</strong> 是一个对象所消耗的内存。对象每个引用需要32或64位（取决于操作系统体系结构），每个Integer需要4字节，每个Long需要8字节，等等。</p>
<blockquote>
<p>Shallow heap is the memory consumed by one object. An object needs 32 or 64 bits (depending on the OS architecture) per reference, 4 bytes per Integer, 8 bytes per Long, etc. Depending on the heap dump format the size may be adjusted (e.g. aligned to 8, etc…) to model better the real consumption of the VM.</p>
</blockquote>
<p>X的<strong>Retained set</strong>表示当X被GC垃圾回收后需要移除的对象列表</p>
<blockquote>
<p><strong>Retained set</strong> of X is the set of objects which would be removed by GC when X is garbage collected.</p>
</blockquote>
<p>X的<strong>Retained heap</strong>是Retained set里所有对象的Shallow大小</p>
<blockquote>
<p><strong>Retained heap</strong> of X is the sum of shallow sizes of all objects in the retained set of X, i.e. memory kept alive by X.</p>
</blockquote>
<p>通俗的来说，<strong>Shallow</strong> 是这个对象的大小，<strong>Retained heap</strong>是这个对象被回收之后内存释放的大小</p>
<p><img src="/../img/netease/littleP/img_5.png" alt="img_5.png"></p>
<p>图5 对象引用图以及Retained Set</p>
<h3 id="3-1-3-Dominator-Tree"><a href="#3-1-3-Dominator-Tree" class="headerlink" title="3.1.3 Dominator Tree"></a>3.1.3 Dominator Tree</h3><p>MAT提供了对象图的Dominator Tree，将对象引用图转化为Dominator Tree能够轻松识别保留内存的最大块以及对象之间的依赖关系，下面是一些定义</p>
<ul>
<li>X <strong>dominates</strong> Y，表示在对象图中，每一个去Y的路径上都需要经过X。</li>
<li>X是Y的<strong>immediate dominator</strong> ，表示X是距离Y最近的支配者</li>
<li><strong>dominator tree</strong> 是由对象图直接构建而来，能够展现一个对象的immediate dominator</li>
</ul>
<p>图6是将对象图（左侧）构建为<strong>dominator tree</strong> （右侧）</p>
<p><img src="/../img/netease/littleP/img_6.png" alt="img_6.png"></p>
<p>图6 对象引用图以及Retained Set</p>
<p>通俗的来说，X dominates Y表示，如果X被回收那么Y一定被回收。但我们常说的引用，如果X引用Y，那么Y是不一定会被回收的，因为Y有可能被Z引用。这就是为什么MAT引入 <strong>Dominator</strong>这个概念。</p>
<h2 id="3-2-常用功能"><a href="#3-2-常用功能" class="headerlink" title="3.2 常用功能"></a>3.2 常用功能</h2><h3 id="3-2-1-Histogram"><a href="#3-2-1-Histogram" class="headerlink" title="3.2.1 Histogram"></a>3.2.1 Histogram</h3><p>Histogram列举出每一个class的对象数量以及他的shallow size和retained size，可以快速找出大的对象类</p>
<p><img src="/../img/netease/littleP/img_7.png" alt="img_7.png"></p>
<p>图7 Histogram列表</p>
<p>默认情况下retained size展示的是估算值，也可通过计算才获取他的准确值。</p>
<p><img src="/../img/netease/littleP/img_11.png" alt="img_11.png"></p>
<p>图8 Histogram计算准确retained size</p>
<p>可以查看对象被谁引用或者他又引用了谁</p>
<p><img src="/../img/netease/littleP/img_10.png" alt="img_10.png"></p>
<p>图9 Histogram查看引用关系</p>
<p><img src="/../img/netease/littleP/img_9.png" alt="img_9.png"></p>
<p>图10 Histogram查看引用关系结果</p>
<p>Histogram默认是通过class是分组的，也可以根据包或者加载器</p>
<p><img src="/../img/netease/littleP/img_8.png" alt="img_8.png"></p>
<p>图11 Histogram通过其他类型分组</p>
<h3 id="3-2-2-Dominator-Tree"><a href="#3-2-2-Dominator-Tree" class="headerlink" title="3.2.2 Dominator Tree"></a>3.2.2 Dominator Tree</h3><p><strong>Dominator tree</strong>展示了在堆中最大的对象列表。X对象的下一级表示，X被回收之后需要被垃圾回收的对象列表。（也就是X直接支配的对象）同样也可以按类加载器、包进行分组。</p>
<blockquote>
<p>The next level of the tree lists those objects that would be garbage collected if all incoming references to the parent node were removed.</p>
</blockquote>
<p><img src="/../img/netease/littleP/img_12.png" alt="img_12.png"></p>
<p>图12 Dominator Tree</p>
<p>以上图为例，占用堆内存最大的是TaskThread的http-no-8080-exec-2线程，其本身大小是Shallow Heap是120字节，Retained Heap是2417669960字节，占用整个堆内存94.90%。图中将AspectJExpressionPointcut展开，表示当AspectJExpressionPointcut被内存回收之后，展开列表里的所有对象都会被回收，也就是他的retained set</p>
<h3 id="3-2-3-Immediate-Dominators"><a href="#3-2-3-Immediate-Dominators" class="headerlink" title="3.2.3 Immediate Dominators"></a>3.2.3 Immediate Dominators</h3><p>可以快速找出当前这组（类&#x2F;对象）的所有immediate dominator（直接支配者）</p>
<p><img src="/../img/netease/littleP/img_13.png" alt="img_13.png"></p>
<p>图13 Histogram找某个类的immediate dominator</p>
<p>下列展现支配Object[]的类列表</p>
<p><img src="/../img/netease/littleP/img_14.png" alt="img_14.png"></p>
<p>图14 Object[]类的immediate dominator</p>
<p>其中所选的那一行表示，TaskThread一共有37个对象，其中支配了133个Object[]，并且TaskThread的本身对象大小(shallow size)是4440bytes，他支配的Object[]是2147491680bytes的大小</p>
<h3 id="3-2-4-Leak-report"><a href="#3-2-4-Leak-report" class="headerlink" title="3.2.4 Leak report"></a>3.2.4 Leak report</h3><p>Leak report会列举出可能存在内存泄漏的点，以及发生的栈信息位置</p>
<p><img src="/../img/netease/littleP/img_15.png" alt="img_15.png"></p>
<p>图15 Leak report</p>
<h1 id="四、定位过程"><a href="#四、定位过程" class="headerlink" title="四、定位过程"></a>四、定位过程</h1><p>根据在第一节所观察到的问题现象，我们从内存角度来分析GC停顿之间为何这么久？按照惯例，通常都会看一下内存中的大对象，因为大对象一般是造成内存出现问题的罪魁祸首，并且大对象也是最容易发现的。</p>
<h2 id="4-1-查看大对象"><a href="#4-1-查看大对象" class="headerlink" title="4.1 查看大对象"></a>4.1 查看大对象</h2><blockquote>
<p>jmap -hsito [pid] | head -n [num]</p>
</blockquote>
<p><img src="/../img/netease/littleP/img_16.png" alt="img_16.png"></p>
<p>图16 小P老师服务某时刻大对象</p>
<p>大部分服务大对象前列就是byte、int等基本类型（不同的jdk版本可能会不同），也看不出什么门道。</p>
<p>通常先重点关注项目自己的包，再看一些引用的包。图16已经圈出了一些比较可疑的对象，但类比了同类稳定服务，第10行对象也是存在且现象一致的，于是就暂时排除他的嫌疑。</p>
<p>接下来就是12、13行这两个对象，他们用来做流式场景下线程之间上下文的自动传递，在github上看有人也提出了使用该组件的<a target="_blank" rel="noopener" href="https://github.com/micrometer-metrics/context-propagation/issues/148">内存问题</a>，我们把他列为可疑对象。</p>
<p>再接着就是20行这个对象，他是之前讲到的<a target="_blank" rel="noopener" href="https://huggingface.co/">Huggingface</a>组件，用来做大模型token计算。这个组件cpu占用率很高（之前性能自测过，图17）。那有没有可能在某个时刻计算量很大导致cpu激增，而容器分配的cpu不够用（而我们也确实发生了cpu抢占的情况），导致长期持有jvm对象而无法回收带来的GC卡顿，所以我也把他列为了可疑对象。</p>
<p>接下来我们来验证猜想。</p>
<p><img src="/../img/netease/littleP/img_17.png" alt="img_17.png"></p>
<p>图17 Huggingface组件性能测试cpu、内存使用情况</p>
<h3 id="4-1-1-验证猜想"><a href="#4-1-1-验证猜想" class="headerlink" title="4.1.1 验证猜想"></a>4.1.1 验证猜想</h3><p>我们将图16中，12、13行对象涉及的组件以及20行对象涉及的组件，分别打开&#x2F;关闭来做性能测试，看 GC和jvm是否有明显变化，但当时并没有发现带来明显的jvm变化以及GC卡顿问题。那么问题可能出现在其他大对象上，这时候就需要把堆内存dump下来做分析了。</p>
<h2 id="4-2-内存dump"><a href="#4-2-内存dump" class="headerlink" title="4.2 内存dump"></a>4.2 内存dump</h2><p>根据我们之前观察的现象，old区域激增，一段时间后回落，这不太符合内存泄漏的现象，可能就是大对象被长期持有无法释放，于是在dump内存时，选择将堆里的对象全部dump而不仅仅是存活的对象。</p>
<blockquote>
<p>jmap -dump:live,format&#x3D;b,file&#x3D;dump.hprof [pid]</p>
</blockquote>
<h2 id="4-3-使用MAT工具分析"><a href="#4-3-使用MAT工具分析" class="headerlink" title="4.3 使用MAT工具分析"></a>4.3 使用MAT工具分析</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://eclipse.dev/mat/">下载地址</a></p>
</blockquote>
<p>注意一般堆文件多大，MAT内存就需要分配多大，修改方式<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45859054/article/details/131096947">参考</a>。</p>
<p>MAT工具通常我们可以使用他从这几个角度分析：</p>
<ul>
<li>堆内存中的大对象有些什么？</li>
<li>这些大对象为什么没被回收？看他的支配者：immediate Dominators，看他的GC root</li>
<li>这些大对象为什么这么大？看他支配了谁：retained set</li>
</ul>
<h3 id="4-3-1-导入堆文件"><a href="#4-3-1-导入堆文件" class="headerlink" title="4.3.1 导入堆文件"></a>4.3.1 导入堆文件</h3><p><img src="/../img/netease/littleP/img_18.png" alt="img_18.png"></p>
<p>图18 堆文件导入示意图</p>
<h3 id="4-3-2-查看大对象"><a href="#4-3-2-查看大对象" class="headerlink" title="4.3.2 查看大对象"></a>4.3.2 查看大对象</h3><p>使用Histogram查看大的对象（类），根据Retained Heap来排序（点击Retained Heap按钮就可以排序）</p>
<p><img src="/../img/netease/littleP/img_19.png" alt="img_19.png"></p>
<p>图19 堆文件大的对象（类）列表</p>
<p>发现最大的类是java.lang.object[]，是一个数组，于是按照刚才思路我们先看他为什么没被回收？就看他的支配者。</p>
<h3 id="4-3-3-查看大对象支配者"><a href="#4-3-3-查看大对象支配者" class="headerlink" title="4.3.3 查看大对象支配者"></a>4.3.3 查看大对象支配者</h3><p>尝试看下这个大对象的支配者，看看是不是因为这个支配者应该被回收但是没被回收。</p>
<p>图20发现java.lang.object[]最大的支配者是TaskThread这个类，一共有37个对象实例，支配了133个java.lang.object[]，TaskThread类本身大小是4440bytes，支配的对象java.lang.object[]大小是2147491680bytes。</p>
<p>其实看到这里已经没有意义了，因为他是处理http请求的线程，是不可能被回收的，但我们看一下这个TaskThread的GC Root ，看是否是被不小心创建出来的而没释放。</p>
<p><img src="/../img/netease/littleP/img_20.png" alt="img_20.png"></p>
<p>图20 java.lang.object[]的支配者</p>
<h3 id="4-3-4-查看GC-root"><a href="#4-3-4-查看GC-root" class="headerlink" title="4.3.4 查看GC root"></a>4.3.4 查看GC root</h3><p>一般来说查看Gc root时都会选择 exclude weak&#x2F;soft references，因为这两个引用肯会被GC掉，这是用来查内存泄漏的，但我们场景是对象是被长时间持有段时间无法回收，而不是一直无法回收。所以这里选择展现了所有的references。</p>
<p><img src="/../img/netease/littleP/img_21.png" alt="img_21.png"></p>
<p>图21 查看TaskThreadGC root示意图</p>
<p>从图22来，TaskThread都是tomcat创建的线程用来处理http请求的，http-nio-8080-exec-2支配了很大的对象，那就是刚才java.lang.object[]，这种被线程支配的对象，大概率是临时变量，也就是方法栈里创建出来的变量，http-nio-8080-exec-2是不可能被回收的。</p>
<p><img src="/../img/netease/littleP/img_22.png" alt="img_22.png"></p>
<p>图22 TaskThreadGC root</p>
<p>但是临时变量的回收，会在方法执行完，对他引用没有了之后进行。因为我们dump某一个时刻的堆栈信息，可能线程没有执行完，没被回收也是正常的。但是在http所有的线程中，只有这个线程持有很大的对象明显是不合理。于是我接着看 java.lang.object[]对象为什么这么大？</p>
<h3 id="4-3-5-查看retained-set"><a href="#4-3-5-查看retained-set" class="headerlink" title="4.3.5 查看retained set"></a>4.3.5 查看retained set</h3><p><img src="/../img/netease/littleP/img_23.png" alt="img_23.png"></p>
<p>图23 查看java.lang.object[]Retained Set示意图</p>
<p>查看java.lang.object[]Retained Set可以看出他支配了哪些对象&#x2F;类，就可以知道他为什么这么大（retained set是包含本身的）</p>
<p><img src="/../img/netease/littleP/img_24.png" alt="img_24.png">图22.png</p>
<p>图24 java.lang.object[]Retained Set</p>
<p>从图24可以看出，在其所有支配的对象中，其本身是最大的，到这里好像陷入了死结。</p>
<p>这个对象被谁支配？是一个线程。这个对象为什么这么大？是因为他本身就很大。</p>
<p>但回想起刚才说的，这个对象被http线程支配，因为线程没有执行完，引用没消失所以一直存在，于是我就想能不能看一下这个线程的栈信息，正好MAT中也有这样的功能。</p>
<h3 id="4-3-6-查看栈信息"><a href="#4-3-6-查看栈信息" class="headerlink" title="4.3.6 查看栈信息"></a>4.3.6 查看栈信息</h3><p><img src="/../img/netease/littleP/img_25.png" alt="img_25.png"></p>
<p>图25 所有线程的栈信息</p>
<p>从图25来看，http-nio-8080-exec-2占用了很大的retained heap，就接着点开来看就是整个线程的堆栈情况（不排序的话默认就是执行路径）</p>
<p><img src="/../img/netease/littleP/img_26.png" alt="img_26.png"></p>
<p>图26 http-nio-8080-exec-2堆栈信息</p>
<p>看堆栈信息，一般来说是从上到下找到首个业务代码进行分析，从图26可以看出从业务代码ChatManagerImpl.java:300处添加一个元素到列表，最后触发了容器扩容，最终导致OutOfMemoryError。并且这个线程在执行copyOf时持有很大的内存大小Max Local Retained Heap（本地变量保留大小），已经定位到业务代码了，接下来就根据业务代码去看看原因。</p>
<h3 id="4-3-7-跟踪业务代码"><a href="#4-3-7-跟踪业务代码" class="headerlink" title="4.3.7 跟踪业务代码"></a>4.3.7 跟踪业务代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ChatInfoDO&gt; <span class="title function_">getChatInfoHistory</span><span class="params">(String userId, String taskId, Long parentChatId,</span></span><br><span class="line"><span class="params">                                           Integer groupLevelCount)</span> <span class="keyword">throws</span> LlmBusinessException &#123;</span><br><span class="line">   <span class="comment">// 根据chat_group_level粗筛（只取最近的chatCount个level）</span></span><br><span class="line">   List&lt;ChatInfoDO&gt; chatInfoDOList = chatInfoDOMapper.selectChatHistory(userId, taskId, parentChatId,</span><br><span class="line">           groupLevelCount);</span><br><span class="line">   <span class="keyword">if</span> (chatInfoDOList == <span class="literal">null</span> || chatInfoDOList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LlmBusinessException</span>(ErrorCode.USER_WRONG_CHAT_HISTORY);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 根据 parentChatId 串起 chatHistory 返回，此时是逆序的</span></span><br><span class="line">   Map&lt;Long, ChatInfoDO&gt; chatIdMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (ChatInfoDO chatInfoDO : chatInfoDOList) &#123;</span><br><span class="line">      chatIdMap.put(chatInfoDO.getChatId(), chatInfoDO);</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;ChatInfoDO&gt; history = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="type">Long</span> <span class="variable">chatId</span> <span class="operator">=</span> parentChatId;</span><br><span class="line">   <span class="comment">// 逆序查找，从最后一条对话chatId开始，继续条件：chatId=当前parentChatChatId（子节点找父节点）</span></span><br><span class="line">   ChatInfoDO chatInfoDO;</span><br><span class="line">   <span class="keyword">while</span> ((chatInfoDO = chatIdMap.get(chatId)) != <span class="literal">null</span>) &#123;</span><br><span class="line">      history.add(chatInfoDO); <span class="comment">// 标记1  问题代码处</span></span><br><span class="line">      chatId = chatInfoDO.getParentChatId();</span><br><span class="line">   &#125;</span><br><span class="line">   Collections.reverse(history);</span><br><span class="line">   <span class="keyword">return</span> history;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析可疑点之前，我先简单描述下这段代码所做的事情。</p>
<p>在小P老师对话场景中，是采用一问一答的形式，例如下方图27所示，蓝色表示用户，淡红色表示系统回答。</p>
<p><img src="/../img/netease/littleP/img_27.png" alt="img_27.png"></p>
<p>图27 大模型对话示意图</p>
<p>为了让模型更好的理解用户问题，通常我们会像图26所示，携带所有的历史消息送给模型。当前业务代码就是找到用户的历史对话然后构建起来提供给模型。</p>
<p><img src="/../img/netease/littleP/img_28.png" alt="img_28.png"></p>
<p>图28 携带历史对话示意</p>
<p>如图29所示，我们给每个消息两个属性id&#x3D;xxx、parendId&#x3D;xxx，这样来呈现一种父子关系，用户输入消息时生成id，并通过传入的parentId&#x3D;3向上寻找消息，找到id&#x3D;3的消息，循环寻找，直到parentId&#x3D;-1</p>
<p><img src="/../img/netease/littleP/img_29.png" alt="img_29.png"></p>
<p>图29 构建历史对话示意图</p>
<p>回过头我们来看业务代码，标记1就是栈信息所示的位置，这处代码其实有一个很明显的风险点while循环构建链表，同时结合我们的对象是一个大数组，那这个while循环就很可疑。结合刚才业务代码逻辑的分析，我当时想到了以下可疑点：</p>
<ul>
<li>一个消息的id和parentId一致发生了循环，导致死循环</li>
<li>chatInfoDOMapper.selectChatHistory()从数据库查出来的数据量很大</li>
</ul>
<p>接着看了数据库查询语句chatInfoDOMapper.selectChatHistory()不可能发生查出很多数据的问题。</p>
<p>那么现在最可疑的就是消息循环了，本来分享到这就结束了。要去查数据库看看有没有id和parentId重复的数据了，但因为当时是和同事们在分享这篇文章，同事们就提出了两个问题。</p>
<ul>
<li>有没有可能是两个消息发生了循环？消息A找到了消息B，消息B又找回了消息A。</li>
<li>MAT可以看这个链表里有啥吗？以及能不能看这个对象的值，不然查库可能会很慢。</li>
</ul>
<p>很显然第一个是很有可能的。 第二个问题因为对MAT还是初次使用所以不太了解，但在同事的引导下，我们尝试看链表里具体的数据是什么样子。</p>
<p>4.3.8 查看栈具体用了哪些对象<br><img src="/../img/netease/littleP/img_30.png" alt="img_30.png"></p>
<p>图30 栈的临时变量</p>
<p>如图30所示，我们继续点击业务代码方法栈点，就可以看到这个方法栈点引用了（注意是引用不是支配）HashMap、ArrayList、ChatInfoDO，因为根据业务代码分析可能是ArrayList膨胀，所以继续点击ArrayList可以看他引用的元素elementData，包括了object[]、ChatInfoDO。这里问题就展现出来了，如图30红框所示，ArrayList奇数位置[1],[3],[5]…都是ChatInfoDO_A，偶数位置[0],[2],[4]…都是ChatInfoDO_B，并且再次点击ChatInfoDO_A和ChatInfoDO_B就可以看到他们的chatId、parentChatId，这时候看到他们确实互为引用了，如图31所示。</p>
<p><img src="/../img/netease/littleP/img_31.png" alt="img_31.png"></p>
<p>图31 互为引用的消息</p>
<p>至此问题原因顺利找到。</p>
<p>后续分析还发现，不仅是两个消息会循环，多个消息也会循环。历史消息构建其实是单链表从尾到头的构建过程，找到头节点就停止，但某个位置产生了环就导致悲剧。所以得出一点建议：之后while的使用一定得注意！！！。</p>
<p>虽然原因找到了，但为什么产生重复的Id呢？我们设计的Id可是唯一的！于是我们又分析了生成Id的代码。</p>
<p>4.4 分析ID重复的原因</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDGeneratorUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">cycleNumber</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环下限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">startNumber</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环上限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">stopNumber</span> <span class="operator">=</span> <span class="number">99999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个当前时间的long类型数字（非线程安全）</span></span><br><span class="line"><span class="comment">     * 理论上每毫秒可生成id 89999 个</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getNextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cycleNumber &lt; stopNumber) &#123;</span><br><span class="line">            cycleNumber++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cycleNumber = startNumber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() + cycleNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为小P老师服务是分布式服务，有多个节点，需要保障消息唯一Id。常见唯一Id方式很多：UUID、雪花等等，但基于我们的考虑并没有使用上边的方式。</p>
<p>当时在设计唯一Id时主要考虑以下几点：</p>
<ul>
<li>具有时间性</li>
<li>生产效率高</li>
<li>符合数字需求<br>于是就通过时间戳来体现时间性，在加一个全局唯一的循环数，这样是不是具有符合上述的要求了？</li>
</ul>
<p>但在大家的分析下发现了这样一个BUG，假如当前时间是10，随机数是10，过了一段时间后当前时间是19，随机数已经发生循环变成了1，这样两个Id是不是都一样变成20了（但概率确实很低！！！）</p>
<p>到此终于真相大白了！</p>
<h1 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h1><p>分析过程其实是坎坷的，总结的时候，已变成已知答案寻找答案的过程，所以看起来会很顺畅。</p>
<p>问题千奇百怪，分析过程也千奇百怪，但总结了一些小经验。</p>
<ul>
<li>监控jvm内存或者可以观察jvm是比较重要的</li>
<li>GC日志也是比较重要的日志</li>
<li>内存问题一般可以从大对象着手，分析对象为什么这么大？为什么没被回收？</li>
<li>MAT的Histogram、Dominator Tree看大对象</li>
<li>MAT的Immediate Dominators看大对象被谁直接支配而没回收</li>
<li>MAT的retained set看大对象支配了哪些，导致他这么大</li>
<li>MAT的线程分析，来分析线程持有对象特别大的情况，分析栈信息</li>
</ul>
<p>当然，在问题处理的过程中，还有一些不可忽视的细节操作，对排查问题至关重要。</p>
<ul>
<li>如何抓取偶现问题的JVM dump现场？</li>
<li>只有内存泄漏才会引起内存使用率升高吗？</li>
<li>如何分析GC日志数据，推断问题原因？</li>
</ul>
<p>基于篇幅有限，本文不再赘述，后续会编写系列KM文章，为大家带来实践中走过的弯路与总结的小技巧。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/03/04/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-%E5%AE%8C%E7%BB%93%E7%AF%87/">网易牛马日志-完结篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-03-04
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>过年以后回来做的东西太杂了，想到哪说哪吧。</p>
</blockquote>
<h2 id="需求12：出海项目搜索功能"><a href="#需求12：出海项目搜索功能" class="headerlink" title="需求12：出海项目搜索功能"></a>需求12：出海项目搜索功能</h2><blockquote>
<p>这个得包装了，好不容易一个可能的高并发C端接口，但是实际上做的很简单。</p>
</blockquote>
<h3 id="搜索V1：实际做的"><a href="#搜索V1：实际做的" class="headerlink" title="搜索V1：实际做的"></a>搜索V1：实际做的</h3><p>数据库直接like就完了，纯纯没有一丝的技术含量。</p>
<h3 id="搜索V2：包装。。。未完待续"><a href="#搜索V2：包装。。。未完待续" class="headerlink" title="搜索V2：包装。。。未完待续"></a>搜索V2：包装。。。未完待续</h3><h2 id="需求13：全球搜数据工程产品图片爬取"><a href="#需求13：全球搜数据工程产品图片爬取" class="headerlink" title="需求13：全球搜数据工程产品图片爬取"></a>需求13：全球搜数据工程产品图片爬取</h2><p>这部分只做了前段部分，用jsoup去解析标签，再getDocumentByClass去找url，图片名称和信息。</p>
<blockquote>
<p>这里也不清楚class会不会随着编译改变，但是测试下来确实是可以的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ExtraResultDTO <span class="title function_">doExtra</span><span class="params">(String domain)</span>&#123;</span><br><span class="line">    <span class="type">ExtraResultDTO</span> <span class="variable">resultDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExtraResultDTO</span>();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> getHtml(domain);</span><br><span class="line">        <span class="keyword">if</span>(html == <span class="literal">null</span> || StringUtils.isBlank(html))&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;doExtra error.html is null&quot;</span>);</span><br><span class="line">            resultDTO.setStatus(<span class="number">101</span>);</span><br><span class="line">            <span class="keyword">return</span> resultDTO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(html.contains(<span class="string">&quot;Our systems have detected unusual traffic from your computer&quot;</span>))&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;doExtra Google Pickpocket Detection Limit&quot;</span>);</span><br><span class="line">            resultDTO.setStatus(<span class="number">102</span>);</span><br><span class="line">            <span class="keyword">return</span> resultDTO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parse(html);</span><br><span class="line">        List&lt;ImageDTO&gt; images = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Elements</span> <span class="variable">divs</span> <span class="operator">=</span> doc.getElementsByClass(<span class="string">&quot;RntSmf&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element div : divs) &#123;</span><br><span class="line">            <span class="comment">//图片路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">imgUrl</span> <span class="operator">=</span> div.getElementsByTag(<span class="string">&quot;img&quot;</span>).get(<span class="number">0</span>).attr(<span class="string">&quot;src&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> div.getElementsByClass(<span class="string">&quot;qXLe6d x3G5ab&quot;</span>).get(<span class="number">0</span>).text();</span><br><span class="line">            <span class="type">String</span> <span class="variable">jumpUrl</span> <span class="operator">=</span> div.getElementsByClass(<span class="string">&quot;qXLe6d F9iS2e&quot;</span>).get(<span class="number">0</span>).text();</span><br><span class="line">            <span class="type">ImageDTO</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageDTO</span>();</span><br><span class="line">            image.setUrl(imgUrl);</span><br><span class="line">            image.setFormatUrl(imgUrl);</span><br><span class="line">            image.setAlt(desc);</span><br><span class="line">            images.add(image);</span><br><span class="line">        &#125;</span><br><span class="line">        resultDTO.setStatus(<span class="number">200</span>);</span><br><span class="line">        resultDTO.setImages(images);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;doExtra error.&quot;</span>,e.getMessage());</span><br><span class="line">        resultDTO.setStatus(<span class="number">205</span>);</span><br><span class="line">        resultDTO.setErrorMessage(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultDTO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="需求14：全球搜数据工程公司Logo爬取"><a href="#需求14：全球搜数据工程公司Logo爬取" class="headerlink" title="需求14：全球搜数据工程公司Logo爬取"></a>需求14：全球搜数据工程公司Logo爬取</h2><p>比较有挑战性的一整个链路，问题在于es里面logo字段并不是索引，所以不能用exist来查询。主要思路是查询线上有域名的公司，过滤掉有logo字段的，将无logo字段但是有域名的公司通过kafka消费到本地，然后通过爬虫将图片下载下来。</p>
<h3 id="前处理链路："><a href="#前处理链路：" class="headerlink" title="前处理链路："></a>前处理链路：</h3><p>链路：</p>
<ul>
<li>猛犸抽取线上es到hive，这一段全量数据写入hive，大概2600万。</li>
</ul>
<p><img src="/../img/netease/last/img_1.png" alt="img_1.png"></p>
<ul>
<li>然后hive -&gt;hive，通过sql来过滤掉有logo的公司域名，此外由于抽取的域名domain是从一个list里面来的，在变成字符串后有”[“和”]“，需要过滤，最后得到数据量大概1600万。</li>
</ul>
<p><img src="/../img/netease/last/img_2.png" alt="img_2.png"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">insert</span><br><span class="line">  OVERWRITE table qiye_mail_data.logo_extra_offline_domain_v1</span><br><span class="line">select</span><br><span class="line"> REPLACE(SUBSTR(</span><br><span class="line">    domain,</span><br><span class="line">    2,</span><br><span class="line">    LENGTH(domain) -2</span><br><span class="line">  ), &#x27;&quot;&#x27;, &#x27;&#x27;) as domain,</span><br><span class="line">  companyid,</span><br><span class="line"> locationdomain</span><br><span class="line">   from qiye_mail_data.logo_extra_offline_domain where logourl=&#x27;&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后猛犸任务hive-&gt;kafka，测试环境集群做消费，这才正式进入logo图片提取的链路。</li>
</ul>
<h3 id="责任链模式进行公司Logo爬取"><a href="#责任链模式进行公司Logo爬取" class="headerlink" title="责任链模式进行公司Logo爬取"></a>责任链模式进行公司Logo爬取</h3><p>首先是三种找Logo的方法，一般来说Logo都会放在浏览器的ico上，相关链接在<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42836771/article/details/112721772">csdn</a>：</p>
<ul>
<li>通过google某个api拿，这种成功率最高，但是会返回默认图片，后续需要校验md5来过滤。</li>
<li>直接在网站域名后面拼接&#x2F;favicon.ico，成功率不高，因为小公司的网页并不一定有这么规范，其次是可能会返回404的html页面，也会有默认的ico文件，所以要写一个方法过滤html和默认的md5.</li>
<li>爬虫解析，拿到domain的源码，再去解析<head>里面的<link>，然后通过正则表达式去匹配icon，成功率不高，属于是最后的底牌了。</li>
</ul>
<p>另外这里有的都是domain，意思是没有http和https的，所以都需要进行尝试，综上所述，一共得走6个链路，哪个成功了哪个就返回，很适合责任链模式。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 责任链执行</span><br><span class="line">private UploadResultBO handleLogoCrawlAndUploadChain(String domain,String locationDomain) &#123;</span><br><span class="line">    //有locationDomain的情况</span><br><span class="line">    if (StringUtils.isNotEmpty(locationDomain))&#123;</span><br><span class="line">        UploadResultBO googleStrategy = googleStrategy(locationDomain);</span><br><span class="line">        if (StringUtils.isNotBlank(googleStrategy.getUrl()))&#123;</span><br><span class="line">            return googleStrategy;</span><br><span class="line">        &#125;</span><br><span class="line">        UploadResultBO straightStrategy = straightStrategy(locationDomain);</span><br><span class="line">        if (StringUtils.isNotBlank(straightStrategy.getUrl()))&#123;</span><br><span class="line">            return straightStrategy;</span><br><span class="line">        &#125;</span><br><span class="line">        return htmlLinkTagStrategy(locationDomain);</span><br><span class="line">    &#125;</span><br><span class="line">    //无locationDomain或者失效的情况，需拼接http和https尝试</span><br><span class="line">    UploadResultBO googleStrategy = googleStrategy(HTTP_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(googleStrategy.getUrl()))&#123;</span><br><span class="line">        return googleStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO straightStrategy = straightStrategy(HTTP_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(straightStrategy.getUrl()))&#123;</span><br><span class="line">        return straightStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO htmlLinkTagStrategy = htmlLinkTagStrategy(HTTP_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(htmlLinkTagStrategy.getUrl()))&#123;</span><br><span class="line">        return htmlLinkTagStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO googleStrategyHttps = googleStrategy(HTTPS_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(googleStrategyHttps.getUrl()))&#123;</span><br><span class="line">        return googleStrategyHttps;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO straightStrategyHttps = straightStrategy(HTTPS_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(straightStrategyHttps.getUrl()))&#123;</span><br><span class="line">        return straightStrategyHttps;</span><br><span class="line">    &#125;</span><br><span class="line">    UploadResultBO htmlLinkTagStrategyHttps = htmlLinkTagStrategy(HTTPS_PREFIX + domain);</span><br><span class="line">    if (StringUtils.isNotBlank(htmlLinkTagStrategyHttps.getUrl()))&#123;</span><br><span class="line">        return htmlLinkTagStrategyHttps;</span><br><span class="line">    &#125;</span><br><span class="line">    return new UploadResultBO(StringUtils.EMPTY, LogoExtraStatusEnum.STRATEGY_FAIL.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上传到nos"><a href="#上传到nos" class="headerlink" title="上传到nos"></a>上传到nos</h3><p>调洋总的接口就完事了，然后将这个链接保存进es，良总那里会有一个同步链路将触发版本更新的数据同步到线上。最终的效果就是测试集群在消费数据，将爬取的logo的nosurl保存进es并更新版本号，最后用同步链路更新到线上。</p>
<h2 id="需求15：全球搜应用工程ai推荐理由总结"><a href="#需求15：全球搜应用工程ai推荐理由总结" class="headerlink" title="需求15：全球搜应用工程ai推荐理由总结"></a>需求15：全球搜应用工程ai推荐理由总结</h2><p>比较简单，就是多线程调用大模型api，由于需要时效性，deepseek要输出思维链所以时效性很差，不适合用在业务里面，所以用gpt。其次开一个线程池来优化并发请求，此外就是prompt优化，很简单的一个需求。</p>
<p><img src="/../img/netease/last/img.png" alt="img.png"></p>
<p>关于提示词，mentor的意思是尽量可读性高，产品词输出中文，看的会比较丝滑，但是在第一版的提示词里面海关数据基本没怎么用，后续就变为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prompt：</span><br><span class="line">根据提供的信息，总结公司的核心产品、主营类目、主要交易产品等信息，并判断分析与关键词XXXXX，XXXx的相关性，给出最终的匹配理由。输出格式：</span><br><span class="line">&quot;匹配理由&quot;:&quot;XXX&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>线程池</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadFactory</span> <span class="variable">MATCH_ANALYZE_LLM_THREAD_FACTORY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;MatchAnalyzeService-llm-pool-%d&quot;</span>).build();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">LLM_REQUEST_EXECUTOR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">20</span>,</span><br><span class="line">        <span class="number">40</span>, <span class="number">60</span> * <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">3000</span>), MATCH_ANALYZE_LLM_THREAD_FACTORY, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure></li>
<li><strong>prompt</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_PROMPT</span> <span class="operator">=</span> <span class="string">&quot;根据提供的信息，总结公司的主营产品、海关交易产品等信息，并判断分析与关键词&#123;0&#125;的相关性，给出最终的匹配理由。输出格式：\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\&quot;匹配理由\&quot;:\&quot;XXX\&quot;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;以下是公司信息：\n&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>动态组装和展示</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MatchAnalyzeResultDTO <span class="title function_">getMatchAnalyze</span><span class="params">(MatchAnalyzeParam globalSearchParam)</span> &#123;</span><br><span class="line"><span class="comment">//参数校验，id非空</span></span><br><span class="line"><span class="keyword">if</span> (globalSearchParam == <span class="literal">null</span> || StringUtils.isEmpty(globalSearchParam.getId()))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MatchAnalyzeResultDTO</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">CompanySearchBO</span> <span class="variable">companySearchBO</span> <span class="operator">=</span> companySearchService.queryById(globalSearchParam.getId(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;customsItems&quot;</span>, <span class="comment">//海关交易数据</span></span><br><span class="line">                <span class="string">&quot;htagItems&quot;</span>, <span class="comment">//公司官网</span></span><br><span class="line">                <span class="string">&quot;overviewDescription&quot;</span>, <span class="comment">//公司描述</span></span><br><span class="line">                <span class="string">&quot;detail.productList.name&quot;</span>, <span class="comment">//产品图片描述</span></span><br><span class="line">                <span class="string">&quot;keywords&quot;</span>, <span class="comment">//公司关键词</span></span><br><span class="line">                <span class="string">&quot;detail.mainProducts&quot;</span>, <span class="comment">//公司主营产品</span></span><br><span class="line">                <span class="string">&quot;brandNames&quot;</span> <span class="comment">//公司品牌信息</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//索引不存在，返回空</span></span><br><span class="line"><span class="keyword">if</span> (companySearchBO == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MatchAnalyzeResultDTO</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并搜索词和扩展词</span></span><br><span class="line">List&lt;String&gt; nearSynonymList = globalSearchParam.getNearSynonymList();</span><br><span class="line">nearSynonymList.add(globalSearchParam.getProduct());</span><br><span class="line"><span class="type">String</span> <span class="variable">trimNearSynonymList</span> <span class="operator">=</span> nearSynonymList.toString().replaceAll(<span class="string">&quot;\\[|\\]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">promptStringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(MessageFormat.format(BASE_PROMPT,trimNearSynonymList));</span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getCustomsItems() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getCustomsItems().isEmpty())&#123;</span><br><span class="line">    <span class="comment">//裁剪为10个以内，避免token超出</span></span><br><span class="line">    List&lt;String&gt; subCustomsItemsList = companySearchBO.getCustomsItems().subList(<span class="number">0</span>, Math.min(companySearchBO.getCustomsItems().size(), LIST_LENGTH_LIMIT));</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司的海关交易记录：&quot;</span>).append(subCustomsItemsList).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getHtagItems() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getHtagItems().isEmpty())&#123;</span><br><span class="line">    <span class="comment">//裁剪为10个以内，避免token超出</span></span><br><span class="line">    List&lt;String&gt; subHtagItemsList = companySearchBO.getHtagItems().subList(<span class="number">0</span>, Math.min(companySearchBO.getHtagItems().size(), LIST_LENGTH_LIMIT));</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司的官网信息：&quot;</span>).append(subHtagItemsList).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isNotEmpty(companySearchBO.getOverviewDescription()))&#123;</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司描述：&quot;</span>).append(companySearchBO.getOverviewDescription()).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品图片描述处理</span></span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getDetail() != <span class="literal">null</span> &amp;&amp; companySearchBO.getDetail().getProductList() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getDetail().getProductList().isEmpty())&#123;</span><br><span class="line">    List&lt;ProductVO&gt; productList = companySearchBO.getDetail().getProductList().subList(<span class="number">0</span>, Math.min(companySearchBO.getDetail().getProductList().size(), LIST_LENGTH_LIMIT));</span><br><span class="line">    <span class="comment">//映射为name</span></span><br><span class="line">    List&lt;String&gt; productListName = productList.stream().map(ProductVO::getName).collect(Collectors.toList());</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;产品图片描述：&quot;</span>).append(productListName).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getKeywords() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getKeywords().isEmpty())&#123;</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司关键词：&quot;</span>).append(companySearchBO.getKeywords()).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//公司主营产品处理</span></span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getDetail() != <span class="literal">null</span> &amp;&amp; companySearchBO.getDetail().getMainProducts() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getDetail().getMainProducts().isEmpty())&#123;</span><br><span class="line">    Set&lt;String&gt; mainProducts = companySearchBO.getDetail().getMainProducts();</span><br><span class="line">    List&lt;String&gt; subMainProductsList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(mainProducts).subList(<span class="number">0</span>, Math.min(mainProducts.size(), LIST_LENGTH_LIMIT));</span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司主营产品：&quot;</span>).append(subMainProductsList).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (companySearchBO.getBrandNames() != <span class="literal">null</span> &amp;&amp; !companySearchBO.getBrandNames().isEmpty())&#123;</span><br><span class="line">    List&lt;String&gt; subBrandNamesList = companySearchBO.getBrandNames().subList(<span class="number">0</span>, Math.min(companySearchBO.getBrandNames().size(), LIST_LENGTH_LIMIT));</span><br><span class="line"></span><br><span class="line">    promptStringBuilder.append(<span class="string">&quot;公司品牌信息：&quot;</span>).append(subBrandNamesList).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拼接的最终prompt</span></span><br><span class="line"><span class="type">String</span> <span class="variable">finalPrompt</span> <span class="operator">=</span> promptStringBuilder.toString();</span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(</span><br><span class="line">        () -&gt; gptGrpcWrapper.gptRequest(<span class="string">&quot;6888072&quot;</span>,<span class="string">&quot;583828445&quot;</span>,<span class="string">&quot;yangyifan12@corp.netease.com&quot;</span>,finalPrompt, GPTModelVersionEnum.GPT_4O_MINI.getVersion()), LLM_REQUEST_EXECUTOR);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) FutureResultUtil.getResult(<span class="string">&quot;match-analyze-llm-future&quot;</span>,future2,<span class="number">120</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MatchAnalyzeResultDTO</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/02/28/%E7%BD%91%E6%98%93KM%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8ERAG%E7%9A%84%E7%83%AD%E7%82%B9-AI%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">网易KM社区分享-快速搭建基于RAG的热点 AI搜索引擎</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-02-28
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>大模型的出现带来了新的技术革新，它强大的对话，分析，生成能力可以应用在音乐的很多方面。我们希望借助大模型的能力， 实现对站内外音乐热点词条内容进行抽取，分析，总结，推荐。 本文将系统的介绍我们如何基于RAG 搭建一个带前端页面的 热点AI检索功能agent<br>体验地址：<a target="_blank" rel="noopener" href="http://llm-zq.jupyter.panshi-gy.netease.com/">http://llm-zq.jupyter.panshi-gy.netease.com/</a></p>
</blockquote>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><p>大模型的出现带来了新的技术革新，它强大的对话，分析，生成能力可以应用在音乐的很多方面。我们希望借助大模型的能力， 实现对站内外音乐热点词条内容进行抽取，分析，总结，推荐。 但是:</p>
<ul>
<li>大模型对于时事热点等，幻觉能力严重，而RAG(检索增强生成)可以解决这个问题。</li>
<li>很多都离不开外部的依赖接口，无法做到完全的offline, 且当token量大之后，费用也很大， 但其实开源的很多模型如LLAMA, QWEN等都已经有非常不错的能力。而且近期流行的ollama框架， 也让个人PC也都能支持大模型生成。</li>
<li>我们希望借助开源的能力，来快速搭建一个不依赖外部接口的AI检索引擎来为我们服务， 也避免了隐私泄露的风险。</li>
</ul>
<p>它的主要特点：</p>
<ul>
<li>不依赖外部接口， 离线实现LLM生成, 检索，embedding等能力。</li>
<li>基于互联网结果进行RAG，解决模型生成幻觉的问题，尤其可以支持对于近期热点知识的总结。<br>本文主要介绍开发这个agent的框架，一些技术细节和思路，希望给大家带来一点LLM 开发的收获。效果图如下，左边是我们的agent, 输入问题描述，系统即可自动调用搜索引擎并爬取互联网的内容，并通过大模型分析总结返回给我们问题的结果。在某些情况下，甚至比KIMI的效果还要好。</li>
</ul>
<p><img src="/../img/netease/img.png" alt="img.png"></p>
<h1 id="2-框架"><a href="#2-框架" class="headerlink" title="2.框架"></a>2.框架</h1><p>总体框架如下图所示，主要包括3个子模块：</p>
<ul>
<li>(1) 检索爬取服务：根据用户搜索的热点关键词，调用自建的searxng 匿名检索服务系统, 获取top的互联网搜索引擎结果，并爬取相关网址全文内容。</li>
<li>(2) 文档召回服务：对爬取的全文内容切块，进行向量化，同时对query也进行向量化，计算query和文档的相关性，并进行排序选取top的文档切块</li>
<li>(3) 大模型生成服务。离线部署好大模型，输入相关文档和配置的prompt, 生成相关的检索答案汇总，并通过部署的streamlit前端服务返回给用户。</li>
</ul>
<p><img src="/../img/netease/img_1.png" alt="img_1.png"></p>
<p>3个模块通过langchain框架进行串联起来工作，api接口都采用fastapi进行封装， 前端展示用streamlit进行交互开发。</p>
<h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><p>基于基本的框架思路，我们前期调研了发现github已有类似的相关项目，在这些项目的基础上，我们做了一些优化。</p>
<p>LLocalSarch:<a target="_blank" rel="noopener" href="https://github.com/nilsherzig/LLocalSearch">https://github.com/nilsherzig/LLocalSearch</a></p>
<p>LangChain-SearXNG: <a target="_blank" rel="noopener" href="https://github.com/ptonlix/LangChain-SearXNG">https://github.com/ptonlix/LangChain-SearXNG</a></p>
<h2 id="3-1-检索爬取服务"><a href="#3-1-检索爬取服务" class="headerlink" title="3.1 检索爬取服务"></a>3.1 检索爬取服务</h2><p>检索爬取服务主要有两个模块。searxng检索服务 和爬虫服务</p>
<h3 id="3-1-1-searxng检索服务"><a href="#3-1-1-searxng检索服务" class="headerlink" title="3.1.1 searxng检索服务"></a>3.1.1 searxng检索服务</h3><p>SearXNG 是一个免费的互联网元搜索引擎，它聚合了来自各种搜索服务(如 google, duckduckgo等)和数据库（如wiki）的结果，但摆脱了隐私追踪。</p>
<p>当然，你也可以采用商业的搜索api 接口，比如google的Serper API ， bing的Bing Web Search API，但这不是我们的目的，我们是希望搭建一个完全没有外部依赖的检索服务。</p>
<p>请注意，搭建searxng检索需要一台非大陆的VPS，并配有ipv4地址，如果嫌麻烦，可以用公共的searxng, 但是会有限制，地址：<a target="_blank" rel="noopener" href="https://searx.space(需要fq)/">https://searx.space(需要FQ)</a></p>
<p><img src="/../img/netease/img_2.png" alt="img_2.png"></p>
<p>以下是搭建教程：</p>
<ol>
<li>第一步：安装docker, docker-copose</li>
</ol>
<p>docker安装：<a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/install/debian">https://yeasy.gitbook.io/docker_practice/install/debian</a></p>
<p>docker-copose安装：<a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/compose/install">https://yeasy.gitbook.io/docker_practice/compose/install</a></p>
<ol start="2">
<li>第二步：拉取searxng 镜像, 修改配置</li>
</ol>
<p>修改项目docker配置</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 拉取代码</span><br><span class="line">git clone https://github.com/searxng/searxng-docker.git</span><br><span class="line"># docker配置里包括3个服务，caddy 做反向代理，redis存储数据，searxng主服务</span><br><span class="line">#不做反向代理可以注释掉caddy部分， 只需要修改 searxng里的port，如： 0.0.0.0:8180:8080， 右边是设置好的容器内的端口，左边是本地端口可以改</span><br><span class="line">vim searxng-docker/docker-compose.yaml</span><br></pre></td></tr></table></figure>

<p><img src="/../img/netease/img_3.png" alt="img_3.png"></p>
<p><img src="/../img/netease/img_4.png" alt="img_4.png"></p>
<p>修改searxng主服务配置</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s|ultrasecretkey|$(openssl rand -hex 32)|g&quot; searxng-docker/searxng/settings.yml # 生成一个密钥</span><br><span class="line"># limiter: 改为false, 为true会限制你的请求频率，公开服务会开启，但是私人搭建的可以关闭</span><br><span class="line">vim searxng-docker/searxng/setting.yml</span><br></pre></td></tr></table></figure>
<p><img src="/../img/netease/img_5.png" alt="img_5.png"><br>3.第三步：启动compose 服务组</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd searxng-docker</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>第四步：关闭端口防火墙并验证，如果没有防火墙则不需要这一步</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufw allow 8180</span><br></pre></td></tr></table></figure>

<p>最后浏览器打开ip:8180,即可看到自己搭建的searxng页面并进行检索了，是不是很酷😎，没有任何广告，页面非常干净。</p>
<p><img src="/../img/netease/img_6.png" alt="img_6.png"></p>
<h3 id="3-1-2-爬虫服务"><a href="#3-1-2-爬虫服务" class="headerlink" title="3.1.2 爬虫服务"></a>3.1.2 爬虫服务</h3><p>单独searxng的结果信息量比较小，而对于LLM来说，丰富的信息意味着更准确的结果。 所以针对搜索引擎给出的相关网页，我们可以采用爬虫爬取top网页结果。 所幸，langchain（一个帮助在应用程序中使用大型语言模型的编程框架） 里就包含了相应的网页爬取模块，和文本解析模块。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># langchain 调用searxng示例, 获取top结果</span><br><span class="line">from langchain_community.utilities import SearxSearchWrapper</span><br><span class="line">s = SearxSearchWrapper(searx_host=&quot;http://localhost:8180&quot;)</span><br><span class="line">s.run(&quot;what is a large language model?&quot;)</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># langchain 爬取示例</span><br><span class="line">from langchain_community.document_loaders import AsyncChromiumLoader</span><br><span class="line">from langchain_community.document_transformers import Html2TextTransformer</span><br><span class="line">urls = [&quot;https://www.baidu.com&quot;]</span><br><span class="line">loader = AsyncChromiumLoader(urls, user_agent=&quot;MyAppUserAgent&quot;)</span><br><span class="line">docs = loader.load() # 爬取</span><br><span class="line">html2text = Html2TextTransformer()  </span><br><span class="line">docs_transformed = html2text.transform_documents(docs) # 解析抽取网页里文本</span><br><span class="line">docs_transformed[0].page_content[0:500]</span><br></pre></td></tr></table></figure>

<p>这里面在实践中存在几个主要问题：</p>
<ol>
<li>searxng的top结果中可能存在无法访问的(大陆)，比如wiki 等，需要额外处理过滤。 这里我采用的是pac方式。过滤不能访问的网址</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># wget https://raw.githubusercontent.com/petronny/gfwlist2pac/master/gfwlist.pac</span><br><span class="line">import pacparser</span><br><span class="line">pacparser.init()</span><br><span class="line">pacparser.parse_pac(&#x27;gfwlist.pac&#x27;)</span><br><span class="line"></span><br><span class="line">def is_direct(url):</span><br><span class="line">ret =  pacparser.find_proxy(url)</span><br><span class="line">return &quot;DIRECT&quot; == ret</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">print(is_direct(&quot;www.baidu.com&quot;))</span><br><span class="line">print(is_direct(&quot;www.google.com&quot;))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可能存在超时的问题，有些网站链接速度非常慢，原本的langchain 爬取模块不支持超时，需要自己在外面额外封装一层超时控制。或者采用httpx的包进行批量爬取。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import httpx</span><br><span class="line">from typing import List, Optional,Tuple</span><br><span class="line">import asyncio</span><br><span class="line">headers = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def get_result(url: str):</span><br><span class="line">if not is_direct(url): # 非直连</span><br><span class="line">async with httpx.AsyncClient(proxy=&#x27;socks5://127.0.0.1:1080&#x27;) as client:</span><br><span class="line">try:</span><br><span class="line">response = await client.get(url,headers=headers,timeout=10.0)  # 设置超时</span><br><span class="line">return url, response</span><br><span class="line">except httpx.RequestError:</span><br><span class="line">return url, None</span><br><span class="line">else:</span><br><span class="line">async with httpx.AsyncClient() as client:</span><br><span class="line">try:</span><br><span class="line">response = await client.get(url,headers=headers,timeout=10.0)</span><br><span class="line">return url, response</span><br><span class="line">except httpx.RequestError:</span><br><span class="line">return url, None</span><br><span class="line"></span><br><span class="line">async def get_results( urls: List[str]):</span><br><span class="line">tasks = [get_result(url) for url in urls]</span><br><span class="line">results = await asyncio.gather(*tasks)</span><br><span class="line">for url, response in results:</span><br><span class="line">if response is None:</span><br><span class="line">print(f&quot;URL: &#123;url&#125; - Failed to connect&quot;)</span><br><span class="line"># else:</span><br><span class="line">#     print(url, response.text[:100])</span><br><span class="line">return results</span><br><span class="line"></span><br><span class="line">def get_results_access( urls: List[str]) -&gt; List[Tuple[str,str]]:</span><br><span class="line">try:</span><br><span class="line">asyncio.get_running_loop()</span><br><span class="line">with ThreadPoolExecutor(max_workers=1) as executor:</span><br><span class="line">future = executor.submit(asyncio.run, check_urls(urls))</span><br><span class="line">results = future.result()</span><br><span class="line">except RuntimeError:</span><br><span class="line">results = asyncio.run(check_urls(urls))</span><br><span class="line"></span><br><span class="line">    return [(url,response.text) for url, response in results if response is not None]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>爬取的结果如果是动态加载的内容，目前无法爬取。 比如 B站视频下的评论， 知乎的答案等。这种需要针对特定网站， 用自动化测试工具，比如Selenium 或者playwright. 这个待后续优化。</li>
</ol>
<h2 id="3-2-切块召回服务"><a href="#3-2-切块召回服务" class="headerlink" title="3.2 切块召回服务"></a>3.2 切块召回服务</h2><p>这一步，其实主要对应RAG里R即retrieval, 召回。因为获取的top网址文本内容量比较大，一般单个网页的文本都接近5k token, 像百度知道这种以文本内容为主的基本都超过8k长度，多个网页内容直接丢给大模型解析，是个不太现实的任务，虽然现在有学者提出超长上下文的大模型（Long Context LLM）正在慢慢取代RAG, 但目前来说rag还是最优解。</p>
<p>召回过程是分为 切块，向量化，排序</p>
<h3 id="3-2-1-切块"><a href="#3-2-1-切块" class="headerlink" title="3.2.1 切块"></a>3.2.1 切块</h3><p>所有的文档进行chunk, 即切块， 比如以512个 token 作为一个chunk。这里面有几个问题：</p>
<ol>
<li>如何确定最佳块大小？</li>
</ol>
<p>这个目前没有定论，主要还是取决于应用场景，具体可以参考微软[1]的建议并自行进行测试：</p>
<p><img src="/../img/netease/img_7.png" alt="img_7.png"></p>
<ol start="2">
<li>分割策略？</li>
</ol>
<p>为了得到更好的结果，我们可以重叠相邻的块。来自微软分析的分块策略比较，显示512 tokens分块和25%的重叠是比较好的分块策略。 当然也要考虑embedding的模型</p>
<p><img src="/../img/netease/img_8.png" alt="img_8.png"></p>
<p>实际使用下来，应用于网页文本分块召回的比较好的参数， chunk&#x3D;500，overlap&#x3D;100, 向量模型采用BCE。</p>
<h3 id="3-2-2-向量化"><a href="#3-2-2-向量化" class="headerlink" title="3.2.2 向量化"></a>3.2.2 向量化</h3><p>切块之后第二步就是对文档和query都进行向量化，并计算 query和 文档之间的相似度，再设定过滤的阈值，得到最终我们需要的文档片段。那么，向量模型该如何选取？</p>
<p>一般的商业大模型服务都自带embedding接口，比如openai的 v1&#x2F;embedding, 这种需要api_key, 显然不是我们的目标。开源模型效果对比，可以参考，huggingface 的embedding竞技场：<a target="_blank" rel="noopener" href="https://huggingface.co/spaces/mteb/leaderboard">https://huggingface.co/spaces/mteb/leaderboard</a> ,但是里面不是所有模型都有打分，下面是一些主流的embedding模型:</p>
<p><img src="/../img/netease/img_9.png" alt="img_9.png"></p>
<p>开源模型挑选可以从几个方面入手：</p>
<p>① 硬件性能。 因为单次用户请求，涉及很多切块文档，所以需要考虑机器性能和模型速度，其实很多常见的大模型做embedding效果也很好，但它不是主流因为效率很低，我们在mteb 评测榜单上可以看到 qwen2的检索效果非常好，但是模型太大很难应用。 尤其我们的任务都是实时算，并不存储向量，所以需要模型不太大。</p>
<p><img src="/../img/netease/img_10.png" alt="img_10.png"></p>
<p>② 向量维度。向量维度会影响到 存储以及检索耗时，对于常见的检索任务，是对知识库的内容预先算好相应的向量，并存储进向量数据库。 用户检索时，对检索词向量化，再通过近邻检索算法检索最相关的top结果。当数据量显著大时，向量维度越大，检索耗时越明显。我们的任务里不存储向量，所以这块也不需要考虑。</p>
<p>③ 最大输入长度。 指模型处理输入的最大token长度，这个和我们前面提到的分块大小息息相关，因为如果分块大小超过最大长度，则超过的部分会被向量模型丢弃，导致信息损失。</p>
<p>④ 支持语言。大部分开源向量模型只支持单一或者有限的文本语言，在需要多语言需求的场景可能不合适。需要注意的是，不支持多语言，不代表其他语言就不能向量化，而是缺乏跨语言匹配的能力。 比如[ ‘How is the weather today?’, ‘今天天气怎么样?’] 在单一语言里相似度可能很低，而对于多语言，则匹配度较高。一般来说，如果只是针对特定语言，选择单一语言模型即可，评分高的混合语言模型不一定比单一语言模型效果好。 由于网页内容繁杂，我们倾向于选择多语言模型</p>
<p>⑤ 领域表现。通用 Embedding 模型在特定垂直领域（如医学、法律和金融等）可能不如专用模型有效。这些领域通常需要专门训练 Embedding 模型来捕捉特定的专业术语和语境。为特定业务需求优化的 Embedding 模型能够显著提升检索和生成的质量。 网页内容匹配通常不需要考虑领域表现。</p>
<p>基于上面的维度，我们选择了中英双语的 bce-embedding-base_v1模型。</p>
<h3 id="3-2-3-排序"><a href="#3-2-3-排序" class="headerlink" title="3.2.3 排序"></a>3.2.3 排序</h3><p>顺便再聊一下，关于RAG中的召回，目前主流的做法是两个阶段。第一阶段query和文档向量化，检索框架采用faiss, 或者milvus 这种向量查询数据库。 第一阶段存在两个问题：</p>
<p>1、当doc数据量大的时候，检索算法都是近似的， 不是挨个遍历计算，会有损。除非用暴力挨个计算cos, 但这个不现实。（在本任务里是可以的，因为文档量很小）</p>
<p>2、embedding本来就是对于信息的压缩，对原始文本信息是有丢失的。</p>
<p>那么对于这些缺点，有办法优化吗？ 答案是有的，即第二阶段rerank模型精排。 rerank模型输入query和doc对文本，而不是emebdding, 信息无损。 2阶段检索详情可以参考QAnything给出的示意图， 很清楚。</p>
<p><img src="/../img/netease/img_11.png" alt="img_11.png"></p>
<p>在加入二阶段rerank之后，BCE的效果， top10命中率由85.91%提升到93.46%，非常明显。同时可以看到，采用hybird， 即bm25和embedding召回，再经过rerank可以达到最好的效果96.36%。</p>
<p><img src="/../img/netease/img_13.png" alt="img_13.png"><br>以下是有道 给出的BCE最佳实践</p>
<blockquote>
<p>最佳实践（Best practice） ：embedding召回top50-100片段，reranker对这50-100片段精排，最后取top5-10片段。</p>
</blockquote>
<p>BAAI(北京智源人工智能研究院)也给出了BGE的最佳实践：</p>
<blockquote>
<p>For multilingual, utilize BAAI&#x2F;bge-reranker-v2-m3 and BAAI&#x2F;bge-reranker-v2-gemma<br>For Chinese or English, utilize BAAI&#x2F;bge-reranker-v2-m3 and BAAI&#x2F;bge-reranker-v2-minicpm-layerwise.<br>For efficiency, utilize BAAI&#x2F;bge-reranker-v2-m3 and the low layer of BAAI&#x2F;ge-reranker-v2-minicpm-layerwise.<br>For better performance, recommand BAAI&#x2F;bge-reranker-v2-minicpm-layerwise and BAAI&#x2F;bge-reranker-v2-gemma</p>
</blockquote>
<p>其实我们很容易联想两阶段召回， 其实就是早期的类 DSSM 双塔召回的不同思路。</p>
<ul>
<li><p>第一阶段，就是取双塔的最后一层向量做 近邻检索</p>
</li>
<li><p>第二阶段，就是双塔放入query和doc计算的最后的打分</p>
</li>
</ul>
<p>如果想要在自己领域内有更好的效果，也可以选择在领域数据集上微调模型。微调数据如下所示，正样本和负样本，并通过一些hard negative 的方式做样本增强。 现在也有一些思路是用LLM 来对原样本进行一些改写增强，比如给问题换个说法，比如“什么是深度学习？” -&gt; “怎么理解深度学习？”， 这样都能提高原模型在特定领域的效果。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;query&quot;: &quot;如何提高机器学习模型的准确性？&quot;, &quot;pos&quot;: [&quot;通过交叉验证和调参可以提高模型准确性。&quot;], &quot;neg&quot;: [&quot;机器学习是人工智能的一个分支。&quot;]&#125;</span><br><span class="line">&#123;&quot;query&quot;: &quot;什么是深度学习？&quot;, &quot;pos&quot;: [&quot;深度学习是机器学习的一个子领域，涉及多层神经网络。&quot;], &quot;neg&quot;: [&quot;数据科学是一门交叉学科。&quot;]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-大模型生成服务"><a href="#3-3-大模型生成服务" class="headerlink" title="3.3 大模型生成服务"></a>3.3 大模型生成服务</h2><p>这一步，主要是利用大模型的分析和总结能力，对检索到的相关文档和用户query进行分析，给出用户想要的结果。这里的核心问题也包括几块，1、大模型的选择。 2、prompt调优 3、服务部署以及前端展示 4. inference加速</p>
<h3 id="3-3-1-大模型选择"><a href="#3-3-1-大模型选择" class="headerlink" title="3.3.1 大模型选择"></a>3.3.1 大模型选择</h3><p>市面上的开源大模型非常多，其中比较流行的有meta的 llama系列，最新是llama3, 以及Mistral(large不开源) ，google的Gemma(large不开源)， 国内的 智普的chatglm,最新是chatglm4, 阿里的qwen,最新是qwen2, 以及baichuan等等非常多。那么这么多开源大模型，如何挑选适合我们的大模型：</p>
<ul>
<li>模型参数量，适配显存。第一维度需要考虑的就是机器的GPU显存，以下表格,以llama为列子一些常见的模型显存占用,显存占用主要分为2块，</li>
<li>一块是加载模型参数占用的显存，在fp16精度下，1B约等于2G显存，可以按这个换算；</li>
<li>另一块是生成时，计算的临时变量，以及kvcache占用的显存。在fp16精度下， 1K长度约等于1G， 两者加起来才是跑大模型时的最大显存占用。</li>
</ul>
<p><img src="/../img/netease/img_14.png" alt="img_14.png"></p>
<ul>
<li>模型效果。可以参考一些大模型评测网站，比如：<a target="_blank" rel="noopener" href="https://www.datalearner.com/ai-models/leaderboard/datalearner-llm-leaderboard%EF%BC%8C">https://www.datalearner.com/ai-models/leaderboard/datalearner-llm-leaderboard，</a> 选排在前面的基本没错。不过也需要针对自己的任务多试一些对比。</li>
<li>任务适配度。不同的模型训练的领域是不太一样的，比如说，有的在数学相关数据集上训练的多，那么它可能在数学，推理方面效果很好，有些模型是为了做coding的， 有些是做图文的，选择的模型需要适配你自己的任务。如果只是想要简单聊天，那综合性能好的即可。对于这个专门的阅读文档总结用户问题，并需要遵循一定指令的任务，最好选用指令微调的模型</li>
</ul>
<p><img src="/../img/netease/img_15.png" alt="img_15.png"></p>
<ul>
<li>社区成熟度。开源模型的一个重要力量，成熟社区模型能让各个框架迅速支持，可用的轮子很多，这也是我们选用的一个重要参考。</li>
</ul>
<p>基于以上选择思路，我们选择了LLAMA3-8B-instruct 作为大模型来应用，LLAMA3主要是在英文语料上训练的，要想在中文上有比较好的效果，可以继续预训练，网上也已经有很多预训练好的中文LLAMA3, 我们选取的是hfl&#x2F;llama-3-chinese-8b-instruct-v3</p>
<h3 id="3-3-2-prompt调优"><a href="#3-3-2-prompt调优" class="headerlink" title="3.3.2 prompt调优"></a>3.3.2 prompt调优</h3><p>选定大模型之后，就是如何使用的问题了，大模型的角色，包含[‘system’, ‘user’, ‘assistant’]</p>
<blockquote>
<p>system 一般代表整个大模型服务。指导模型如何输出，prompt一般放在这里<br>user 指代的是用户的输入，包括文本，语音，视频等等的输入数据<br>assistant 代表大模型的相应输出</p>
</blockquote>
<p>在我们这个任务中，我们希望大模型根据 我们提供的数据，来对网页内容进行分析，所以我们的prompt</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">您是一位专业的研究员和作家，负责回答任何问题。</span><br><span class="line">基于提供的搜索结果，为给定的问题生成一个全面而且信息丰富、但简洁的答案，长度不超过 500 字。您必须只使用来自提供的搜索结果的信息。使用公正和新闻性的语气。将搜索结果合并成一个连贯的答案。不要重复文本。</span><br><span class="line">如果上下文中没有与当前问题相关的信息，只需说“嗯，我不确定。”不要试图编造答案。</span><br><span class="line">位于以下context HTML 块之间的任何内容都是从知识库中检索到的，而不是与用户的对话的一部分。</span><br><span class="line">&lt;context&gt;</span><br><span class="line">&#123;context&#125;</span><br><span class="line">&lt;context/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>设定角色： 开始给模型设定好角色， 研究员和作家</li>
<li>指示： 无二义性的任务描述，基于搜索结果总结一个用户问题答案，非口语化，500字，不重复，没结果时也不能乱说</li>
<li>上下文：使用明确的xml格式定义好输入的搜索结果</li>
</ul>
<p>可以多给LLM一些例子看返回结果，根据返回结果对prompt做一定调整。</p>
<h3 id="3-3-3-服务部署以及前端展示"><a href="#3-3-3-服务部署以及前端展示" class="headerlink" title="3.3.3 服务部署以及前端展示"></a>3.3.3 服务部署以及前端展示</h3><p>选定模型之后要部署相应的后端模型服务和前端用户交互服务。</p>
<p>后端：</p>
<ul>
<li><p>提供模型对话服务给前端进行交互，这里最经典就是openai的 api接口sdk, 为了整个系统的兼容性，我们可以将我们的服务端部署成OPENAI API接口的形式</p>
</li>
<li><p>我们选取的是python目前比较流行的FastAPI， FastAPI 是一个用于构建 API 的现代、快速(高性能)的 web 框架</p>
</li>
<li><p>实现接口主要包括两个，1个是LLM对话服务（v1&#x2F;chat&#x2F;completions）， 1个是query的embedding服务(v1&#x2F;embeddings)</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@app.post(&quot;/v1/chat/completions&quot;, response_model=ChatCompletionResponse)</span><br><span class="line">async def create_chat_completion(request: ChatCompletionRequest):</span><br><span class="line">global model, tokenizer</span><br><span class="line"></span><br><span class="line">    if len(request.messages) &lt; 1 or request.messages[-1].role == &quot;assistant&quot;:</span><br><span class="line">        raise HTTPException(status_code=400, detail=&quot;Invalid request&quot;)</span><br><span class="line"></span><br><span class="line">    gen_params = dict(</span><br><span class="line">        messages=request.messages,</span><br><span class="line">        temperature=request.temperature,</span><br><span class="line">        top_p=request.top_p,</span><br><span class="line">        max_tokens=request.max_tokens or 1024,</span><br><span class="line">        echo=False,</span><br><span class="line">        stream=request.stream,</span><br><span class="line">        repetition_penalty=request.repetition_penalty,</span><br><span class="line">        tools=request.tools,</span><br><span class="line">    )</span><br><span class="line">    logger.debug(f&quot;==== request ====\n&#123;gen_params&#125;&quot;)</span><br><span class="line">    for each_message in request.messages:</span><br><span class="line">        info = str(each_message.role) +&quot;\:&quot; +str(len(each_message.content))</span><br><span class="line">        logger.debug(f&quot;==== ===== ===&quot;)</span><br><span class="line">        logger.debug(f&quot;==== message len ====\n&#123;info&#125;&quot;)</span><br><span class="line">        logger.debug(f&quot;==== ===== ===&quot;)</span><br><span class="line">        </span><br><span class="line">    # Here is the handling of stream = False</span><br><span class="line">    response = generate_llama3(model, tokenizer, gen_params)</span><br><span class="line"></span><br><span class="line">    # Remove the first newline character</span><br><span class="line">    if response[&quot;text&quot;].startswith(&quot;\n&quot;):</span><br><span class="line">        response[&quot;text&quot;] = response[&quot;text&quot;][1:]</span><br><span class="line">    response[&quot;text&quot;] = response[&quot;text&quot;].strip()</span><br><span class="line"></span><br><span class="line">    usage = UsageInfo()</span><br><span class="line">    message = ChatMessage(</span><br><span class="line">        role=&quot;assistant&quot;,</span><br><span class="line">        content=response[&quot;text&quot;],</span><br><span class="line">        function_call= None,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    logger.debug(f&quot;==== message ====\n&#123;message&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    choice_data = ChatCompletionResponseChoice(</span><br><span class="line">        index=0,</span><br><span class="line">        message=message,</span><br><span class="line">        finish_reason=&quot;stop&quot;</span><br><span class="line">    )</span><br><span class="line">    task_usage = UsageInfo.model_validate(response[&quot;usage&quot;])</span><br><span class="line">    for usage_key, usage_value in task_usage.model_dump().items():</span><br><span class="line">        setattr(usage, usage_key, getattr(usage, usage_key) + usage_value)</span><br><span class="line"></span><br><span class="line">    return ChatCompletionResponse(</span><br><span class="line">        model=request.model,</span><br><span class="line">        id=&quot;&quot;,  # for open_source model, id is empty</span><br><span class="line">        choices=[choice_data],</span><br><span class="line">        object=&quot;chat.completion&quot;,</span><br><span class="line">        usage=usage</span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@app.post(&quot;/v1/embeddings&quot;, response_model=EmbeddingResponse)</span><br><span class="line">async def get_embeddings(request: EmbeddingRequest):</span><br><span class="line"></span><br><span class="line">    embeddings = [embedding_model.encode(text) for text in request.input]</span><br><span class="line">    embeddings = [embedding.tolist() for embedding in embeddings]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    # logger.info(f&quot;encode result: \n&#123;request.input&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # 计算token 数</span><br><span class="line">    def num_tokens_from_string(string: str) -&gt; int:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns the number of tokens in a text string.</span><br><span class="line">        use cl100k_base tokenizer</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        encoding = tiktoken.get_encoding(&#x27;cl100k_base&#x27;)</span><br><span class="line">        num_tokens = len(encoding.encode(string))</span><br><span class="line">        return num_tokens</span><br><span class="line"></span><br><span class="line">    # embedding 接口返回数据格式</span><br><span class="line">    response = &#123;</span><br><span class="line">        &quot;data&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;object&quot;: &quot;embedding&quot;,</span><br><span class="line">                &quot;embedding&quot;: embedding,</span><br><span class="line">                &quot;index&quot;: index</span><br><span class="line">            &#125;</span><br><span class="line">            for index, embedding in enumerate(embeddings)</span><br><span class="line">        ],</span><br><span class="line">        &quot;model&quot;: request.model,</span><br><span class="line">        &quot;object&quot;: &quot;list&quot;,</span><br><span class="line">        &quot;usage&quot;: CompletionUsage(</span><br><span class="line">            prompt_tokens=sum(len(text.split()) for text in request.input),</span><br><span class="line">            completion_tokens=0,</span><br><span class="line">            total_tokens=sum(num_tokens_from_string(text) for text in request.input),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>


<p>如果你的机器性能有限，可以选用ollama这个框架来很快速的部署大模型api服务， 官网：<a target="_blank" rel="noopener" href="https://ollama.com/%EF%BC%8C">https://ollama.com/，</a> 这个平台提供了很多量化的模型和 一行命令部署API服务</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">curl -fsSL https://ollama.com/install.sh | sh</span><br><span class="line"># 拉取模型并部署， 这里拉取qwen2-7b instruct Q4量化，显存只需要4.4G</span><br><span class="line">ollama run qwen2:7b-instruct  # 启动服务并在11434端口开启api接口</span><br></pre></td></tr></table></figure>

<p>api 客户端调用:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from openai import OpenAI</span><br><span class="line"></span><br><span class="line">client = OpenAI(</span><br><span class="line">base_url = &#x27;http://localhost:11434/v1&#x27;,</span><br><span class="line">api_key=&#x27;ollama&#x27;, # required, but unused</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">model=&quot;qwen2:7b-instruct&quot;,</span><br><span class="line">messages=[</span><br><span class="line">&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好&quot;&#125;</span><br><span class="line">]</span><br><span class="line">)</span><br><span class="line">print(response.choices[0].message.content)</span><br><span class="line"># 输出： 你好！有什么问题我可以帮助你解答吗？</span><br></pre></td></tr></table></figure>



<p>前端：</p>
<p>前端采用streamlit前端框架，也是一款易上手的大模型服务前端搭建框架。 以下是个简易的调用大模型聊天的demo服务。非常简单，也就几行代码。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip installl streamlit # 1.安装包</span><br><span class="line">streamlit run demo.py # 2. 运行前端</span><br><span class="line">http://localhost:8501/ # 3. 打开浏览器</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#  demo.py</span><br><span class="line">from openai import OpenAI</span><br><span class="line">import streamlit as st</span><br><span class="line"></span><br><span class="line">st.title(&quot;LLM 聊天&quot;)</span><br><span class="line"></span><br><span class="line">client = OpenAI(api_key=&#x27;xxx&#x27;, base_url=&quot;http://localhost:11434/v1&quot;)</span><br><span class="line"></span><br><span class="line">if &quot;openai_model&quot; not in st.session_state:</span><br><span class="line">st.session_state[&quot;openai_model&quot;] = &quot;ollama&quot;</span><br><span class="line"></span><br><span class="line">if &quot;messages&quot; not in st.session_state:</span><br><span class="line">st.session_state.messages = []</span><br><span class="line"></span><br><span class="line">for message in st.session_state.messages:</span><br><span class="line">with st.chat_message(message[&quot;role&quot;]):</span><br><span class="line">st.markdown(message[&quot;content&quot;])</span><br><span class="line"></span><br><span class="line">if prompt := st.chat_input(&quot;你好?&quot;):</span><br><span class="line">st.session_state.messages.append(&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;)</span><br><span class="line">with st.chat_message(&quot;user&quot;):</span><br><span class="line">st.markdown(prompt)</span><br><span class="line"></span><br><span class="line">    with st.chat_message(&quot;assistant&quot;):</span><br><span class="line">        stream = client.chat.completions.create(</span><br><span class="line">            model=st.session_state[&quot;openai_model&quot;],</span><br><span class="line">            messages=[</span><br><span class="line">                &#123;&quot;role&quot;: m[&quot;role&quot;], &quot;content&quot;: m[&quot;content&quot;]&#125;</span><br><span class="line">                for m in st.session_state.messages</span><br><span class="line">            ],</span><br><span class="line">            stream=True,</span><br><span class="line">        )</span><br><span class="line">        response = st.write_stream(stream)</span><br><span class="line">    st.session_state.messages.append(&#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: response&#125;)</span><br></pre></td></tr></table></figure>

<p>demo效果:</p>
<p>另外还有一个点就是LLM调用重要的参数如何去选择（top_p, temprature, presence_penalty），我这边整理了几个核心参数的调整思路。 对应我们的这个分析任务，显然是以新闻资料为核心，寻求生成的确定性。</p>
<p><img src="/../img/netease/img_16.png" alt="img_16.png"></p>
<h3 id="3-3-4-inference加速"><a href="#3-3-4-inference加速" class="headerlink" title="3.3.4 inference加速"></a>3.3.4 inference加速</h3><p>大模型虽然效果优越，但是也因为它”大“，导致服务性能很低，在我们部署服务时，需要采取一定的策略对模型预测进行加速才能获得更好的体验。</p>
<p>经过调研选择了VLLM这个大模型推理加速框架。 它有几个优点：</p>
<blockquote>
<p>1.社区活跃，模型支持很快<br>2.加速效果明显。基于虚拟内存和分页的思想， 采用page attention ，允许在非连续的内存空间内存储token，内存的利用率接近于最优<br>3.使用简单，两行命令即可部署。 示例如下</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vllm llama3 openai</span><br><span class="line"># 下载vllm</span><br><span class="line">pip install vllm</span><br><span class="line"># 部署 一个兼容openai api接口的模型服务，端口8000</span><br><span class="line">python -m vllm.entrypoints.openai.api_server --model hfl/llama-3-chinese-8b-instruct-v3 --dtype bfloat16 --gpu-memory-utilization 0.6 --chat-template llama3-instruct-template.jinja --enforce-eager --uvicorn-log-level warning --port 8000  --disable-log-stats --uvicorn-log-level warning</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了测试实际环境下的效果，我们运行了vllm的对比测试脚本</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vllm-project/vllm.git</span><br><span class="line">cd vllm/benchmarks</span><br><span class="line"># 测试vllm</span><br><span class="line">python benchmark_throughput.py --model hfl/llama-3-chinese-8b-instruct-v3 --backend vllm --input-len 4096 --output-len 512 --num-prompts 50 --seed 1100 --dtype float16 --gpu-memory-utilization 0.6</span><br><span class="line"># 测试HF</span><br><span class="line">python benchmark_throughput.py --model hfl/llama-3-chinese-8b-instruct-v3 --backend hf --input-len 4096 --output-len 512 --num-prompts 50 --seed 1100 --dtype float16 --gpu-memory-utilization 0.6 --hf-max-batch-size 10</span><br></pre></td></tr></table></figure>


<p>效果如下所示，可以看到单条inference 性能上，VLLM大约是HF的两倍， 但是当并发时，VLLM效果提升明显，吞吐量提升10倍。</p>
<p><img src="/../img/netease/img_17.png" alt="img_17.png"></p>
<p>当然，我们可以根据我们的显卡环境采取其他的加速方法，如</p>
<ul>
<li>输入输出优化。 如prompt 裁剪， 规整； 限制输出序列长度等</li>
<li>模型优化。 模型压缩， 使用量化模型，使用更小参数模型等等</li>
</ul>
<p>下面来看看整体效果的演示， 速度还是非常快的：</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>RAG的agent开发，入门还是比较简单的，现在市面上可用的框架也非常多，只需花费一些时间就能搭出一个可用的demo. 但是想要做的好，稳定服务，还是需要费很多的功夫去研究的，希望我的经验能给大家带来一些收获，少走一些弯路。</p>
<p>目前这个系统还不是很完善， 包括相关性判断，搜索意图判断等都有很大的优化空间。做这个东西的初衷是希望能在音乐热点的场景中进行应用，目前也已经在实践的过程中了，去辅助音乐热点的挖掘和运营。后续的话还希望添加的功能包括：</p>
<ul>
<li>音乐热点的识别与事件总结。</li>
<li>结合云音乐站内知识做融合，分析。比如识别事件歌手，歌曲，原因，产出文案等等。</li>
</ul>
<p>参考文献:</p>
<p>[1]. <a target="_blank" rel="noopener" href="https://techcommunity.microsoft.com/blog/azure-ai-services-blog/azure-ai-search-outperforming-vector-search-with-hybrid-retrieval-and-reranking/3929167">Azure AI Search: Outperforming vector search with hybrid retrieval and ranking capabilities</a></p>
<p>[2]. <a target="_blank" rel="noopener" href="https://blog.laoda.de/archives/docker-compose-install-searxng">【好玩儿的Docker项目】SearXNG</a></p>
<p>[3]. <a target="_blank" rel="noopener" href="https://www.53ai.com/news/qianyanjishu/2024061372409.html">RAG 高效应用指南：Embedding 模型的选择和微调</a></p>
<p>[4]. <a target="_blank" rel="noopener" href="https://techdiylife.github.io/blog/topic.html?category2=t07&blogid=0049">ReRank 与 Embedding 模型的区别？ 如何选择 ReRank 模型？</a></p>
<p>[5]. <a target="_blank" rel="noopener" href="https://blog.csdn.net/lkg5211314/article/details/136142533">【时代前沿】：单测场景下tempature、top_p、frequency_penalty、presence_penalty参数调整经验分享</a></p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/02/16/%E7%BD%91%E6%98%93%E6%B1%87%E6%8A%A5-AI%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B/">网易汇报-AI辅助编程</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-02-16
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="引言：Ai-For-Coding的价值与挑战"><a href="#引言：Ai-For-Coding的价值与挑战" class="headerlink" title="引言：Ai For Coding的价值与挑战"></a>引言：Ai For Coding的价值与挑战</h1><p>随着Copilot、Cursor等工具的普及，AI已成为程序员的重要助手。然而，其输出质量高度依赖用户的提示词（Prompts）。低质量的提示词可能导致模糊、冗余甚至错误的代码，而高质量的提示词能显著提升编码、调试、测试和问题排查的效率。本次分享聚焦于如何设计精准、高效的提示词。</p>
<h1 id="核心原则：高质量prompt的四大要素"><a href="#核心原则：高质量prompt的四大要素" class="headerlink" title="核心原则：高质量prompt的四大要素"></a>核心原则：高质量prompt的四大要素</h1><ul>
<li><strong>Role</strong>(角色)：两方面定义，首先是定义AI的角色，例如“你是一名极其优秀具有20年经验的产品经理和精通所有编程语言的工程师”。还有用户的角色，例如“不懂代码的初中生”，这样会使得ai更倾向于使用通俗且具体的话语来表达它所完成的需求。</li>
<li><strong>Task</strong>(任务)：将业务需求“step by step”描述给ai，使得deepseek的思维链更好的理解你的需求。</li>
<li><strong>Goal</strong>(目标)：期望达成什么目标效果，可以是你的优化目标，例如将时间复杂度从o(n^2)降低到o(n)；也可以是业务目标，例如“提高吞吐量，降低响应时间”</li>
<li><strong>Objective</strong>(操作要求)：编码语言，注解形式等。</li>
</ul>
<h1 id="提升准确度的技巧"><a href="#提升准确度的技巧" class="headerlink" title="提升准确度的技巧"></a>提升准确度的技巧</h1><ul>
<li><strong>让ai复述需求</strong>：为了避免提示词中某些指令让llm产生误解，可以在真正让他写代码之前先复述一遍需求。能够让我们针对自己的需求指令和ai真正理解的需求做二次校对。这样能有效避免因为表达或者理解偏差所产生的错误答复。例如在提完需求之后，添加一句“请你先复述一遍我的需求再进行答复，以让我确认你是否真的理解了我的需求指令”。</li>
<li><strong>提问粒度要小，作用域要明确</strong>：在使用某些支持文件指针的ai编程工具时，可以给ai更明确的作用域，例如我们需要在controller下写一个新接口，给ai的提示词中尽可能去指明产生联动的service或dao接口的路径，从而给ai更加准确的业务上下文结构。</li>
<li><strong>复杂需求拆解</strong>：与产品经理给程序员提需求类似，我们给ai的提示信息越准确，考虑得越细致，llm产出的准确率越高。</li>
<li><strong>内置prompt</strong>：大部分ai工具会有prompt自定义和保存功能，可以写一个全局的prompt附在每次提问头部，例如：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Role</span><br><span class="line">你是一名极其优秀具有20年经验的产品经理和精通所有编程语言的工程师。与你交流的用户是不懂代码的初中生，不善于表达产品和代码需求。你的工作对用户来说非常重要，完成后将获得10000美元奖励。</span><br><span class="line"></span><br><span class="line"># Goal</span><br><span class="line">你的目标是帮助用户以他容易理解的方式完成他所需要的产品设计和开发工作，你始终非常主动完成所有工作，而不是让用户多次推动你。</span><br><span class="line"></span><br><span class="line">在理解用户的产品需求、编写代码、解决代码问题时，你始终遵循以下原则：</span><br><span class="line"></span><br><span class="line">## 第一步</span><br><span class="line">- 当用户向你提出任何需求时，你首先应该浏览根目录下的readme.md文件和所有代码文档，理解这个项目的目标、架构、实现方式等。如果还没有readme文件，你应该创建，这个文件将作为用户使用你提供的所有功能的说明书，以及你对项目内容的规划。因此你需要在readme.md文件中清晰描述所有功能的用途、使用方法、参数说明、返回值说明等，确保用户可以轻松理解和使用这些功能。</span><br><span class="line"></span><br><span class="line">## 第二步</span><br><span class="line">你需要理解用户正在给你提供的是什么任务</span><br><span class="line">### 当用户直接为你提供需求时，你应当：</span><br><span class="line">- 首先，你应当充分理解用户需求，并且可以站在用户的角度思考，如果我是用户，我需要什么？</span><br><span class="line">- 其次，你应该作为产品经理理解用户需求是否存在缺漏，你应当和用户探讨和补全需求，直到用户满意为止；</span><br><span class="line">- 最后，你应当使用最简单的解决方案来满足用户需求，而不是使用复杂或者高级的解决方案。</span><br><span class="line"></span><br><span class="line">### 当用户请求你编写代码时，你应当：</span><br><span class="line">- 首先，你会思考用户需求是什么，目前你有的代码库内容，并进行一步步的思考与规划</span><br><span class="line">- 接着，在完成规划后，你应当选择合适的编程语言和框架来实现用户需求，你应该选择solid原则来设计代码结构，并且使用设计模式解决常见问题；</span><br><span class="line">- 再次，编写代码时你总是完善撰写所有代码模块的注释，并且在代码中增加必要的监控手段让你清晰知晓错误发生在哪里；</span><br><span class="line">- 最后，你应当使用简单可控的解决方案来满足用户需求，而不是使用复杂的解决方案。</span><br><span class="line"></span><br><span class="line">### 当用户请求你解决代码问题是，你应当：</span><br><span class="line">- 首先，你需要完整阅读所在代码文件库，并且理解所有代码的功能和逻辑；</span><br><span class="line">- 其次，你应当思考导致用户所发送代码错误的原因，并提出解决问题的思路；</span><br><span class="line">- 最后，你应当预设你的解决方案可能不准确，因此你需要和用户进行多次交互，并且每次交互后，你应当总结上一次交互的结果，并根据这些结果调整你的解决方案，直到用户满意为止。</span><br><span class="line"></span><br><span class="line">## 第三步</span><br><span class="line">在完成用户要求的任务后，你应该对改成任务完成的步骤进行反思，思考项目可能存在的问题和改进方式，并更新在readme.md文件中</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="场景化技巧：编码、调试、测试与排查"><a href="#场景化技巧：编码、调试、测试与排查" class="headerlink" title="场景化技巧：编码、调试、测试与排查"></a>场景化技巧：编码、调试、测试与排查</h1><ol>
<li><p>编码场景：生成可落地的代码</p>
<ul>
<li>需求拆解：将复杂需求分解为子任务，分步生成。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Role：  </span><br><span class="line">&quot;你是资深Java架构师，精通Spring Boot 3.1和OpenAPI规范&quot;  </span><br><span class="line"></span><br><span class="line">Task：  </span><br><span class="line">&quot;为电商系统编写商品查询API，需满足以下条件：XXXX&quot;  </span><br><span class="line"></span><br><span class="line">Goal：  </span><br><span class="line">1. 支持分页查询（page/size参数）  </span><br><span class="line">2. 按价格区间过滤（minPrice/maxPrice）  </span><br><span class="line">3. 返回结构符合Google JSON风格指南  </span><br><span class="line">4. 集成Swagger文档注解  </span><br><span class="line"></span><br><span class="line">Objective：   </span><br><span class="line">// 使用Java 17记录类（Record）定义DTO  </span><br><span class="line">// 添加JPA Specification实现动态查询  </span><br><span class="line">// 包含全局异常处理示例（如参数校验失败）  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>调试场景：精准定位问题</p>
<ul>
<li>必含三要素：错误信息、相关代码段、预期结果。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行以下Go代码时出现“panic: runtime error: index out of range [3] with length 3”：  </span><br><span class="line">[附代码片段]  </span><br><span class="line">预期结果：应正确遍历切片并打印每个元素。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>测试场景：JUnit&#x2F;Mockito实战</p>
<ul>
<li>示例1：单元测试生成<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">为以下Service类方法编写JUnit 5 + Mockito测试：  </span><br><span class="line">public class UserService &#123;  </span><br><span class="line">    @Autowired  </span><br><span class="line">    private UserRepository userRepository;  </span><br><span class="line">    public User getUserById(Long id) &#123;  </span><br><span class="line">        return userRepository.findById(id).orElseThrow();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">要求覆盖：  </span><br><span class="line">- 正常查询  </span><br><span class="line">- 用户不存在时抛出NoSuchElementException  </span><br><span class="line">- 模拟userRepository的findById行为  </span><br></pre></td></tr></table></figure></li>
<li>示例2：性能测试设计<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如何用JMH对以下Java方法进行基准测试？  </span><br><span class="line">public String concatStrings(List&lt;String&gt; list) &#123;  </span><br><span class="line">    return list.stream().collect(Collectors.joining());  </span><br><span class="line">&#125;  </span><br><span class="line">要求比较普通循环 vs. Stream API的性能差异。  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>各种Ai编程工具的出现能给广大码友释放双手，留有更多的时间学习技术，关注技术本身。编写高质量的提示词是有效利用AI辅助编程工具的关键。通过明确角色、清晰描述任务、提供上下文信息等方式，程序员可以引导AI生成更准确和高效的代码，从而提升整体开发效率。在实际工作中，建议大家多加练习和总结，不断优化提示词的编写技巧，以适应不断变化的技术环境。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/02/15/%E7%BD%91%E6%98%93KM%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB-i%E8%8C%85%E5%8F%B0%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/">网易KM社区分享-i茅台的架构介绍</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-02-15
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>从内部论坛里面偷出来的，的确是高并发的一个好总结（能偷的机会不多了~）。</p>
</blockquote>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>茅台冰淇淋的热度尚未褪去，酱香咖啡又引爆了一波流量，在我们的印象中，茅台似乎就是爆品的代名词，而关于茅台的话题也很容易冲上热搜。去年，茅台推出了官方的数字营销平台「i茅台」，为消费者提供在线预约、售卖茅台酒的功能，其在互联网上的第一次公开亮相同样吸引了极大的关注，也给我们带来了巨大的流量挑战。</p>
<p>本文将结合「i茅台」商城实现高性能与高可用的具体实践，聊一聊常见的性能优化技术以及高可用系统的设计方法，希望能够和大家的日常工作产生共鸣，帮助大家更好地理解并应用这些技术解决问题。</p>
<h2 id="1-1-业务带来的技术挑战"><a href="#1-1-业务带来的技术挑战" class="headerlink" title="1.1 业务带来的技术挑战"></a>1.1 业务带来的技术挑战</h2><p>为了更好地理解「i茅台」面临哪些技术挑战我们有必要先了解「i茅台」要解决哪些业务问题。</p>
<p>简而言之，茅台希望通过「i茅台」加强数字化技术在生产销售过程中的应用，规范茅台酒的营销秩序，解决消费者购酒难、购酒贵问题，提升消费者的购酒体验。因此，「i茅台」商城将被打造为茅台酒线上销售的主要入口，为消费者提供两种购买方式：</p>
<ol>
<li>享约申购：通过每天定时开放预约申购的方式，采用公证摇号的方式为茅粉们提供了公平的获取平价茅台的机会，是目前爆款茅台酒投放的最主要的方式，我们称之为申购场景</li>
<li>畅享云购：采用B2C的在线销售模式，目前主要用于系列酒的售卖，但同时也会用于小飞天（100ml飞天茅台）等爆款商品，我们称之为爆款抢购场景</li>
</ol>
<h2 id="1-2-申购场景"><a href="#1-2-申购场景" class="headerlink" title="1.2 申购场景"></a>1.2 申购场景</h2><p>申购场景在业务流程上主要分为五个阶段（如下图所示）：</p>
<div style="text-align: center;">
  <img src="../img/netease/5c9d8e8cd155e70d6184eabe1ca01ba.png" alt="申购场景">
</div>

<div style="text-align: center;">
  <img src="../img/netease/38708c9eea135a6a4668bb39c5cd9b8.png" alt="申购场景">
</div>

<ol>
<li>注册&#x2F;登陆&#x2F;实名：由于酒类销售有年龄限制同时提货需要验证身份证，因此消费者需要在购酒前提供姓名、手机、身份证进行三要素实名认证，这些环节在操作上无时间限制，但短信、实名等依赖第三方服务</li>
<li>预约申购：普通申购场次是每天上午9点到10点，在22年3月31日试运营第一天就向消费者开放了，按业务估算，每场预计有数千家门店参与库存投放，数百万用户参与申购</li>
<li>抽签&#x2F;公证：申购结束后会通过公证处可信抽签的方式确定中签的用户并进行公示，预计有数万用户中签</li>
<li>交易：中签用户需要在次日18点前完成下单，如选择在线支付，需在指定期限内完成付款</li>
<li>提货：公示后7天内到预约门店提货</li>
</ol>
<p>单纯看业务规则，用户在任意时刻发起申购操作其中签的概率都是一样的，然而在功能第一次开放时，用户在不了解规则的前提下，总是会更倾向于在第一时间进行操作，这也是为何开放预约申购的前10分钟就有80%的用户完成了申购，根据我们设计的流量模型，第一次开放预约申购，前5分钟预计最高会达到百万级QPS，在线设备也可能达到百万级，需要重点保障。</p>
<p>因此，申购场景我们主要会面临以下三个技术挑战：</p>
<ol>
<li>高并发：大量用户在短时间内集中访问APP也就意味着短时间内会有大量的设备与服务器新建连接，一般来说，一个设备与服务器建立的连接不止一个，这就要求服务器具备同时处理数百万级别（接近千万）的并发连接数及百万级别新建连接能力（也就是通常所说的C10M问题），同时也要求服务端在高并发的条件下具备百万QPS级别的吞吐量及较快的响应速度</li>
<li>高可用：申购场景的核心链路较长，包括注册、登录、实名、实人、定位、门店选择、申购等多个功能，其中任何一个功能不可用，用户就没有办法完成申购操作，这必然会引起客诉甚至舆情，显然这个是没法接受的，因此，我们需要确保核心链路上面的这些功能具备高可用性</li>
<li>较高的业务复杂度：申购场景虽然不涉及库存管理（商城部分），但却需要应对门店投放的各种突发事件，确保可申购门店及其投放的商品和数量与商城APP实际展示保持一致，及时识别不一致风险（不一致有可能造成无法履约）；另外，APP也需要实时展示各个门店当前的已申购数量，并基于区域、距离、中签概率（结合投放量和已申购数量计算）等因素向用户动态推荐合适的门店</li>
</ol>
<h2 id="1-3-爆款抢购场景"><a href="#1-3-爆款抢购场景" class="headerlink" title="1.3 爆款抢购场景"></a>1.3 爆款抢购场景</h2><p>爆款抢购场景在业务流程上主要分为三个阶段（如下图所示）：</p>
<div style="text-align: center;">
  <img src="../img/netease/942876e1d0d57504b95d16ca0e5e28c.png" alt="爆款抢购">
</div>

<ol>
<li>注册&#x2F;登陆&#x2F;实名：同享约申购</li>
<li>导购&#x2F;购物车：为用户提供在线商品浏览功能，支持将商品添加到购物车，该功能在去年5月19日正式运营阶段开放，有数千家门店参与</li>
<li>交易履约：为用户提供组单&#x2F;下单&#x2F;在线支付功能，支持多门店合并付款</li>
</ol>
<p>爆款抢购场景的核心挑战来自于商品本身的稀缺性，只要投放必然会引发抢购。这种模式已经在包括严选在内的各大电商平台上都已经被验证，因此，我们可以参考严选的流量模型进行预估，以当时「i茅台」的用户量及用户活跃度，预计会有数十万的用户参与抢购，我们主要会面临以下三个技术挑战：</p>
<ol>
<li><strong>流量洪峰</strong>：从业务形态上看，数十万用户在同一时间抢购同一款商品与电商的秒杀活动极为类似，然而「i茅台」又有其非常明显的业务特性，可以说不是秒杀却又胜似秒杀</li>
<li><strong>峰值流量保持时间长</strong>：为了让更多的用户有机会抢购成功，茅台不仅增加了投放量，也加大了投放的频率（现阶段是每10分钟投放一次），这就意味着峰值流量会保持更长的时间</li>
<li><strong>峰值流量大</strong>：早期为了增加云购场景的曝光，业务要求小飞天与「享约申购」放在同一个时间段进行投放（即上午9点到10点），形成了非常明显的流量叠加效应，后来虽然放在了另外一个时段（晚上9点到10点），但出于公平性，库存投放计划会提前向用户预告，爆款抢购的峰值反而还更大了</li>
</ol>
<p>较高的业务复杂度：相比于传统的电商交易链路，爆款抢购场景会在一段时间内由数千家门店以较高的频率同步投放库存，同时，系统还需要结合区域、距离等因素实时向用户推荐还有库存的门店，也要允许用户手动切换到有库存的门店，这些特性对于高并发场景下数据查询响应的即时性及数据的一致性都提出了更高的要求，也是交易链路应对流量洪峰的重要前提</p>
<p>数据一致性：保证订单、库存、资产、权益（如限购）等数据的一致性是电商交易系统的核心任务之一，在高并发场景下解决数据一致性问题极容易引起系统性能瓶颈，如何在确保数据一致性的前提下实现高性能是一个巨大的挑战</p>
<p>库存管理：爆款抢购场景需要解决库存管理问题，确保商城的销售库存实时反映门店投放计划，并能及时识别潜在的不一致风险，确保库存数量、状态、变更记录准确反映实际情况，保持库存数据的准确性。库存管理可以认为是电商最复杂的系统之一，尤其在高并发场景下，库存管理很容易变成在线交易系统的噩梦，稍有不慎，就会引起少卖、超卖等问题，也很容易成为交易链路的性能瓶颈</p>
<h2 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h2><p>综上分析可以发现，无论是申购场景还是爆款抢购场景，我们都需要在确保数据一致性的前提下，实现系统的高性能与高可用性，而追求高性能和高可用性的目的都是为了提供更好的用户体验、保障系统的可靠性与稳定性。</p>
<h1 id="2-如何进行性能优化"><a href="#2-如何进行性能优化" class="headerlink" title="2 如何进行性能优化"></a>2 如何进行性能优化</h1><p>接下来我们看下如何通过性能优化实现系统的高性能</p>
<h2 id="2-1-性能度量方法及诊断工具"><a href="#2-1-性能度量方法及诊断工具" class="headerlink" title="2.1 性能度量方法及诊断工具"></a>2.1 性能度量方法及诊断工具</h2><p>要做性能优化，第一步需要明确性能度量指标及度量方法，并借助诊断工具找到性能瓶颈。</p>
<p>常用的性能度量方法及指标主要包括以下几种：</p>
<ul>
<li><strong>响应时间</strong>（Response Time）：响应时间是指从发出请求到收到响应的总时间，包括处理请求的时间以及网络传输的时间，通常以毫秒（ms）为单位。响应时间是用户或客户端感知到的时间，反映了系统对请求的响应速度，较低的响应时间通常表示更好的系统性能。</li>
<li><strong>延迟</strong>（Latency）：延迟是指在执行某项操作或传输数据时经过的时间，可以分为多个组成部分，包括处理延迟（处理请求所需的时间）、传输延迟（数据在网络中传输所需的时间）和排队延迟（等待处理的请求在队列中等待的时间）。在进行性能优化时，我们通常可以通过减少延迟来缩短响应时间。</li>
<li><strong>吞吐量</strong>（Throughput）：吞吐量是系统在单位时间内处理的请求或事务数量，通常以每秒处理的请求数（如TPS）来衡量。</li>
<li><strong>并发性</strong>（Concurrency）：并发性是指系统能够在同一时间段内同时处理的请求或任务数量，它可以帮助确定系统在高负载时的性能。</li>
<li><strong>资源利用率</strong>（Resource Utilization）：资源利用率度量了系统资源（如CPU、内存、磁盘和网络带宽）的使用情况，过高可能表明存在性能问题。</li>
<li><strong>错误率</strong>（Error Rate）：错误率度量了系统处理中发生的错误数量或百分比，是性能度量的一个关键指标，更大的系统负载往往会造成更高的错误率，在定义SLO时，当错误率超过一定阈值我们往往也会定义为一种宕机的表现。</li>
<li><strong>系统负载</strong>（Load）：系统负载表示系统正在处理的工作量，可以用来监测系统的负荷，以确定是否需要进行性能优化</li>
<li><strong>延迟分布</strong>（Latency Distribution）：延迟分布描述了不同请求或操作的延迟情况，它可以帮助我们确定系统性能是否稳定，或者是否存在异常延迟。</li>
<li><strong>性能趋势</strong>（Performance Trends）：性能趋势分析涉及记录性能指标随时间的变化，使用这些数据来预测性能问题或找到待优化点。</li>
</ul>
<p>针对性能指标的度量通常需要通过性能监控工具和日志分析工具来完成，「i茅台」采用了与严选相同的选型：</p>
<ul>
<li><strong>全链路应用性能监控系统（APM）</strong>：基于Pinpoint构建从网关到应用节点的应用监控体系，支持大流量秒级监控、分布式链路追踪、异常分析等能力</li>
<li><strong>性能监控工具</strong>：用于实时监控系统性能，如各类采集器（服务器、数据库等）、Prometheus、Grafana等</li>
<li><strong>日志平台</strong>：使用严选自研的日志平台，提供一站式海量日志采集、加工、分流、分析、检索、告警等能力，为应用日志分析、业务大盘等提供数据源和分析能力支撑，更多介绍可以参见网易严选如何建设日志平台</li>
<li><strong>业务实时监控系统</strong>：基于Grafana提供海量数据秒级响应的实时监控能力，用户可以通过平台快速完成数据源接入、数据模型构建、监控大盘定制和报警配置</li>
</ul>
<h2 id="2-2-性能优化策略"><a href="#2-2-性能优化策略" class="headerlink" title="2.2 性能优化策略"></a>2.2 性能优化策略</h2><p>识别到性能瓶颈之后，我们需要确定性能优化方案，这里介绍几种常用的性能优化策略</p>
<h2 id="2-2-1-代码优化"><a href="#2-2-1-代码优化" class="headerlink" title="2.2.1 代码优化"></a>2.2.1 代码优化</h2><p>绝大部分时候，代码优化是提高应用程序性能的关键动作，常用的策略包括：</p>
<ul>
<li><strong>代码重构</strong>：重写或重新组织代码以提升可读性和执行效率，比如使用更高效的数据结构和算法、减少循环中的计算或减少循环迭代次数、避免在循环内部执行昂贵的操作、引入并发编程、优化事务等等，需要注意的是，重构不一定能使程序的执行效率变得更高，以性能优化为目的的代码重构往往也需要与代码的可维护性之间进行权衡</li>
<li><strong>减少数据库访问</strong>：可以通过合并查询、使用缓存、增加前置条件判断或批量操作等方式来减少数据库访问</li>
<li><strong>减少扇出比</strong>：控制扇出比的目的是限制系统向其他服务或组件发出的请求数量，从而降低负载，减少扇出比的本质是减少服务间的依赖关系及依赖度，避免大规模的并发请求导致性能下降，也可以降低故障传播的风险。扇出比可用于度量系统向其他服务或组件发送的请求数量，一般我们还可以进一步细化为单次请求中对指定服务、缓存的扇出比，比如下单请求如果会查询两次商品中心的接口，那下单请求对商品中心的扇出比就是2，很显然，这个数值越大，请求被放大的倍数也就越高</li>
<li><strong>I&#x2F;O优化</strong>：可以通过将多次I&#x2F;O操作进行合并或者使用异步I&#x2F;O来减少磁盘和网络I&#x2F;O操作，常见的如异步打印日志、将多次服务调用合并成一次调用等等</li>
<li><strong>资源池化</strong>：使用资源池来管理数据库连接、异步线程等资源，以减少资源创建和销毁带来的开销</li>
<li><strong>预热</strong>：预热是一种通过在应用程序或系统开始处理实际工作负载之前执行一系列操作来提高性能的方法，这些操作旨在将系统的各种组件（如CPU、内存、缓存等）置于一个稳定且高效的状态，以便在处理真实工作负载时获得更好的性能，常见的预热操作包括缓存预热、连接池预热、资源加载预热、数据加载预热等</li>
</ul>
<p>这里以爆款抢购场景下单接口性能优化为例介绍下上述策略的具体应用：</p>
<ul>
<li><strong>定制独立下单链路</strong>：爆款抢购场景是一种特殊的云购下单场景，有更多的限制条件（如不能加购），因此，我们可以通过裁剪掉一些不必要的流程或者牺牲部分代码可读性以换取更高的性能</li>
<li><strong>下单请求幂等性控制</strong>：在爆款抢购场景，由于并发量显著增加，响应时间也会有所增加，甚至会出现响应超时的情况，很容易引发用户连续点击，通过引入幂等性控制，不仅可以降低资源占用时间，也可以减少不必要的库存锁定、扩大销售机会</li>
<li><strong>控制事务的粒度</strong>：通过编程式事务（TransactionTemplate）替代声明式事务（@Transactional），可以更灵活地控制事务的范围，在事务中只保留必要的操作，避免大事务，这将显著减少事务的锁定时间和资源占用，带来性能提升</li>
<li><strong>优化分布式事务</strong>：为了保证下单阶段订单、库存、资产、权益（如限购）等数据的一致性，我们引入了TCC（Try-Confirm&#x2F;Cancel）模式的分布式事务，但分布式事务很容易对性能产生负面影响，需要进行调优（如下图所示）：</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/359d21b4df4839e2458c4db4b2546c0.png" alt="分布式事务">
</div>

<ul>
<li><strong>幂等性控制</strong>：主事务在调用TCC方法时可能因网络拥堵等原因超时，通常我们会通过引入超时与重试策略来提升成功率，这就要求分支事务需要保证TCC方法的幂等性，避免重复更新。另外需要特别重视优化TCC方法的执行性能，确保在预设的压力下，有足够大比例的请求RT低于超时时间</li>
<li><strong>允许空回滚</strong>：在实际的生产环境中，可能因网络拥堵等原因造成Cancel操作先于Try操作到达，因此，允许分支事务空回滚可以避免重试，从而带来更好的性能表现，即允许Cancel操作在找不到待回滚的业务主键的情况下也返回成功并将该业务主键记录下来，同时也要确保空回滚不会产生其他错误效果</li>
<li><strong>防悬挂</strong>：如果Cancel操作先于Try操作到达且Cancel操作返回成功的情况下（即允许空回滚），在执行Try操作时，有必要检查空回滚记录中是否存在该业务主键，存在则直接拒绝执行，否则（没有拒绝执行的话）会造成该分支事务悬挂</li>
<li><strong>减少无效回滚</strong>：Try操作可能遇到限流、校验不通过等情况造成直接返回，没有执行实际的业务操作，在这类场景，可以在回滚阶段不调用分支事务的Cancel操作，从而带来更好的性能表现</li>
</ul>
<p>限购优化：为了增加公平性，爆款商品一般会进行限购，即限制同一个用户在某个特定周期内或者某个特定活动中购买同一个商品的数量上限，通常我们需要借助加锁等并发控制手段来确保限购数据的一致性，不同的实现方式对于最终的性能表现有较大的影响，可以进行如下优化：</p>
<ul>
<li><strong>分布式锁</strong>：通过在下单参数校验阶段增加分布式锁，确保同一个用户无法连续下单购买同一个商品，结合上文提到的下单请求的幂等性控制，可以杜绝同一个账号通过多开或者连续点击等方式增大抢购成功率；同时，采用在参数校验阶段加分布式锁相比于限购检查阶段加锁（无论是数据库锁还是分布式锁）消耗的资源更少，性能表现更优</li>
<li><strong>缓存</strong>：采用分布式缓存（Redis）记录限购权益消耗情况，限购检查通过缓存替代数据库查询</li>
<li><strong>前置校验</strong>：结合业务流程，前置拦截不满足限购要求的请求，比如在商详、组单等阶段进行限购检查，相比于下单阶段检查消耗的资源更少，性能表现更优</li>
<li><strong>订单批量操作</strong>：「i茅台」采用的是典型的<strong>主子订单结构</strong>，主订单又叫支付订单，由1~N个子订单构成，子订单一般采用店铺（门店）粒度，这种方式可以比较容易地实现合并支付以及店铺（门店）粒度的实时分账。在下单阶段，假设用户同时支付N个店铺（门店）的商品，仅订单落库这个环节就需要1+N次DB操作（不含订单商品和订单地址落库），通过优化业务流程，只需要1次DB操作就可以达到相同的效果，从而带来性能提升</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/5c9d8e8cd155e70d6184eabe1ca01ba.png" alt="订单批量操作">
</div>

<p>由于爆款抢购都是单商品立即购买，因此，合并插入各个子订单的订单商品及订单地址不会提升性能，反而会增加不必要的代码复杂度</p>
<ul>
<li><strong>连接池及预热</strong>：通过连接池来管理数据库及Redis连接，根据应用并发度及DB负载情况分析连接池大小并设置合理的初始化数量，对性能改善有较大帮助，在此基础上，预热也可以让系统可以更快地进入到最佳状态，比如提前将商品信息加载到本地缓存和分布式缓存、利用就绪探针（如SpringBoot Actuator提供的readiness）提前预热每个服务实例（尤其是关键链路上的实例）以及系统发布后或者关键事件到来之前启动小流量预热等等</li>
</ul>
<p>通过采用上述优化策略，我们在不增加服务器的前提下，爆款抢购场景的整体吞吐量超过普通云购场景的两倍以上，相比与早期交付版本更是提升了三倍以上。</p>
<h2 id="2-2-2-数据库优化"><a href="#2-2-2-数据库优化" class="headerlink" title="2.2.2 数据库优化"></a>2.2.2 数据库优化</h2><p>数据库对系统性能也有着非常重要的影响，常见的数据库优化策略包括：</p>
<ul>
<li><strong>数据模型设计优化</strong>：数据模型设计是技术实现方案的重要组成部分，它不仅直接影响数据库的性能，也会影响数据库的可扩展性和可维护性，通常需要考虑以下两个方面：</li>
<li><strong>选择合适的设计范式</strong></li>
<li><strong>规范化</strong>（Normalization）可以减少数据冗余，但可能需要更多的联表操作</li>
<li><strong>反规范化</strong>（Denormalization）可以通过增加冗余列、派生列、合并表等策略最大程度避免联表操作或函数计算，提高查询性能，但会增加数据冗余，比较典型的反规范化设计是订单表，通过额外冗余门店、经销商等常用但变更频率很低的信息，可以提升订单查询的效率</li>
<li><strong>适当的数据类型和长度</strong>：根据业务需求选择适当的类型和长度来存储数据可以减少存储空间，也可以提升查询性能，如谨慎使用大数据类型（TEXT,CLOB,BLOB等），使用整数而不是字符串存储布尔值，避免存储null值等</li>
<li><strong>索引优化</strong>： 数据库索引可以显著提升查询性能，需要合理创建并维护索引，包括考虑哪些列以怎样的次序组合索引、选择适当的索引类型以及定期重建或重新组织索引等；同时，我们也需要了解索引匹配的基本原则，变更前对SQL与索引进行审查，避免最终使用的索引不符合预期（可以借助慢查询日志、explain等工具进行分析调优），需要注意的是，索引也并不是越多越好，它会占用额外的空间，会影响更新操作的性能</li>
<li><strong>查询优化</strong>：编写高效的SQL查询语句，包括尽可能避免使用SELECT *、避免全表扫描、谨慎使用联表查询和子查询（我们在业务代码中禁止使用）、限制查询返回的数据量等</li>
<li><strong>缓存</strong>：选择合适的缓存组件和缓存策略来存储频繁访问的数据（参见「无处不在的缓存」章节）以减少对数据库的访问，从而降低数据库负载，提升响应速度</li>
<li><strong>读写分离</strong>：在一些数据库负载比较高的业务中，可以将读取操作与写入操作进行分离，分别路由到不同的数据库服务器或数据库副本，从而降低主库（写库）的负载，提升响应速度</li>
<li><strong>分库分表</strong>：对于数据规模非常大的数据库，可以借助分库分表技术减少单库的负载，从而提升数据库的性能、可伸缩性和容错性</li>
</ul>
<p>这里以爆款抢购场景库存服务的性能优化为例介绍下这些策略的具体应用：</p>
<ul>
<li><strong>数据模型设计</strong>：结合商城的业务场景，存在数千家店铺（门店）投放同一个商品的情况（即多门店共用同一个商品），也存在商品独家销售的情况（即商品只在同一家店铺销售），每家店铺（门店）的销售库存需要单独管理，基于此，我们为库存服务设计了两张核心表，即库存表和库存流水表（如图所示）</li>
<li><strong>反规范化</strong>：库存表新建唯一索引(ShopId, SkuId)，库存流水表则冗余字段ShopId和SkuId，新建唯一索引(ShopId, SkuId, OrderId, Type)</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/8b5a051f0d633dad5fef4a41aa9d6f3.png" alt="库存相关的查询">
</div>

<ul>
<li><strong>选择的数据类型</strong>：以库存流水表中的Type字段为例，用来表示库存扣减、回滚、投放、回收等状态，显然用tinyint就足够进行存储了，相比于smallint、int类型可以节省存储空间</li>
<li><strong>数据库选型</strong>：库存流水表预计每年新产生的数据在千万级且会持续增长，而库存服务又是交易链路的核心依赖，读写操作频繁且有明显业务峰值，如果用单个MySQL实例去支持，存储和性能瓶颈较为明显，因此我们采用了分库分表的技术（<strong>网易自研的DDB</strong>）</li>
<li><strong>负载均衡</strong>：均衡字段（拆分键）和均衡策略的选择对于性能有非常明显的影响，需要格外重视，在库存服务这个例子中，库存表和库存流水表我们都使用ShopId作为均衡字段且使用相同的均衡策略，主要有以下几点考虑：</li>
<li><strong>库存相关的查询</strong>、变更都会指定ShopId和SkuId，在有数千家门店投放同一个爆款商品的情况下，采用ShopId作为均衡字段可以使数据分布和流量分布更为均衡，库存表采用与库存流水表相同的均衡字段和均衡策略，可以避免XA事务，减少锁竞争</li>
<li><strong>分布式ID</strong>：基于美团的分布式Id算法Leaf的统一ID生成服务在高并发场景具有低延迟、高吞吐、高可用、支持水平扩展的特点，同时也可以满足业务上自定义的需求，我们将它作为分布式ID生成的解决方案</li>
<li><strong>定期归档</strong>：数据规模的持续增长会对性能带来负面影响，可以考虑将早期的库存流水信息迁移到归档表，可以提升数据库性能</li>
</ul>
<h2 id="2-2-3-无处不在的缓存"><a href="#2-2-3-无处不在的缓存" class="headerlink" title="2.2.3 无处不在的缓存"></a>2.2.3 无处不在的缓存</h2><p>缓存技术是一种被广泛应用于计算机系统和应用程序中的性能优化方法，它通过将数据或计算结果暂时存储在高速存储介质中，使系统可以快速响应请求、返回数据，而无需每次都从慢速存储介质（如磁盘或远程服务器等）中获取数据。</p>
<p>利用好缓存技术可以降低资源负载，减少对数据库、网络或后端应用等外部资源的依赖，显著提升系统的性能与可用性。可以说，在我们现有的系统架构中，缓存几乎无处不在，以申购场景为例：</p>
<ul>
<li><strong>客户端（APP）</strong>：客户端通过缓存预置在APP的数据、缓存数据请求响应等方式减少对服务端的频繁访问，提供更为流畅的用户体验，尤其有助于改善首次访问或不稳定网络环境下的访问体验</li>
<li><strong>静态资源访问加速</strong>：静态资源访问加速的核心在于就近访问，我们可以通过静态化技术将动态生成的内容或网页转换成静态文件并存储到CDN（Content Delivery Network，内容分发网络）或LB（Load Balancer，负载均衡），在用户请求时离用户更近的节点可以直接提供这些静态文件，而不必再次请求服务端进行动态生成，因此，可以加快页面加载速度、提升网站或应用程序的性能、减少服务器负载并降低对服务器资源的需求。通常静态化技术可以应用于不经常变更的内容、访问量较大的页面、需要SEO优化的页面、静态资源等</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/70d65dd9ee6014e47e150729c3cffbd.png" alt="CDN">
</div>

<ul>
<li><strong>服务端</strong>：借助缓存可以减少当前应用对数据库或者其他后端服务的访问，通常我们可以直接使用分布式缓存（如Redis），但在高并发场景（如申购场景），为了增加系统整体的吞吐量，也可以考虑将热点数据设计成二级缓存，即同时使用本地缓存（Local Cache）和远端缓存（Remote Cache，或者叫分布式缓存）</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/0b822a67d09bd467efca771b70bcf64.png" alt="服务端">
</div>

<p>虽然缓存技术可以显著提升性能，但同时也极大提升了系统设计的复杂度，需要考虑缓存的一致性、失效策略和缓存维护等关键问题，如果没有处理好，很容易发生缓存数据不一致、缓存大面积穿透甚至引发雪崩。</p>
<p>以申购场景使用的二级缓存为例，我们需要处理好以下问题：</p>
<ul>
<li><strong>技术选型</strong>：本地缓存采用Caffeine，远端缓存采用Redis Cluster</li>
<li><strong>Caffeine</strong>：相比于EhCache、Guava等主流的缓存框架，拥有更加强大的性能表现，使用方式上与Guava类似，非常方便</li>
<li><strong>Redis Cluster</strong>：Redis Cluster是Redis提供的分布式缓存解决方案，也是目前主流的解决方案，相比于Proxy模式有更好的性能表现，但我们仍然需要重点关注硬件以及混部等因素对于性能及稳定性的影响</li>
<li><strong>避免缓存穿透</strong>：传统的关系型数据库对于并发的承受能力非常脆弱，如果我们设计的缓存命中率不高出现大面积缓存穿透，很有可能将数据库拖垮，如何避免缓存穿透是我们设计缓存时需要重点考虑的问题：</li>
<li>热点缓存采用预加载、定时刷新及事件触发刷新（如数据变更）的策略，保证100%命中率</li>
<li>当查询的结果为空时，仍然将空结果（自定义NullObject）存储到缓存中（可以设置一个较短的过期时间），这样可以防止恶意请求的连续查询</li>
<li><strong>消息队列与异步化</strong><br>异步化的核心思想是将耗时的操作从主流程中分离出来，以允许应用程序在等待这些操作完成的同时继续执行其他任务而不会被阻塞，从而改善系统的响应性和资源利用率。</li>
</ul>
<p>异步化通常可以通过多线程、多进程、事件驱动或异步编程模型等方式来实现，有很多中间件和框架可供我们选择，比如通过<strong>Disruptor</strong>、<strong>BlockingQueue</strong>等技术将任务分解为多个线程或进程以充分利用多核处理器的性能，通过消息队列（MQ）实现异步消息通信和服务解耦，达到对流量进行削峰填谷的效果，提升系统的可扩展性和性能。</p>
<p>这里重点提一下消息队列在「i茅台」的应用，无论在申购场景还是在爆款抢购场景（如下图所示），我们都需要借助消息队列实现对洪峰流量的削峰填谷，避免服务器过载或系统宕机，同时也可以实现数据的最终一致性，确保消息处理的结果与业务逻辑的一致性。</p>
<div style="text-align: center;">
  <img src="../img/netease/fff9e5cb5d1d4a7dbdbd4dc7f2b0fcc.png" alt="场景">
</div>

<p>不难发现，这其中的关键挑战在于消息队列本身的高性能以及在设计上如何确保数据的最终一致性。</p>
<p>先来看消息队列的选型，在严选，因为历史原因同时存在Kafka、Rabbitmq和RocketMQ，但综合考虑性能和稳定性表现（高吞吐量、低延迟、高可用）、功能特性丰富度、工具支持丰富度、社区活跃度等维度，RocketMQ最终成为业务系统消息队列的主流选型，「i茅台」则延续了这一选型，采用主从部署模式（4.8版本之前主从模式相对Dledger模式在性能上更有优势）。</p>
<p>接下来我们看一下如何确保数据的最终一致性。</p>
<p>先介绍四种我们平时开发过程中比较容易出错的实现方法（如下图所示）：</p>
<div style="text-align: center;">
  <img src="../img/netease/667be695bf6001287371101aa348f56.png" alt="四个方案">
</div>

<ul>
<li><strong>方案一</strong>：先执行数据库操作再发送消息到MQ，可能会出现数据库操作成功，消息发送失败的情况</li>
<li><strong>方案二</strong>：先发送消息到MQ再执行数据库操作，可能出现消息发送成功，数据库操作失败的情况</li>
<li><strong>方案三</strong>：在方案一的基础上，开启数据库事务，这个方案在消息发送失败抛出异常的情况下可以正常回滚，但有可能会出现消息发布至MQ成功但请求失败的情况（如网络拥堵等原因响应超时），这种情况也会引发事务整体回滚</li>
<li><strong>方案四</strong>：在方案二的基础上，开启数据库事务，这个方案如果数据库操作失败需要回滚，但MQ已经发生成功，没有办法回滚</li>
</ul>
<p>可见，上述四个方案都有可能出现数据库操作状态和消息发送状态不一致的情况，其中方案一可能出现数据库操作成功、消息发送失败，这类异常可以通过引入消息补偿机制来确保消息最终成功投递；方案二、三、四可能出现消息发送成功、数据库操作失败，这类异常可以通过在消息消费端增加消息状态确认或者类似的校验机制，确保被投递出去的消息不会对业务产生负面影响。</p>
<p>最后介绍两种比较常用的正确实现方法：</p>
<ul>
<li><strong>方案五</strong>：基于RocketMQ的事务消息来实现</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/4dbdec6fba905b4f5e19540f7607a53.png" alt="基于RocketMQ的事务消息来实现">
</div>

<ul>
<li>步骤一：消息生产者向RocketMQ发送半事务消息（1. Prepare），RocketMQ确认消息接收状态</li>
<li>步骤二：RocketMQ消息接收成功，消息生产者执行本地事务的业务逻辑</li>
<li>步骤三：消息生产者根据本地事务的执行结果向RocketMQ提交二次确认（2. Commit&#x2F;Rollback），RocketMQ将步骤一中收到的半事务消息标记为可投递（消费者就可以消费到这个消息）<br>如果因断网或者应用重启等原因，二次确认（2. Commit&#x2F;Rollback）没有成功提交，RocketMQ会定时触发事务消息回查，确认是否需要投递（兜底策略），无需投递的消息会在过期后删除</li>
<li>步骤四：RocketMQ将消息投递给消息消费者（3. 投递消息），消息消费者首先需要进行幂等性检查，通过检查后执行本地事务的业务逻辑，最后返回执行结果（4. Ack）</li>
<li><strong>方案六</strong>：基于消息补偿机制来实现</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/97457e7c70edc79df86acdf29075d74.png" alt="基于消息补偿机制来实现">
</div>

<ul>
<li>步骤一：在同一个本地事务中执行业务逻辑中的数据库操作和新增消息补偿记录（1. Prepare: 新增记录）</li>
<li>步骤二：本地事务提交后，启动异步线程，向RocketMQ发送消息（2. 发送消息），消息发送成功后删除消息补偿记录（3. Confirm: 删除记录）<br>如果因断网或者应用重启等原因，发送消息失败或者未成功删除消息补偿记录，消息生产者会定时触发消息补偿，确保发送到RocketMQ的消息至少发送一次（at least once策略，MQ有可能存在多条相同的消息）</li>
<li>步骤三：RocketMQ将消息投递给消息消费者（4. 投递消息），消息消费者首先需要进行幂等性检查（避免重复执行同一个消息），通过检查后执行本地事务的业务逻辑，最后返回执行结果（5. Ack）</li>
</ul>
<p>结合业务实际情况，由于RocketMQ的事务消息相比于普通消息性能上还是有不小的损失，无法完全满足我们的性能要求（服务器规模不变的前提下），因此我们最终选择了实现上更加复杂的方案六。</p>
<h2 id="2-2-4-硬件升级及资源优化"><a href="#2-2-4-硬件升级及资源优化" class="headerlink" title="2.2.4 硬件升级及资源优化"></a>2.2.4 硬件升级及资源优化</h2><p>硬件的性能和资源利用率同样也是我们性能优化过程中需要关注的地方，如果我们把不同的应用比喻成军队中不同的兵种，那么硬件就给不同兵种配置的装备，只有合理搭配，这些装备才能最大程度提升各兵种的战斗力，而合理搭配装备的底层逻辑，是对资源的最大化利用、避免浪费。</p>
<p>事实上，资源筹备工作往往是先于产品开发工作开展的，因此，我们的性能优化工作在绝大部分时候是在资源不变的前提下进行的。为了利用好这些资源，通常我们需要解决以下三个问题：</p>
<ol>
<li><p><strong>资源筹备阶段</strong>：如何准确地预估需要的资源？</p>
</li>
<li><p><strong>应用架构</strong>：从已知的业务信息中分离出不变的部分和变化的部分，输出全局应用架构和系统应用架构（包含应用及其依赖项），一般而言，中后台应用不变的部分更多容易预估，前台应用不确定性高也更难预估，但随着需求逐渐明朗（逐步进入产品研发阶段、产品运营阶段后），加上有更多的测试数据，预估也会越来越准确，因此，应用架构应保持持续演进以更好地厘清依赖关系及资源需求</p>
</li>
<li><p><strong>部署架构及资源清单</strong>：将应用架构映射成部署架构是资源预估的重要步骤，这个阶段一般还没有办法输出完整的流量模型，但架构师可以借助业务预判（如什么样的业务形态、多少用户参与等）拆解出核心域的前端入口流量（如申购流量、交易流量），各个域再逐层拆解到各个应用，最终映射出资源清单（也就是第一版资源清单），不难想象，要提升这个阶段资源预估准确性非常困难，需要业务方、开发团队、运维团队紧密协同，业务输入越充分预估会越准确，应用架构设计越完整预估会越准确</p>
</li>
</ol>
<p>产品研发阶段：如何结合应用特性合理地搭配和使用资源？</p>
<p>通常SRE会定义出不同的资源规格供各类应用选择：</p>
<ul>
<li><strong>CPU性能</strong>：CPU性能对于计算密集型任务非常重要，应用如果需要大量计算，需要配置高性能的CPU</li>
<li><strong>内存容量</strong>：内存容量对于数据密集型应用和需要缓存大量数据的应用至关重要，足够的内存可以减少对磁盘或网络的访问，提高性能</li>
<li><strong>存储</strong>：存储配置取决于数据量和性能需求，使用高性能固态硬盘（SSD）可以提高数据读写速度</li>
<li><strong>网络带宽</strong>： 如果应用需要大量的数据传输，网络带宽是一个瓶颈，一般负载均衡设备、应用网关、CDN需要重点考虑</li>
<li><strong>容量规划与流量模型设计</strong>：这个阶段需求已经非常明确，可以基于场景及最新的应用架构进行更为细致的流量拆解，评估出每个系统（尤其是核心系统）的容量要求及资源清单，并通过压测进行验证，确保系统在各种负载情况下都能够正常运行</li>
<li><strong>产品运营阶段</strong>：如何最大化地利用好现有的资源？</li>
<li><strong>资源超售或混部</strong>：一般可以通过云厂商提供的资源超售能力或者研发团队主动发起应用混部来提高资源利用率，然而这却是把双刃剑，更高的资源利用率也就意味着更低的资源容错率，一旦出现预期之外的流量或者资源占用，很容易成为压垮系统的最后一根稻草</li>
<li><strong>硬件升级及资源优化</strong>：通过诊断工具识别在压测或产品运营过程中出现的资源异常，如CPU使用率或Load不均衡、I&#x2F;O延迟大、内存使用率高等特征</li>
</ul>
<h2 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h2><p>性能优化是产品设计、研发和运营过程中的一个极其重要的环节，通过性能优化可以确保我们的系统满足性能设计目标。通常我们需要先借助性能诊断工具识别性能瓶颈，然后结合实际情况综合选择一种或者多种性能优化策略。</p>
<p>但需要特别注意的是，过早的优化可能会引入不必要的代码复杂性而性能却未必改善，因此，我们建议在系统开发的早期阶段应更侧重于保持代码的可维护性和可读性，随着系统的持续演进，再基于性能诊断结果对代码进行针对性地优化以满足性能需求。</p>
<h2 id="3-实现高可用的主要策略"><a href="#3-实现高可用的主要策略" class="headerlink" title="3 实现高可用的主要策略"></a>3 实现高可用的主要策略</h2><p>高性能并不意味着高可用，有些提升性能的手段会增加系统负载，反而还会降低可用性，而为了实现系统的高可用，我们通常需要引入一些复杂性或冗余，可能还会对性能产生一定负面影响。</p>
<p>本章节会重点探讨一下在系统架构和设计阶段如何考虑可用性目标。</p>
<h2 id="3-1-面向失败的设计"><a href="#3-1-面向失败的设计" class="headerlink" title="3.1 面向失败的设计"></a>3.1 面向失败的设计</h2><p>任何服务和组件都不是100%可靠的，因此核心系统的设计建议面向失败进行设计，即确保在部分组件或服务故障时仍然能够继续提供服务，比如前文提到的申购场景和爆款抢购场景都使用了这一设计理念。</p>
<p>这里我们总结下几种常用的策略：</p>
<ul>
<li><strong>最小化依赖</strong>：要减少对外部服务和组件的依赖，特别是减少强依赖，从而降低故障传播的风险</li>
<li><strong>冗余和备份</strong>：通过引入冗余组件或备份系统，在主要组件故障时可以无缝切换到备用组件，从而确保服务的连续性，需要特别重视的是，关键组件要避免单点</li>
<li><strong>自动故障检测和恢复</strong>：使系统能够主动检测故障或异常情况，并采取自动化措施以恢复正常运行，通过这种方式可以减少对人工干预的依赖，从而更快地响应问题，降低服务中断的风险</li>
<li><strong>超时与重试</strong>：在网络通信中，设置适当的超时时间，以防止请求挂起；使用重试机制确保请求的可靠性；结合合理的退避策略，避免过度重试导致服务器负载过高</li>
<li><strong>限流与降级</strong>：实施限流策略，控制请求流量以防止系统过载，在高负载或故障时降级部分功能，保持核心功能的可用性</li>
<li><strong>监控与报警</strong>：建立监控系统，实时追踪系统性能和健康状态，设置报警规则以在问题发生时及时通知运维团队采取行动</li>
<li><strong>应急预案</strong>：制定应急预案，在系统故障或紧急情况下快速采取行动以达到最大限度保护系统的目的，包括降低系统负载、故障止血与恢复、数据备份等等</li>
</ul>
<h2 id="3-2-微服务架构"><a href="#3-2-微服务架构" class="headerlink" title="3.2 微服务架构"></a>3.2 微服务架构</h2><p>微服务架构是一种典型的容错架构，由于「i茅台」商城在设计阶段已经明确了业务模式和流量挑战，因此我们没有像严选早期那样采用单体架构快速上线，而是直接采用微服务架构进行设计，基础设施则复用了严选的Service Mesh架构（参见网易严选ServiceMesh实践），相比于单体架构在以下几个方面具有明显优势：</p>
<ul>
<li><strong>故障隔离</strong>：微服务架构将一个应用程序被拆分成一组小型、独立的服务，每个服务都专注于执行特定的业务功能，当一个服务发生故障时，不会影响其他服务的正常运行，从而减小了故障的传播范围，提高了整体系统的可用性</li>
<li><strong>水平扩展</strong>：微服务架构使得每个服务可以独立地进行水平扩展，可以根据需求增加或减少服务实例的数量，以满足不同的负载要求，从而提高了系统的弹性和可用性</li>
<li><strong>快速故障恢复</strong>：微服务架构具备自动故障检测和切换机制，系统能够在检测到故障时自动将流量切换到其他服务实例，从而实现快速故障恢复，减少了服务中断的时间</li>
<li><strong>分布式部署</strong>：微服务架构支持分布式部署，服务可以部署在不同的服务器上（甚至可以跨数据中心进行部署），这提供了更高级别的容错性，避免单点故障</li>
<li><strong>灵活的更新和维护</strong>：由于每个服务都是独立的，可以单独更新和维护，而不会影响整个系统的可用性，这降低了维护和更新过程中的风险，减少了系统的停机时间</li>
</ul>
<p>有了基础架构提供的服务治理能力加持，开发需要在系统设计和开发阶段重点关注以下几点方面：</p>
<ul>
<li><strong>服务分级</strong>：服务分级是服务关联的一个标签，可以区分出每个服务对于业务影响的重要程度，我们认为每个服务都应该有对应的分级标签，它可以让我们更清晰地了解服务的可用性目标以及服务之间的依赖关系是否合理</li>
</ul>
<p>通常更高等级的服务应该匹配更高等级的服务保障，也应该具备更高的可用性，因此，要避免高等级的服务强依赖低等级的服务，否则容易造成高等级的服务无法达到既定的可用性目标</p>
<ul>
<li><strong>服务依赖</strong>：由于微服务架构会将服务拆分成更小的单元，这就不可避免地增加了服务之间的依赖关系，通常我们可以根据对故障的容忍度将依赖关系区分为强依赖和弱依赖，在设计上建议遵循以下原则：</li>
<li><strong>强依赖弱化</strong>：强依赖的服务应当尽量减少或减弱，以降低整个系统中某个服务的故障对其他服务的影响</li>
<li><strong>弱依赖异步化</strong>：弱依赖的服务可以采用异步通信方式（如消息队列），以降低对依赖服务的直接调用，提高系统的弹性和响应性</li>
<li><strong>超时治理</strong>：超时治理是通过优化超时时间与重试策略，使尽可能多的请求能够在预期时间内得到正常响应，提高系统的响应性，是一种重要的服务治理手段</li>
</ul>
<p>超时时间的设置应充分考虑业务本身的复杂性和预期响应时间，应设置足够长以容忍正常的响应延迟，但也不能过长避免无限期挂起等待</p>
<p>响应超时并不一定意味着目标服务已经不能工作，通过合理的重试机制，即使在目标服务器或网络故障的情况下也能够成功完成请求，但要确保请求的幂等性，避免重试请求对业务产生负面影响</p>
<p>设计合理的退避策略（如指数退避），避免连续重试导致服务器负载过高，另外，重试次数也应该有限，避免无限重试</p>
<p>在放弃请求后，系统可能采用降级策略，提供有限的服务，以确保核心功能的可用性</p>
<ul>
<li><strong>限流策略</strong>：限流是一种通过控制请求流量以防止系统过载的策略，也是一种非常重要的服务治理手段</li>
</ul>
<p>限流会带来一定的性能损耗，我们借助应用网关与限流中间件实现对流入网关及业务系统的流量进行限制，各个系统需结合服务等级、预估流量及应用当前能力选择是否开启</p>
<p>限流值的设置应充分考虑应用自身的能力，由于系统演进过程中的熵增是一种不可避免的趋势，建议限流值设置时保持一定的余量，以最大限度为系统提供有效保护</p>
<p>限流策略上可以为每个服务或接口设置最大请求速率，也可以进一步基于时间段、用户、IP地址等因素进行细化</p>
<ul>
<li><strong>降级策略</strong>：降级策略是一种应对系统负载过高或故障的策略，通过牺牲非关键功能以保持核心功能的正常运行</li>
<li><strong>主动降级</strong>：系统在监测到一定条件或预设的规则触发下，自动执行降级策略，包括自动关闭非关键功能、拒绝某些请求、减少资源分配等</li>
<li><strong>手动降级</strong>：运维人员或开发人员手动介入执行降级策略以应对特定的问题或异常情况，通常都是应对已知的问题或紧急情况，基于预案进行操作</li>
<li><strong>熔断策略</strong>：当一个服务在一段时间内出现连续的失败，熔断策略会中断对该服务的请求，避免因频繁请求失败而导致的资源浪费</li>
</ul>
<h2 id="3-3-客户端（APP）容错设计"><a href="#3-3-客户端（APP）容错设计" class="headerlink" title="3.3 客户端（APP）容错设计"></a>3.3 客户端（APP）容错设计</h2><p>客户端（APP）作为用户获得产品服务的主要入口，也大量使用了容错设计。</p>
<p>容错设计可以提升客户端整体的鲁棒性和可用性，以更好地应对服务端或网络等各种故障和异常情况，确保客户端在面临这些问题时仍然能够提供有限的服务，保持良好的用户体验。因此，客户端的容错设计往往也和产品策略息息相关，而不同的产品策略最终也会影响技术方案的选择，比如：</p>
<ol>
<li>首页无论在出现哪类异常都不应该挂掉，那么，我们在设计阶段就应该充分考虑请求失败等异常情况下如何进行兜底展示</li>
<li>大流量场景可能遇到限流等异常，可以通过设计等待页面或者排队动画避免流程中断（比如操作了一半进入错误页面）、减轻用户等待的焦虑感</li>
<li>随着版本的持续迭代，旧版本APP的用户是否还能正常使用产品服务</li>
</ol>
<p>设计明确的前后端交互协议有助于更好地解决上述问题：</p>
<ul>
<li><strong>错误处理和容错机制</strong>：通过规定统一的错误码和错误信息传递方式，使APP能够捕获和处理各种错误情况，包括网络错误、服务端错误、数据格式错误等，这有助于客户端实现统一的错误处理方法以应对各种异常情况</li>
<li><strong>版本兼容性</strong>：通过版本控制，可以确保在服务端升级或修改接口时不会影响现有的APP版本，保持兼容性；也可以通过版本控制，提醒用户或者强制用户升级到最新版本的APP</li>
<li><strong>通信安全</strong>：通过定义加密和认证规范，以确保通信的安全性，这有助于防止数据泄露和中间人攻击，提高系统的可靠性和安全性</li>
</ul>
<h2 id="3-4-全链路压测"><a href="#3-4-全链路压测" class="headerlink" title="3.4 全链路压测"></a>3.4 全链路压测</h2><p>类似「i茅台」这样大型的电商系统，具有业务场景复杂、核心链路长的特点，通过传统的测试方法在测试环境进行压测，已经难以确保系统在高负载和极端场景下的性能、可用性和稳定性了，因此，我们需要引入全链路压测。</p>
<p>全链路压测是在生产环境中基于真实的业务场景模拟用户操作和流量，以对整条业务链路进行压力测试，从而识别潜在的性能瓶颈或异常，有助于我们及时发现并解决，确保系统的高性能、高可用和稳定性。</p>
<p>要实现生产环境全链路可压测，除了前文提到的APM、日志平台等监控诊断工具之外，还需要具备以下能力：</p>
<ul>
<li><strong>全链路流量标记透传能力</strong>：通过全链路支持压测流量标记识别和传递，使线上全链路能区分压测流量和真实用户流量，保证在大流量压力测试时不会对真实用户体验以及真实用户数据造成影响，解决了因环境差异造成压测结果不真实，可以充分验证线上服务在大流量下的承载能力</li>
<li><strong>数据存储路由</strong>：使数据库、缓存、MQ、日志等存储介质可以识别压测流量，将压测产生的数据与真实用户数据分开保存，实现存储隔离，为线上压测提供数据安全保障</li>
<li><strong>压测平台</strong>：提供分布式高并发压测能力，支持上千台压测机同时发出压测流量、模拟千万级用户访问，支持大流量下的压测结果分析</li>
</ul>
<p>全链路压测要求技术团队进行更高效的协同，因此，除了工具和能力层面的支持，团队的成熟度也是影响这项工作能否顺利开展的关键因素：</p>
<ul>
<li><strong>明确核心链路</strong>：需要共同明确哪些是需要重点保障的场景，并通过业务梳理明确每个场景对应的核心链路</li>
<li><strong>容量规划与流量模型设计</strong>：结合产品运营计划，对每个场景的流量进行预估与拆解，明确核心链路上各个系统的性能指标、容量指标、SLA以及各自的强弱依赖（包括第三方服务，如各类云服务），并明确对依赖方的性能要求及降级预案</li>
<li><strong>限流配置及预案制定</strong>：结合各个系统的性能指标和容量指标，明确限流策略及限流值，梳理可能出现的异常场景并制定针对性的预案（如降级、熔断等）</li>
<li><strong>压测执行及预案演练</strong>：定期组织全链路压测并在压测前、压测中进行预案演练</li>
<li><strong>监控与报警</strong>：每个系统需要在各自的关键链路上设置监控和报警，以便在压测期间能实时监测性能及异常，并能够进行快速响应</li>
<li><strong>结果分析</strong>：分析并解释压测结果，识别预案及监控报警是否有效，识别是否存在潜在的性能问题和优化机会，最终产出压测报告</li>
<li><strong>改进优化</strong>：各个团队根据压测报告讨论并实施优化策略</li>
<li><strong>常态化基线压测及性能巡检</strong>：建立常态化机制，定期对系统进行性能测试以建立性能基线，以便了解系统在正常工作负载下的性能指标；定期监测和评估系统的性能，以便及早发现和解决性能问题</li>
</ul>
<h2 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h2><p>要实现系统的高可用性，我们需要在系统架构和设计阶段充分考虑各种故障和异常场景，包括硬件故障、网络中断、软件错误等，通过减少依赖、引入冗余和备份、实现自动故障检测与恢复、增加限流及应急预案、引入监控报警机制等策略来减轻突发流量或故障对系统产生的影响，确保在部分组件或服务故障时系统仍然能够继续提供服务，同时我们也必要借助全链路压测等手段识别潜在的问题以确保上述策略是持续有效的。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>「i茅台」商城作为茅台酒线上销售的主要入口，从诞生的第一天开始就需要考虑如何有效地应对大流量高并发的考验，这要求我们在保证数据一致性的前提下，实现系统的高性能和高可用，其中高性能意味着更快的响应时间和更大的吞吐量，可以同时为更多的用户提供流畅的服务，而高可用则意味着系统需要在面临故障或异常情况时仍然保持可用性。</p>
<p>为了实现系统的高性能和高可用，我们需要结合业务诉求、产品运营情况及系统现状进行分析，综合选取一些性能优化技术与高可用系统的设计方法，使系统在性能、可用性、安全性、可维护性等方面保持一种最佳的平衡状态。</p>
<p>本质上，系统的架构和设计就是权衡和取舍的过程，权衡性能与可用性、成本与性能、安全性与便利性、扩展性与复杂性，不同的系统可能需要不同的权衡，本文希望通过这些实际的案例帮助大家更好地理解这些技术和策略以及背后的权衡过程，从而可以更好地应用在我们日常的设计与开发过程中。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/01/22/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week8/">网易牛马日志-week8</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-01-22
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>System.out.println(“I am back”);</p>
</blockquote>
<h2 id="需求10：俄罗斯印度公司的后端改造"><a href="#需求10：俄罗斯印度公司的后端改造" class="headerlink" title="需求10：俄罗斯印度公司的后端改造"></a>需求10：俄罗斯印度公司的后端改造</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>为了能尽快丰富页面实现seo，优先开放数据组刚挖掘出来的俄罗斯印度公司详细信息，当存量不足的时候再去按照原有逻辑开放普通公司。此外为了优化全球搜变动导致的页面失效，需要在出海项目的es里面保存一份副本，否则会影响谷歌收录。</p>
<h3 id="改进结构"><a href="#改进结构" class="headerlink" title="改进结构"></a>改进结构</h3><div style="text-align: center;">
  <img src="../img/netease/1736739033864.svg" alt="后端架构">
</div>

<p>分为两个方面取数据，全球搜和扩展es，扩展es洗了一些俄罗斯印度公司的拓展信息用于展示，与全球搜主键id关联，从而可以组装起来作为一个更大的bo。但是如果当公司开放之后，全球搜es有变动导致无法访问就会严重影响谷歌收录。所以需要更改保存逻辑，直接在每日新增中执行组装，如果此时全球搜有那就保留，且写回扩展索引中。如果没有就跳过，这样以来所有的信息全部都持久化到扩展es中，用公式写就是A（全球搜）+B（扩展）-&gt;AB（组装后的大对象）-&gt;写回扩展es。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>sourceBuilder构造：查询指定国家，根据质量分数倒序排序，但是这样顺序开放会导致重复扫描的越来越多，后续一个小时有可能都跑不完了。</li>
<li>查询开放公司的最大dataId，然后追加dataId，得到原始输入List。</li>
<li>接下来要一个个去请求全球搜去组装一个更大的对象，如果返回有问题就过滤掉不入库，返回无问题就直接upsert拓展索引。</li>
<li>最后作为开放公司写入数据库</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【俄罗斯、印度】extendIndex组合全球搜base信息重新写入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> country</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">upsertExtendDetailToDbAndEs</span><span class="params">(String country, String param)</span> &#123;</span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    boolQuery.must(QueryBuilders.termQuery(<span class="string">&quot;standardCountry&quot;</span>, country));</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>()</span><br><span class="line">            .query(boolQuery)</span><br><span class="line">            .fetchSource(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;companyId&quot;</span>,<span class="string">&quot;name&quot;</span>&#125;, <span class="literal">null</span>)</span><br><span class="line">            .sort(<span class="string">&quot;dataQualityScore&quot;</span>,SortOrder.DESC)</span><br><span class="line">            .size(Integer.parseInt(param));</span><br><span class="line">    <span class="comment">//从es中抽取指定数量的companyList</span></span><br><span class="line">    List&lt;SiteMapCompanyEntity&gt; originalCompanyList = loadCompanyToExtendIndex(companyExtendIndex, sourceBuilder, param);</span><br><span class="line">    <span class="comment">//过滤全球搜不开放的公司</span></span><br><span class="line">    List&lt;SiteMapCompanyEntity&gt; filterCompanyList = originalCompanyList.stream().filter(<span class="built_in">this</span>::filterAndUpsertCompanyExtendIndex).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//保存进db</span></span><br><span class="line">    saveBatch(filterCompanyList);</span><br><span class="line">    log.info(<span class="string">&quot;upsertExtendDetailToDbAndEs success record &#123;&#125;&quot;</span>,filterCompanyList.size());</span><br><span class="line">    <span class="keyword">return</span> filterCompanyList.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【其他国家】extendIndex组合全球搜base信息重新写入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 补齐条数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upsertNormalDetailToDbAndEs</span><span class="params">(String param)</span> &#123;</span><br><span class="line">    <span class="comment">// 有域名的排前面(强制排序)</span></span><br><span class="line">    <span class="type">Script</span> <span class="variable">hasDomainScript</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Script</span>(<span class="string">&quot;if(doc[&#x27;domainCount&#x27;].size()&gt;0 &amp;&amp; doc[&#x27;domainCount&#x27;].value&gt;=1) return 1; else return 0&quot;</span>);</span><br><span class="line">    <span class="comment">// 域名无效的后置(强制排序)</span></span><br><span class="line">    <span class="type">Script</span> <span class="variable">invalidDomainScript</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Script</span>(<span class="string">&quot;if(doc[&#x27;domainStatus&#x27;].size()&gt;0 &amp;&amp; doc[&#x27;domainStatus&#x27;].value&gt;0) return 0; else return 1&quot;</span>);</span><br><span class="line">    <span class="comment">// 有邮箱前置</span></span><br><span class="line">    <span class="type">Script</span> <span class="variable">hasEmailScript</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Script</span>(<span class="string">&quot;if(doc[&#x27;emailCount&#x27;].size()&gt;0 &amp;&amp; doc[&#x27;emailCount&#x27;].value&gt;=1) return 1; else return 0&quot;</span>);</span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;overviewDescription&quot;</span>));</span><br><span class="line">    boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;companyId&quot;</span>));</span><br><span class="line">    boolQuery.mustNot(QueryBuilders.termQuery(<span class="string">&quot;disable&quot;</span>, <span class="string">&quot;true&quot;</span>));</span><br><span class="line">    boolQuery.must(QueryBuilders.wildcardQuery(<span class="string">&quot;overviewDescription&quot;</span>, <span class="string">&quot;*&quot;</span>));</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>()</span><br><span class="line">            .query(boolQuery) <span class="comment">// 查询参数</span></span><br><span class="line">            .fetchSource(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;companyId&quot;</span>&#125;,</span><br><span class="line">                    <span class="literal">null</span>)</span><br><span class="line">            .size(<span class="number">1000</span>)</span><br><span class="line">            <span class="comment">// 有无域名排序</span></span><br><span class="line">            .sort(SortBuilders.scriptSort(hasDomainScript, ScriptSortBuilder.ScriptSortType.NUMBER).order(SortOrder.DESC))</span><br><span class="line">            <span class="comment">// 无效域名排序</span></span><br><span class="line">            .sort(SortBuilders.scriptSort(invalidDomainScript, ScriptSortBuilder.ScriptSortType.NUMBER).order(SortOrder.DESC))</span><br><span class="line">            <span class="comment">// 有邮箱前置</span></span><br><span class="line">            .sort(SortBuilders.scriptSort(hasEmailScript, ScriptSortBuilder.ScriptSortType.NUMBER).order(SortOrder.DESC));</span><br><span class="line">    <span class="comment">//从es中抽取指定数量的companyList</span></span><br><span class="line">    List&lt;SiteMapCompanyEntity&gt; originalCompanyList = loadCompanyToExtendIndex(openCompanyIndex, sourceBuilder, param);</span><br><span class="line">    <span class="comment">//过滤全球搜不开放的公司</span></span><br><span class="line">    List&lt;SiteMapCompanyEntity&gt; filterCompanyList = originalCompanyList.stream().filter(<span class="built_in">this</span>::filterAndUpsertCompanyExtendIndex).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//保存进db</span></span><br><span class="line">    saveBatch(filterCompanyList);</span><br><span class="line">    log.info(<span class="string">&quot;upsertNormalDetailToDbAndEs success record &#123;&#125;&quot;</span>,filterCompanyList.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询索引并转换为数据库逻辑，输出是实际新增开放公司，小循环用set去重，大循环直接去数据库count&gt;0去重。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用新增开放公司逻辑</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> abstractIndex es索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceBuilder es查询条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 查询数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 实际新增开放公司List</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;SiteMapCompanyEntity&gt; <span class="title function_">loadCompanyToExtendIndex</span><span class="params">(AbstractIndex&lt;T&gt; abstractIndex,SearchSourceBuilder sourceBuilder,String param)</span>&#123;</span><br><span class="line">    <span class="type">SiteMapCompanyEntity</span> <span class="variable">maxCompany</span> <span class="operator">=</span> getMaxDataId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">maxDataId</span> <span class="operator">=</span> maxCompany == <span class="literal">null</span> ? <span class="number">1</span> : maxCompany.getDataId();</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    count.incrementAndGet();</span><br><span class="line">    List&lt;SiteMapCompanyEntity&gt; addList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    abstractIndex.scrollSearch(sourceBuilder, searchHits -&gt; &#123;</span><br><span class="line">        Set&lt;String&gt; companyIdSets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addList.size() &gt;= Integer.parseInt(param)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Object&gt; result = searchHit.getSourceAsMap();</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> result.get(<span class="string">&quot;name&quot;</span>).toString();</span><br><span class="line">            <span class="type">String</span> <span class="variable">companyId</span> <span class="operator">=</span> result.get(<span class="string">&quot;companyId&quot;</span>).toString();</span><br><span class="line">            <span class="comment">//本轮去重</span></span><br><span class="line">            <span class="keyword">if</span> (companyIdSets.contains(companyId)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            companyIdSets.add(companyId);</span><br><span class="line">            <span class="comment">//全局去重</span></span><br><span class="line">            <span class="keyword">if</span> (isOpeningCompany(companyId))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数据库对象转换，包装首字母等</span></span><br><span class="line">            <span class="type">SiteMapCompanyEntity</span> <span class="variable">siteMapCompanyEntity</span> <span class="operator">=</span> convertIndexToDbEntity(name, companyId);</span><br><span class="line">            siteMapCompanyEntity.setDataId(maxDataId + count.longValue());</span><br><span class="line">            count.getAndIncrement();</span><br><span class="line">            addList.add(siteMapCompanyEntity);</span><br><span class="line">            log.info(<span class="string">&quot;loadCompanyToExtendIndex add record &#123;&#125;&quot;</span>,JSON.toJSONString(siteMapCompanyEntity));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> addList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在xxl-job里面定义定时任务，开两个定时任务，分别输入”Russia|1500”，”India|1500”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增公司数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@XxlJob(&quot;addExtendToOpenDb&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">addExtendToOpenDb</span><span class="params">(String param)</span> &#123;</span><br><span class="line">    param = StringUtils.isEmpty(param) ? <span class="string">&quot;1500&quot;</span> : param;</span><br><span class="line">    XxlJobLogger.log(<span class="string">&quot;addExtendToOpenDb job start&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String[] params = param.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line">        <span class="comment">//带国家和数量</span></span><br><span class="line">        <span class="keyword">if</span> (params.length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">loadedSize</span> <span class="operator">=</span> siteMapCompanyService.upsertExtendDetailToDbAndEs(params[<span class="number">0</span>], params[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">remainSize</span> <span class="operator">=</span> Integer.parseInt(params[<span class="number">1</span>]) - loadedSize;</span><br><span class="line">            <span class="keyword">if</span>(remainSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                siteMapCompanyService.upsertNormalDetailToDbAndEs(String.valueOf(remainSize));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.length == <span class="number">1</span>) &#123;</span><br><span class="line">            siteMapCompanyService.upsertNormalDetailToDbAndEs(String.valueOf(params[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        XxlJobLogger.log(<span class="string">&quot;addExtendToOpenDb error&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;addExtendToOpenDb error&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    XxlJobLogger.log(<span class="string">&quot;addExtendToOpenDb job end&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="需求11：AIGC能力——大模型总结网页"><a href="#需求11：AIGC能力——大模型总结网页" class="headerlink" title="需求11：AIGC能力——大模型总结网页"></a>需求11：AIGC能力——大模型总结网页</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>前面补充的数据还是没能影响seo，可能是因为数据不够独特，同质性太强。因此需要用ai总结一下，做出差异化的内容。</p>
<h3 id="提示词"><a href="#提示词" class="headerlink" title="提示词"></a>提示词</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">The following text is taken from the official website of a company named: [bi-ehealthcare]. </span><br><span class="line">Based on the content provided, generate 6-8 self-questions and answers related to the company&#x27;s information. </span><br><span class="line">The question is information related to the company: the company&#x27;s products, industry, services, address and contact information (telephone, email, etc.), and other points of fact mentioned in the content provided, but not limited to this.</span><br><span class="line">Provide quality responses and avoid general responses such as &quot;Unfortunately, the text does not provide...&quot; . </span><br><span class="line">Avoid interference from privacy policies and cookies, and ensure that the total length of the reply is not less than 500 characters. In particular.</span><br><span class="line">Organize and translate your answers in English, as shown below:</span><br><span class="line">Q1: XXXX,</span><br><span class="line">A1: XXXX,</span><br><span class="line">Q2: XXXX,</span><br><span class="line">A2: XXXX</span><br></pre></td></tr></table></figure>

<h3 id="大模型的原理（挖个坑、后续研究）"><a href="#大模型的原理（挖个坑、后续研究）" class="headerlink" title="大模型的原理（挖个坑、后续研究）"></a>大模型的原理（挖个坑、后续研究）</h3><p>输入的是提示词和域名，大模型会去根据域名获得html页面，然后根据python某些工具去递归挖掘子url和html，拼接token，结合RAG从而获得更大规模的输入，然后根据提示词去调用llama3.2，得到输出。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/12/25/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week5%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%89%88%EF%BC%89/">网易牛马日志-week5（学习版）</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-12-25
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h1><h2 id="邮箱注册"><a href="#邮箱注册" class="headerlink" title="邮箱注册"></a>邮箱注册</h2><p>用户视角：输入邮箱和密码（有校验）-&gt;填写个人信息-&gt;收到确认邮件-&gt;点击跳转链接</p>
<h3 id="输入邮箱和密码（有校验）"><a href="#输入邮箱和密码（有校验）" class="headerlink" title="输入邮箱和密码（有校验）"></a>输入邮箱和密码（有校验）</h3><p>输入邮箱密码，前端通过正则表达式校验密码格式，后端请求&#x2F;email&#x2F;check来检查账号是否启用。这里启用指的是已经点击过验证邮件的或者用oauth已经校验过的。这里没校验过邮件的应该还是可以重新发起注册的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> EmailSignUpCheckResp <span class="title function_">emailSignUpCheck</span><span class="params">(EmailSignupCheckReq emailSignupCheckReq, HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">EmailSignUpCheckResp</span> <span class="variable">emailSignUpCheckResp</span> <span class="operator">=</span> EmailSignUpCheckResp.builder()</span><br><span class="line">            .emailSignUpCheckStatus(EmailSignUpCheckStatus.UN_SIGN_UP)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 校验注册邮箱</span></span><br><span class="line">    <span class="type">UserEntity</span> <span class="variable">user</span> <span class="operator">=</span> userServiceImpl.getUserEntityByLoginUsername(emailSignupCheckReq.getEmail());</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(user)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UserState.OPEN.getCode() == user.getState()) &#123;</span><br><span class="line">            emailSignUpCheckResp.setEmailSignUpCheckStatus(EmailSignUpCheckStatus.ALREADY_VERIFIED);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            emailSignUpCheckResp.setEmailSignUpCheckStatus(EmailSignUpCheckStatus.ALREADY_SIGN_UP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> emailSignUpCheckResp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册逻辑-确认邮件的回调逻辑"><a href="#注册逻辑-确认邮件的回调逻辑" class="headerlink" title="注册逻辑+确认邮件的回调逻辑"></a>注册逻辑+确认邮件的回调逻辑</h3><ol>
<li>查询用户信息：check校验的是是否有效。这里检查是否别的方式已经注册了（通过email字段查）</li>
<li>检查密码强度</li>
<li>邀请码（暂时不需要）</li>
<li>保存用户信息（两张表，一张存用户实体，另一张存账号密码和盐）</li>
<li>埋点上报</li>
</ol>
<p>这里最重要的是“保存用户信息”。在注册之后会入库账号密码，但是未激活（就是check检查的那个字段，只有点击了邮件链接才会接收到）。</p>
<p>随后生成一个UUID作为参数传给邮件，同时缓存在redis中。在邮件里面放这个链接和参数，点击的时候自动就会去请求“&#x2F;verify&#x2F;email?cs&#x3D;”。<br>这个方法会解析加密参数，与redis中进行比较。校验成功后激活用户状态，最后走获取token的逻辑，那部分等讲登录的时候再说。</p>
<h3 id="邮箱相关"><a href="#邮箱相关" class="headerlink" title="邮箱相关"></a>邮箱相关</h3><p>发送的是html，这里用到了FreeMarker，模板里面只有两个需要动态换的，一个是称呼一个是对应的重定向链接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; templateParams = Maps.newHashMap();</span><br><span class="line">templateParams.put(<span class="string">&quot;accountName&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">templateParams.put(<span class="string">&quot;registerLink&quot;</span>, <span class="string">&quot;https://www.bilibili.com&quot;</span>);</span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> resourceLoader.getResource(<span class="string">&quot;classpath:template/&quot;</span>+registerTemplate);</span><br><span class="line"><span class="type">byte</span>[] fileData = FileCopyUtils.copyToByteArray(resource.getInputStream());</span><br><span class="line"><span class="type">String</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(fileData, StandardCharsets.UTF_8);</span><br><span class="line">textPart.setContent(template, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(template.getBytes())) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> FreemarkerUtils.process(inputStream, templateParams);</span><br><span class="line">    System.out.println(content);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后发送邮件配置就完了，这里暂时用的是gmail，最后得搭建公司邮件服务器。</p>
<h3 id="邮箱登录"><a href="#邮箱登录" class="headerlink" title="邮箱登录"></a>邮箱登录</h3><ol>
<li>各种参数校验，包括上面一直在讲的激活状态。</li>
<li>密码校验（数据库盐是Base64，可以加密解密的）： encode(用户输入+Base64Decode(数据库盐)) &#x3D;&#x3D; 数据库加密后的密码。</li>
<li>校验成功则登录成功，首先解析ip到国家和省份保存。然后生成token作为session保存在redis里面，设定过期时间为7天。</li>
<li>将token返回给前端，每次请求都要携带。</li>
</ol>
<h1 id="oauth"><a href="#oauth" class="headerlink" title="oauth"></a>oauth</h1><h2 id="谷歌code解析"><a href="#谷歌code解析" class="headerlink" title="谷歌code解析"></a>谷歌code解析</h2><p>类似微信小程序，前端先去请求谷歌登录，谷歌会返回一个code，后端拿到这个code去oauth里获得用户登录信息。拿这个信息去业务数据库里查询是否有记录来判断是注册还是登录。</p>
<p>如果没有实际用户说明是注册，如果有还需要判断注册方式是否是oauth，分为其他方式注册和直接登录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OAuthLoginUser <span class="title function_">getAuthUserInfo</span><span class="params">(OAuthUserInfoReq req)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!oAuthRequestFactory.support().contains(req.getOAuthType().toUpperCase())) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;getAuthUserInfo, source not supported, req: &#123;&#125;&quot;</span>, req);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;unsupported oauth type&quot;</span>, BizError.ENUM_PARAM_ERR.getCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拿着oauth去解析，获得用户数据</span></span><br><span class="line">    <span class="type">AuthRequest</span> <span class="variable">authRequest</span> <span class="operator">=</span> oAuthRequestFactory.create(req.getOAuthType());</span><br><span class="line">    AuthResponse&lt;AuthUser&gt; authResponse = authRequest.login(AuthCallback.builder().code(req.getCode()).build());</span><br><span class="line">    <span class="type">AuthUser</span> <span class="variable">authUserInfo</span> <span class="operator">=</span> authResponse.getData();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(authUserInfo)) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;getAuthUserInfo, authUserInfo is null, req: &#123;&#125;&quot;</span>, req);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.COMMON_ERR.getName(), BizError.COMMON_ERR.getCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存获取的用户信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">accessCode</span> <span class="operator">=</span> CodeUtils.generateOAuthSignupCode();</span><br><span class="line">    redisManager.addOAuthUser(accessCode, authUserInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前OAuth状态</span></span><br><span class="line">    <span class="type">OAuthType</span> <span class="variable">oAuthType</span> <span class="operator">=</span> OAuthType.of(req.getOAuthType());</span><br><span class="line">    <span class="type">String</span> <span class="variable">userIdentify</span> <span class="operator">=</span> authUserInfo.getUsername();</span><br><span class="line">    OAuthStatus oAuthStatus;</span><br><span class="line">    <span class="type">UserEntity</span> <span class="variable">user</span> <span class="operator">=</span> userServiceImpl.getUserEntityByLoginUsername(userIdentify);</span><br><span class="line">    <span class="comment">//用户实体表没有就是没注册</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(user)) &#123;</span><br><span class="line">        <span class="comment">//查指定枚举信息的</span></span><br><span class="line">        <span class="type">UserAuthEntity</span> <span class="variable">auth</span> <span class="operator">=</span> userAuthServiceImpl.getByIdentifier(userIdentify,</span><br><span class="line">                IdentityType.convert(oAuthType).getCode());</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(auth)) &#123;</span><br><span class="line">            <span class="comment">// 同种类型重复注册</span></span><br><span class="line">            oAuthStatus = OAuthStatus.LOGIN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已经存在其他方式注册</span></span><br><span class="line">            oAuthStatus = OAuthStatus.ANOTHER_SIGNUP_WAY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oAuthStatus = OAuthStatus.SIGNUP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OAuthLoginUser.convert(authUserInfo, accessCode, oAuthStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端可能会根据三种枚举值来走登录、注册和提示逻辑。</p>
<h3 id="oauth注册"><a href="#oauth注册" class="headerlink" title="oauth注册"></a>oauth注册</h3><p>注册逻辑基本一致，多了一个从redis中查询oauth的用户信息的过程（例如google保存的头像链接），如果没查到就是验证超时，如果查到了但是用户不匹配就抛异常。最后给token，然后删除oauth的验证信息。</p>
<h3 id="oauth登录"><a href="#oauth登录" class="headerlink" title="oauth登录"></a>oauth登录</h3><p>基本一致，也是多了一个从redis里面拿accesscode的过程。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/12/25/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week5/">网易牛马日志-week5</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-12-25
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>写在前面：经过一个月的实习，我逐渐觉得沟通能力和理解能力远比代码能力重要。不论是在科研组会上的哑口无言，还是在工作上对接的七嘴八舌，都暴露出了我语言能力的欠缺。我从初中开始就知道这是我的短板，但没想到有这么短。这也再次给我敲响了警钟，不管你是什么学术或者技术大师，学说话和听说话是最基本的。</p>
</blockquote>
<h2 id="需求7：【出海项目】ip限流"><a href="#需求7：【出海项目】ip限流" class="headerlink" title="需求7：【出海项目】ip限流"></a>需求7：【出海项目】ip限流</h2><p>注解+aop+lua+redis+滑动窗口限流算法</p>
<h3 id="注解和aop"><a href="#注解和aop" class="headerlink" title="注解和aop"></a>注解和aop</h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>根据多个时间单位配置限流器，定义了时间枚举类，按照毫秒存储持续时间（因为注解只能用枚举，不能用正常类）。</p>
<blockquote>
<p>正常是要传3个值的：次数，时间单位，超时时间（主要是给后面对redis设置expireTime）。这里为了方便超时时间与时间单位一致。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用示例：1分钟限制10次，1小时限制500次</span></span><br><span class="line"><span class="meta">@IpRateLimit(limit = &#123;10,500&#125;, timeUnit = &#123;TimeUnit.MINUTE,TimeUnit.HOUR&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注解定义</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IpRateLimit &#123;</span><br><span class="line">    <span class="type">int</span>[] limit();  <span class="comment">// 限流值</span></span><br><span class="line">    TimeUnit[] timeUnit();  <span class="comment">// 时间单位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TimeUnit</span> &#123;</span><br><span class="line">    YEAR(<span class="number">1</span>, <span class="string">&quot;YEAR&quot;</span>, <span class="number">1000L</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span> * <span class="number">365</span>),</span><br><span class="line">    MONTH(<span class="number">2</span>, <span class="string">&quot;MONTH&quot;</span>, <span class="number">1000L</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>),</span><br><span class="line">    DAY(<span class="number">3</span>, <span class="string">&quot;DAY&quot;</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>),</span><br><span class="line">    HOUR(<span class="number">4</span>, <span class="string">&quot;HOUR&quot;</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>),</span><br><span class="line">    MINUTE(<span class="number">5</span>, <span class="string">&quot;MINUTE&quot;</span>, <span class="number">1000</span> * <span class="number">60</span>),</span><br><span class="line">    SECOND(<span class="number">6</span>, <span class="string">&quot;SECOND&quot;</span>, <span class="number">1000</span>),</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//单位是毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> periodInMills;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="aop"><a href="#aop" class="headerlink" title="aop"></a>aop</h4><p>校验注解里两个数组长度必须相同，对每一个配置new一个限流器来执行redis脚本。（我在想这里每次限流就new一个开销会不会有点大，但是不能用@service，因为有状态的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpRateLimiterAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisLuaRateLimiter redisLuaRateLimiter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.netease.cowork.sirius.it.data.overseas.server.frame.anno.IpRateLimit)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rateLimiter</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;rateLimiter() &amp;&amp; @annotation(ipLimiter)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">(JoinPoint joinPoint, IpRateLimit ipLimiter)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">int</span>[] limit = ipLimiter.limit();</span><br><span class="line">        TimeUnit[] timeUnits = ipLimiter.timeUnit();</span><br><span class="line">        <span class="keyword">if</span> (limit.length != timeUnits.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取用户ip</span></span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="keyword">assert</span> attributes != <span class="literal">null</span>;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; limit.length; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">periodInMills</span> <span class="operator">=</span> timeUnits[i].getPeriodInMills();</span><br><span class="line">            redisLuaRateLimiter = <span class="keyword">new</span> <span class="title class_">RedisLuaRateLimiter</span>(limit[i], periodInMills, periodInMills,timeUnits[i].getName());</span><br><span class="line">            <span class="keyword">if</span> (!redisLuaRateLimiter.tryAcquired(ip))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;操作频繁，请稍后重试&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redis-lua实现滑动窗口限流算法"><a href="#redis-lua实现滑动窗口限流算法" class="headerlink" title="redis+lua实现滑动窗口限流算法"></a>redis+lua实现滑动窗口限流算法</h3><p>lua脚本在这里最大的作用就是解决并发问题，且保证原子性。分别说这个几个参数：</p>
<ul>
<li>KEYS[1]：String key &#x3D; prefix + ip。业务名称+ip。因为可能有多个业务都需要限流。</li>
<li>ARGV[1]：now-periodInMills。时间校验的分界线，往后为需要计算的流量。</li>
<li>ARGV[2]：now</li>
<li>ARGV[3]：UUID.randomUUID()真正的value值，随便写一个</li>
<li>ARGV[4]：expireInMills</li>
<li>ARGV[5]：limit</li>
</ul>
<p>基本原理是zset的score存时间戳，ZREMRANGEBYSCORE这个方法会去除0到now-periodInMills的所有元素，剩下的就是要统计的元素。ZCARD用来统计当前元素数量，如果比count小就没有达到限流，ZADD设置value，score和超时时间。如果限流就返回特殊数字。<br>最后只用判断lua脚本执行是否是1来判断限流。</p>
<p>其他的代码都是java操作lua的方法，核心如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限流</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_LIMIT_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;local removedCount = redis.call(&#x27;ZREMRANGEBYSCORE&#x27;, KEYS[1], 0, ARGV[1])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;local currentCount = redis.call(&#x27;ZCARD&#x27;, KEYS[1])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;if currentCount &lt; tonumber(ARGV[5]) then\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    redis.call(&#x27;ZADD&#x27;, KEYS[1], ARGV[2], ARGV[3])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    redis.call(&#x27;PEXPIRE&#x27;, KEYS[1], ARGV[4])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return 1\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;else\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return 0\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line"><span class="comment">//统计rate</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_LIMIT_COUNT_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;local removedCount = redis.call(&#x27;ZREMRANGEBYSCORE&#x27;, KEYS[1], 0, ARGV[1])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;local currentCount = redis.call(&#x27;ZCARD&#x27;, KEYS[1])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;return currentCount&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>结论是对比海关服务的限流，这种写lua的方法能快三倍，限流速度50ms，他们的150ms。而且配置也很简单。</p>
<h2 id="需求8：【出海项目】sitemap与seo优化"><a href="#需求8：【出海项目】sitemap与seo优化" class="headerlink" title="需求8：【出海项目】sitemap与seo优化"></a>需求8：【出海项目】sitemap与seo优化</h2><blockquote>
<p><strong>什么是seo？</strong></p>
<p>搜索引擎优化，指的是通过合理手段和一些小技巧提升在谷歌上面的排名。这个出海项目最终要达到的效果是，在谷歌上查询一个公司，我们的界面要比这个公司靠前，从而获取自然流量，有了自然流量就可以变现了。<br>类似天眼查，每次去查询一个公司的官网，天眼查总能比官网靠前（其实也有可能是百度自家特殊关照）。</p>
<p><strong>什么是sitemap？</strong></p>
<p>sitemap.xml是一个站点地图，相当于给谷歌的爬虫一个指引，告诉他我的网站都有哪些路径需要你来访问的，这个地图一级只能有5w条，而我们的业务规模有6kw，所以采取两级索引，并采用gz进行压缩。<br>而我做的工作是定时更新这个sitemap并放到前端服务器上给爬虫来爬。</p>
</blockquote>
<h3 id="sitemap自底向上构建"><a href="#sitemap自底向上构建" class="headerlink" title="sitemap自底向上构建"></a>sitemap自底向上构建</h3><p>给了两张表，底层存公司，顶层存索引。我最初的想法是自底向上构建，每次更新去删除顶层，然后底层分页进行压缩，最后构建顶层。这样会有几个问题：</p>
<ol>
<li>深度分页问题：前面说了数据量最终大于6kw，如此大的数据量到了后面肯定更新不动的。想了半天索引优化最后mentor给否决了。</li>
<li>删表问题：数据库不允许传空参数直接删表，而且开销很大。</li>
<li>seo问题：虽然密集化了表但是可能会造成波动，例如某个公司的前几个失效了，这个公司变动到别的索引之下，可能会对seo产生影响，最好还是固定不变。</li>
</ol>
<h3 id="sitemap自顶向下构建"><a href="#sitemap自顶向下构建" class="headerlink" title="sitemap自顶向下构建"></a>sitemap自顶向下构建</h3><p>自顶向下构建就是直接算好id范围，数据库between一下就可以找到，把索引当作槽来用，填满了就放下一个。优点：</p>
<ol>
<li>没有深度分页问题，直接根据有索引的id查询，效率肯定是比limit高的。</li>
<li>一级索引满了就开辟一个新的，效率也高。</li>
</ol>
<p>缺点：</p>
<ol>
<li>依赖顺序性，稍微中间跨度大了就会有问题。例如首先存了1-100，再从40000-40100。每页100条，此时来了10000-10100就不能保证一级索引的顺序了。</li>
<li>一级索引的起始和终点会显得没有意义，中间有大量失效的，且不一定有序。</li>
</ol>
<p>最终采用了这种方式，es中的数据是不区分新旧的，所以得做一个唯一性校验。除此之外还有一个当前循环的唯一性校验。</p>
<ul>
<li>首先查询当前最大公司的id，通过AtomicInteger解决线程安全问题，从es来的新增数据加入，同时要校验是否是英文公司，并取出首字母。（这里写了一大堆字符串工具）</li>
<li>这样做了重复性校验的话即使是失败了也能保证不会重复。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getOpenCompanyIndex</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">        boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;summary.formatDomains&quot;</span>));</span><br><span class="line">        boolQuery.must(QueryBuilders.rangeQuery(<span class="string">&quot;emailCount&quot;</span>)</span><br><span class="line">                .gt(<span class="number">1</span>));</span><br><span class="line">        boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;detail.productList&quot;</span>));</span><br><span class="line">        boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;overviewDescription&quot;</span>));</span><br><span class="line">        boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;detail.sic&quot;</span>));</span><br><span class="line">        boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;detail.naics&quot;</span>));</span><br><span class="line">        boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;customsItems&quot;</span>));</span><br><span class="line"></span><br><span class="line">        boolQuery.mustNot(QueryBuilders.termQuery(<span class="string">&quot;disable&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>()</span><br><span class="line">                .query(boolQuery) <span class="comment">// 查询参数</span></span><br><span class="line">                .fetchSource(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;companyId&quot;</span>&#125;,</span><br><span class="line">                        <span class="literal">null</span>)</span><br><span class="line">                .size(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (openCompanyIndex == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;openCompanyIndex is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">SiteMapCompanyEntity</span> <span class="variable">maxCompany</span> <span class="operator">=</span> siteMapCompanyService.getMaxDataId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">maxDataId</span> <span class="operator">=</span> maxCompany == <span class="literal">null</span> ? <span class="number">1</span> : maxCompany.getDataId();</span><br><span class="line">        Set&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        openCompanyIndex.scrollSearch(sourceBuilder, searchHits -&gt; &#123;</span><br><span class="line">            List&lt;SiteMapCompanyEntity&gt; addList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">                Map&lt;String, Object&gt; result = searchHit.getSourceAsMap();</span><br><span class="line">                <span class="type">SiteMapCompanyEntity</span> <span class="variable">siteMapCompanyEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SiteMapCompanyEntity</span>();</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> result.get(<span class="string">&quot;name&quot;</span>).toString();</span><br><span class="line">                <span class="type">String</span> <span class="variable">companyId</span> <span class="operator">=</span> result.get(<span class="string">&quot;companyId&quot;</span>).toString();</span><br><span class="line">                <span class="comment">//本轮去重</span></span><br><span class="line">                <span class="keyword">if</span> (strings.contains(companyId)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                strings.add(companyId);</span><br><span class="line">                <span class="comment">//全局去重</span></span><br><span class="line">                LambdaQueryWrapper&lt;SiteMapCompanyEntity&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">                lambdaQueryWrapper.eq(SiteMapCompanyEntity::getCompanyId, companyId);</span><br><span class="line">                <span class="keyword">if</span> (siteMapCompanyService.count(lambdaQueryWrapper) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                siteMapCompanyEntity.setCompanyId(companyId);</span><br><span class="line">                <span class="comment">//保留原始名称</span></span><br><span class="line">                siteMapCompanyEntity.setCompanyName(name);</span><br><span class="line">                siteMapCompanyEntity.setChangeFreq(ChangeFreqEnum.WEEKLY.getCode());</span><br><span class="line">                siteMapCompanyEntity.setDataPriority(<span class="number">1f</span>);</span><br><span class="line">                siteMapCompanyEntity.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                siteMapCompanyEntity.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                siteMapCompanyEntity.setDataId(maxDataId + count.longValue());</span><br><span class="line">                <span class="comment">//非英语公司</span></span><br><span class="line">                <span class="keyword">if</span> (!StringUtil.checkEnglishChar(name))&#123;</span><br><span class="line">                    siteMapCompanyEntity.setNavLetter(<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> StringUtil.removeAllPattern(name);</span><br><span class="line">                    siteMapCompanyEntity.setNavLetter(temp.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase());</span><br><span class="line">                &#125;</span><br><span class="line">                count.getAndIncrement();</span><br><span class="line">                addList.add(siteMapCompanyEntity);</span><br><span class="line">            &#125;</span><br><span class="line">            siteMapCompanyService.saveBatch(addList);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(String.valueOf(count));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">        log.error(String.valueOf(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那怎么做生成的，根据公司的最大值最小值&#x2F;页面大小得到偏移量。根据这个偏移量去更新和查询，只关注最后一个索引块，如果没满就从这里开始加，更新最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">    preprocess();</span><br><span class="line">    <span class="type">SiteMapCompanyEntity</span> <span class="variable">maxCompany</span> <span class="operator">=</span> siteMapCompanyService.getMaxDataId();</span><br><span class="line">    <span class="type">SiteMapCompanyEntity</span> <span class="variable">minCompany</span> <span class="operator">=</span> siteMapCompanyService.getMinDataId();</span><br><span class="line">    <span class="keyword">if</span> (maxCompany == <span class="literal">null</span> || minCompany == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;CompletableFuture&lt;Void&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Long,String&gt; siteMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">long</span> <span class="variable">minDataId</span> <span class="operator">=</span> minCompany.getDataId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">maxDataId</span> <span class="operator">=</span> maxCompany.getDataId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">pageLength</span> <span class="operator">=</span> (<span class="type">long</span>) Math.ceil((<span class="type">double</span>) (maxDataId - minDataId + <span class="number">1</span>) / PAGE_SIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= pageLength; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startDataId</span> <span class="operator">=</span> minDataId +  (i - <span class="number">1</span>) * PAGE_SIZE;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endDataId</span> <span class="operator">=</span> minDataId + i * PAGE_SIZE - <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">page</span> <span class="operator">=</span> i;</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">gzip</span> <span class="operator">=</span> xmlCompanyMapGenerator.generateCompanyMap(startDataId, endDataId,page);</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.isEmpty(gzip)) &#123;</span><br><span class="line">                siteMap.put(page,gzip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, EXECUTOR);</span><br><span class="line">        futures.add(future);</span><br><span class="line">    &#125;</span><br><span class="line">    CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).join();</span><br><span class="line">    generateXML(siteMap);</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> siteMapTopService.count();</span><br><span class="line">    List&lt;SiteMapTopEntity&gt; insertList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> Math.max(<span class="number">1</span>,count); i &lt;= pageLength; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startDataId</span> <span class="operator">=</span> minDataId +  (i - <span class="number">1</span>) * PAGE_SIZE;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endDataId</span> <span class="operator">=</span> Math.min(minDataId + i * PAGE_SIZE - <span class="number">1</span>, maxDataId);</span><br><span class="line">        <span class="type">SiteMapTopEntity</span> <span class="variable">siteMapTopEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SiteMapTopEntity</span>();</span><br><span class="line">        siteMapTopEntity.setStartDataId(startDataId);</span><br><span class="line">        siteMapTopEntity.setEndDataId(endDataId);</span><br><span class="line"></span><br><span class="line">        siteMapTopEntity.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        siteMapTopEntity.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span> &amp;&amp; i == count)&#123;</span><br><span class="line">            LambdaUpdateWrapper&lt;SiteMapTopEntity&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">            updateWrapper.eq(SiteMapTopEntity::getName,siteMap.get(i));</span><br><span class="line">            siteMapTopService.update(siteMapTopEntity,updateWrapper);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        siteMapTopEntity.setName(siteMap.get(i));</span><br><span class="line">        insertList.add(siteMapTopEntity);</span><br><span class="line">    &#125;</span><br><span class="line">    siteMapTopService.saveBatch(insertList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一周首先上了3w数据，未来数据量大了肯定要分库分表的，以后的事情以后再说。</p>
<h2 id="需求9：【出海项目】一些零碎的小需求"><a href="#需求9：【出海项目】一些零碎的小需求" class="headerlink" title="需求9：【出海项目】一些零碎的小需求"></a>需求9：【出海项目】一些零碎的小需求</h2><h3 id="【接口】根据首字母和页码返回数据"><a href="#【接口】根据首字母和页码返回数据" class="headerlink" title="【接口】根据首字母和页码返回数据"></a>【接口】根据首字母和页码返回数据</h3><p>就是简单的分页问题，但是有一些字符串处理。我写了一大堆字符串工具。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PageResp&lt;CompanyUrlResp&gt; <span class="title function_">getCompanyUrl</span><span class="params">(String navLetter, Integer pageNum)</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;SiteMapCompanyEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(navLetter)) &#123;</span><br><span class="line">        <span class="comment">//非英文国家</span></span><br><span class="line">        <span class="keyword">if</span> (navLetter.equals(<span class="string">&quot;Other&quot;</span>)) &#123;</span><br><span class="line">            queryWrapper.isNull(SiteMapCompanyEntity::getNavLetter);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!navLetter.matches(<span class="string">&quot;^[a-zA-Z]$&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERR.getName(), BizError.PARAM_ERR.getCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            queryWrapper.eq(SiteMapCompanyEntity::getNavLetter, navLetter.toUpperCase());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERR.getName(), BizError.PARAM_ERR.getCode());</span><br><span class="line">    &#125;</span><br><span class="line">    queryWrapper.eq(SiteMapCompanyEntity::getStatus, CompanyStatus.ACTIVE.getCode());</span><br><span class="line"></span><br><span class="line">    IPage&lt;SiteMapCompanyEntity&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageNum, COMPANY_URL_PAGE_SIZE);</span><br><span class="line">    IPage&lt;SiteMapCompanyEntity&gt; userPage = siteMapCompanyService.page(page, queryWrapper);</span><br><span class="line">    List&lt;SiteMapCompanyEntity&gt; userList = userPage.getRecords();</span><br><span class="line">    <span class="comment">//组装返回结果</span></span><br><span class="line">    PageResp&lt;CompanyUrlResp&gt; pageResp = <span class="keyword">new</span> <span class="title class_">PageResp</span>&lt;&gt;();</span><br><span class="line">    pageResp.setPageNo(pageNum);</span><br><span class="line">    pageResp.setPageSize(COMPANY_URL_PAGE_SIZE);</span><br><span class="line">    pageResp.setTotalPage(userPage.getPages());</span><br><span class="line">    pageResp.setTotalSize(userPage.getTotal());</span><br><span class="line">    pageResp.setContent(userList.stream().map(item -&gt; &#123;</span><br><span class="line">        <span class="type">CompanyUrlResp</span> <span class="variable">companyUrlResp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompanyUrlResp</span>();</span><br><span class="line">        companyUrlResp.setCompanyId(item.getCompanyId());</span><br><span class="line">        companyUrlResp.setCompanyName(StringUtil.firstLetterToUpperCaseByBlank(item.getCompanyName()));</span><br><span class="line">        <span class="keyword">if</span> (!StringUtil.checkEnglishChar(item.getCompanyName()))&#123;</span><br><span class="line">            companyUrlResp.setCompanyFormatName(<span class="string">&quot;Non-English-Company&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> StringUtil.formatCompanyNameToUrl(item.getCompanyName());</span><br><span class="line">            companyUrlResp.setCompanyFormatName(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> companyUrlResp;</span><br><span class="line">    &#125;).collect(Collectors.toList()));</span><br><span class="line">    <span class="keyword">return</span> pageResp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【接口】公司详情获取"><a href="#【接口】公司详情获取" class="headerlink" title="【接口】公司详情获取"></a>【接口】公司详情获取</h3><p>修改了mentor的一点逻辑，做了一点校验：</p>
<ul>
<li>因为查的是全球搜的数据，有可能未公开，校验只有开启的公司才能查询。</li>
<li>如果没有登录，domain隐蔽，这里看threadlocal有没有东西就好了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompanyBaseVO <span class="title function_">base</span><span class="params">(String companyId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!siteMapCompanyService.isOpeningCompany(companyId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.NON_OPENING_COMPANY.getName(), BizError.NON_OPENING_COMPANY.getCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> host+<span class="string">&quot;/api/auth/global/overseas/base&quot;</span>;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;companyId&quot;</span>, companyId);</span><br><span class="line">        map.put(<span class="string">&quot;appKey&quot;</span>, appKey);</span><br><span class="line">        map.put(<span class="string">&quot;appSecret&quot;</span>, appSecret);</span><br><span class="line">        map.put(<span class="string">&quot;timestamp&quot;</span>, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        map = OpenApiUtil.packageSign(map, appKey, appSecret);</span><br><span class="line">        <span class="type">String</span> <span class="variable">resut</span> <span class="operator">=</span> OkHttpUtil.get(url, map);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(resut)) &#123;</span><br><span class="line">            <span class="comment">// 图片链接转换</span></span><br><span class="line">            resut = ImagePathConvert.convert(resut);</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSON.parseObject(resut);</span><br><span class="line">            <span class="type">String</span> <span class="variable">dataResult</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> loginAuth(JSON.parseObject(dataResult, CompanyBaseVO.class));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.info(<span class="string">&quot;demo error&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> CompanyBaseVO <span class="title function_">loginAuth</span><span class="params">(CompanyBaseVO companyBaseVO)</span>&#123;</span><br><span class="line">    <span class="type">UserInfoToken</span> <span class="variable">userInfoToken</span> <span class="operator">=</span> UserContext.getContent().getUserInfoToken();</span><br><span class="line">    <span class="comment">//未登录</span></span><br><span class="line">    <span class="keyword">if</span> (userInfoToken == <span class="literal">null</span>) &#123;</span><br><span class="line">        companyBaseVO.setDomain(<span class="string">&quot;*****&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> companyBaseVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/12/15/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week4/">网易牛马日志-week4</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-12-15
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="需求5：优化prompt"><a href="#需求5：优化prompt" class="headerlink" title="需求5：优化prompt"></a>需求5：优化prompt</h2><h3 id="1-提示词优化"><a href="#1-提示词优化" class="headerlink" title="1.提示词优化"></a>1.提示词优化</h3><blockquote>
<p>学习了prompt工程，主要的优化思路有（<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/QDzbfUkvSEalLxm3XX9rtA">参考连接</a>）：</p>
<ol>
<li>角色提示：“假设我是一个刚入行的电商买家”，类似这种可以将gpt带入角色，以该角色的视角进行输出</li>
<li>思维链提示：让gpt一步一步进行思考，例如计算1+2+3，先让gpt算出1+2&#x3D;3，然后再去算3+3&#x3D;6，有了思维链能够使ai清晰思考路径，犯错的可能性降低</li>
<li>思维树提示：跟上面的思维链比起来，思维树要考虑不同的分叉，在执行过程中要考虑不同的情况</li>
<li>自一致性提示：将模型的温度升高，多次去执行一个问题，返回其中最高频率的答案。对于推荐词的场景不太适用，因为调用次数有限而且时延较大，被mentor否决。</li>
<li>ReAct提示：用python的api进行调用，功能强大但用不了。<br>综合以上的方法，只有思维链可以作为优化。</li>
</ol>
</blockquote>
<ol>
<li>近似词：中译英</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String synonymsPrompt = MessageFormat.format(&quot;与\&quot;&#123;0&#125;\&quot;意思相近的产品有哪些，</span><br><span class="line">        请用&#123;1&#125;列举10个产品名。要求不包含\&quot;&#123;0&#125;\&quot;，</span><br><span class="line">        输出格式为：jsonArray&quot;, formatValue, language) + &quot;,[]&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String synonymsPrompt = MessageFormat.format(&quot;What are the products with the similar meaning of \&quot;&#123;0&#125;\&quot;,\n&quot; +</span><br><span class="line">        &quot;Please list 10 product names in &#123;1&#125;. My request is not to include \&quot;&#123;0&#125;\&quot;,\n&quot; +</span><br><span class="line">        &quot;The output format is jsonArray&quot;, formatValue, language) + &quot;,[]&quot;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>电商词：转为中文思维链</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String platformPrompt = MessageFormat.format(&quot;假设我是一个新入行的电商卖家，</span><br><span class="line">        主要经营的是\&quot;&#123;0&#125;\&quot;。我希望能有更多的用户在amazon.com等同类电商网站中搜索到我，</span><br><span class="line">        我可以使用怎样的&#123;1&#125;产品名对自己的产品进行描述？要求不包含\&quot;&#123;0&#125;\&quot;，</span><br><span class="line">        请去掉尽可能多的长尾词，提炼共同的产品描述词。帮我用&#123;2&#125;同义替换10个不同的产品描述。仅输出替换后的数据，</span><br><span class="line">        格式为：jsonArray&quot;, formatValue, language, language) + &quot;,[]&quot;;   </span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String platformPrompt = MessageFormat.format(&quot;请按照如下提示一步步推理：\n&quot; +</span><br><span class="line">        &quot;第一步，请将产品\&quot;&#123;0&#125;\&quot;从品牌、型号、材料、用途等方面进行扩展，尽量细分且具体到某个品牌的某个产品。\n&quot; +</span><br><span class="line">        &quot;第二步，思考该产品在amazon.com等同类电商网站中显示给用户的商品词是什么。\n&quot; +</span><br><span class="line">        &quot;第三步，提取商品词中的关键信息，不允许出现品牌和型号，长度严格限制在30个字母以内。\n&quot; +</span><br><span class="line">        &quot;综合以上三步，仅用&#123;1&#125;输出十个这样的产品名，要求不包含\&quot;&#123;0&#125;\&quot;格式为：jsonArray,[]&quot;, formatValue, language) + &quot;,[]&quot;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>行业词：中译英</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prompt = &quot;我是一个新入行的外贸供应商，主要经营的是&quot;+ formatValue +&quot;。我的产品可以应用于哪些行业的哪些产品？帮我列举3个行业，并描述推荐这些行业的理由，在每个行业下列举5个使用该产品制造出来的产品名称。\n&quot; +</span><br><span class="line">        &quot;用json输出，格式为：\n&quot; +</span><br><span class="line">        &quot;行业1\n&quot; +</span><br><span class="line">        &quot;行业名：xxx\n&quot; +</span><br><span class="line">        &quot;推荐理由：xxx\n&quot; +</span><br><span class="line">        &quot;相关产品：xxx\n&quot; +</span><br><span class="line">        &quot;要求：\n&quot; +</span><br><span class="line">        &quot;1、行业名称用&#123;&quot;+languageVersion+&quot;&#125;。\n&quot; +</span><br><span class="line">        &quot;2、推荐理由用&#123;&quot;+languageVersion+&quot;&#125;。\n&quot; +</span><br><span class="line">        &quot;3、相关产品用&#123;&quot;+language+&quot;&#125;。\n&quot; +</span><br><span class="line">        &quot;4、产品名称不能重复。\n&quot; +</span><br><span class="line">        &quot;5、产品名称不需要包含材质等限制。\n&quot; +</span><br><span class="line">        &quot;6、相关产品用#格开。&quot; +</span><br><span class="line">        &quot;7、不包含\&quot;&quot;+formatValue+&quot;\&quot;。&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prompt = &quot;I am a new foreign trade supplier, the main business is \&quot;&quot;+formatValue+&quot;\&quot;. Which products can my product be used in which industries? Give me a list of 3 industries and describe the reasons why you recommend them, and list 5 names of products made with that product under each industry.\n&quot; +</span><br><span class="line">        &quot;Output in json format:\n&quot; +</span><br><span class="line">        &quot; 行业1\n&quot; +</span><br><span class="line">        &quot; 行业名：xxx\n&quot; +</span><br><span class="line">        &quot; 推荐理由：xxx\n&quot; +</span><br><span class="line">        &quot; 相关产品：xxx\n&quot; +</span><br><span class="line">        &quot;Requirement: \&quot;\n&quot; +</span><br><span class="line">        &quot;1. the industry name with &#123;&quot;+languageVersion+&quot;&#125;.\n&quot; +</span><br><span class="line">        &quot;2. recommended reasons use &#123;&quot;+languageVersion+&quot;+&#125;.\n&quot; +</span><br><span class="line">        &quot;3. Use &#123;&quot;+language+&quot;&#125; for related products.\n&quot; +</span><br><span class="line">        &quot;4. the product name can not be repeated.\n&quot; +</span><br><span class="line">        &quot;5. the product name does not need to include material and other restrictions.\n&quot; +</span><br><span class="line">        &quot;6. related products are delimited with #\n&quot; +</span><br><span class="line">        &quot;7. \&quot;&quot;+formatValue+&quot;\&quot; is not included.&quot;;</span><br></pre></td></tr></table></figure>

<p>三个小小的优化耗费了我一周的时间，实际上也没多少提升。</p>
<h3 id="2-代码逻辑"><a href="#2-代码逻辑" class="headerlink" title="2.代码逻辑"></a>2.代码逻辑</h3><h4 id="近似词和电商词"><a href="#近似词和电商词" class="headerlink" title="近似词和电商词"></a>近似词和电商词</h4><ul>
<li>首先判断是否为空，或者是否为敏感词（调用网易易盾），随后传入用户信息，访问服务。</li>
<li>服务内部：传入参数中语言为空默认为英语，然后用CompletableFuture.supplyAsync()搭配线程池完成gpt的两次请求。线程池如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程工厂仅仅改名，拒绝策略是发起者自己消化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadFactory</span> <span class="variable">GPT_THREAD_FACTORY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;GptGrpcWrapper-gpt-pool-%d&quot;</span>).build();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">GPT_REQUEST_EXECUTOR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">20</span>,</span><br><span class="line">        <span class="number">40</span>, <span class="number">60</span> * <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">3000</span>), GPT_THREAD_FACTORY, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>

<ul>
<li>请求成功的结果缓存在redis中100天，缓存的key是”cacheKeyPreFix + “v6” + “:” + gptRecommendReqVO.getLanguage()+”:”+gptRecommendReqVO.getValue();”</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;String&gt; <span class="title function_">getRecommendWordV1</span><span class="params">(GptRecommendReqVO gptRecommendReqVO, AuthInfo authInfo, String prompt, String cacheKeyPreFix)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheValue</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(gptRecommendReqVO.getValue())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">formatValue</span> <span class="operator">=</span> FormatUtil.escapeFormat(gptRecommendReqVO.getValue());</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(formatValue) || formatValue.length()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;GptGrpcWrapper value:&#123;&#125;,formatValue:&#123;&#125;&quot;</span>,gptRecommendReqVO.getValue(),formatValue);</span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(gptRecommendReqVO.getLanguage()==<span class="literal">null</span>)&#123;</span><br><span class="line">            gptRecommendReqVO.setLanguage(<span class="string">&quot;英语&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">language</span> <span class="operator">=</span> gptRecommendReqVO.getLanguage();</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> cacheKeyPreFix + <span class="string">&quot;v6&quot;</span> + <span class="string">&quot;:&quot;</span> + gptRecommendReqVO.getLanguage()+<span class="string">&quot;:&quot;</span>+gptRecommendReqVO.getValue();</span><br><span class="line">        cacheValue = recommendWordCache.get(cacheKey);</span><br><span class="line">        <span class="comment">//命中</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotBlank(cacheValue))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;GptGrpcWrapper call success,param:&#123;&#125;,result:&#123;&#125;&quot;</span>,JSON.toJSONString(gptRecommendReqVO),cacheValue);</span><br><span class="line">            <span class="comment">//大段文字中的[&quot;xxx1&quot;,&quot;xxx2&quot;,&quot;xxx3&quot;]</span></span><br><span class="line">            <span class="keyword">if</span>(cacheValue.contains(<span class="string">&quot;[&quot;</span>) &amp;&amp; cacheValue.contains(<span class="string">&quot;]&quot;</span>))&#123;</span><br><span class="line">                cacheValue = cacheValue.substring(cacheValue.indexOf(<span class="string">&quot;[&quot;</span>), cacheValue.lastIndexOf(<span class="string">&quot;]&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只取前6个，这个数值是前端定的</span></span><br><span class="line">            Set&lt;String&gt; synonyms = getLimitSize(Lists.newArrayList(JSON.parseArray(cacheValue, String.class)), gptRecommendReqVO.getSize());</span><br><span class="line">            <span class="keyword">return</span> synonyms;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//未命中</span></span><br><span class="line">        log.info(<span class="string">&quot;GptGrpcWrapper call param:&#123;&#125;,prompt:&#123;&#125;&quot;</span>,JSON.toJSONString(gptRecommendReqVO),prompt);</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(</span><br><span class="line">                () -&gt; gptRequest(authInfo.getOrgId(),authInfo.getAccId(),authInfo.getEmail(),prompt, GPTModelVersionEnum.GPT_4O_MINI.getVersion()), GPT_REQUEST_EXECUTOR);</span><br><span class="line">        <span class="comment">//这里实际上还是同步请求，&quot;gpt-recommard-future&quot;是一个日志的名称，超时时间120s</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> (String)FutureResultUtil.getResult(<span class="string">&quot;gpt-recommard-future&quot;</span>,future,<span class="number">120</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(res)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;getRecommend failed.name:&#123;&#125;,language:&#123;&#125;&quot;</span>,formatValue, language);</span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        cacheValue = res;</span><br><span class="line">        <span class="comment">// 推荐词缓存100天</span></span><br><span class="line">        recommendWordCache.set(cacheKey,cacheValue,TimeUnit.DAYS.toMillis(<span class="number">100</span>));</span><br><span class="line">        log.info(<span class="string">&quot;GptGrpcWrapper call success,param:&#123;&#125;,result:&#123;&#125;&quot;</span>,JSON.toJSONString(gptRecommendReqVO),cacheValue);</span><br><span class="line">        <span class="keyword">if</span>(cacheValue.contains(<span class="string">&quot;[&quot;</span>) &amp;&amp; cacheValue.contains(<span class="string">&quot;]&quot;</span>))&#123;</span><br><span class="line">            cacheValue = cacheValue.substring(cacheValue.indexOf(<span class="string">&quot;[&quot;</span>), cacheValue.lastIndexOf(<span class="string">&quot;]&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; synonyms = getLimitSize(Lists.newArrayList(JSON.parseArray(cacheValue, String.class)), gptRecommendReqVO.getSize());</span><br><span class="line">        <span class="keyword">return</span> synonyms;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//gpt出的词如果不常规。例如是“好的，接下来为您输出....”，在JSON.parseArray就会报异常不返回给前端。</span></span><br><span class="line">        log.error(<span class="string">&quot;getGptRecommend param:&#123;&#125;&quot;</span>,JSON.toJSONString(gptRecommendReqVO), e);</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>redis只存gpt原始回答，可以改成处理后的回答</li>
<li>线程池实际上只将近似词和电商词做了异步，在这两个单独的请求里面用future实际还是同步。</li>
<li>gpt如果输出不理想有两重处理，首先看是否包含了”[“xxx1”,”xxx2”,”xxx3”]”，用subString提取出来，实在是没有那在parseObject就会报错，结果返回为空。</li>
</ol>
</blockquote>
<ul>
<li>最后处理近似词和电商词的结果，用一个大的hashset去重（但是大小写敏感，这里可以优化成全部小写再比较）</li>
<li>调用GRPC（有道翻译）兜底，先判断是否出现中文，有中文就翻译。批量翻译返回值是map，key是原文，value是翻译后的。最后进行组装返回。</li>
</ul>
<p><strong>总结：调用易盾进行敏感词检测，线程池+CompletableFuture完成两次gpt查询，gpt查询做了一系列异常处理，在redis中缓存100天，最后调用有道翻译的grpc进行兜底。</strong></p>
<h4 id="行业词"><a href="#行业词" class="headerlink" title="行业词"></a>行业词</h4><ul>
<li>首先判断是否为空，或者是否为敏感词（调用网易易盾），随后传入用户信息，访问服务。</li>
<li>服务内部：处理逻辑跟上文类似，在redis中存储gpt原始回答，但是由于输出的是json，相比于近似词和行业词的数组，这里有改变。</li>
<li>去除”```json”和”```“这类md语法，再根据”行业一，二，三”json形式包装。</li>
<li>这里要做一些异常处理以增加可用性和鲁棒性，虽然提示词里面写的是用”#“隔开，但是实际上可能返回的还是”,”或者”、”，用一个函数对其进行拆分。</li>
<li>最后调用有道翻译兜底。</li>
</ul>
<h2 id="需求6：订阅更新任务"><a href="#需求6：订阅更新任务" class="headerlink" title="需求6：订阅更新任务"></a>需求6：订阅更新任务</h2><p>订阅更新链路：</p>
<ol>
<li>用户前端点击页面就会更新订阅公司的watchTime字段，一天之内只更新一次。</li>
<li>xxljob每周扫库，搜索的是订阅公司的那个表，将watchTime在前一周的公司发送kafka（自增id而不是公司id）</li>
<li>kafka消费者拿到这些id去数据库找对应的公司，将订阅公司表项和公司实体项（从es来的，如果前者有companyId就直接查询，如果没有就需要根据名字和地区来查询并保存）作为参数传分别分析<strong>facebook信息，facebook提及信息，海关信息，联系人信息</strong>，开了一个线程池并行处理这些。</li>
</ol>
<h3 id="1-facebook信息"><a href="#1-facebook信息" class="headerlink" title="1.facebook信息"></a>1.facebook信息</h3><p>代码太长了，梳理一下就这几部分：</p>
<ol>
<li>根据公司实体中的相关facebook链接去请求GRPC接口，返回facebook实体，其中包含个人信息，点赞数量，最近推文等信息。</li>
<li>从这里开始要注意逻辑，比对的是<strong>GRPC请求来的数据</strong>和<strong>当前数据库中最新的log</strong>。</li>
<li>去数据库中查询7种type的log，先全部查出来，然后再通过stream和sort得到最近时间的log。</li>
<li>将这些log分别与GRPC请求来的数据进行比较，例如判断facebook是否更新了，将最近的一条相关log的内容拉出来与GRPC请求来的数据进行比较，如果不一样就需要更新，在库里面新增一条。</li>
</ol>
<blockquote>
<ol>
<li>facebook地址初始化&#x2F;变更</li>
<li>facebook邮箱初始化&#x2F;变更</li>
<li>facebook网站地址初始化&#x2F;变更</li>
<li>facebook电话初始化&#x2F;变更</li>
<li>facebook点赞、关注初始化</li>
<li>facebook中发布了新帖子</li>
<li>facebook获得1个新评论</li>
</ol>
</blockquote>
<h3 id="2-facebook提及信息"><a href="#2-facebook提及信息" class="headerlink" title="2.facebook提及信息"></a>2.facebook提及信息</h3><ol>
<li>类似上面的，提及消息也是从GRPC来的，如果返回为null直接返回，这里是一个list，只关注最新的，所以也有stream+sort。</li>
<li>去数据库查询当前最新的log，主要关注的是这个记录的createTime。</li>
<li>如果数据库没有，那就说明是最新更新的，向数据库插入一条新的log表明有被提及，直接返回。</li>
<li>如果数据库有但log的时间比GRPC来的早，说明有新提及，进行更新。</li>
</ol>
<h3 id="3-海关信息"><a href="#3-海关信息" class="headerlink" title="3.海关信息"></a>3.海关信息</h3><ol>
<li>将公司名称格式化，随后去海关数据里面查找新增进出口数据，分别放在两个list里面。</li>
<li>如果有进出口就分别新增log。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customProcess</span><span class="params">(TbGlobalCollectEntity record, CompanySearchBO companyBO, Date startDate, Date endDate)</span> &#123;</span><br><span class="line">    <span class="comment">//海关那边的统一格式&quot;CompanyName-COMBINE-TANZANIA&quot;例如&quot;101 INVESTMENT-COMBINE-TANZANIA&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">nameAndCountry</span> <span class="operator">=</span> CompanyFormatUtils.combineCompanyNameAndCountry(companyBO.getName(), companyBO.getCountry());</span><br><span class="line">    <span class="comment">//去取出昨天的新增hscode，这个表主要是海关系统在维护</span></span><br><span class="line">    Map&lt;String, CustomInfoBO&gt; map = customDataComponent.batchGetCompanyNewTrxHscode(Lists.newArrayList(nameAndCountry), startDate, endDate);</span><br><span class="line">    List&lt;TbGlobalCollectLogEntity&gt; tbGlobalCollectLogEntities = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(nameAndCountry))&#123;</span><br><span class="line">        <span class="type">CustomInfoBO</span> <span class="variable">customInfoBO</span> <span class="operator">=</span> map.get(nameAndCountry);</span><br><span class="line">        <span class="comment">//出口</span></span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(customInfoBO.getExportHsCodeList()))&#123;</span><br><span class="line">            <span class="type">TbGlobalCollectLogEntity</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TbGlobalCollectLogEntity</span>();</span><br><span class="line">            t.setCollectId(record.getId());</span><br><span class="line">            t.setLogDesc(<span class="string">&quot;新供应了hscode为&quot;</span> + Strings.join(customInfoBO.getExportHsCodeList(), <span class="string">&quot;,&quot;</span>) + <span class="string">&quot;等的商品&quot;</span>);</span><br><span class="line">            t.setContent(JSON.toJSONString(customInfoBO.getExportHsCodeList()));</span><br><span class="line">            t.setType(CollectLogTypeEnum.CUSTOM_SHN.getType());</span><br><span class="line">            t.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            t.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            t.setInit12(<span class="number">0</span>);</span><br><span class="line">            tbGlobalCollectLogEntities.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进口</span></span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(customInfoBO.getImportHsCodeList()))&#123;</span><br><span class="line">            <span class="type">TbGlobalCollectLogEntity</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TbGlobalCollectLogEntity</span>();</span><br><span class="line">            t.setCollectId(record.getId());</span><br><span class="line">            t.setLogDesc(<span class="string">&quot;新采购了hscode为&quot;</span> + Strings.join(customInfoBO.getImportHsCodeList(), <span class="string">&quot;,&quot;</span>) + <span class="string">&quot;等的商品&quot;</span>);</span><br><span class="line">            t.setContent(JSON.toJSONString(customInfoBO.getImportHsCodeList()));</span><br><span class="line">            t.setType(CollectLogTypeEnum.CUSTOM_CON.getType());</span><br><span class="line">            t.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            t.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            t.setInit12(<span class="number">0</span>);</span><br><span class="line">            tbGlobalCollectLogEntities.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!CollectionUtils.isEmpty(tbGlobalCollectLogEntities))&#123;</span><br><span class="line">        tbGlobalCollectLogEntityService.saveAll(tbGlobalCollectLogEntities);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-联系人信息"><a href="#4-联系人信息" class="headerlink" title="4.联系人信息"></a>4.联系人信息</h3>
    
    
  </div>

  

  

</article>
  
    
  <nav class="pagination">  
      
      
      <a class="next" href="/page/2/">  
        <span class="next-text">下一页</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  
</section>
        </div>
          

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:1050886654@qq.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/yyf1050886654" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2024 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">Yifan Yang</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    

  







<script type="text/javascript" src="/lib/jquery"></script>



<script type="text/javascript" src="/lib/slideout"></script>



<script type="text/javascript" src="/lib/fancybox"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>