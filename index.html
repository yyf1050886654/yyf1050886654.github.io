<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/default" title="YYF's Blog" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://yyf1050886654.github.io/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>YYF&#39;s Blog</title>

<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">YYF&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/collect/">
      <li class="mobile-menu-item">
        
        
        收藏              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">YYF's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/collect/">  
              
              
              收藏  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <section id="posts" class="posts">
  
  
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/30/JVM%E9%9D%A2%E8%AF%95%E7%AF%87/">JVM面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-30
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="JVM如何解决跨代问题"><a href="#JVM如何解决跨代问题" class="headerlink" title="JVM如何解决跨代问题"></a>JVM如何解决跨代问题</h2><p>如果在年轻代的某个对象引用了老年代的对象，在触发Young GC的时候只会检查年轻代而不会检查老年代，此时如果老年代引用了一个年轻代的对象就不会被YGC发现而回收了此对象。但是这种情况出现的比较少，除非是老年代动态的引用了一个刚产生的对象。</p>
<p><strong>记忆集和卡表</strong><br>如果为了小概率事件每次YGC都去扫描一遍永久代，开销会很大。此时我们只需要保存从非扫描区域到扫描区域的指针就可以了。这个保存的扫描指针逻辑上叫做记忆集，放在新生代中。</p>
<p>卡表是hotspot虚拟机对于记忆集的具体实现，类似位图，把非扫描区域分块，然后用一个卡表数组来记录对应块是否变脏，如果记录的为1说明变脏，在YGC的时候把对应块加入扫描。本质上是用空间换时间。</p>
<p><strong>写屏障</strong><br>这里的写屏障跟volatile的不一样，这里仅仅是对引用操作做了一层aop，在写后屏障加入添加卡表的操作，在写前屏障添加该页是否脏的判断，可以解决伪共享问题。</p>
<h2 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h2><p>三色标记算法是可达性分析的一个扫描过程，例如CMS，先做初始标记标记出GCroot，然后再并发标记，这个过程是通过三色标记算法实现的。最后扫描到的白色节点就被视为没有引用，在下一轮GC会被回收。</p>
<ul>
<li>黑色，直接或者间接连接到GCroot并且自身所有引用都被扫描过了</li>
<li>灰色：从黑色节点扩散，但是自己的子节点还没有被完全扫描</li>
<li>白色：没有被染指的节点，也就是不可达区域</li>
</ul>
<p><strong>三色标记的缺点</strong></p>
<ol>
<li>多标问题：在一个节点被标记成灰色之后，上一个节点断开联系，最终这个节点还是会被染黑，但实际上是垃圾。这个现象称为浮动垃圾，在下一轮会被回收。</li>
<li>漏标问题：多标至少可以通过下一轮垃圾回收清除，漏标就严重多了。当一个灰色节点与一个白色节点断掉之后立刻有黑色节点相连。这个时候三色标记算法还是会认为这个节点是白色的，就会被垃圾回收，而此时确实有黑色节点的引用，会报空指针异常。</li>
</ol>
<div style="text-align: center;">
  <img src="../img/jvm/img_5.png" alt="" />
</div>

<p><strong>如何解决</strong><br>两个条件同时发生才会有漏标现象：首先是有灰色节点与白色节点断开联系，又有黑色节点与白色节点产生联系。</p>
<p>破坏一个就不会产生漏标：</p>
<ul>
<li>增量更新：增量更新破坏了第一个条件：「至少有一个黑色对象新增了对白色对象的引用」，在并发标记阶段，黑色对象D指向了白色对象G，这时会把黑色对象D记录下来，在重新标记阶段，会把黑色对象D标记为灰色对象D，然后以灰色对象D为根节点，扫描整个引用链，白色对象G就会被依次标记为灰色、黑色，白色对象G漏标的问题就解决了。 缺点是会重新扫描以黑色对象为根节点的子树，时间长（CMS解决方案）</li>
<li>原始快照：原始快照破坏了第二个条件：「所有灰色对象指向该白色对象的引用都断开了」，在并发标记阶段，灰色对象E断开了对白色对象G的引用，这是会把白色对象G记录下来，在最终标记阶段，会把白色对象G标记为灰色，然后以灰色对象G为根节点，扫描整个引用链，如此以来原来的白色对象G就会被依次标记为灰色、黑色，白色对象G漏标的问题就解决了。缺点是如果没有黑色对象来引用就会变成浮动垃圾（G1解决方案）</li>
</ul>
<h2 id="类的回收"><a href="#类的回收" class="headerlink" title="类的回收"></a>类的回收</h2><p>类的元数据在方法区也就是元空间中，在fullGC是有可能会被垃圾回收的。一个类能被垃圾回收需要满足三个要求：</p>
<ol>
<li>没有实例对象</li>
<li>没有静态方法的引用</li>
<li>类加载器已经被GC</li>
</ol>
<p><strong>private static final int I &#x3D; 0，这个i会回收吗</strong></p>
<p>看情况，跟着类走，本身这就是一个GCroot，一共有四种GCroot（类的常量引用类似这种，静态引用，虚拟机栈的引用，本地方法栈的引用）。如果不是类被卸载的话是不能被GC的。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95%E7%AF%87/">设计模式面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-28
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是在不改变原先对象的前提下，通过生成一个代理对象，扩展原先对象的一些功能。比如aop，不入侵业务代码实现方法前后逻辑。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理是写死的，也就是说需要程序员手动写一个proxy代理类，与原先类共同继承一个接口（个人理解其实从实现层面是可以不共同实现一个接口的，但是这样就会导致管理混乱，代理对象如果能复用这个接口那就会逻辑上通顺很多）</p>
<p>静态代理实现步骤:</p>
<ul>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ul>
<p>一旦要新增方法，代理对象也会改变，不满足设计模式中开放封闭的原则。这些代理类实际都是在编译过程中产生的class文件</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>分为jdk动态代理和gclib。前者必须要求代理类实现了某个接口，后者没有这点限制。但是相对于jkd而言，gclib效率较低速度较慢。gclib的原理是生成一个子类来代理父类，由于不能继承final类，所以gclib不能代理final类</p>
<p><strong>jdk动态代理</strong></p>
<ol>
<li>Proxy.newProxyInstance方法，得到动态代理对象。传入参数是对象的类加载器，类的接口和一个InvocationHandler自定义的处理逻辑</li>
<li>新建一个类实现InvocationHandler，这里面只有一个方法invoke，包装了反射中的method.invoke，我们需要在这句调用前后加上自己的逻辑就可以简单实现aop。</li>
<li>新建一个工厂类的静态方法来获取这个动态代理对象</li>
<li>使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好，&quot;</span> + name + <span class="string">&quot;！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InvocationHandler实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法调用前的处理逻辑&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;方法调用后的处理逻辑&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 被代理的对象</span></span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">helloService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建InvocationHandler</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloInvocationHandler</span>(helloService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (HelloService) Proxy.newProxyInstance(</span><br><span class="line">                helloService.getClass().getClassLoader(),</span><br><span class="line">                helloService.getClass().getInterfaces(),</span><br><span class="line">                handler</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用代理对象的方法</span></span><br><span class="line">        proxyInstance.sayHello(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>gclib动态代理</strong></p>
<ol>
<li>首先自定义MethodInterceptor，这一点与上面的InvocationHandler是一致的。但是注意这里不是method.invoke来调用实际逻辑了。这里用methodProxy来调用原始方法。</li>
<li>使用的时候首先创建增强类Enhancer</li>
<li>设置类加载器和父类（也就是被代理对象）</li>
<li>设置拦截器，就是第一点创建的对象</li>
<li>最后获取这个代理类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好，&quot;</span> + name + <span class="string">&quot;！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的MethodInterceptor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在方法执行前添加逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理类：方法调用前的处理&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在方法执行后添加逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理类：方法调用后的处理&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Enhancer对象</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(Person.class); <span class="comment">// 设置被代理类的父类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">PersonMethodInterceptor</span>()); <span class="comment">// 设置回调</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">proxyPerson</span> <span class="operator">=</span> (Person) enhancer.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用代理对象的方法</span></span><br><span class="line">        proxyPerson.sayHello(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在spring aop中，如果某个类实现了接口，则默认使用jdk动态代理；否则使用cglib</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/25/kafka%E9%9D%A2%E8%AF%95%E7%AF%87/">消息队列面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-25
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>rocketMq的架构是类似于kafka的，实现了许多kafka没有的功能，但是依旧没有在市场上打败kafka，kafka的性能这么高的原因得益于零拷贝技术。</p>
<p>在传统io方式中是需要经过cpu的，用户调用read()方法，数据通过dma传输到内存缓冲区，然后通过cpu拷贝到用户态的用户缓冲区，得到了用户能见的数据。再通过write()将数据拷贝到操作系统内核态的socket写缓冲区，最后通过网卡发送数据。这个过程一共经历了四次用户态和内核态的切换：</p>
<ol>
<li>系统调用read，用户态-&gt;内核态</li>
<li>dma后，cpu将数据从内核态拷贝回用户态</li>
<li>系统调用write，用户态-&gt;内核态</li>
<li>write方法返回，重新回到用户态</li>
</ol>
<p>以及四次数据的拷贝。</p>
<p><strong>mmap</strong></p>
<p>mmap是一种将内存映射到用户态空间的系统调用。简单来说就是用户态和内核态使用同一片空间，不用进行上下文切换。因此整个流程就会变为：</p>
<ol>
<li>mmap系统调用，用户态-&gt;内核态</li>
<li>dma将磁盘数据写到内核态的缓冲区，返回给用户态，同时用户态也能看到这片缓冲区，可以进行操作。需要进行上下文切换但不用拷贝</li>
<li>操作完了之后系统调用write写到网卡发送，用户态-&gt;内核态</li>
<li>拷贝两次，从内核态缓冲区拷贝到socket缓冲区，再用dma方式写回磁盘或者网卡，最后回到用户态</li>
</ol>
<p>综上所述，总共经历了3次io和四次上下文切换。减少的这一次叫做零拷贝。</p>
<p><strong>sendfile</strong></p>
<p>sendfile不会给用户态返回具体的数据，直接从内核态走socket传输走了。</p>
<ol>
<li>sendfile系统调用，用户态-&gt;内核态</li>
<li>dma拷贝到内核态的缓冲区，这里不会返回给用户态具体的信息，也就是说用户态操作不了，直接拷贝给socket</li>
<li>再从socket拷贝到网卡，返回用户态</li>
</ol>
<p>综上所述，一共两次上下文切换和三次io，对比 mmap+write，主要是没有再用户态进行拷贝。</p>
<p>说了这么多，到底跟kafka和rocketmq有什么关系呢？kafka是基于sendfile的，而rocketmq是基于mmap的，都使用了零拷贝技术，但是由于rocketmq新增了一些高级功能，需要直到具体的数据信息而不是直接发送，就用了能看见数据的mmap方式。kafka为了追求极致性能就没有这些花里胡哨的功能，使用了效率更高的sendfile</p>
<h2 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h2><ul>
<li>异步：不用等待同步操作，把消息扔给mq然后就直接返回，mq连接的另一端会异步进行操作</li>
<li>解耦：可以将业务进行拆分，也是上面异步的思想</li>
<li>削峰：到来的高并发请求先进入mq，类似漏桶限流算法，避免打倒服务器和数据库</li>
</ul>
<h2 id="Kafka的架构"><a href="#Kafka的架构" class="headerlink" title="Kafka的架构"></a>Kafka的架构</h2><p>kafka是基于发布者-订阅者模型的，在这个模型中有发布者，订阅者，broker和服务发现中心。具体到kafka就是producer，consumer，broker，topic，partition，配置中心是zookeeper：</p>
<ul>
<li>broker：就是一个物理上的kafka服务实体</li>
<li>topic：消息是按照主题划分的，例如业务消息和日志消息就可以用两个topic划分</li>
<li>partition：一个topic内也不只有一个队列，这个分区就是队列的意思。需要注意的是kafka在逻辑上是一个整体，但是物理上一个topic内所有分区不一定在同一个broker上。</li>
</ul>
<div style="text-align: center;">
  <img src="../img/kafka/img.png" alt="" />
</div>

<ul>
<li>生产者组：生成消息放入消息队列，是多对多的关系，一个生产者可以生成很多个topic的消息，也可以生成一个topic内多个partition的消息</li>
<li>消费者组：消费的进度用offset表示，消费者组并不会真的把消息队列的信息删除，而是用一个偏移量来表示消费到了哪里。每一个消费者组的偏移量可以是不同的，一般来说一个partition最好只有一个消费者，如果多了的话并发控制也会成为性能影响因素</li>
<li>zookeeper：对于如此庞大规模的kafka集群，实体之间是怎么互相发现对方的？这里使用了zookeeper作为服务发现框架。kafka高度依赖zookeeper</li>
</ul>
<p>kafka为了保证高可用，还有类似主从架构的副本机制，使得某个broker挂了之后，部署在其他地方的partition能够继续工作。总而言之，一个topic多个partition的机制能够使消息分散在多个broker上，实现负载均衡。partition的副本也会保存在不同的机器上。从逻辑上看是整体的，物理上看都不会集中在一块区域。</p>
<h2 id="Kafka的存储机制"><a href="#Kafka的存储机制" class="headerlink" title="Kafka的存储机制"></a>Kafka的存储机制</h2><p>前情提要：一个topic可能横跨多个broker，每一个broker的文件系统只会保存自己实际物理存储的日志。只有通过zookeeper才能看到一个topic的全部分区信息。</p>
<p>在一个broker下，文件信息是这么存储的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;kafka-log-dir&gt;/</span><br><span class="line">    └── &lt;topic-name&gt;/</span><br><span class="line">        └── &lt;partition-number&gt;/</span><br><span class="line">            ├── 00000000000000000000.log        # 日志文件</span><br><span class="line">            ├── 00000000000000000000.index      # 偏移量索引文件</span><br><span class="line">            ├── 00000000000000000000.timeindex  # 时间索引文件</span><br><span class="line">            ├── 00000000000000000001.log        # 下一日志段</span><br><span class="line">            ├── 00000000000000000001.index      # 下一日志段的偏移量索引文件</span><br><span class="line">            ├── 00000000000000000001.timeindex  # 下一日志段的时间索引文件</span><br></pre></td></tr></table></figure>
<ul>
<li>日志段（segment）：一个分区下有多个segment，segment中保存了实际的数据，这些数据的key是offset，每一个segment以当前最小的offset命名。查询的时候通过二分查找找到对应的offset</li>
<li>索引（index）：同时会生成一个与segment同名的索引。保存当前segment下offset的索引信息（类似二级索引），加快日志内的查找速度</li>
<li>时间索引文件：存储offset对应的时间戳，便于根据时间查找信息。</li>
</ul>
<p><strong>生产者</strong></p>
<p>当收到生产者数据的时候，用户态内存接收到之后，会给操作系统内核态的page cache，os再择机刷盘。这个写过程是顺序写，也就是说在对应的分区的最后一个log后面写刚刚的消息。</p>
<p><strong>消费者</strong></p>
<p>消费者消费数据的时候，根据offset先在文件名中二分查找到segment，再用对应的索引来加速搜索。</p>
<p><strong>日志滚动</strong></p>
<p>如果一个segment达到了默认的1GB或者超过了7天没有新增，那就会有一个新的segment</p>
<p><strong>日志删除</strong></p>
<p>可以配置kafka的消息删除时间，这个时候上面的日志索引文件就有用了，通过判断时间戳来删除。在删除过程中会使用copyonwrite以避免有消费者这个时候消费消息。</p>
<h2 id="Kafka如何保证消息不丢失"><a href="#Kafka如何保证消息不丢失" class="headerlink" title="Kafka如何保证消息不丢失"></a>Kafka如何保证消息不丢失</h2><p>消息丢失不是Kafka一个管道能说了算的，可能在生产者传输的过程中丢失，也有可能消费者offset更新完了之后就掉了导致没有真正消费信息。</p>
<ul>
<li>生产者的信息丢失：类似tcp的各种握手，可以使用一个回调函数返回kafka是否接收到了信息，这里最好不要用同步操作get，用异步ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt;开一个线程监听；如果失败了就重传，可以设置重传次数。</li>
<li>消费者的信息丢失：offset默认是消费者接受了这个消息就更新，但是可能会发生拿到消息就掉电导致消息没有实际被消耗。可以采用offset手动更新，在消费者逻辑的最后手动提交offset，这样就能保证消费完了才更新offset</li>
<li>kafka的信息丢失：架构中都有这么多副本在兜底了，但是副本之间不一定时时刻刻都保持同步。设置几个参数就能保证kafka的高可用</li>
</ul>
<blockquote>
<ul>
<li>acks&#x3D;all，表示所有副本都更新完写操作才返回，默认值是1，也就是主节点更新了就返回，但是这样依旧可能造成丢数据问题。因此为了绝对安全可以设置acks&#x3D;all，但是会极大的影响性能。</li>
<li>设置副本数量&gt;&#x3D;3，虽然造成了数据冗余，但是可以保证高可用</li>
<li>设置更新的副本数量&gt;1，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。min.insync.replicas 的默认值为 1 ，在实际生产中应尽量避免默认值 1，是acks&#x3D;all的一种折中</li>
<li>设置 unclean.leader.election.enable &#x3D; false，当发生主从数据不一致的时候，只有完全同步的数据副本才能被选举为leader</li>
</ul>
</blockquote>
<p>kafka是ap架构还cp架构？从上面的各种默认参数来看，比如acks&#x3D;1，默认的时候还是倾向于可用性的，也就是会牺牲一部分一致性。但是经过上面的种种配置之后，就可以使kafka集群是强一致性的，在某些场合下可以灵活改变配置。</p>
<h2 id="生产者向Kafka发送消息的执行流程"><a href="#生产者向Kafka发送消息的执行流程" class="headerlink" title="生产者向Kafka发送消息的执行流程"></a>生产者向Kafka发送消息的执行流程</h2><ol>
<li>配置生产者，一般消息有三个值，topic，key和value（保证顺序的话就要指定partition）。还可以配置acks的参数，reties的次数，配置完这些之后产生一个生产者对象。</li>
<li>序列化消息，将key和value序列化，例如StringSerializer</li>
<li>消息需要选择进入哪个分区，如果key没有配置的话就轮询（RR），如果有的话就hash然后取模</li>
<li>如果配置了批处理，先把消息放在缓冲区，等达到了batchsize再传送</li>
<li>请求压缩：kafka集群主要的瓶颈在网络io而不是cpu，在进入的时候压缩，在出去的时候解压，能够减少网络延迟</li>
<li>当达到了batchsize，根据选择的分区发往broker。根据acks配置的参数返回消息</li>
<li>超时重试</li>
<li>如果有回调函数就会执行</li>
</ol>
<blockquote>
<p>kafka可以在分区内保证顺序，但是消费的整体顺序是无法保证的，如果需要严格的顺序消费，以下有两种方法解决：</p>
<ul>
<li>指定key是相同的，在序列化的时候无法保证不同的key散列取余以后是在同一个分区，如果key是相同的就可以保证在一个分区</li>
<li>key可以不同，指定partition相同就可以了，从根源上解决问题</li>
</ul>
</blockquote>
<h2 id="消费者消费失败会怎样"><a href="#消费者消费失败会怎样" class="headerlink" title="消费者消费失败会怎样"></a>消费者消费失败会怎样</h2><p>消费者会有一个重试次数，如果由于网络导致消费失败，信息不会阻塞，会进入一个死信队列。可以在这个队列里面进一步分析原因，也可以继续消费这个队列的信息。</p>
<p>重试次数默认是10次，并且间隔是0s，也就是立即重试10次，没有消费成功就进入死信队列，不会阻塞下一条信息。</p>
<h2 id="Kafka如何保证不重复消费信息"><a href="#Kafka如何保证不重复消费信息" class="headerlink" title="Kafka如何保证不重复消费信息"></a>Kafka如何保证不重复消费信息</h2><p>如上面所述，即便是手动提交offset还是可能出现重复消费，这个时候只能通过消费者的幂等进行校验了</p>
<p><strong>三种消息投递保证</strong></p>
<ul>
<li>At most once：至多一次，对应上面的消费者自动提交offset，这个时候掉电了这条消息就没有了</li>
<li>At least once：对应手动提交offset，可能会重复多次。需要消费者自己做幂等</li>
<li>Exactly once：消息精确传输一次。这不仅仅依赖于kafka，同时也要消费者的配合。</li>
</ul>
<p>kafka的生产者在发送的时候会用全局唯一id+offset来进行幂等发送，避免因为发送端超时重试而导致重复消费。同时开启事务，确保消息是原子性的。</p>
<p>消费者只会消费已经提交过事务的消息（类似MVCC，未提交事务的信息是有可能回滚的，消费他们有风险）。同时类似At Least once，消费者也需要配合做幂等。</p>
<h3 id="Exactly-Once-的实现机制"><a href="#Exactly-Once-的实现机制" class="headerlink" title="Exactly Once 的实现机制"></a>Exactly Once 的实现机制</h3><ol>
<li><p><strong>生产者的角色</strong>：</p>
<ul>
<li><strong>幂等性</strong>：生产者通过启用幂等性功能（<code>enable.idempotence=true</code>）来确保在发送过程中，每条消息只有一个唯一的 ID。即使发生网络错误或重试，生产者也不会重复发送相同的消息。</li>
<li><strong>事务支持</strong>：生产者使用事务来发送消息。在一个事务中，生产者可以发送多条消息，这些消息在调用 <code>commitTransaction()</code> 之前对消费者是不可见的。如果在发送过程中出现错误，生产者可以调用 <code>abortTransaction()</code>，此时所有消息都将被丢弃，确保没有未提交的消息被消费。</li>
</ul>
</li>
<li><p><strong>消费者的角色</strong>：</p>
<ul>
<li>**配置为 <code>read_committed</code>**：消费者配置为 <code>isolation.level=read_committed</code>，确保只读取那些已成功提交的事务消息。这意味着消费者只会处理生产者通过 <code>commitTransaction()</code> 提交的消息。</li>
<li><strong>手动提交偏移量</strong>：消费者在处理每条消息后手动提交偏移量（<code>commitSync()</code>），以标记这些消息已被成功处理。只有在确认消息处理成功后，才提交偏移量，以避免处理失败导致的重复消费。</li>
<li><strong>实现幂等性处理</strong>：消费者在业务逻辑中需要实现幂等性，以确保即使同一条消息被多次消费，最终的业务效果也应该一致。例如，使用数据库的唯一约束来避免重复插入。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>唯一性保证</strong>：通过生产者的唯一 ID 和事务管理，确保在 Kafka 中发送的消息是唯一的，并且不会因重试而重复。</li>
<li><strong>消费的一致性</strong>：消费者通过手动提交偏移量和实现幂等性来确保消息的消费是唯一的，并且只处理那些已经提交的消息，避免了未提交消息可能引起的回滚和不一致。</li>
<li><strong>消息可见性</strong>：未提交的事务消息对消费者是不可见的，确保了只有经过确认的消息才能被消费。</li>
</ul>
<p>这种机制结合起来，使得在 Kafka 中能够实现 <strong>Exactly Once</strong> 的消息处理语义，从而在关键任务和需要高一致性的数据流动场景中得以应用。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/22/Mysql%E9%9D%A2%E8%AF%95%E7%AF%87/">Mysql面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-22
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="InnoDB的存储形式"><a href="#InnoDB的存储形式" class="headerlink" title="InnoDB的存储形式"></a>InnoDB的存储形式</h2><p>众所周知InnoDB存储数据的数据结构是B+树，其中树的节点就是数据页。</p>
<p>数据页内部：</p>
<p>一个数据页上会有多条记录，对应着实际的记录。在数据页内部是按照主键id顺序排列的。除此之外还有一个页目录，将顺序排列的某些记录归为一个槽。例如一个数据页有12345，可能12是一个槽，345是另一个，槽只保存最大的那个节点。当搜索的时候，比如我要搜索4，由于4大于12这个页的最大值2，所以会在345里面搜索。这个时候需要遍历的成本就低很多了。一般来说槽只会包含不超过8条记录。使用二分法找到这个槽，然后在在这个槽进行遍历。页目录只是为了加快在页内的查找速度。实际上每一个页里面记录也是通过链表串起来的。对外只会暴露当前页主键最大值和最小值。方便b+树的查找。</p>
<p>B+树：</p>
<p>b+树与b树的不同点在于，b+只有底层真正存储数据，b树在非叶子节点也会存储数据。而且b+底层是一个双向链表，可以方便进行范围查询。对于innoDB而言，为索引节点还是数据节点根据页头的某个字段决定。索引节点中存储着下一个表对应的最小主键。我们可以把查找一次当作一次io，由于索引节点能存储的数据是很多的，千万级别的数据最多也不过三四层，也就是说io次数会很小。b+树的缺点是会由于添加数据导致分裂，影响性能。</p>
<blockquote>
<p>InnoDB默认得要一个索引，可以不显式的给出，但是背后隐藏列会默认出一个索引作为数据页的排序参照</p>
</blockquote>
<h2 id="为什么用B-树而不是B树，红黑树或者跳表"><a href="#为什么用B-树而不是B树，红黑树或者跳表" class="headerlink" title="为什么用B+树而不是B树，红黑树或者跳表"></a>为什么用B+树而不是B树，红黑树或者跳表</h2><ul>
<li>b树：由于非叶子节点也会存储数据，那么就没有b+树存储数据多。查询的效率也不稳定，可能在非底层就查询到数据了。而且不是双向链表，范围查询做不到</li>
<li>红黑树：也是二叉树，io次数肯定比b+树多，跳表同理</li>
<li>哈希表：不支持范围查询，这同样是redis为什么用跳表而不是哈希表的理由</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是为了加快搜索而建立的数据结构</p>
<ul>
<li>按照数据结构划分：B+树索引，Hash索引</li>
<li>物理存储划分：聚簇索引（叶子节点是数据），非聚簇索引（叶子节点存的是主键id，后续还要回表去聚簇索引找）</li>
<li>字段特性：主键索引，唯一索引（建立在唯一字段上的索引），普通索引，前缀索引（查电话号码）</li>
<li>字段个数：单列索引，联合索引</li>
</ul>
<h2 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h2><p>首先是事务的ACID四个特性：</p>
<ul>
<li>原子性：事务内的东西是同时完成或者同时取消的。innodb的事务可以做到，redis的事务就没有原子性。</li>
<li>一致性：事务完成前后，由一个一致的状态转移到另一个一致的状态。例如银行转账两个账户600+800，转账后总数是不能变的</li>
<li>隔离性：并发导致的事务之间应该隔离，一个人购买商品的事务不应该影响另一个人的购买</li>
<li>持久性：持久化下来，掉电也不会丢失</li>
</ul>
<p>InnoDB的持久性是通过redolog完成的，原子性是undolog，隔离性是MVCC完成的，一致性是上面三者都完成后就会保证一致性。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul>
<li>脏读：一个事务还没有提交，别的事务就能看到它的修改了。例如事务1修改了余额，事务2读取了这部分，但是事务1触发回滚，这就导致事务2读到了脏数据。</li>
<li>不可重复读：在一个事务内读取两次数据，两次数据读取的不一样。这通常是由于另一个事务的提交，这个数据对于其他事务都是可见的（有点像volatile）</li>
<li>幻读： 查询数量，事务内前后查询两次不一致，像发生了幻觉</li>
</ul>
<p>事务隔离级别：</p>
<ul>
<li>读未提交：</li>
<li>读提交：解决脏读</li>
<li>可重复读：解决脏读+不可重复读</li>
<li>串行化：解决幻读+不可重复读+幻读</li>
</ul>
<h2 id="MVCC（多版本并发控制）"><a href="#MVCC（多版本并发控制）" class="headerlink" title="MVCC（多版本并发控制）"></a>MVCC（多版本并发控制）</h2><p>在前面讲的记录中有两个隐藏字段：添加该条记录的事务id和指向上一个版本undolog指针。MVCC是依靠这两个字段完成的，更新数据时会在数据页中替换新的记录，然后将旧的记录作为指针保存下来，这时所有的版本都连成一条链，包含了当时进行更新的事务id。</p>
<p>MVCC提供了ReadView这个数据结构，由于事务id是顺序递增的，ReadView将事务id分为三个部分，已经提交的事务，正在进行的事务和没有发生的事务。已经提交的事务是有访问权的，正在运行的事务是不允许查看的，此时如果发生并发现象，查询数据的时候会根据这三个范围和当前全部的事务id进行过滤，这样就能避免读到还没有提交事务的数据。从而解决了脏读问题</p>
<p><strong>MVCC是如何解决不可重复读的</strong></p>
<p>主要是ReadView生成的时机问题，如果每一次快照读都生成一个ReadView，有可能在两次快照读期间有别的事务提交了，这两次的ReadView范围就会不一样，还是会发生不可重复读。但是如果在事务刚开始的时候就生成ReadView，就能保证执行下来的可见性，即使在第二次读之前，在readview中的那个事务提交了，还能保证接下来的读操作不可见这个数据。</p>
<p><strong>MVCC解决了幻读吗</strong></p>
<p>在默认隔离级别下的innoDB很大程度能够避免幻读，范围查询也需要看版本号。在某些情况下还是能出现幻读，例如当前没有s&#x3D;5的数据，此时进行查询是没有的，另一个事务添加了这条数据，此时事务id在readview里面，是不允许访问的。但是原来事务又更新了这条数据，现在事务id是自己的了。下次查询的时候就会查询出来。（虽然更新一条不存在的数据逻辑上很诡异）</p>
<p>需要通过间隙锁才能解决幻读，也就是锁住一段范围内的，其他事务添加这段范围内的数据就会被阻塞。</p>
<h2 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h2><p>前面所讲的数据库事务的ACID中，持久性就是由redolog保证的。mysql在更新的时候先写redolog，然后再在合适的实际将redolog真正写在数据页上。首先读取操作的时候不会每次都从磁盘io，会缓存在buffer pool中，那么写操作也会在buffer pool中操作，此时就变成了一个脏页。redolog的左右就是把这个脏页的操作记录并持久化下来，这个过程是比刷数据页要快的，很多时候查询的并不是顺序读，有可能在很多数据页上。</p>
<p><strong>刷盘时机:</strong></p>
<p>redolog也是有缓冲区的，把buffer pool中的修改保存在redolog缓存区中，然后再在合适的时机刷盘，一般有以下几个时机：</p>
<ul>
<li>mysql正常关闭</li>
<li>后台线程会每隔1s刷盘</li>
<li>当缓冲区满了一半就触发</li>
<li>根据刷盘策略</li>
</ul>
<p>刷盘策略有以下三种：</p>
<ul>
<li>每次事务提交只写在缓冲区中，但是如果在1s内掉电，redolog buffer就会没有了，这种策略可能会掉最多1s的数据</li>
<li>每次事务提交直接写磁盘，效率较低，但是安全</li>
<li>每次事务提交给操作系统的page cache，交给操作系统写。这种情况如果mysql停机了还是能写，因为操作系统没有停止，但是如果掉点了还是会丢1s的数据，算是上面两种的一个折中。</li>
</ul>
<div style="text-align: center;">
  <img src="../img/Mysql/img_16.png" alt="" />
</div>

<p><strong>日志文件组：</strong></p>
<p>redolog不是一个文件，而是多个文件，这些文件按照环形存储，会覆盖。头指针是checkpoint，尾指针是write pos。每次有缓冲区来的数据就移动pos。如果mysql进行了redolog到数据块的持久化，checkpoint就往后移动。</p>
<p>如果这个环形文件满了，就需要阻塞mysql，进行部分redolog到数据页的操作。</p>
<p><strong>总结：</strong></p>
<p>redolog保证了mysql的持久性，这种操作比直接修改数据页要高效，由于直接修改数据页可能会存在随机写的情况，而redolog是追加写，就好像每次找东西随机写就是看目录找书页，而追加就是往后翻一页。</p>
<p>然而redolog在某些策略下也不是万无一失的，因为redolog也是有缓存的，如果没有及时写在磁盘里就会丢失1s的数据。</p>
<blockquote>
<p>由此可见redolog和真正存在数据页中还有一段时间差，那这个时候来了一个读请求，怎么保证一致性？<br>会在buffer pool找，而不是直接去磁盘找，本来redolog就是为了存buffer pool的脏页的，是内存同步到外存，</p>
</blockquote>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>binlog是解决主从同步的一种日志形式，只记录写操作，select和show是不记录的。有三种格式形式：</p>
<ul>
<li>statement：只记录更新的语句，不管前后状态，一般存储的数据量较小</li>
<li>row：不光记录更新的具体语句，更新前后的状态也保存，一般用在需要计算的sql语句，例如now()，用第一种方式就会造成数据不一致，第二种会保存在主机上面的结果。当然存储的数据量会更大</li>
<li>mix：根据具体sql的形式选取策略，例如正常sql就用statement，涉及到计算的就用row</li>
</ul>
<p><strong>刷盘方式：</strong></p>
<p>与redolog类似，也有一个缓冲区，但是binlog的缓冲区线程之间是独立的，最终都要写进磁盘。</p>
<ul>
<li>0：不同线程的binlog buffer写到page cache里面，由操作系统写回</li>
<li>1：直接写到磁盘</li>
<li>n：n个线程的binlog buffer写到page cache后触发一次写到磁盘。掉电就丢失n个线程的数据</li>
</ul>
<h2 id="binlog就够了为什么还需要redolog"><a href="#binlog就够了为什么还需要redolog" class="headerlink" title="binlog就够了为什么还需要redolog"></a>binlog就够了为什么还需要redolog</h2><p>binlog主要负责主从同步，redolog负责恢复数据库。一个是外部机制，一个是内部机制，两者独立但是互补，服务于不同的需求。</p>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>如果在binlog和redolog之间出现问题就会导致数据不一致。所以需要两阶段提交</p>
<div style="text-align: center;">
  <img src="../img/Mysql/img_17.png" alt="" />
</div>

<p>写redo的时候设置为prepare，等到binlog写完了才设置为commit状态。mysql认为binlog写完了就是一个事务结束，即便没有再设置redolog的状态。</p>
<p>例如在写完redolog时宕机，binlog没有写，这个时候就会触发回滚；但是写完了binlog宕机了，redolog没有被改变为commit，还是会被认为事务提交了</p>
<p><strong>存在什么问题：</strong></p>
<ul>
<li>多线程下需要原子性</li>
<li>如果是“双1配置”，一个事务io两次</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/19/%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%88%B7%E9%A2%98/">一句话刷题</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-19
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <ul>
<li><strong>无重复字符的最长字串</strong>：滑动窗口+heshset，右窗口需要在for外，每轮循环移动右窗口</li>
<li>LRU缓存机制：偷懒直接linkedHashMap，hashmap长度并不为cachesize，重写替换条件为size&gt;cachesize，构造函数要传一个允许get后重排序的boolean</li>
<li>反转链表：pre,p,q三指针</li>
<li>数组第k个最大元素：快排思想，根据每次划分的结果二分查找</li>
<li>最大子数组和：动态规划，看前面的是否为负数，为负数就抛弃自己作为开头，为正数就自己加上</li>
<li>合并两个有序链表：模拟题</li>
<li><strong>最长回文字串</strong>：二维动态规划，撇去前后剩下的也是回文子串</li>
<li>两数之和：hashmap存余数</li>
<li>二叉树层次遍历：queue秒杀，记得最牢的一集</li>
<li>搜索旋转排序数组：随便划分总有一段是顺序的</li>
<li>岛屿数量：dfs上下左右</li>
<li>全排列：dfs回溯，visited数组</li>
<li>有效的括号：stack秒了</li>
<li>二叉树的最近公共祖先：回溯，找两个列表的最末尾相同元素</li>
<li>环形链表：hashmap看是否包括</li>
<li>反转链表2：模拟</li>
<li><strong>最长递增子序列</strong>：动态规划，找前面每一个比自己小的，取最大值+1</li>
<li>字符串相加：太简单不说</li>
<li><strong>接雨水</strong>：单调栈，左-&gt;右和右-&gt;左，取最小值</li>
<li><strong>编辑距离</strong>：二维动态规划，需要考虑左右对角线三个，对角线（相同），左右对角线取最大+1（不相同）</li>
<li><strong>最长公共子序列</strong>：二维动态规划。比上面的好理解，对角线的+1（相同），左右取最大（不相同）</li>
<li>栈实现队列：两个栈来回倒，一个入一个出，在入之前检查出是否为空，反之亦然</li>
<li>括号生成：左右括号剩余数量判别，右边的数量一定得大于等于左边剩余</li>
<li>反转字符串中的单词：split和stringbuilder</li>
<li>二叉树的锯齿状层次遍历： 基本上就是普通的层次遍历，用reversed就可以倒转。</li>
<li>环形链表2：哈希表存节点，遍历的时候同时检车哈希表是否含有</li>
<li>二叉树右视图：层次遍历</li>
<li>子集：回溯，以1234为例，依次增加子集的元素个数</li>
<li>组合总和：回溯，每次dfs都是传剩余，递归终止条件是剩余&lt;0，&#x3D;0就添加一条，最后会有重复，需要一个排序+hashset去重</li>
<li><strong>分割回文串：</strong> 两步走：首先二维动态规则找到所有的回文字串；再类似prim算法遍历dp数组回溯</li>
<li>单词搜索：回溯，上下左右依次dfs，条件全为或，有一个为真就会是真</li>
<li>找到字符串中所有字母异位词：哈希表（偷懒方法，滑动窗口每一个与目标字符串数组进行比较，用toCharArray和Arrays.sort和equals）</li>
<li>电话号码的字母组合：哈希表写一个键盘集合，然后回溯</li>
<li>重排链表：快慢指针找中点（奇数得在正常中点的后面一个）+后半部分倒转链表+双指针连接</li>
<li>旋转图像：沿着左下右上对角线对调，然后按行按照中线对调</li>
<li>搜索二维矩阵2：四个指针上下左右，逐步缩小范围，当循环内不再发生改变就为真</li>
<li>腐烂的橘子：多源bfs，跟二叉树的层次遍历差不多</li>
<li>课程表：拓扑排序，先记录所有点的入度，每次都找到入度为0的点，如果最后还有入度不为0的说明有环</li>
<li>从前序与中序遍历序列构造二叉树：经典题目，要时不时写一下</li>
<li>实现前缀树：Trim[26]数组，要用一个isend区分是前缀还是单词</li>
<li>有序数组转化为二叉搜索树：二分+递归</li>
<li><strong>单词拆分：</strong> 动态规划，当dp[j] &#x3D;&#x3D; 1 &amp;&amp; hashset.contains(s.subString(i,j))时dp[i]&#x3D;1，字符串在字典里当且仅当划分的两部分应该也在字典里</li>
<li>打家劫舍：经典dp题目，有两种策略，不抢的时候选择上一个两种情况中最大的，抢的时候前一个只能不抢。</li>
<li><strong>最大正方形：</strong> 二维dp，dp[i][j]表示以ij为左下角的最大正方形，取左，上，对角线三个里面最小的。</li>
<li>最小路径和：二维dp入门题目，看一眼肯定会</li>
<li><strong>零钱兑换：</strong> dp数组长度为钱的多少，dp表示当前钱兑换的最少次数。每次往后移动都需要首尾指针一起动</li>
<li><strong>排序链表：</strong> 菜就多练</li>
<li>两数相加：两个链表做加法，太简单了不说，还有个2，就是反转之后相加</li>
<li>k个一组翻转链表：虽然是hard但是很简单，思路一定要清晰</li>
<li><strong>二叉树的最大路径和</strong>：树形dp，用一个全局变量保存全局最大路径和，返回的时候需要判断子树是否为负数，如果都为负数就返回自己，只要有一个是正数就返回自己+正数</li>
<li>二叉树的直径：跟上面思路是一样的，但是dp返回的是当前树的高度，也是用全局变量保存最大值</li>
<li>打家劫舍3：树形dp，根节点抢了子节点都不能抢了，取其中dp[0]的和再加自己的，不抢就找dp[0]和dp[1]中较大的那个</li>
<li>求根到叶子节点数字之和：深度和广度+回溯</li>
<li>路径总和：回溯</li>
<li><strong>字符串解码：</strong> 双栈，存数和字符串，遇到]后进行循环拼接，再将前面的依次出栈直到[</li>
<li>最长连续序列：首先set去重，然后遍历，如果有比当前元素小的就跳过，也就是说每次都找一段里面最小的元素。然后用一个全局变量保存最大的。</li>
<li>最长公共前缀：按列遍历，注意长度是否超出</li>
<li>螺旋矩阵：上下左右四个指针，需要注意只有一列或者一行的情况，在循环的过程中要保持上下界左右界不越界</li>
<li>合并K个升序链表：两两合并即可，或者每次都找最小节点</li>
<li>删除链表的倒数第N个节点：栈先进后出</li>
<li>复制ip地址：回溯，但是还有一点边界没搞明白</li>
<li><strong>二叉树的最大宽度</strong>：新建一个内部类，保存编号，左节点是<em>2，右节点是</em>2+1，按层次遍历，找出一层内编号差最大的。</li>
<li>对称二叉树：递归比较左子树和右字数</li>
<li><strong>每种字符至少取k个</strong>：反向思维，滑动窗口。先哈希表存所有元素的个数，然后再-k，r随着循环移动，移动一次对应元素个数-1，当哈希表内出现负数元素，左边指针移动并且释放元素直到哈希表内都不为负数。最后取出最大的那次</li>
<li><strong>最小覆盖字串</strong>：滑动窗口，首先哈希表保存目标字符的个数。r随着循环移动，每次都从哈希表减去对应字符的个数，如果不在哈希表就跳过。如果哈希表所有元素都小于等于0（也就是说集齐了所有，这里有可能比原来多），那么就记录这个长度，左边指针开始动直到再一次没有集齐元素</li>
<li>二叉树的最大深度：左右子树求最大，dp</li>
<li>平衡二叉树判断，返回一个数组，[0]是高度，[1]是是否平衡</li>
<li>岛屿的最大面积：dfs没什么好说的</li>
<li><strong>N皇后</strong>：终极回溯题，上下和两侧的对角线都不能有元素重复。设置四个visited数组，然后每一行开始尝试放q，如果能进行到最后一行那就保存，其余就是回溯操作</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/19/hot100%E5%A4%A9%E5%A4%A9%E5%88%B7-%E7%AC%AC%E4%B8%80%E6%9C%9F/">hot100天天刷-第一期</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-19
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>记住大概的方法就行了</p>
</blockquote>
<h2 id="1-无重复字符的最短字串（滑动窗口）"><a href="#1-无重复字符的最短字串（滑动窗口）" class="headerlink" title="1.无重复字符的最短字串（滑动窗口）"></a>1.无重复字符的最短字串（滑动窗口）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">原题：</a>给定一个字符串，找出不含有重复字符的最长<strong>字串</strong>（字串是连续的）。</p>
<p>滑动窗口：主要思想是随着左边窗口的移动，右边窗口也一定会向右边移动。每一次循环找的都是以charAt(i)开头的最长字串。由于i在增加，在每次移动的同时保存最长字串的长度就是结果。</p>
<p>判断是否重复：当右指针遍历到hashset含有的元素就停止右移。为了保证i移动的同时，后续字符都是以i这个元素开头的，当前循环结束以后需要把charAt(i)从hashset剔除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">//检查重复性</span></span><br><span class="line">    HashSet&lt;Character&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//p是最右边的指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">//p一直向右边移动，直到碰到set里面有的元素，就进行下一次大循环</span></span><br><span class="line">        <span class="keyword">while</span> (p &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hashSet.contains(s.charAt(p)))&#123;</span><br><span class="line">                hashSet.add(s.charAt(p));</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//留一个max来返回最大值</span></span><br><span class="line">        max = Math.max(max,hashSet.size());</span><br><span class="line">        <span class="comment">//在下一次大循环前保证set只有当前元素以后的，所以要把上一个元素从set删除</span></span><br><span class="line">        hashSet.remove(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-最长回文字串（二维动态规划）"><a href="#2-最长回文字串（二维动态规划）" class="headerlink" title="2.最长回文字串（二维动态规划）"></a>2.最长回文字串（二维动态规划）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/">原题：</a>给你一个字符串，找到最长的回文字串。</p>
<p>动态规划：回文子串的性质是，把最开始和最末尾的元素删除还是一个回文字串。状态转移方程为<br>$$<br>dp[i][i] &#x3D; 1<br>$$<br>$$<br>dp[i][j] &#x3D; dp[i+1][j-1] \land (S_{i} &#x3D;&#x3D; S_{j})<br>$$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对角线上的元素都为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//沿着对角线逐渐增大，而不是根据表格行列遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt; s.length(); k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//字串长度为2的时候单独考虑</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//aa，bb这种字串</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(i+k))&#123;</span><br><span class="line">                    dp[i][i+k] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//循环外部变量保存最大值和起始点和重点，因为返回的是具体的字串，需要调用substring</span></span><br><span class="line">                    <span class="keyword">if</span> (length &lt; k+<span class="number">1</span>)&#123;</span><br><span class="line">                        length = k+<span class="number">1</span>;</span><br><span class="line">                        head = i;tail = i+k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//其余长度</span></span><br><span class="line">            <span class="comment">//只有dp[i+1][i+k-1]为回文字串且[i]和[i+k]相同的时候才是一个回文字串</span></span><br><span class="line">            <span class="keyword">if</span> (i+k &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(i+k) &amp;&amp; dp[i+<span class="number">1</span>][i+k-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][i+k] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (k+<span class="number">1</span> &gt; length)&#123;</span><br><span class="line">                    length = k+<span class="number">1</span>;</span><br><span class="line">                    head = i;tail = i+k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(Arrays.deepToString(dp));</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(head,tail+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-最大子数组和（动态规划）"><a href="#3-最大子数组和（动态规划）" class="headerlink" title="3.最大子数组和（动态规划）"></a>3.最大子数组和（动态规划）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">原题：</a>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>动态规划：pre表示的是i之前的最大子数组和的最大值.如果pre是负数，那就相当于拖nums[i]后腿了，与其加上前面的不如自己作为开头。状态转移方程：</p>
<p>$$f(i) &#x3D; max ( f(i-1)+nums[i],nums[i] ) $$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        pre = Math.max(pre+nums[i],nums[i]);</span><br><span class="line">        max = Math.max(max,pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-最长公共子序列（二维动态规划，与dp-i-1-j-1-dp-i-1-j-dp-i-j-1-有关）"><a href="#4-最长公共子序列（二维动态规划，与dp-i-1-j-1-dp-i-1-j-dp-i-j-1-有关）" class="headerlink" title="4.最长公共子序列（二维动态规划，与dp[i-1][j-1],dp[i-1][j],dp[i][j-1]有关）"></a>4.最长公共子序列（二维动态规划，与dp[i-1][j-1],dp[i-1][j],dp[i][j-1]有关）</h2><blockquote>
<p>这道题和编辑长度是一个类型的</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">原题：</a>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>需要考虑dp[i-1][j-1],dp[i-1][j],dp[i][j-1]，所以dp[][]要多一行一列，状态转移方程：</p>
<ul>
<li>text1.charAt(i) &#x3D;&#x3D; text2.charAt(j):$dp[i][j] &#x3D; dp[i-1][j-1]+1$</li>
<li>text1.charAt(i) !&#x3D; text2.charAt(j):$dp[i][j] &#x3D; max(dp[i-1][j],dp[i][j-1])$</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="comment">//二维动态规划</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length()+<span class="number">1</span>][text2.length()+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][dp[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-编辑距离（二维动态规划，与dp-i-1-j-1-dp-i-1-j-dp-i-j-1-有关）"><a href="#5-编辑距离（二维动态规划，与dp-i-1-j-1-dp-i-1-j-dp-i-j-1-有关）" class="headerlink" title="5.编辑距离（二维动态规划，与dp[i-1][j-1],dp[i-1][j],dp[i][j-1]有关）"></a>5.编辑距离（二维动态规划，与dp[i-1][j-1],dp[i-1][j],dp[i][j-1]有关）</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">原题：</a>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p>
<p>与上面那个很相似，如果两个字符是相同的话就看dp[i-1][j-1]，但是不同的话也需要看dp[i-1][j-1]，因为即便字符不同也可以通过替换解决。状态转移方程为：</p>
<ul>
<li>text1.charAt(i) &#x3D;&#x3D; text2.charAt(j):$dp[i][j] &#x3D; dp[i-1][j-1]$</li>
<li>text1.charAt(i) !&#x3D; text2.charAt(j):$dp[i][j] &#x3D; min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1$</li>
</ul>
<p>还有不同的就是初始化边缘不再都是0了，根据插入字符的数量决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length()+<span class="number">1</span>][word2.length()+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(Arrays.deepToString(dp));</span></span><br><span class="line">    <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>][dp[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/17/Redis%E9%9D%A2%E8%AF%95%E7%AF%87/">Redis面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-17
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="redis的数据结构"><a href="#redis的数据结构" class="headerlink" title="redis的数据结构"></a>redis的数据结构</h2><ul>
<li>基本数据结构：string，hash，list，set，sorted set</li>
<li>高级数据结构：geo，hyperloglog，bitmap</li>
</ul>
<h2 id="String的SDS"><a href="#String的SDS" class="headerlink" title="String的SDS"></a>String的SDS</h2><p>redis是基于c的，但是其并没有采用c语言的字符串形式。c语言的字符串是给首数据的指针，遍历字符串的时候一直往后找直到出现”\0”，这对于需要快速处理字符串的redis是不可接受的。</p>
<p>于是redis发明了一个SDS（简单动态字符串），相对于原先的c语言字符串，这里最大的不同是使用一个数据结构里面保存字符串的数组和长度。优点如下：</p>
<ol>
<li>统计字符串的时间复杂度为o(1)：由于c语言的字符串是需要遍历的，类似链表的结构，但是sds直接就有一个字段保存长度</li>
<li>可以保存二进制信息：由于c语言是要找到”\0”为末尾信息，不允许有空格，使得c语言字符串的存储形式受限；而sds没有这方面的特性，直接保存在一个数组里面，因此redis可以用字符串存储图片等二进制信息。</li>
<li>不会发生溢出：由于保存了数组的长度和数组剩余长度，当进行字符串拼接的时候会校验新的长度是否会导致数组溢出，c语言是没有这个特性的。</li>
</ol>
<h2 id="压缩队列ziplist"><a href="#压缩队列ziplist" class="headerlink" title="压缩队列ziplist"></a>压缩队列ziplist</h2><p>在讲其他数据结构之前，需要讲一下压缩。在redis中list，set和zset都有两种数据结构，其中一种就是ziplist，初始为ziplist而当元素数量达到一定阈值就会进化为其他的。</p>
<p>一般来说存储数据每一个格子长度都是固定的，但redis为了节约这部分空白数据就使用了动态长度，也就是说每一个格子只会正好包括数据而不会有空白。但是这样不是固定长度也给遍历带来的问题，不能够按照数组那种长度*个数来找地址，于是redis也做了一些方便搜索的数据结构。</p>
<p><strong>连锁更新问题</strong></p>
<p>除了搜索有缺点，还存在着更新问题，也能想到，如果在中间的某个数据需要更新，那么后面所有的数据都需要向后移动，造成很大的开销，所以redis只在数据量很小的情况下使用这个数据结构。</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>类似jdk1.7实现的hashmap，就是拉链法解决哈希冲突。相较于jdk的hashmap，这里的扩容机制有很大不同。</p>
<p><strong>渐进式扩容</strong><br>对于redis来说，由于是单线程，hashmap扩容会导致线程阻塞，影响性能，所以采用了渐进式hash。每当需要进行扩容的时候不会立刻一次性全部扩容，而是同时创建一个两倍大小的hashmap，在以后的每一次请求中，都会移动一部分数据从旧的hashmap到新的hashmap中，新增的数据就直接写在新表上。</p>
<p>这样将一次扩容平坦到每次请求中，完成扩容的同时也没有严重影响性能。但是此时get一个数据就需要在两个表上都要找。</p>
<h2 id="sorted-set和跳表"><a href="#sorted-set和跳表" class="headerlink" title="sorted set和跳表"></a>sorted set和跳表</h2><p>zset是按照分数score有序排列的集合，底层使用了ziplist+skiplist，当元素数量大于128且元素长度大于64字节的时候自动扩展为跳表。</p>
<p><strong>跳表</strong></p>
<p>单向链表查找的时间复杂度平均为o(n)，跳表用多层链表实现在单向链表上查询的时间复杂度降低为logn</p>
<div style="text-align: center;">
  <img src="../img/Java/img_10.png" alt="" />
</div>

<p>查询就像坐了快车，只有大站到达，节约了不少遍历的时间，一般来说上一层的节点数量是下一层的一半，当需要添加数据的时候如何确定这个节点的层级呢。如果说加入一个节点那么它在最底层的概率为100%，由于上面一层的数量是一半，那么他是2层节点的概率就为50%，3层的就为25%。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机生成节点的层数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lvl</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (random.nextFloat() &lt; P &amp;&amp; lvl &lt; MAX_LEVEL) &#123;</span><br><span class="line">        lvl++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lvl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么用跳表而不是红黑树或者b树</strong></p>
<ul>
<li>hashmap的红黑树结构不适合范围查找，zset有个命令就是查询score在某个范围之内的，而且指针数量也较少，实现难度较低</li>
<li>b树数据结构较大，内存不友好。节点分裂等实现起来较为复杂。</li>
</ul>
<h2 id="redis为什么这么快"><a href="#redis为什么这么快" class="headerlink" title="redis为什么这么快"></a>redis为什么这么快</h2><ol>
<li>基于单线程的io阻塞模型，能够高效的进行网络io</li>
<li>基于内存，且有自己的vm，不会导致虚拟内存频繁换入换出</li>
<li>高效的数据结构</li>
</ol>
<h2 id="redis的单线程io多路复用模型"><a href="#redis的单线程io多路复用模型" class="headerlink" title="redis的单线程io多路复用模型"></a>redis的单线程io多路复用模型</h2><blockquote>
<p>select&#x2F;poll&#x2F;epoll：<br>这三种是操作系统提供给程序员的系统调用api，epoll只有linux内核可以用，这三个系统调用封装了io多路复用机制：</p>
<ul>
<li>select：对于到来的socket链接，操作系统会把它按照特定的数据结构组织成一个文件（这个文件中元素的数量是有上限的，为1024），select操作将这个文件给内核态进行遍历，根据这些数据结构的状态找到需要进行处理的socket然后标记，再返回给用户态。这样的优点是简单直接，缺点是找到需要处理的socket时间复杂度大，而且能够处理的socket有限，所以仅仅支持小规模的io多路复用</li>
<li>poll：是select的升级版，主要是将1024这个上线取消了，使用了链表就没有上限了，其余从用户态到内核态处理，从内核态到用户态都是一样的，都需要遍历两次，效率较低。</li>
<li>epoll：首先是对于数据结构的处理，epoll在内核态维护了一个红黑树，使得处理socket不用每次都在两个态之间每次都复制，仅仅是将新增的加入红黑树，而且查询效率也很高；其次是采用了事件驱动的方法，并不会像select&#x2F;poll那样轮询，这里是直接阻塞，等有消息再通知，是一种阻塞的方式。</li>
<li>水平触发和边缘触发：水平触发是有事件来了就一直通知，直到事件被处理；边缘触发是只通知一次，但是消息可能会丢失。</li>
</ul>
</blockquote>
<p>redis基于reactor模式建立了一套高效的单线程io模型（这里的单线程指的是从socket到epoll发现到执行器处理的流程是单线程），主要组件有：</p>
<ul>
<li>多个socket（多个客户端请求，四元组即为一个socket）</li>
<li>io多路复用：redis是基于epoll的，实现事件驱动的监听机制</li>
<li>事件分派器：根据epoll_wait监听到的socket事件来决定接下来的执行逻辑</li>
<li>事件执行逻辑：有accept，read，write。accept逻辑是根据新来的socket加入红黑树维护并监听</li>
</ul>
<div style="text-align: center;">
  <img src="../img/Java/img_11.png" alt="" />
</div>

<h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><ul>
<li>rdb：将当前的redis数据压缩成一个rdb文件，在文件压缩的过程中（save）会阻塞主线程，但是可以采用bgsave的方式，开辟一个新的线程执行。优点是数据形成的文件dump格式紧凑，redis恢复速度快；缺点是在两次save中间可能会导致丢数据，需要fork一个线程来进行save操作</li>
<li>aof：类似记录日志，每次操作都需要保存。优点是实时性比rdb要好，不容易丢数据；缺点是文件占的地方很大，可能偶尔还需要一个压缩线程来压缩，恢复速度也比dump.rdb慢</li>
</ul>
<p><strong>aof的刷盘方式</strong>：</p>
<ul>
<li>always：每次操作完就刷盘一条aof</li>
<li>everysec：每一秒钟刷盘一次</li>
<li>no：不主动刷盘，靠操作系统来刷盘</li>
</ul>
<p><strong>aof为什么是一条命令执行完了才触发</strong>：</p>
<ol>
<li>有可能命令是错误的，只有正确的命令会aof</li>
<li>不会阻塞当前的任务</li>
<li>缺点是反着来的，不阻塞当前任务但是会阻塞下条任务，有可能执行校验完了执行完了，但是出现异常使得数据丢失没有存储</li>
</ol>
<p><strong>rdb的机制</strong>：<br>bgsave：copyonwirte<br>save：save 50 1000，50s有1000条变化就触发</p>
<h2 id="过期删除"><a href="#过期删除" class="headerlink" title="过期删除"></a>过期删除</h2><ul>
<li>定时清除：在设置key的过期时间的同时给一个定时任务，过期了定时任务删除。这种策略对于cpu不友好，还需要监控每一个key的剩余时间</li>
<li>惰性删除：过期了不会立即删除，直到有访问的时候查询过期时间表，过期了就删除，返回空值。缺点是对于内存不友好</li>
<li>定期删除：根据某个时间进行定期删除，算是上面两种的折中方案</li>
</ul>
<p>redis是惰性删除和定期删除相结合的过期删除策略，根据cpu运载情况选择策略，对于定期删除是随机挑选一些key检查过期情况，其中过期的删除，但是当这个比例大于某个阈值的时候redis就认为有大量过期key需要处理，因此会立即做一次删除，以此类推。</p>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><ol>
<li>volatile-lru</li>
<li>volatile-lfu</li>
<li>volatile-random</li>
<li>volatile-ttl</li>
<li>all-lru</li>
<li>all-lfu</li>
<li>all-random</li>
<li>no-eviction：默认的策略，满了会报错，驱逐新请求</li>
</ol>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><ol>
<li>从服务器向主服务器发送replicaof命令，参数是自己的ip地址，请求主机的唯一id</li>
<li>主机收到了之后返回自己的runid和当前复制的offset</li>
<li>接着主机开始bgsave自己的rdb文件，与从机同步，每次复制都会有一个offset</li>
<li>在复制的过程中可能也会有新的数据，此时主机会用一个缓冲区缓存这部分数据</li>
<li>从机接受完成后，主机再把刚刚缓冲区的传给从机器</li>
</ol>
<h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>主机会维护一个环形缓冲区，储存最近的操作。如果这个环形缓冲区满了就说明有的请求恢复不了了，需要重新进行增量复制。如果没有满，就会用到上面说的那个offset进行增量复制。增量复制的时间很短，毕竟只用传掉线时间丢失的一部分数据。</p>
<p>这个缓冲区的大小应该设置为比掉线恢复时间*平均输入数据稍大，这样就可以避免丢失数据而全量复制</p>
<h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><blockquote>
<p>哨兵也是集群，集群管理集群</p>
</blockquote>
<p><strong>主官下线和客观下线</strong></p>
<p>redis集群通过心跳机制（ping-pong）来检测服务器是否存活，哨兵定期与服务器实例进行检测，当某一个哨兵发现主服务器没有在规定时间内返回pong，就会认为这个服务器下线了，这就是主观下线：</p>
<p>但是这也有可能是由于网络信道丢失消息，未必是主服务器真的宕机了，所以还需要其他哨兵对其进行判断，当超过参数quorum的哨兵认为是下线了，那么就会被认为是客观下线，这个时候就需要进行故障转移。</p>
<p><strong>选举和故障转移</strong></p>
<p>既然主节点发生了故障，那么由谁来进行故障转移呢。那当然是最先发现故障的哨兵，但也可以是两个哨兵同时发现了故障，这个时候就要选举了，每个哨兵只有一个选票，自己发现的需要我选我，当哨兵获得的选票大于半数且也要大于quorum的时候就被选举为故障转移的节点。</p>
<p>接下来就由这个节点进行故障转移：</p>
<ol>
<li>主节点周围的从节点选一个作为下个主节点，进行转移：首先过滤网络状态不好的；再按照优先级，复制进度，id号进行择优。（网络状态有一个主从复制的断连次数，根据这个可以排除网络状态）</li>
<li>其他的从节点全部修改为replicaof这个节点</li>
<li>订阅者通知频道告诉客户端进行了改变</li>
<li>继续监视被替换的这个主机，如果上线了就让他变成从机</li>
</ol>
<h2 id="大key问题"><a href="#大key问题" class="headerlink" title="大key问题"></a>大key问题</h2><p>什么是大key，一般来说String占用大于1MB，或者list，Hash，zset，set长度大于5000个会被认为是大key。String这种情况很可能是因为存储了二进制文件数据，其他顺序结构有可能是没有设计好表导致存储了过多数据。</p>
<p>原因：</p>
<ul>
<li>程序设计不当，使用String存储了二进制文件（SDS是可以存Base64的）</li>
<li>业务规模突然变大：导致list缓存了较多数据</li>
<li>没有清除，例如哈希表缓存了大量没有用的数据</li>
</ul>
<p>危害：</p>
<ul>
<li>太大了话会阻塞redis线程，redis脆弱的单线程</li>
<li>网络拥塞，一个大key就是1MB，1000个用户请求就是1GB</li>
</ul>
<p>如何发现：</p>
<ul>
<li>redis自带的–bigkeys参数</li>
<li>scan命令自己手动看，有点像redis自带的任务管理器，结合别的一些指令可以查看各种value的大小。这个命令效率比较低</li>
<li>第三方开源工具</li>
<li>阿里云内嵌的redis有工具能管理大key</li>
</ul>
<p>如何解决：</p>
<ul>
<li>大的hash表可以拆分为多个key，使用二次哈希拆分为多个hash</li>
<li>手动清理大的string（其实在redis桌面客户端就可以手动清理了，估计背后也是这一条命令）</li>
<li>采用合适的数据结构：不要拿string来存照片或者文本</li>
</ul>
<h2 id="redis的阻塞原因"><a href="#redis的阻塞原因" class="headerlink" title="redis的阻塞原因"></a>redis的阻塞原因</h2><ol>
<li>使用了o(n)的命令，例如keys，这个会在全表找key匹配，还有一些查询范围的数据（zset那些，这个时候又要吟唱跳表的好处了）</li>
<li>大key</li>
<li>持久化：rdb的save会阻塞，bgsave不会；aof会阻塞下一条，重写也会阻塞（就是压缩aof大小的那个操作）</li>
<li>集群库容等各种硬件问题</li>
<li>swap：就是虚拟内存那一套，磁盘换内存，这对于redis也是很致命的。redis快的其中一条原因就是在内存中。因此需要禁止大量swap。</li>
</ol>
<h2 id="热key问题"><a href="#热key问题" class="headerlink" title="热key问题"></a>热key问题</h2><p>突如其来的集中访问某几个key，处理不好会导致缓存击穿。</p>
<p>如何发现：</p>
<ul>
<li>redis自带的参数–hotkeys，但是用这个的前提是内存替换策略要选lfu相关的（可能是因为有了lfu才开启了频率计算吧）</li>
<li>开源工具</li>
<li>monitor命令，可以监控redis当前的一些命令，自己观察某些key的频率手动解决。</li>
</ul>
<p>如何解决：</p>
<ul>
<li>读写分离主从架构</li>
<li>redis cluster：哈希槽，多个热点数据分散在多个库</li>
<li>二级缓存</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/14/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E8%AF%95%E7%AF%87/">分布式面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-14
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>传统的哈希取模操作是基于当前服务器数量的，例如有三台服务器，每次算哈希值就对这三个取模，由于模只可能是0，1，2。</p>
<p>上述HASH算法时，会出现一些缺陷：如果服务器已经不能满足缓存需求，就需要增加服务器数量，假设我们增加了一台缓存服务器，此时如果仍然使用上述方法对同一张图片进行缓存，那么这张图片所在的服务器编号必定与原来3台服务器时所在的服务器编号不同，因为除数由3变为了4，最终导致所有缓存的位置都要发生改变，也就是说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据；同理，假设突然有一台缓存服务器出现了故障，那么我们则需要将故障机器移除，那么缓存服务器数量从3台变为2台，同样会导致大量缓存在同一时间失效，造成了缓存的雪崩，后端服务器将会承受巨大的压力，整个系统很有可能被压垮。为了解决这种情况，就有了一致性哈希算法。</p>
<p>一致性哈希算法也是使用取模的方法，但是取模算法是对服务器的数量进行取模，而一致性哈希算法是对 2^32 取模，具体步骤如下：</p>
<p>步骤一：一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个虚拟的圆环，称为 Hash 环；<br>步骤二：接着将各个服务器使用 Hash 函数进行哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置<br>步骤三：最后使用算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其应该定位到的服务器<br>下面我们使用具体案例说明一下一致性哈希算法的具体流程：</p>
<p>（1）步骤一：哈希环的组织：</p>
<div style="text-align: center;">
  <img src="../img/Distributio/img.png" alt="" />
</div>

<p>圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1，我们把这个由 2^32 个点组成的圆环称为hash环。</p>
<p>（2）步骤二：确定服务器在哈希环的位置：</p>
<p>哈希算法：hash（服务器的IP） % 2^32</p>
<p>上述公式的计算结果一定是 0 到 2^32-1 之间的整数，那么上图中的 hash 环上必定有一个点与这个整数对应，所以我们可以使用这个整数代表服务器，也就是服务器就可以映射到这个环上，假设我们有 ABC 三台服务器，那么它们在哈希环上的示意图如下：</p>
<div style="text-align: center;">
  <img src="../img/Distributio/img_1.png" alt="" />
</div>

<p>3）步骤三：将数据映射到哈希环上：</p>
<p>我们还是使用图片的名称作为 key，所以我们使用下面算法将图片映射在哈希环上：hash（图片名称） % 2^32，假设我们有4张图片，映射后的示意图如下，其中橘黄色的点表示图片：</p>
<div style="text-align: center;">
  <img src="../img/Distributio/img_2.png" alt="" />
</div>

<p>那么，怎么算出上图中的图片应该被缓存到哪一台服务上面呢？我们只要从图片的位置开始，沿顺时针方向遇到的第一个服务器就是图片存放的服务器了。最终，1号、2号图片将会被缓存到服务器A上，3号图片将会被缓存到服务器B上，4号图片将会被缓存到服务器C上。</p>
<p><strong>一致性 hash 算法的优点</strong></p>
<p>前面提到，如果简单对服务器数量进行取模，那么当服务器数量发生变化时，会产生缓存的雪崩，从而很有可能导致系统崩溃，而使用一致性哈希算法就可以很好的解决这个问题，因为一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，只有部分缓存会失效，不至于将所有压力都在同一时间集中到后端服务器上，具有较好的容错性和可扩展性。</p>
<p>假设服务器B出现了故障，需要将服务器B移除，那么移除前后的示意图如下图所示：</p>
<div style="text-align: center;">
  <img src="../img/Distributio/img_3.png" alt="" />
</div>

<p><strong>一致性 hash 算法的缺点</strong></p>
<p>可能会出现倾斜，当服务器的哈希值都很接近就会出现在一段区间里分布着大量的服务器，分布不够均匀。因此也有了虚拟节点这个概念。也就是对服务器用多个哈希函数进行多次运算，使其分布更加均匀。、</p>
<blockquote>
<p>扩展：如果服务器之间有权重，如何设计负载均衡算法：</p>
<ol>
<li>轮盘赌：多个服务器的权重按百分比进行分配，每次有访问请求就生成随机数，这样权重大的就有更大的概率被选中。缺点是如果服务器进行扩展，这个规则需要更改</li>
<li>一致性哈希的虚拟节点：可以根据权重分配更多的虚拟节点，但是效果有待验证，因为毕竟也是随机的，增加节点并不一定就能获得更大的访问范围。</li>
</ol>
</blockquote>
<h2 id="分布式限流算法"><a href="#分布式限流算法" class="headerlink" title="分布式限流算法"></a>分布式限流算法</h2><ul>
<li>固定窗口计数器算法：在一分钟内设定n次访问量，如果超过了n次就拒绝访问。缺点是限流不够平滑，如果在1分钟内前30秒就处理了n个，后面半分钟就等于空转；也无法保证限流速率和攻击，如果服务器的承载力就是1分钟n个请求，在这分钟的后30s给出n个请求，后面一分钟的前半部分给出n个，也能将服务器击垮</li>
<li>滑动窗口计数器算法：划分的更细了，例如划分一秒多少个请求，这样可以应对突发的请求增大，但是也有不平滑的问题，也不好控制速率</li>
<li>漏桶算法：请求进入桶，慢慢漏下来，满了就丢弃请求。这样优点是可以控制速率，但是同时也会导致漏请求</li>
<li>令牌桶算法：桶里面是令牌，可以通过控制令牌的流速改变处理速度</li>
</ul>
<div style="text-align: center;">
  <img src="../img/Distributio/img_4.png" alt="" />
</div>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/14/Spring%E9%9D%A2%E8%AF%95%E7%AF%87/">Spring面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-14
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="Spring的循环依赖问题怎么解决"><a href="#Spring的循环依赖问题怎么解决" class="headerlink" title="Spring的循环依赖问题怎么解决"></a>Spring的循环依赖问题怎么解决</h2><p>循环依赖问题指的是在依赖注入过程中两个类互相依赖，这会导致实例化的过程混乱，因为一个类实例化需要另一个类已经实例化了，一般有三种循环依赖问题：</p>
<ol>
<li>构造函数依赖循环，这个解决不了</li>
<li>setter的依赖循环，其中bean是多例（prototype）</li>
<li>setter的依赖循环，其中bean是单例。</li>
</ol>
<p>Spring仅仅对第三种进行了解决。第一种在new的时候就进行不下去了，无法生成对象；第二种由于无穷无尽的循环会生成很多的bean，最后导致oom。</p>
<p><strong>如何解决</strong></p>
<p>spring用一个三级缓存解决了，总的来说就是在一个类没有初始化的时候提前暴露bean存到三级缓存中，然后进行这个类初始化完成之后就放回第一层缓存中。</p>
<p>创建 BeanA： Spring 首先将 BeanA 的实例存储在三级缓存中。 在创建 BeanA 的过程中，发现需要注入 BeanB。</p>
<p>创建 BeanB： Spring 将 BeanB 的实例存储在三级缓存中（因为 BeanB 也需要 BeanA）。 在创建 BeanB 的过程中，Spring 发现 BeanA 还未完全初始化，所以从三级缓存中获取 BeanA 的代理对象。</p>
<p>注入依赖： 当 BeanA 创建完成后，Spring 会将 BeanB 注入到 BeanA 的字段中。 同样地，BeanA 会注入到 BeanB 的字段中，完成依赖注入。</p>
<blockquote>
<p>在三级缓存这一块，主要记一下 Spring 是如何支持循环依赖的即可，也就是如果发生循环依赖的话，就去 三级缓存 singletonFactories 中拿到三级缓存中存储的 ObjectFactory 并调用它的 getObject() 方法来获取这个循环依赖对象的前期暴露对象（虽然还没初始化完成，但是可以拿到该对象在堆中的存储地址了），并且将这个前期暴露对象放到二级缓存中，这样在循环依赖时，就不会重复初始化了！</p>
</blockquote>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>大的可以分为四个部分：</p>
<ol>
<li>bean创建阶段：通过调用反射api完成bean的实例化</li>
<li>依赖注入：为bean设置相关属性和依赖</li>
<li>初始化bean：首先检查是否实现了Aware包下面的各种aware接口，例如beanname，beanclassloader，beanfactory，其次再检查是否实现了Postbeanprocess接口，执行postbeanbeforeinitialization，再看有没有实现bean初始化方法InitializationBean和xml的init-method，最后再用postBeanAfterInitialization</li>
<li>销毁，disposableBean和destory-bean</li>
</ol>
<div style="text-align: center;">
  <img src="../img/Spring/img.png" alt="" />
</div>

<h2 id="依赖注入的三种方式"><a href="#依赖注入的三种方式" class="headerlink" title="依赖注入的三种方式"></a>依赖注入的三种方式</h2><ul>
<li>字段注入：上面加@Autowired</li>
<li>构造器注入：官方推荐</li>
<li>setter注入：通过setter方法注入</li>
</ul>
<h2 id="Bean会有线程安全问题吗"><a href="#Bean会有线程安全问题吗" class="headerlink" title="Bean会有线程安全问题吗"></a>Bean会有线程安全问题吗</h2><p>首先来看看bean的作用域，常见的有：</p>
<ul>
<li>singleton：默认的bean是单例的</li>
<li>prototype：每次获取都是不一样的bean</li>
<li>request：一次http请求就一个bean</li>
</ul>
<p>如果作用范围是prototype，那不会有线程安全问题，一次获取就有一个bean。但是如果是单例的bean会有线程安全问题，可以通过以下几个方式解决：</p>
<ul>
<li>尽量使用无状态bean</li>
<li>使用ThreadLocal</li>
<li>加锁synchronized</li>
</ul>
<h2 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h2><ol>
<li>客户端发送http请求，首先由DispatcherServlet接收</li>
<li>DispatcherServlet去HandlerMapping里面找（这是一个哈希表，存储了请求路径和controller的映射关系）</li>
<li>找到了对应的Controller，先去通过适配器HandlerAdapter，再去请求Controller</li>
<li>调用完成后返回一个视图和模型ModelAndView。</li>
<li>DispatcherServlet找视图解析器ViewResolver进行解析。</li>
<li>解析得到的Model结合View进行渲染返回请求者</li>
</ol>
<div style="text-align: center;">
  <img src="../img/Spring/img_1.png" alt="" />
</div>

<h2 id="spring的事务传播逻辑"><a href="#spring的事务传播逻辑" class="headerlink" title="spring的事务传播逻辑"></a>spring的事务传播逻辑</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486668&idx=2&sn=0381e8c836442f46bdc5367170234abb&chksm=cea24307f9d5ca11c96943b3ccfa1fc70dc97dd87d9c540388581f8fe6d805ff548dff5f6b5b&token=1776990505&lang=zh_CN#rd">详情看这篇文章</a></p>
</blockquote>
<ol>
<li>TransactionDefinition.PROPAGATION_REQUIRED：外部方法没有开启事务，那就自己开启事务，且开启的事务之间相互独立不打扰；如果外部方法有事务，那就与外部同生共死，如果外部事务回滚自己也回滚。外部事务中的一个子事务回滚那所有都回滚。且如果内部事务异常被捕获，外部事物还是会回滚</li>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW：外部事务回滚，内部的new不回滚。内部事务回滚，如果被catch了就不会造成外部事务回滚，如果没有catch就会回滚。（上一个是有无catch都会造成外部事物回滚）</li>
<li>TransactionDefinition.PROPAGATION_NESTED：与上一个是反的，外部事务回滚会造成内部回滚，自身回滚也是看catch，如果catch了外部事物就不会滚</li>
</ol>
<h2 id="Transactional注解使用"><a href="#Transactional注解使用" class="headerlink" title="@Transactional注解使用"></a>@Transactional注解使用</h2><p>可以使用在方法和类上，使用在类上就是给所有方法都加上事务。常用参数有5个，事务隔离级别（读未提交，读提交，可重复读，串行化），传播行为，超时时间（在指定的时间内未完成回滚），是否只读，触发回滚的异常类型</p>
<h2 id="spring自调用导致失效问题"><a href="#spring自调用导致失效问题" class="headerlink" title="spring自调用导致失效问题"></a>spring自调用导致失效问题</h2><p>由于Transaction这个注释用到了aop，进行事务的对象都是代理对象。如果是自己调用就无法拦截到这个内部调用，所以事务会失效。这个时候可以获取其代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">     ((MyService)AopContext.currentProxy()).method2(); <span class="comment">// 先获取该类的代理对象，然后通过代理对象调用method2。</span></span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/14/Java%E5%9F%BA%E7%A1%80%E7%AF%87/">Java基础篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-14
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="Java的异常体系"><a href="#Java的异常体系" class="headerlink" title="Java的异常体系"></a>Java的异常体系</h2><p>分为异常Exception和错误Error，异常是可以用try&#x2F;catch来解决的，但是error就很严重了，会直接导致线程终止。他们都继承自ThrowAble接口。</p>
<p>其中exception分为可以检查到的异常（checked exception），表示能够在编译阶段就发现并且抛出错误的异常，比如sqlexception或者ioexception；编译时无法检测出的异常（unchecked exception），指的就是运行时异常（runtimeException）例如数组越界，空指针这种。 runtimeException都是无法检测出的异常，其余的都是可以在编译阶段检测出来的。</p>
<p>error是比较严重的错误，例如oom或者stackoverflow，还有虚拟机内部的一些问题，这些error会导致线程直接终止，<del>并不能用try&#x2F;catch</del></p>
<blockquote>
<p>gpt了一下，其实error也可以用catch，因为都是继承自throwable接口，throwable满足这个语法糖。但是出现了error就算catch了程序还是出现了严重错误，捕获这些问题并不能修复，继续运行可能导致更加严重的问题。</p>
</blockquote>
<h2 id="finally方法块"><a href="#finally方法块" class="headerlink" title="finally方法块"></a>finally方法块</h2><ul>
<li>finally并不一定会执行：如果出现了电源掉电或者cpu卡死就不会（<del>这有点幽默了</del>）</li>
<li>不建议在finally里面写返回：try&#x2F;catch&#x2F;finally方法块的逻辑是，即使在try中已经返回了，也会执行finally里面的语句，try的返回值保存起来，同时如果finally里面也有return，就会覆盖try的返回值。</li>
</ul>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>Java数据的传输是通过字节流的，也就是一个byte[]数组，如何将Java转化为这个数组就是序列化要干的事情，原生提供的序列化可以提供实现serialization接口并且指定serialVersionUID完成序列化，这个serialVersionUID会为反序列化提供一个校验，如果id与当前要强制类型转换的类是一样的，那就可以转换，否则就会抛出异常。</p>
<p>比如下面这个代码，文件模拟的是传输的数据流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 显式定义版本号</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.ser&quot;</span>));</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line">            out.writeObject(person);</span><br><span class="line">            out.close();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 模拟反序列化后类发生变化</span></span><br><span class="line">            <span class="comment">// 修改 serialVersionUID 为 2L，模拟版本不匹配</span></span><br><span class="line">            <span class="comment">// private static final long serialVersionUID = 2L;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反序列化</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.ser&quot;</span>));</span><br><span class="line">            <span class="type">Person</span> <span class="variable">deserializedPerson</span> <span class="operator">=</span> (Person) in.readObject();  <span class="comment">// 读取对象</span></span><br><span class="line">            in.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Deserialized Person: &quot;</span> + deserializedPerson.name + <span class="string">&quot;, &quot;</span> + deserializedPerson.age);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();  <span class="comment">// 如果 serialVersionUID 不匹配，这里会抛出 InvalidClassException</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意几点：</p>
<ol>
<li>序列化转化的是对象，也就是说static修饰的字段是不会被序列化的，反正最终反序列化变成了一个对象之后类的静态属性又不会有变化，</li>
<li>不想序列化的变量用transient修饰，例如下面这个代码</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// static 字段</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">transientField</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// transient 字段</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">instanceField</span> <span class="operator">=</span> <span class="number">30</span>; <span class="comment">// 实例字段</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 序列化对象</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;example.ser&quot;</span>));</span><br><span class="line">            out.writeObject(example);</span><br><span class="line">            out.close();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 修改 staticField 值以查看序列化和反序列化的影响</span></span><br><span class="line">            Example.staticField = <span class="number">100</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 反序列化对象</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;example.ser&quot;</span>));</span><br><span class="line">            <span class="type">Example</span> <span class="variable">deserializedExample</span> <span class="operator">=</span> (Example) in.readObject();</span><br><span class="line">            in.close();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 打印结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Deserialized Example:&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Static Field: &quot;</span> + Example.staticField); <span class="comment">// staticField 仍然是 100</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Instance Field: &quot;</span> + deserializedExample.instanceField); <span class="comment">// instanceField 是 30</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Transient Field: &quot;</span> + deserializedExample.transientField); <span class="comment">// transientField 是 0</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>但是Java默认的这个序列化并不好，至少我在开发的时候都用的是Json，为什么呢？</p>
<ol>
<li>不支持跨平台，java序列化得到的字节流只能java反序列化出来，json不一样，java转化为的json可以用python再反序列化回来</li>
<li>性能较差，转化后的字节数组大</li>
<li>安全性</li>
</ol>
<h2 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String,StringBuffer,StringBuilder"></a>String,StringBuffer,StringBuilder</h2><ul>
<li>string是被final修饰的，同时内部的实现数组（char[]或者byte[]）是private，无法通过外界修改。因此字符串的拼接是需要新生成对象的。</li>
<li>stringbuffer：方法由synchronized修饰，是线程安全的，其拼接字符串不会创建一个新的stringbuffer类，效率比string不知道高到哪里去了</li>
<li>stringbuilder：在大部分情况下string的操作都不太需要线程同步，这个类就取消了同步操作，效率比上一个高。</li>
</ul>
<p><strong>字符串的拼接</strong></p>
<p>java是没有运算符重载的，但是唯一为了string的拼接修改了+和+&#x3D;，使得string可以通过+和+&#x3D;操作</p>
<p>查看字节码我们可以知道，其实string的+和+&#x3D;是基于stringbuilder调用append方法，最后再使用tostring赋值给String，但是每次进行这样一个拼接操作就需要new一个stringbuilder，对于循环来说，这样的开销就非常大了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    s += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure>

<p>如果直接使用append来拼接，就不会有这个问题了。所以在大量字符串操作的时候用buffer或者builder比较好。</p>
<h2 id="字符串常量池和String对象"><a href="#字符串常量池和String对象" class="headerlink" title="字符串常量池和String对象"></a>字符串常量池和String对象</h2><p><strong>字符串常量池</strong><br>首先做个区分，java程序在编译成了class文件之后会有一个常量池，也叫做静态常量池。当在被类加载器加载进内存时会将其分为字符串常量池和运行时常量池。</p>
<ul>
<li>运行时常量池是一直跟着方法区的，方法区在哪里它在哪里。在jdk1.7的时候方法区叫做永久代，放在运行时数据区，也就是和堆栈在一起的区域，为了减少oom的可能和内存的压力，在jdk1.8以后被搬到了直接内存中，由操作系统管理不由jvm虚拟机管理，从而减少了jvm的内存压力。但是虚拟机参数可以配置元空间的大小，并不是可以无限扩大的，也会有oom：metaspace的报错。说回运行时常量池，包含了class文件里静态常量池里的字面量和符号引用，但唯独没有字符串。<strong>也就是说除字符串以外的字面量比如整形和浮点，符号引用的类与接口全限定名，方法和字段的名称和描述符，都还在运行时常量池；维度字符串排除出去了</strong></li>
<li>字符串常量池：在jdk1.6的时候是没有与运行时常量池分开来的，也是跟着方法区的，到了1.7被分到堆内存去了。原因是本来方法区进行垃圾回收的机会就很少，除了fullgc基本到不了这里，字符串又是一个很容易产生大量对象的地方。所以就放到heap中了，可以进行垃圾回收，这里创建出的也被称之为字符串对象。实际上String的引用都是在字符串常量池里的地址。</li>
</ul>
<p><strong>new String(“abc”)的问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>我们假设前面都没有关于abc这个字符串的创建，这个操作会创建两个对象：</p>
<ul>
<li>首先会在字符串常量池上创建abc这个对象</li>
<li>由于new了一个String对象，会在堆上创建一个新的对象</li>
</ul>
<p>但是如果前面有String s2&#x3D;”abc”，也就是前面已经有在字符串常量池里面创建对象了，前面这个new的代码只会创建一个对象，即堆内存上的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);  <span class="comment">// true，因为 s1 和 s2 都引用常量池中的同一个对象</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;              <span class="comment">// 常量池中的 &quot;abc&quot; 对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);  <span class="comment">// 堆中的新对象</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);   <span class="comment">// false，s1 和 s2 是不同的对象，s1 是常量池中的，s2 是堆中的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>那我在new了一个String以后，我怎么找到字符串常量池里面的对象？<br>intern可以直接找，返回的是在字符串常量池里的地址，这样就保证了字符串内容是一致的情况下，地址也完全一样，在某些要用锁的场合下，使用intern可以保证锁的对象是唯一的。<br>例如在黑马点评这个锁代码块里面：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span>  Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">	<span class="keyword">synchronized</span>(userId.toString().intern())&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里面每一个id的toString都会创建一个新的对象，为了保证锁对象的唯一性，需要用intern直接取出常量池的地址</p>
</blockquote>
<p>为什么要有这种设计？字符串常量池本身就是为了可重复才扩展的，有的时候不想要与字符串的常量池共享，就需要创建一个新的字符串。</p>
<h2 id="Double和BigDecimal的区别"><a href="#Double和BigDecimal的区别" class="headerlink" title="Double和BigDecimal的区别"></a>Double和BigDecimal的区别</h2><ul>
<li>double是基本数据类型，bigDecimal是类</li>
<li>double双精度浮点型可能会有数据溢出的情况，bigdecimal是用字符串做运算的，精度有保障，由于是字符串，会频繁创建对象，开销较大</li>
<li>精度要求特别高比如在金融领域需要用big</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>类加载器加载字节码文件分为三部分：通过类的全限定名获取字节码文件，将字节码文件生成一个InstanceKlass文件在方法区，保存了类的元数据包括字段，方法，虚方法表登；同时会在堆中生成一个Class对象，作为访问这个InstanceKlass对象的接口。 正是这个Class对象为Java反射提供了基础。</p>
<p>获取Class对象有以下四种方式：</p>
<ol>
<li>Class.forName传入路径</li>
<li>通过对象获取class（instance.getClass()）</li>
<li>通过类加载器传入loadClass路径获取（走的就是双亲委派机制那一套了，估计findClass是根据路径改造成全限定名然后找，但是这里仅仅是加载类，没有连接过程，所有静态代码块不会执行）</li>
<li>可以直接.class获取</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 获取Class对象</span></span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 获取构造器并创建对象</span></span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 获取并调用方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">sayHello</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">            sayHello.invoke(person);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 获取并修改字段</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">            ageField.setAccessible(<span class="literal">true</span>); <span class="comment">// 如果字段是private的，需要设置可访问</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> (<span class="type">int</span>) ageField.get(person);</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄: &quot;</span> + age);</span><br><span class="line">            ageField.set(person, <span class="number">30</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;修改后的年龄: &quot;</span> + ageField.get(person));</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设存在如下Person类</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好，我是&quot;</span> + name + <span class="string">&quot;，今年&quot;</span> + age + <span class="string">&quot;岁。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何获得私有变量&#x2F;方法：setAccessible</p>
</blockquote>
<p><strong>反射的优缺点</strong></p>
<ul>
<li>优点：灵活度高，多种框架都是基于反射的，能够在运行时动态操作类和对象</li>
<li>缺点：安全性，private字段可以访问，性能开销</li>
</ul>
<blockquote>
<p>总结：为什么反射的效率低？<br>反射效率低的原因可以归结为以下几点：</p>
<ul>
<li>需要进行动态的类型解析，耗费额外时间。 </li>
<li>反射的调用绕过了编译时的优化。 </li>
<li>反射需要执行额外的安全性检查。 </li>
<li>方法调用的间接性导致了额外的步骤和开销。 </li>
<li>缺乏JIT对反射的优化支持。 </li>
<li>频繁使用时，开销会明显累积。 </li>
<li>反射可能会引发对象包装和拆箱操作，进一步降低效率。</li>
</ul>
</blockquote>
<h2 id="switch能否用String当作case"><a href="#switch能否用String当作case" class="headerlink" title="switch能否用String当作case"></a>switch能否用String当作case</h2><p>在jdk1.7以后有了这个语法糖。在底层原理中switch仅支持int，char等基本数据类型。switch中string是通过case哈希值，然后在equals内容得到的。哈希值是一个int类型的，由于也可能产生哈希碰撞，所以还得再检查字符串内容是否相同。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>虚拟机中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的Class类对象。比如并不存在List<String>.class或是List<Integer>.class，而只有List.class。</p>
<p>也就是说泛型仅仅是在编译的时候做检查，而不会真正落到jvm里</p>
<h2 id="Object有哪些方法"><a href="#Object有哪些方法" class="headerlink" title="Object有哪些方法"></a>Object有哪些方法</h2><ul>
<li>wait和notify以及notifyAll：wait方法是放弃当前监视器锁，进入waitSet，状态变为WAIT。notify和notifyAll是唤醒当前监视器锁下面wait的线程，在hotspot中是分别是随机唤醒一个和全部唤醒。这个方法仅能在synchronized方法块中使用</li>
<li>hashCode和equals：下面讲</li>
<li>getClass：获取Class对象，与类.class方法是一样的，一共有四种方法获取Class对象（getClass，.class，类加载器loadClass,Class.forName）</li>
</ul>
<h2 id="hashCode和equals"><a href="#hashCode和equals" class="headerlink" title="hashCode和equals"></a>hashCode和equals</h2><p>说这两个就离不开集合，例如hashMap存储是按照hashCode散列找Entry，如果hashCode相同则在一个Entry下，但是有可能是哈希碰撞，所以还要比较equals，当且仅当hashCode相等并且equals返回为真的时候才会被认为是一个。在Object中默认hashCode是两个对象的内存散列，equals是比较内存地址是否相同。</p>
<p><strong>String重写的hashCode和equals</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s.hashCode()+<span class="string">&quot;  &quot;</span>+s1.hashCode());</span><br><span class="line">System.out.println(s.equals(s1));</span><br></pre></td></tr></table></figure>

<p>按道理来说s和s1是两个不同的对象，由于之前说的s应该是在字符串常量池，而s1是在堆中，hashCode按照Object默认的比较地址肯定是不相同的。但是String重写了hashCode，通过字符累加的方式计算哈希码，在保证了分散的同时使得相同字符串的哈希码相等。也重写了equals，比较字符串内容而不是比较地址。</p>
<p><strong>为什么重写了equals就必须重写hashCode</strong></p>
<p>如果两个对象内容相同就是一个对象的话，在set里面不能重复。需要重写equals，但是不重写hashCode可能会分配到不同的Entry，这样两个对象同时会被存储。所以保证equals为真的同时hashCode也要相同。</p>

    
    
  </div>

  

  

</article>
  
    
  <nav class="pagination">  
      
      
      <a class="next" href="/page/2/">  
        <span class="next-text">下一页</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  
</section>
        </div>
          

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:1050886654@qq.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/yyf1050886654" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2024      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">Yifan Yang</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    

  







<script type="text/javascript" src="/lib/jquery"></script>



<script type="text/javascript" src="/lib/slideout"></script>



<script type="text/javascript" src="/lib/fancybox"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>