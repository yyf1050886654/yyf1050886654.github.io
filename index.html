<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/default" title="YYF's Blog" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://yyf1050886654.github.io/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>YYF&#39;s Blog</title>

<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">YYF&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/collect/">
      <li class="mobile-menu-item">
        
        
        收藏              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">YYF's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/collect/">  
              
              
              收藏  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <section id="posts" class="posts">
  
  
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/02/28/%E7%BD%91%E6%98%93KM%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8ERAG%E7%9A%84%E7%83%AD%E7%82%B9-AI%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">网易KM社区分享-快速搭建基于RAG的热点 AI搜索引擎</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-02-28
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>大模型的出现带来了新的技术革新，它强大的对话，分析，生成能力可以应用在音乐的很多方面。我们希望借助大模型的能力， 实现对站内外音乐热点词条内容进行抽取，分析，总结，推荐。 本文将系统的介绍我们如何基于RAG 搭建一个带前端页面的 热点AI检索功能agent<br>体验地址：<a target="_blank" rel="noopener" href="http://llm-zq.jupyter.panshi-gy.netease.com/">http://llm-zq.jupyter.panshi-gy.netease.com/</a></p>
</blockquote>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><p>大模型的出现带来了新的技术革新，它强大的对话，分析，生成能力可以应用在音乐的很多方面。我们希望借助大模型的能力， 实现对站内外音乐热点词条内容进行抽取，分析，总结，推荐。 但是:</p>
<ul>
<li>大模型对于时事热点等，幻觉能力严重，而RAG(检索增强生成)可以解决这个问题。</li>
<li>很多都离不开外部的依赖接口，无法做到完全的offline, 且当token量大之后，费用也很大， 但其实开源的很多模型如LLAMA, QWEN等都已经有非常不错的能力。而且近期流行的ollama框架， 也让个人PC也都能支持大模型生成。</li>
<li>我们希望借助开源的能力，来快速搭建一个不依赖外部接口的AI检索引擎来为我们服务， 也避免了隐私泄露的风险。</li>
</ul>
<p>它的主要特点：</p>
<ul>
<li>不依赖外部接口， 离线实现LLM生成, 检索，embedding等能力。</li>
<li>基于互联网结果进行RAG，解决模型生成幻觉的问题，尤其可以支持对于近期热点知识的总结。<br>本文主要介绍开发这个agent的框架，一些技术细节和思路，希望给大家带来一点LLM 开发的收获。效果图如下，左边是我们的agent, 输入问题描述，系统即可自动调用搜索引擎并爬取互联网的内容，并通过大模型分析总结返回给我们问题的结果。在某些情况下，甚至比KIMI的效果还要好。</li>
</ul>
<p><img src="/../img/netease/img.png" alt="img.png"></p>
<h1 id="2-框架"><a href="#2-框架" class="headerlink" title="2.框架"></a>2.框架</h1><p>总体框架如下图所示，主要包括3个子模块：</p>
<ul>
<li>(1) 检索爬取服务：根据用户搜索的热点关键词，调用自建的searxng 匿名检索服务系统, 获取top的互联网搜索引擎结果，并爬取相关网址全文内容。</li>
<li>(2) 文档召回服务：对爬取的全文内容切块，进行向量化，同时对query也进行向量化，计算query和文档的相关性，并进行排序选取top的文档切块</li>
<li>(3) 大模型生成服务。离线部署好大模型，输入相关文档和配置的prompt, 生成相关的检索答案汇总，并通过部署的streamlit前端服务返回给用户。</li>
</ul>
<p><img src="/../img/netease/img_1.png" alt="img_1.png"></p>
<p>3个模块通过langchain框架进行串联起来工作，api接口都采用fastapi进行封装， 前端展示用streamlit进行交互开发。</p>
<h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><p>基于基本的框架思路，我们前期调研了发现github已有类似的相关项目，在这些项目的基础上，我们做了一些优化。</p>
<p>LLocalSarch:<a target="_blank" rel="noopener" href="https://github.com/nilsherzig/LLocalSearch">https://github.com/nilsherzig/LLocalSearch</a></p>
<p>LangChain-SearXNG: <a target="_blank" rel="noopener" href="https://github.com/ptonlix/LangChain-SearXNG">https://github.com/ptonlix/LangChain-SearXNG</a></p>
<h2 id="3-1-检索爬取服务"><a href="#3-1-检索爬取服务" class="headerlink" title="3.1 检索爬取服务"></a>3.1 检索爬取服务</h2><p>检索爬取服务主要有两个模块。searxng检索服务 和爬虫服务</p>
<h3 id="3-1-1-searxng检索服务"><a href="#3-1-1-searxng检索服务" class="headerlink" title="3.1.1 searxng检索服务"></a>3.1.1 searxng检索服务</h3><p>SearXNG 是一个免费的互联网元搜索引擎，它聚合了来自各种搜索服务(如 google, duckduckgo等)和数据库（如wiki）的结果，但摆脱了隐私追踪。</p>
<p>当然，你也可以采用商业的搜索api 接口，比如google的Serper API ， bing的Bing Web Search API，但这不是我们的目的，我们是希望搭建一个完全没有外部依赖的检索服务。</p>
<p>请注意，搭建searxng检索需要一台非大陆的VPS，并配有ipv4地址，如果嫌麻烦，可以用公共的searxng, 但是会有限制，地址：<a target="_blank" rel="noopener" href="https://searx.space(需要fq)/">https://searx.space(需要FQ)</a></p>
<p><img src="/../img/netease/img_2.png" alt="img_2.png"></p>
<p>以下是搭建教程：</p>
<ol>
<li>第一步：安装docker, docker-copose</li>
</ol>
<p>docker安装：<a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/install/debian">https://yeasy.gitbook.io/docker_practice/install/debian</a></p>
<p>docker-copose安装：<a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/compose/install">https://yeasy.gitbook.io/docker_practice/compose/install</a></p>
<ol start="2">
<li>第二步：拉取searxng 镜像, 修改配置</li>
</ol>
<p>修改项目docker配置</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 拉取代码</span><br><span class="line">git clone https://github.com/searxng/searxng-docker.git</span><br><span class="line"># docker配置里包括3个服务，caddy 做反向代理，redis存储数据，searxng主服务</span><br><span class="line">#不做反向代理可以注释掉caddy部分， 只需要修改 searxng里的port，如： 0.0.0.0:8180:8080， 右边是设置好的容器内的端口，左边是本地端口可以改</span><br><span class="line">vim searxng-docker/docker-compose.yaml</span><br></pre></td></tr></table></figure>

<p><img src="/../img/netease/img_3.png" alt="img_3.png"></p>
<p><img src="/../img/netease/img_4.png" alt="img_4.png"></p>
<p>修改searxng主服务配置</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s|ultrasecretkey|$(openssl rand -hex 32)|g&quot; searxng-docker/searxng/settings.yml # 生成一个密钥</span><br><span class="line"># limiter: 改为false, 为true会限制你的请求频率，公开服务会开启，但是私人搭建的可以关闭</span><br><span class="line">vim searxng-docker/searxng/setting.yml</span><br></pre></td></tr></table></figure>
<p><img src="/../img/netease/img_5.png" alt="img_5.png"><br>3.第三步：启动compose 服务组</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd searxng-docker</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>第四步：关闭端口防火墙并验证，如果没有防火墙则不需要这一步</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufw allow 8180</span><br></pre></td></tr></table></figure>

<p>最后浏览器打开ip:8180,即可看到自己搭建的searxng页面并进行检索了，是不是很酷😎，没有任何广告，页面非常干净。</p>
<p><img src="/../img/netease/img_6.png" alt="img_6.png"></p>
<h3 id="3-1-2-爬虫服务"><a href="#3-1-2-爬虫服务" class="headerlink" title="3.1.2 爬虫服务"></a>3.1.2 爬虫服务</h3><p>单独searxng的结果信息量比较小，而对于LLM来说，丰富的信息意味着更准确的结果。 所以针对搜索引擎给出的相关网页，我们可以采用爬虫爬取top网页结果。 所幸，langchain（一个帮助在应用程序中使用大型语言模型的编程框架） 里就包含了相应的网页爬取模块，和文本解析模块。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># langchain 调用searxng示例, 获取top结果</span><br><span class="line">from langchain_community.utilities import SearxSearchWrapper</span><br><span class="line">s = SearxSearchWrapper(searx_host=&quot;http://localhost:8180&quot;)</span><br><span class="line">s.run(&quot;what is a large language model?&quot;)</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># langchain 爬取示例</span><br><span class="line">from langchain_community.document_loaders import AsyncChromiumLoader</span><br><span class="line">from langchain_community.document_transformers import Html2TextTransformer</span><br><span class="line">urls = [&quot;https://www.baidu.com&quot;]</span><br><span class="line">loader = AsyncChromiumLoader(urls, user_agent=&quot;MyAppUserAgent&quot;)</span><br><span class="line">docs = loader.load() # 爬取</span><br><span class="line">html2text = Html2TextTransformer()  </span><br><span class="line">docs_transformed = html2text.transform_documents(docs) # 解析抽取网页里文本</span><br><span class="line">docs_transformed[0].page_content[0:500]</span><br></pre></td></tr></table></figure>

<p>这里面在实践中存在几个主要问题：</p>
<ol>
<li>searxng的top结果中可能存在无法访问的(大陆)，比如wiki 等，需要额外处理过滤。 这里我采用的是pac方式。过滤不能访问的网址</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># wget https://raw.githubusercontent.com/petronny/gfwlist2pac/master/gfwlist.pac</span><br><span class="line">import pacparser</span><br><span class="line">pacparser.init()</span><br><span class="line">pacparser.parse_pac(&#x27;gfwlist.pac&#x27;)</span><br><span class="line"></span><br><span class="line">def is_direct(url):</span><br><span class="line">ret =  pacparser.find_proxy(url)</span><br><span class="line">return &quot;DIRECT&quot; == ret</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">print(is_direct(&quot;www.baidu.com&quot;))</span><br><span class="line">print(is_direct(&quot;www.google.com&quot;))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可能存在超时的问题，有些网站链接速度非常慢，原本的langchain 爬取模块不支持超时，需要自己在外面额外封装一层超时控制。或者采用httpx的包进行批量爬取。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import httpx</span><br><span class="line">from typing import List, Optional,Tuple</span><br><span class="line">import asyncio</span><br><span class="line">headers = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def get_result(url: str):</span><br><span class="line">if not is_direct(url): # 非直连</span><br><span class="line">async with httpx.AsyncClient(proxy=&#x27;socks5://127.0.0.1:1080&#x27;) as client:</span><br><span class="line">try:</span><br><span class="line">response = await client.get(url,headers=headers,timeout=10.0)  # 设置超时</span><br><span class="line">return url, response</span><br><span class="line">except httpx.RequestError:</span><br><span class="line">return url, None</span><br><span class="line">else:</span><br><span class="line">async with httpx.AsyncClient() as client:</span><br><span class="line">try:</span><br><span class="line">response = await client.get(url,headers=headers,timeout=10.0)</span><br><span class="line">return url, response</span><br><span class="line">except httpx.RequestError:</span><br><span class="line">return url, None</span><br><span class="line"></span><br><span class="line">async def get_results( urls: List[str]):</span><br><span class="line">tasks = [get_result(url) for url in urls]</span><br><span class="line">results = await asyncio.gather(*tasks)</span><br><span class="line">for url, response in results:</span><br><span class="line">if response is None:</span><br><span class="line">print(f&quot;URL: &#123;url&#125; - Failed to connect&quot;)</span><br><span class="line"># else:</span><br><span class="line">#     print(url, response.text[:100])</span><br><span class="line">return results</span><br><span class="line"></span><br><span class="line">def get_results_access( urls: List[str]) -&gt; List[Tuple[str,str]]:</span><br><span class="line">try:</span><br><span class="line">asyncio.get_running_loop()</span><br><span class="line">with ThreadPoolExecutor(max_workers=1) as executor:</span><br><span class="line">future = executor.submit(asyncio.run, check_urls(urls))</span><br><span class="line">results = future.result()</span><br><span class="line">except RuntimeError:</span><br><span class="line">results = asyncio.run(check_urls(urls))</span><br><span class="line"></span><br><span class="line">    return [(url,response.text) for url, response in results if response is not None]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>爬取的结果如果是动态加载的内容，目前无法爬取。 比如 B站视频下的评论， 知乎的答案等。这种需要针对特定网站， 用自动化测试工具，比如Selenium 或者playwright. 这个待后续优化。</li>
</ol>
<h2 id="3-2-切块召回服务"><a href="#3-2-切块召回服务" class="headerlink" title="3.2 切块召回服务"></a>3.2 切块召回服务</h2><p>这一步，其实主要对应RAG里R即retrieval, 召回。因为获取的top网址文本内容量比较大，一般单个网页的文本都接近5k token, 像百度知道这种以文本内容为主的基本都超过8k长度，多个网页内容直接丢给大模型解析，是个不太现实的任务，虽然现在有学者提出超长上下文的大模型（Long Context LLM）正在慢慢取代RAG, 但目前来说rag还是最优解。</p>
<p>召回过程是分为 切块，向量化，排序</p>
<h3 id="3-2-1-切块"><a href="#3-2-1-切块" class="headerlink" title="3.2.1 切块"></a>3.2.1 切块</h3><p>所有的文档进行chunk, 即切块， 比如以512个 token 作为一个chunk。这里面有几个问题：</p>
<ol>
<li>如何确定最佳块大小？</li>
</ol>
<p>这个目前没有定论，主要还是取决于应用场景，具体可以参考微软[1]的建议并自行进行测试：</p>
<p><img src="/../img/netease/img_7.png" alt="img_7.png"></p>
<ol start="2">
<li>分割策略？</li>
</ol>
<p>为了得到更好的结果，我们可以重叠相邻的块。来自微软分析的分块策略比较，显示512 tokens分块和25%的重叠是比较好的分块策略。 当然也要考虑embedding的模型</p>
<p><img src="/../img/netease/img_8.png" alt="img_8.png"></p>
<p>实际使用下来，应用于网页文本分块召回的比较好的参数， chunk&#x3D;500，overlap&#x3D;100, 向量模型采用BCE。</p>
<h3 id="3-2-2-向量化"><a href="#3-2-2-向量化" class="headerlink" title="3.2.2 向量化"></a>3.2.2 向量化</h3><p>切块之后第二步就是对文档和query都进行向量化，并计算 query和 文档之间的相似度，再设定过滤的阈值，得到最终我们需要的文档片段。那么，向量模型该如何选取？</p>
<p>一般的商业大模型服务都自带embedding接口，比如openai的 v1&#x2F;embedding, 这种需要api_key, 显然不是我们的目标。开源模型效果对比，可以参考，huggingface 的embedding竞技场：<a target="_blank" rel="noopener" href="https://huggingface.co/spaces/mteb/leaderboard">https://huggingface.co/spaces/mteb/leaderboard</a> ,但是里面不是所有模型都有打分，下面是一些主流的embedding模型:</p>
<p><img src="/../img/netease/img_9.png" alt="img_9.png"></p>
<p>开源模型挑选可以从几个方面入手：</p>
<p>① 硬件性能。 因为单次用户请求，涉及很多切块文档，所以需要考虑机器性能和模型速度，其实很多常见的大模型做embedding效果也很好，但它不是主流因为效率很低，我们在mteb 评测榜单上可以看到 qwen2的检索效果非常好，但是模型太大很难应用。 尤其我们的任务都是实时算，并不存储向量，所以需要模型不太大。</p>
<p><img src="/../img/netease/img_10.png" alt="img_10.png"></p>
<p>② 向量维度。向量维度会影响到 存储以及检索耗时，对于常见的检索任务，是对知识库的内容预先算好相应的向量，并存储进向量数据库。 用户检索时，对检索词向量化，再通过近邻检索算法检索最相关的top结果。当数据量显著大时，向量维度越大，检索耗时越明显。我们的任务里不存储向量，所以这块也不需要考虑。</p>
<p>③ 最大输入长度。 指模型处理输入的最大token长度，这个和我们前面提到的分块大小息息相关，因为如果分块大小超过最大长度，则超过的部分会被向量模型丢弃，导致信息损失。</p>
<p>④ 支持语言。大部分开源向量模型只支持单一或者有限的文本语言，在需要多语言需求的场景可能不合适。需要注意的是，不支持多语言，不代表其他语言就不能向量化，而是缺乏跨语言匹配的能力。 比如[ ‘How is the weather today?’, ‘今天天气怎么样?’] 在单一语言里相似度可能很低，而对于多语言，则匹配度较高。一般来说，如果只是针对特定语言，选择单一语言模型即可，评分高的混合语言模型不一定比单一语言模型效果好。 由于网页内容繁杂，我们倾向于选择多语言模型</p>
<p>⑤ 领域表现。通用 Embedding 模型在特定垂直领域（如医学、法律和金融等）可能不如专用模型有效。这些领域通常需要专门训练 Embedding 模型来捕捉特定的专业术语和语境。为特定业务需求优化的 Embedding 模型能够显著提升检索和生成的质量。 网页内容匹配通常不需要考虑领域表现。</p>
<p>基于上面的维度，我们选择了中英双语的 bce-embedding-base_v1模型。</p>
<h3 id="3-2-3-排序"><a href="#3-2-3-排序" class="headerlink" title="3.2.3 排序"></a>3.2.3 排序</h3><p>顺便再聊一下，关于RAG中的召回，目前主流的做法是两个阶段。第一阶段query和文档向量化，检索框架采用faiss, 或者milvus 这种向量查询数据库。 第一阶段存在两个问题：</p>
<p>1、当doc数据量大的时候，检索算法都是近似的， 不是挨个遍历计算，会有损。除非用暴力挨个计算cos, 但这个不现实。（在本任务里是可以的，因为文档量很小）</p>
<p>2、embedding本来就是对于信息的压缩，对原始文本信息是有丢失的。</p>
<p>那么对于这些缺点，有办法优化吗？ 答案是有的，即第二阶段rerank模型精排。 rerank模型输入query和doc对文本，而不是emebdding, 信息无损。 2阶段检索详情可以参考QAnything给出的示意图， 很清楚。</p>
<p><img src="/../img/netease/img_11.png" alt="img_11.png"></p>
<p>在加入二阶段rerank之后，BCE的效果， top10命中率由85.91%提升到93.46%，非常明显。同时可以看到，采用hybird， 即bm25和embedding召回，再经过rerank可以达到最好的效果96.36%。</p>
<p><img src="/../img/netease/img_13.png" alt="img_13.png"><br>以下是有道 给出的BCE最佳实践</p>
<blockquote>
<p>最佳实践（Best practice） ：embedding召回top50-100片段，reranker对这50-100片段精排，最后取top5-10片段。</p>
</blockquote>
<p>BAAI(北京智源人工智能研究院)也给出了BGE的最佳实践：</p>
<blockquote>
<p>For multilingual, utilize BAAI&#x2F;bge-reranker-v2-m3 and BAAI&#x2F;bge-reranker-v2-gemma<br>For Chinese or English, utilize BAAI&#x2F;bge-reranker-v2-m3 and BAAI&#x2F;bge-reranker-v2-minicpm-layerwise.<br>For efficiency, utilize BAAI&#x2F;bge-reranker-v2-m3 and the low layer of BAAI&#x2F;ge-reranker-v2-minicpm-layerwise.<br>For better performance, recommand BAAI&#x2F;bge-reranker-v2-minicpm-layerwise and BAAI&#x2F;bge-reranker-v2-gemma</p>
</blockquote>
<p>其实我们很容易联想两阶段召回， 其实就是早期的类 DSSM 双塔召回的不同思路。</p>
<ul>
<li><p>第一阶段，就是取双塔的最后一层向量做 近邻检索</p>
</li>
<li><p>第二阶段，就是双塔放入query和doc计算的最后的打分</p>
</li>
</ul>
<p>如果想要在自己领域内有更好的效果，也可以选择在领域数据集上微调模型。微调数据如下所示，正样本和负样本，并通过一些hard negative 的方式做样本增强。 现在也有一些思路是用LLM 来对原样本进行一些改写增强，比如给问题换个说法，比如“什么是深度学习？” -&gt; “怎么理解深度学习？”， 这样都能提高原模型在特定领域的效果。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;query&quot;: &quot;如何提高机器学习模型的准确性？&quot;, &quot;pos&quot;: [&quot;通过交叉验证和调参可以提高模型准确性。&quot;], &quot;neg&quot;: [&quot;机器学习是人工智能的一个分支。&quot;]&#125;</span><br><span class="line">&#123;&quot;query&quot;: &quot;什么是深度学习？&quot;, &quot;pos&quot;: [&quot;深度学习是机器学习的一个子领域，涉及多层神经网络。&quot;], &quot;neg&quot;: [&quot;数据科学是一门交叉学科。&quot;]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-大模型生成服务"><a href="#3-3-大模型生成服务" class="headerlink" title="3.3 大模型生成服务"></a>3.3 大模型生成服务</h2><p>这一步，主要是利用大模型的分析和总结能力，对检索到的相关文档和用户query进行分析，给出用户想要的结果。这里的核心问题也包括几块，1、大模型的选择。 2、prompt调优 3、服务部署以及前端展示 4. inference加速</p>
<h3 id="3-3-1-大模型选择"><a href="#3-3-1-大模型选择" class="headerlink" title="3.3.1 大模型选择"></a>3.3.1 大模型选择</h3><p>市面上的开源大模型非常多，其中比较流行的有meta的 llama系列，最新是llama3, 以及Mistral(large不开源) ，google的Gemma(large不开源)， 国内的 智普的chatglm,最新是chatglm4, 阿里的qwen,最新是qwen2, 以及baichuan等等非常多。那么这么多开源大模型，如何挑选适合我们的大模型：</p>
<ul>
<li>模型参数量，适配显存。第一维度需要考虑的就是机器的GPU显存，以下表格,以llama为列子一些常见的模型显存占用,显存占用主要分为2块，</li>
<li>一块是加载模型参数占用的显存，在fp16精度下，1B约等于2G显存，可以按这个换算；</li>
<li>另一块是生成时，计算的临时变量，以及kvcache占用的显存。在fp16精度下， 1K长度约等于1G， 两者加起来才是跑大模型时的最大显存占用。</li>
</ul>
<p><img src="/../img/netease/img_14.png" alt="img_14.png"></p>
<ul>
<li>模型效果。可以参考一些大模型评测网站，比如：<a target="_blank" rel="noopener" href="https://www.datalearner.com/ai-models/leaderboard/datalearner-llm-leaderboard%EF%BC%8C">https://www.datalearner.com/ai-models/leaderboard/datalearner-llm-leaderboard，</a> 选排在前面的基本没错。不过也需要针对自己的任务多试一些对比。</li>
<li>任务适配度。不同的模型训练的领域是不太一样的，比如说，有的在数学相关数据集上训练的多，那么它可能在数学，推理方面效果很好，有些模型是为了做coding的， 有些是做图文的，选择的模型需要适配你自己的任务。如果只是想要简单聊天，那综合性能好的即可。对于这个专门的阅读文档总结用户问题，并需要遵循一定指令的任务，最好选用指令微调的模型</li>
</ul>
<p><img src="/../img/netease/img_15.png" alt="img_15.png"></p>
<ul>
<li>社区成熟度。开源模型的一个重要力量，成熟社区模型能让各个框架迅速支持，可用的轮子很多，这也是我们选用的一个重要参考。</li>
</ul>
<p>基于以上选择思路，我们选择了LLAMA3-8B-instruct 作为大模型来应用，LLAMA3主要是在英文语料上训练的，要想在中文上有比较好的效果，可以继续预训练，网上也已经有很多预训练好的中文LLAMA3, 我们选取的是hfl&#x2F;llama-3-chinese-8b-instruct-v3</p>
<h3 id="3-3-2-prompt调优"><a href="#3-3-2-prompt调优" class="headerlink" title="3.3.2 prompt调优"></a>3.3.2 prompt调优</h3><p>选定大模型之后，就是如何使用的问题了，大模型的角色，包含[‘system’, ‘user’, ‘assistant’]</p>
<blockquote>
<p>system 一般代表整个大模型服务。指导模型如何输出，prompt一般放在这里<br>user 指代的是用户的输入，包括文本，语音，视频等等的输入数据<br>assistant 代表大模型的相应输出</p>
</blockquote>
<p>在我们这个任务中，我们希望大模型根据 我们提供的数据，来对网页内容进行分析，所以我们的prompt</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">您是一位专业的研究员和作家，负责回答任何问题。</span><br><span class="line">基于提供的搜索结果，为给定的问题生成一个全面而且信息丰富、但简洁的答案，长度不超过 500 字。您必须只使用来自提供的搜索结果的信息。使用公正和新闻性的语气。将搜索结果合并成一个连贯的答案。不要重复文本。</span><br><span class="line">如果上下文中没有与当前问题相关的信息，只需说“嗯，我不确定。”不要试图编造答案。</span><br><span class="line">位于以下context HTML 块之间的任何内容都是从知识库中检索到的，而不是与用户的对话的一部分。</span><br><span class="line">&lt;context&gt;</span><br><span class="line">&#123;context&#125;</span><br><span class="line">&lt;context/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>设定角色： 开始给模型设定好角色， 研究员和作家</li>
<li>指示： 无二义性的任务描述，基于搜索结果总结一个用户问题答案，非口语化，500字，不重复，没结果时也不能乱说</li>
<li>上下文：使用明确的xml格式定义好输入的搜索结果</li>
</ul>
<p>可以多给LLM一些例子看返回结果，根据返回结果对prompt做一定调整。</p>
<h3 id="3-3-3-服务部署以及前端展示"><a href="#3-3-3-服务部署以及前端展示" class="headerlink" title="3.3.3 服务部署以及前端展示"></a>3.3.3 服务部署以及前端展示</h3><p>选定模型之后要部署相应的后端模型服务和前端用户交互服务。</p>
<p>后端：</p>
<ul>
<li><p>提供模型对话服务给前端进行交互，这里最经典就是openai的 api接口sdk, 为了整个系统的兼容性，我们可以将我们的服务端部署成OPENAI API接口的形式</p>
</li>
<li><p>我们选取的是python目前比较流行的FastAPI， FastAPI 是一个用于构建 API 的现代、快速(高性能)的 web 框架</p>
</li>
<li><p>实现接口主要包括两个，1个是LLM对话服务（v1&#x2F;chat&#x2F;completions）， 1个是query的embedding服务(v1&#x2F;embeddings)</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@app.post(&quot;/v1/chat/completions&quot;, response_model=ChatCompletionResponse)</span><br><span class="line">async def create_chat_completion(request: ChatCompletionRequest):</span><br><span class="line">global model, tokenizer</span><br><span class="line"></span><br><span class="line">    if len(request.messages) &lt; 1 or request.messages[-1].role == &quot;assistant&quot;:</span><br><span class="line">        raise HTTPException(status_code=400, detail=&quot;Invalid request&quot;)</span><br><span class="line"></span><br><span class="line">    gen_params = dict(</span><br><span class="line">        messages=request.messages,</span><br><span class="line">        temperature=request.temperature,</span><br><span class="line">        top_p=request.top_p,</span><br><span class="line">        max_tokens=request.max_tokens or 1024,</span><br><span class="line">        echo=False,</span><br><span class="line">        stream=request.stream,</span><br><span class="line">        repetition_penalty=request.repetition_penalty,</span><br><span class="line">        tools=request.tools,</span><br><span class="line">    )</span><br><span class="line">    logger.debug(f&quot;==== request ====\n&#123;gen_params&#125;&quot;)</span><br><span class="line">    for each_message in request.messages:</span><br><span class="line">        info = str(each_message.role) +&quot;\:&quot; +str(len(each_message.content))</span><br><span class="line">        logger.debug(f&quot;==== ===== ===&quot;)</span><br><span class="line">        logger.debug(f&quot;==== message len ====\n&#123;info&#125;&quot;)</span><br><span class="line">        logger.debug(f&quot;==== ===== ===&quot;)</span><br><span class="line">        </span><br><span class="line">    # Here is the handling of stream = False</span><br><span class="line">    response = generate_llama3(model, tokenizer, gen_params)</span><br><span class="line"></span><br><span class="line">    # Remove the first newline character</span><br><span class="line">    if response[&quot;text&quot;].startswith(&quot;\n&quot;):</span><br><span class="line">        response[&quot;text&quot;] = response[&quot;text&quot;][1:]</span><br><span class="line">    response[&quot;text&quot;] = response[&quot;text&quot;].strip()</span><br><span class="line"></span><br><span class="line">    usage = UsageInfo()</span><br><span class="line">    message = ChatMessage(</span><br><span class="line">        role=&quot;assistant&quot;,</span><br><span class="line">        content=response[&quot;text&quot;],</span><br><span class="line">        function_call= None,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    logger.debug(f&quot;==== message ====\n&#123;message&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    choice_data = ChatCompletionResponseChoice(</span><br><span class="line">        index=0,</span><br><span class="line">        message=message,</span><br><span class="line">        finish_reason=&quot;stop&quot;</span><br><span class="line">    )</span><br><span class="line">    task_usage = UsageInfo.model_validate(response[&quot;usage&quot;])</span><br><span class="line">    for usage_key, usage_value in task_usage.model_dump().items():</span><br><span class="line">        setattr(usage, usage_key, getattr(usage, usage_key) + usage_value)</span><br><span class="line"></span><br><span class="line">    return ChatCompletionResponse(</span><br><span class="line">        model=request.model,</span><br><span class="line">        id=&quot;&quot;,  # for open_source model, id is empty</span><br><span class="line">        choices=[choice_data],</span><br><span class="line">        object=&quot;chat.completion&quot;,</span><br><span class="line">        usage=usage</span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@app.post(&quot;/v1/embeddings&quot;, response_model=EmbeddingResponse)</span><br><span class="line">async def get_embeddings(request: EmbeddingRequest):</span><br><span class="line"></span><br><span class="line">    embeddings = [embedding_model.encode(text) for text in request.input]</span><br><span class="line">    embeddings = [embedding.tolist() for embedding in embeddings]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    # logger.info(f&quot;encode result: \n&#123;request.input&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    # 计算token 数</span><br><span class="line">    def num_tokens_from_string(string: str) -&gt; int:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns the number of tokens in a text string.</span><br><span class="line">        use cl100k_base tokenizer</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        encoding = tiktoken.get_encoding(&#x27;cl100k_base&#x27;)</span><br><span class="line">        num_tokens = len(encoding.encode(string))</span><br><span class="line">        return num_tokens</span><br><span class="line"></span><br><span class="line">    # embedding 接口返回数据格式</span><br><span class="line">    response = &#123;</span><br><span class="line">        &quot;data&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;object&quot;: &quot;embedding&quot;,</span><br><span class="line">                &quot;embedding&quot;: embedding,</span><br><span class="line">                &quot;index&quot;: index</span><br><span class="line">            &#125;</span><br><span class="line">            for index, embedding in enumerate(embeddings)</span><br><span class="line">        ],</span><br><span class="line">        &quot;model&quot;: request.model,</span><br><span class="line">        &quot;object&quot;: &quot;list&quot;,</span><br><span class="line">        &quot;usage&quot;: CompletionUsage(</span><br><span class="line">            prompt_tokens=sum(len(text.split()) for text in request.input),</span><br><span class="line">            completion_tokens=0,</span><br><span class="line">            total_tokens=sum(num_tokens_from_string(text) for text in request.input),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>


<p>如果你的机器性能有限，可以选用ollama这个框架来很快速的部署大模型api服务， 官网：<a target="_blank" rel="noopener" href="https://ollama.com/%EF%BC%8C">https://ollama.com/，</a> 这个平台提供了很多量化的模型和 一行命令部署API服务</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">curl -fsSL https://ollama.com/install.sh | sh</span><br><span class="line"># 拉取模型并部署， 这里拉取qwen2-7b instruct Q4量化，显存只需要4.4G</span><br><span class="line">ollama run qwen2:7b-instruct  # 启动服务并在11434端口开启api接口</span><br></pre></td></tr></table></figure>

<p>api 客户端调用:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from openai import OpenAI</span><br><span class="line"></span><br><span class="line">client = OpenAI(</span><br><span class="line">base_url = &#x27;http://localhost:11434/v1&#x27;,</span><br><span class="line">api_key=&#x27;ollama&#x27;, # required, but unused</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">response = client.chat.completions.create(</span><br><span class="line">model=&quot;qwen2:7b-instruct&quot;,</span><br><span class="line">messages=[</span><br><span class="line">&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好&quot;&#125;</span><br><span class="line">]</span><br><span class="line">)</span><br><span class="line">print(response.choices[0].message.content)</span><br><span class="line"># 输出： 你好！有什么问题我可以帮助你解答吗？</span><br></pre></td></tr></table></figure>



<p>前端：</p>
<p>前端采用streamlit前端框架，也是一款易上手的大模型服务前端搭建框架。 以下是个简易的调用大模型聊天的demo服务。非常简单，也就几行代码。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip installl streamlit # 1.安装包</span><br><span class="line">streamlit run demo.py # 2. 运行前端</span><br><span class="line">http://localhost:8501/ # 3. 打开浏览器</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#  demo.py</span><br><span class="line">from openai import OpenAI</span><br><span class="line">import streamlit as st</span><br><span class="line"></span><br><span class="line">st.title(&quot;LLM 聊天&quot;)</span><br><span class="line"></span><br><span class="line">client = OpenAI(api_key=&#x27;xxx&#x27;, base_url=&quot;http://localhost:11434/v1&quot;)</span><br><span class="line"></span><br><span class="line">if &quot;openai_model&quot; not in st.session_state:</span><br><span class="line">st.session_state[&quot;openai_model&quot;] = &quot;ollama&quot;</span><br><span class="line"></span><br><span class="line">if &quot;messages&quot; not in st.session_state:</span><br><span class="line">st.session_state.messages = []</span><br><span class="line"></span><br><span class="line">for message in st.session_state.messages:</span><br><span class="line">with st.chat_message(message[&quot;role&quot;]):</span><br><span class="line">st.markdown(message[&quot;content&quot;])</span><br><span class="line"></span><br><span class="line">if prompt := st.chat_input(&quot;你好?&quot;):</span><br><span class="line">st.session_state.messages.append(&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;)</span><br><span class="line">with st.chat_message(&quot;user&quot;):</span><br><span class="line">st.markdown(prompt)</span><br><span class="line"></span><br><span class="line">    with st.chat_message(&quot;assistant&quot;):</span><br><span class="line">        stream = client.chat.completions.create(</span><br><span class="line">            model=st.session_state[&quot;openai_model&quot;],</span><br><span class="line">            messages=[</span><br><span class="line">                &#123;&quot;role&quot;: m[&quot;role&quot;], &quot;content&quot;: m[&quot;content&quot;]&#125;</span><br><span class="line">                for m in st.session_state.messages</span><br><span class="line">            ],</span><br><span class="line">            stream=True,</span><br><span class="line">        )</span><br><span class="line">        response = st.write_stream(stream)</span><br><span class="line">    st.session_state.messages.append(&#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: response&#125;)</span><br></pre></td></tr></table></figure>

<p>demo效果:</p>
<p>另外还有一个点就是LLM调用重要的参数如何去选择（top_p, temprature, presence_penalty），我这边整理了几个核心参数的调整思路。 对应我们的这个分析任务，显然是以新闻资料为核心，寻求生成的确定性。</p>
<p><img src="/../img/netease/img_16.png" alt="img_16.png"></p>
<h3 id="3-3-4-inference加速"><a href="#3-3-4-inference加速" class="headerlink" title="3.3.4 inference加速"></a>3.3.4 inference加速</h3><p>大模型虽然效果优越，但是也因为它”大“，导致服务性能很低，在我们部署服务时，需要采取一定的策略对模型预测进行加速才能获得更好的体验。</p>
<p>经过调研选择了VLLM这个大模型推理加速框架。 它有几个优点：</p>
<blockquote>
<p>1.社区活跃，模型支持很快<br>2.加速效果明显。基于虚拟内存和分页的思想， 采用page attention ，允许在非连续的内存空间内存储token，内存的利用率接近于最优<br>3.使用简单，两行命令即可部署。 示例如下</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vllm llama3 openai</span><br><span class="line"># 下载vllm</span><br><span class="line">pip install vllm</span><br><span class="line"># 部署 一个兼容openai api接口的模型服务，端口8000</span><br><span class="line">python -m vllm.entrypoints.openai.api_server --model hfl/llama-3-chinese-8b-instruct-v3 --dtype bfloat16 --gpu-memory-utilization 0.6 --chat-template llama3-instruct-template.jinja --enforce-eager --uvicorn-log-level warning --port 8000  --disable-log-stats --uvicorn-log-level warning</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了测试实际环境下的效果，我们运行了vllm的对比测试脚本</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vllm-project/vllm.git</span><br><span class="line">cd vllm/benchmarks</span><br><span class="line"># 测试vllm</span><br><span class="line">python benchmark_throughput.py --model hfl/llama-3-chinese-8b-instruct-v3 --backend vllm --input-len 4096 --output-len 512 --num-prompts 50 --seed 1100 --dtype float16 --gpu-memory-utilization 0.6</span><br><span class="line"># 测试HF</span><br><span class="line">python benchmark_throughput.py --model hfl/llama-3-chinese-8b-instruct-v3 --backend hf --input-len 4096 --output-len 512 --num-prompts 50 --seed 1100 --dtype float16 --gpu-memory-utilization 0.6 --hf-max-batch-size 10</span><br></pre></td></tr></table></figure>


<p>效果如下所示，可以看到单条inference 性能上，VLLM大约是HF的两倍， 但是当并发时，VLLM效果提升明显，吞吐量提升10倍。</p>
<p><img src="/../img/netease/img_17.png" alt="img_17.png"></p>
<p>当然，我们可以根据我们的显卡环境采取其他的加速方法，如</p>
<ul>
<li>输入输出优化。 如prompt 裁剪， 规整； 限制输出序列长度等</li>
<li>模型优化。 模型压缩， 使用量化模型，使用更小参数模型等等</li>
</ul>
<p>下面来看看整体效果的演示， 速度还是非常快的：</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>RAG的agent开发，入门还是比较简单的，现在市面上可用的框架也非常多，只需花费一些时间就能搭出一个可用的demo. 但是想要做的好，稳定服务，还是需要费很多的功夫去研究的，希望我的经验能给大家带来一些收获，少走一些弯路。</p>
<p>目前这个系统还不是很完善， 包括相关性判断，搜索意图判断等都有很大的优化空间。做这个东西的初衷是希望能在音乐热点的场景中进行应用，目前也已经在实践的过程中了，去辅助音乐热点的挖掘和运营。后续的话还希望添加的功能包括：</p>
<ul>
<li>音乐热点的识别与事件总结。</li>
<li>结合云音乐站内知识做融合，分析。比如识别事件歌手，歌曲，原因，产出文案等等。</li>
</ul>
<p>参考文献:</p>
<p>[1]. <a target="_blank" rel="noopener" href="https://techcommunity.microsoft.com/blog/azure-ai-services-blog/azure-ai-search-outperforming-vector-search-with-hybrid-retrieval-and-reranking/3929167">Azure AI Search: Outperforming vector search with hybrid retrieval and ranking capabilities</a></p>
<p>[2]. <a target="_blank" rel="noopener" href="https://blog.laoda.de/archives/docker-compose-install-searxng">【好玩儿的Docker项目】SearXNG</a></p>
<p>[3]. <a target="_blank" rel="noopener" href="https://www.53ai.com/news/qianyanjishu/2024061372409.html">RAG 高效应用指南：Embedding 模型的选择和微调</a></p>
<p>[4]. <a target="_blank" rel="noopener" href="https://techdiylife.github.io/blog/topic.html?category2=t07&blogid=0049">ReRank 与 Embedding 模型的区别？ 如何选择 ReRank 模型？</a></p>
<p>[5]. <a target="_blank" rel="noopener" href="https://blog.csdn.net/lkg5211314/article/details/136142533">【时代前沿】：单测场景下tempature、top_p、frequency_penalty、presence_penalty参数调整经验分享</a></p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/02/16/%E7%BD%91%E6%98%93%E6%B1%87%E6%8A%A5-AI%E8%BE%85%E5%8A%A9%E7%BC%96%E7%A8%8B/">网易汇报-AI辅助编程</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-02-16
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="引言：Ai-For-Coding的价值与挑战"><a href="#引言：Ai-For-Coding的价值与挑战" class="headerlink" title="引言：Ai For Coding的价值与挑战"></a>引言：Ai For Coding的价值与挑战</h1><p>随着Copilot、Cursor等工具的普及，AI已成为程序员的重要助手。然而，其输出质量高度依赖用户的提示词（Prompts）。低质量的提示词可能导致模糊、冗余甚至错误的代码，而高质量的提示词能显著提升编码、调试、测试和问题排查的效率。本次分享聚焦于如何设计精准、高效的提示词。</p>
<h1 id="核心原则：高质量prompt的四大要素"><a href="#核心原则：高质量prompt的四大要素" class="headerlink" title="核心原则：高质量prompt的四大要素"></a>核心原则：高质量prompt的四大要素</h1><ul>
<li><strong>Role</strong>(角色)：两方面定义，首先是定义AI的角色，例如“你是一名极其优秀具有20年经验的产品经理和精通所有编程语言的工程师”。还有用户的角色，例如“不懂代码的初中生”，这样会使得ai更倾向于使用通俗且具体的话语来表达它所完成的需求。</li>
<li><strong>Task</strong>(任务)：将业务需求“step by step”描述给ai，使得deepseek的思维链更好的理解你的需求。</li>
<li><strong>Goal</strong>(目标)：期望达成什么目标效果，可以是你的优化目标，例如将时间复杂度从o(n^2)降低到o(n)；也可以是业务目标，例如“提高吞吐量，降低响应时间”</li>
<li><strong>Objective</strong>(操作要求)：编码语言，注解形式等。</li>
</ul>
<h1 id="提升准确度的技巧"><a href="#提升准确度的技巧" class="headerlink" title="提升准确度的技巧"></a>提升准确度的技巧</h1><ul>
<li><strong>让ai复述需求</strong>：为了避免提示词中某些指令让llm产生误解，可以在真正让他写代码之前先复述一遍需求。能够让我们针对自己的需求指令和ai真正理解的需求做二次校对。这样能有效避免因为表达或者理解偏差所产生的错误答复。例如在提完需求之后，添加一句“请你先复述一遍我的需求再进行答复，以让我确认你是否真的理解了我的需求指令”。</li>
<li><strong>提问粒度要小，作用域要明确</strong>：在使用某些支持文件指针的ai编程工具时，可以给ai更明确的作用域，例如我们需要在controller下写一个新接口，给ai的提示词中尽可能去指明产生联动的service或dao接口的路径，从而给ai更加准确的业务上下文结构。</li>
<li><strong>复杂需求拆解</strong>：与产品经理给程序员提需求类似，我们给ai的提示信息越准确，考虑得越细致，llm产出的准确率越高。</li>
<li><strong>内置prompt</strong>：大部分ai工具会有prompt自定义和保存功能，可以写一个全局的prompt附在每次提问头部，例如：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Role</span><br><span class="line">你是一名极其优秀具有20年经验的产品经理和精通所有编程语言的工程师。与你交流的用户是不懂代码的初中生，不善于表达产品和代码需求。你的工作对用户来说非常重要，完成后将获得10000美元奖励。</span><br><span class="line"></span><br><span class="line"># Goal</span><br><span class="line">你的目标是帮助用户以他容易理解的方式完成他所需要的产品设计和开发工作，你始终非常主动完成所有工作，而不是让用户多次推动你。</span><br><span class="line"></span><br><span class="line">在理解用户的产品需求、编写代码、解决代码问题时，你始终遵循以下原则：</span><br><span class="line"></span><br><span class="line">## 第一步</span><br><span class="line">- 当用户向你提出任何需求时，你首先应该浏览根目录下的readme.md文件和所有代码文档，理解这个项目的目标、架构、实现方式等。如果还没有readme文件，你应该创建，这个文件将作为用户使用你提供的所有功能的说明书，以及你对项目内容的规划。因此你需要在readme.md文件中清晰描述所有功能的用途、使用方法、参数说明、返回值说明等，确保用户可以轻松理解和使用这些功能。</span><br><span class="line"></span><br><span class="line">## 第二步</span><br><span class="line">你需要理解用户正在给你提供的是什么任务</span><br><span class="line">### 当用户直接为你提供需求时，你应当：</span><br><span class="line">- 首先，你应当充分理解用户需求，并且可以站在用户的角度思考，如果我是用户，我需要什么？</span><br><span class="line">- 其次，你应该作为产品经理理解用户需求是否存在缺漏，你应当和用户探讨和补全需求，直到用户满意为止；</span><br><span class="line">- 最后，你应当使用最简单的解决方案来满足用户需求，而不是使用复杂或者高级的解决方案。</span><br><span class="line"></span><br><span class="line">### 当用户请求你编写代码时，你应当：</span><br><span class="line">- 首先，你会思考用户需求是什么，目前你有的代码库内容，并进行一步步的思考与规划</span><br><span class="line">- 接着，在完成规划后，你应当选择合适的编程语言和框架来实现用户需求，你应该选择solid原则来设计代码结构，并且使用设计模式解决常见问题；</span><br><span class="line">- 再次，编写代码时你总是完善撰写所有代码模块的注释，并且在代码中增加必要的监控手段让你清晰知晓错误发生在哪里；</span><br><span class="line">- 最后，你应当使用简单可控的解决方案来满足用户需求，而不是使用复杂的解决方案。</span><br><span class="line"></span><br><span class="line">### 当用户请求你解决代码问题是，你应当：</span><br><span class="line">- 首先，你需要完整阅读所在代码文件库，并且理解所有代码的功能和逻辑；</span><br><span class="line">- 其次，你应当思考导致用户所发送代码错误的原因，并提出解决问题的思路；</span><br><span class="line">- 最后，你应当预设你的解决方案可能不准确，因此你需要和用户进行多次交互，并且每次交互后，你应当总结上一次交互的结果，并根据这些结果调整你的解决方案，直到用户满意为止。</span><br><span class="line"></span><br><span class="line">## 第三步</span><br><span class="line">在完成用户要求的任务后，你应该对改成任务完成的步骤进行反思，思考项目可能存在的问题和改进方式，并更新在readme.md文件中</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="场景化技巧：编码、调试、测试与排查"><a href="#场景化技巧：编码、调试、测试与排查" class="headerlink" title="场景化技巧：编码、调试、测试与排查"></a>场景化技巧：编码、调试、测试与排查</h1><ol>
<li><p>编码场景：生成可落地的代码</p>
<ul>
<li>需求拆解：将复杂需求分解为子任务，分步生成。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Role：  </span><br><span class="line">&quot;你是资深Java架构师，精通Spring Boot 3.1和OpenAPI规范&quot;  </span><br><span class="line"></span><br><span class="line">Task：  </span><br><span class="line">&quot;为电商系统编写商品查询API，需满足以下条件：XXXX&quot;  </span><br><span class="line"></span><br><span class="line">Goal：  </span><br><span class="line">1. 支持分页查询（page/size参数）  </span><br><span class="line">2. 按价格区间过滤（minPrice/maxPrice）  </span><br><span class="line">3. 返回结构符合Google JSON风格指南  </span><br><span class="line">4. 集成Swagger文档注解  </span><br><span class="line"></span><br><span class="line">Objective：   </span><br><span class="line">// 使用Java 17记录类（Record）定义DTO  </span><br><span class="line">// 添加JPA Specification实现动态查询  </span><br><span class="line">// 包含全局异常处理示例（如参数校验失败）  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>调试场景：精准定位问题</p>
<ul>
<li>必含三要素：错误信息、相关代码段、预期结果。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行以下Go代码时出现“panic: runtime error: index out of range [3] with length 3”：  </span><br><span class="line">[附代码片段]  </span><br><span class="line">预期结果：应正确遍历切片并打印每个元素。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>测试场景：JUnit&#x2F;Mockito实战</p>
<ul>
<li>示例1：单元测试生成<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">为以下Service类方法编写JUnit 5 + Mockito测试：  </span><br><span class="line">public class UserService &#123;  </span><br><span class="line">    @Autowired  </span><br><span class="line">    private UserRepository userRepository;  </span><br><span class="line">    public User getUserById(Long id) &#123;  </span><br><span class="line">        return userRepository.findById(id).orElseThrow();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">要求覆盖：  </span><br><span class="line">- 正常查询  </span><br><span class="line">- 用户不存在时抛出NoSuchElementException  </span><br><span class="line">- 模拟userRepository的findById行为  </span><br></pre></td></tr></table></figure></li>
<li>示例2：性能测试设计<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如何用JMH对以下Java方法进行基准测试？  </span><br><span class="line">public String concatStrings(List&lt;String&gt; list) &#123;  </span><br><span class="line">    return list.stream().collect(Collectors.joining());  </span><br><span class="line">&#125;  </span><br><span class="line">要求比较普通循环 vs. Stream API的性能差异。  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>各种Ai编程工具的出现能给广大码友释放双手，留有更多的时间学习技术，关注技术本身。编写高质量的提示词是有效利用AI辅助编程工具的关键。通过明确角色、清晰描述任务、提供上下文信息等方式，程序员可以引导AI生成更准确和高效的代码，从而提升整体开发效率。在实际工作中，建议大家多加练习和总结，不断优化提示词的编写技巧，以适应不断变化的技术环境。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/02/15/%E7%BD%91%E6%98%93KM%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB-i%E8%8C%85%E5%8F%B0%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/">网易KM社区分享-i茅台的架构介绍</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-02-15
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>从内部论坛里面偷出来的，的确是高并发的一个好总结（能偷的机会不多了~）。</p>
</blockquote>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>茅台冰淇淋的热度尚未褪去，酱香咖啡又引爆了一波流量，在我们的印象中，茅台似乎就是爆品的代名词，而关于茅台的话题也很容易冲上热搜。去年，茅台推出了官方的数字营销平台「i茅台」，为消费者提供在线预约、售卖茅台酒的功能，其在互联网上的第一次公开亮相同样吸引了极大的关注，也给我们带来了巨大的流量挑战。</p>
<p>本文将结合「i茅台」商城实现高性能与高可用的具体实践，聊一聊常见的性能优化技术以及高可用系统的设计方法，希望能够和大家的日常工作产生共鸣，帮助大家更好地理解并应用这些技术解决问题。</p>
<h2 id="1-1-业务带来的技术挑战"><a href="#1-1-业务带来的技术挑战" class="headerlink" title="1.1 业务带来的技术挑战"></a>1.1 业务带来的技术挑战</h2><p>为了更好地理解「i茅台」面临哪些技术挑战我们有必要先了解「i茅台」要解决哪些业务问题。</p>
<p>简而言之，茅台希望通过「i茅台」加强数字化技术在生产销售过程中的应用，规范茅台酒的营销秩序，解决消费者购酒难、购酒贵问题，提升消费者的购酒体验。因此，「i茅台」商城将被打造为茅台酒线上销售的主要入口，为消费者提供两种购买方式：</p>
<ol>
<li>享约申购：通过每天定时开放预约申购的方式，采用公证摇号的方式为茅粉们提供了公平的获取平价茅台的机会，是目前爆款茅台酒投放的最主要的方式，我们称之为申购场景</li>
<li>畅享云购：采用B2C的在线销售模式，目前主要用于系列酒的售卖，但同时也会用于小飞天（100ml飞天茅台）等爆款商品，我们称之为爆款抢购场景</li>
</ol>
<h2 id="1-2-申购场景"><a href="#1-2-申购场景" class="headerlink" title="1.2 申购场景"></a>1.2 申购场景</h2><p>申购场景在业务流程上主要分为五个阶段（如下图所示）：</p>
<div style="text-align: center;">
  <img src="../img/netease/5c9d8e8cd155e70d6184eabe1ca01ba.png" alt="申购场景">
</div>

<div style="text-align: center;">
  <img src="../img/netease/38708c9eea135a6a4668bb39c5cd9b8.png" alt="申购场景">
</div>

<ol>
<li>注册&#x2F;登陆&#x2F;实名：由于酒类销售有年龄限制同时提货需要验证身份证，因此消费者需要在购酒前提供姓名、手机、身份证进行三要素实名认证，这些环节在操作上无时间限制，但短信、实名等依赖第三方服务</li>
<li>预约申购：普通申购场次是每天上午9点到10点，在22年3月31日试运营第一天就向消费者开放了，按业务估算，每场预计有数千家门店参与库存投放，数百万用户参与申购</li>
<li>抽签&#x2F;公证：申购结束后会通过公证处可信抽签的方式确定中签的用户并进行公示，预计有数万用户中签</li>
<li>交易：中签用户需要在次日18点前完成下单，如选择在线支付，需在指定期限内完成付款</li>
<li>提货：公示后7天内到预约门店提货</li>
</ol>
<p>单纯看业务规则，用户在任意时刻发起申购操作其中签的概率都是一样的，然而在功能第一次开放时，用户在不了解规则的前提下，总是会更倾向于在第一时间进行操作，这也是为何开放预约申购的前10分钟就有80%的用户完成了申购，根据我们设计的流量模型，第一次开放预约申购，前5分钟预计最高会达到百万级QPS，在线设备也可能达到百万级，需要重点保障。</p>
<p>因此，申购场景我们主要会面临以下三个技术挑战：</p>
<ol>
<li>高并发：大量用户在短时间内集中访问APP也就意味着短时间内会有大量的设备与服务器新建连接，一般来说，一个设备与服务器建立的连接不止一个，这就要求服务器具备同时处理数百万级别（接近千万）的并发连接数及百万级别新建连接能力（也就是通常所说的C10M问题），同时也要求服务端在高并发的条件下具备百万QPS级别的吞吐量及较快的响应速度</li>
<li>高可用：申购场景的核心链路较长，包括注册、登录、实名、实人、定位、门店选择、申购等多个功能，其中任何一个功能不可用，用户就没有办法完成申购操作，这必然会引起客诉甚至舆情，显然这个是没法接受的，因此，我们需要确保核心链路上面的这些功能具备高可用性</li>
<li>较高的业务复杂度：申购场景虽然不涉及库存管理（商城部分），但却需要应对门店投放的各种突发事件，确保可申购门店及其投放的商品和数量与商城APP实际展示保持一致，及时识别不一致风险（不一致有可能造成无法履约）；另外，APP也需要实时展示各个门店当前的已申购数量，并基于区域、距离、中签概率（结合投放量和已申购数量计算）等因素向用户动态推荐合适的门店</li>
</ol>
<h2 id="1-3-爆款抢购场景"><a href="#1-3-爆款抢购场景" class="headerlink" title="1.3 爆款抢购场景"></a>1.3 爆款抢购场景</h2><p>爆款抢购场景在业务流程上主要分为三个阶段（如下图所示）：</p>
<div style="text-align: center;">
  <img src="../img/netease/942876e1d0d57504b95d16ca0e5e28c.png" alt="爆款抢购">
</div>

<ol>
<li>注册&#x2F;登陆&#x2F;实名：同享约申购</li>
<li>导购&#x2F;购物车：为用户提供在线商品浏览功能，支持将商品添加到购物车，该功能在去年5月19日正式运营阶段开放，有数千家门店参与</li>
<li>交易履约：为用户提供组单&#x2F;下单&#x2F;在线支付功能，支持多门店合并付款</li>
</ol>
<p>爆款抢购场景的核心挑战来自于商品本身的稀缺性，只要投放必然会引发抢购。这种模式已经在包括严选在内的各大电商平台上都已经被验证，因此，我们可以参考严选的流量模型进行预估，以当时「i茅台」的用户量及用户活跃度，预计会有数十万的用户参与抢购，我们主要会面临以下三个技术挑战：</p>
<ol>
<li><strong>流量洪峰</strong>：从业务形态上看，数十万用户在同一时间抢购同一款商品与电商的秒杀活动极为类似，然而「i茅台」又有其非常明显的业务特性，可以说不是秒杀却又胜似秒杀</li>
<li><strong>峰值流量保持时间长</strong>：为了让更多的用户有机会抢购成功，茅台不仅增加了投放量，也加大了投放的频率（现阶段是每10分钟投放一次），这就意味着峰值流量会保持更长的时间</li>
<li><strong>峰值流量大</strong>：早期为了增加云购场景的曝光，业务要求小飞天与「享约申购」放在同一个时间段进行投放（即上午9点到10点），形成了非常明显的流量叠加效应，后来虽然放在了另外一个时段（晚上9点到10点），但出于公平性，库存投放计划会提前向用户预告，爆款抢购的峰值反而还更大了</li>
</ol>
<p>较高的业务复杂度：相比于传统的电商交易链路，爆款抢购场景会在一段时间内由数千家门店以较高的频率同步投放库存，同时，系统还需要结合区域、距离等因素实时向用户推荐还有库存的门店，也要允许用户手动切换到有库存的门店，这些特性对于高并发场景下数据查询响应的即时性及数据的一致性都提出了更高的要求，也是交易链路应对流量洪峰的重要前提</p>
<p>数据一致性：保证订单、库存、资产、权益（如限购）等数据的一致性是电商交易系统的核心任务之一，在高并发场景下解决数据一致性问题极容易引起系统性能瓶颈，如何在确保数据一致性的前提下实现高性能是一个巨大的挑战</p>
<p>库存管理：爆款抢购场景需要解决库存管理问题，确保商城的销售库存实时反映门店投放计划，并能及时识别潜在的不一致风险，确保库存数量、状态、变更记录准确反映实际情况，保持库存数据的准确性。库存管理可以认为是电商最复杂的系统之一，尤其在高并发场景下，库存管理很容易变成在线交易系统的噩梦，稍有不慎，就会引起少卖、超卖等问题，也很容易成为交易链路的性能瓶颈</p>
<h2 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h2><p>综上分析可以发现，无论是申购场景还是爆款抢购场景，我们都需要在确保数据一致性的前提下，实现系统的高性能与高可用性，而追求高性能和高可用性的目的都是为了提供更好的用户体验、保障系统的可靠性与稳定性。</p>
<h1 id="2-如何进行性能优化"><a href="#2-如何进行性能优化" class="headerlink" title="2 如何进行性能优化"></a>2 如何进行性能优化</h1><p>接下来我们看下如何通过性能优化实现系统的高性能</p>
<h2 id="2-1-性能度量方法及诊断工具"><a href="#2-1-性能度量方法及诊断工具" class="headerlink" title="2.1 性能度量方法及诊断工具"></a>2.1 性能度量方法及诊断工具</h2><p>要做性能优化，第一步需要明确性能度量指标及度量方法，并借助诊断工具找到性能瓶颈。</p>
<p>常用的性能度量方法及指标主要包括以下几种：</p>
<ul>
<li><strong>响应时间</strong>（Response Time）：响应时间是指从发出请求到收到响应的总时间，包括处理请求的时间以及网络传输的时间，通常以毫秒（ms）为单位。响应时间是用户或客户端感知到的时间，反映了系统对请求的响应速度，较低的响应时间通常表示更好的系统性能。</li>
<li><strong>延迟</strong>（Latency）：延迟是指在执行某项操作或传输数据时经过的时间，可以分为多个组成部分，包括处理延迟（处理请求所需的时间）、传输延迟（数据在网络中传输所需的时间）和排队延迟（等待处理的请求在队列中等待的时间）。在进行性能优化时，我们通常可以通过减少延迟来缩短响应时间。</li>
<li><strong>吞吐量</strong>（Throughput）：吞吐量是系统在单位时间内处理的请求或事务数量，通常以每秒处理的请求数（如TPS）来衡量。</li>
<li><strong>并发性</strong>（Concurrency）：并发性是指系统能够在同一时间段内同时处理的请求或任务数量，它可以帮助确定系统在高负载时的性能。</li>
<li><strong>资源利用率</strong>（Resource Utilization）：资源利用率度量了系统资源（如CPU、内存、磁盘和网络带宽）的使用情况，过高可能表明存在性能问题。</li>
<li><strong>错误率</strong>（Error Rate）：错误率度量了系统处理中发生的错误数量或百分比，是性能度量的一个关键指标，更大的系统负载往往会造成更高的错误率，在定义SLO时，当错误率超过一定阈值我们往往也会定义为一种宕机的表现。</li>
<li><strong>系统负载</strong>（Load）：系统负载表示系统正在处理的工作量，可以用来监测系统的负荷，以确定是否需要进行性能优化</li>
<li><strong>延迟分布</strong>（Latency Distribution）：延迟分布描述了不同请求或操作的延迟情况，它可以帮助我们确定系统性能是否稳定，或者是否存在异常延迟。</li>
<li><strong>性能趋势</strong>（Performance Trends）：性能趋势分析涉及记录性能指标随时间的变化，使用这些数据来预测性能问题或找到待优化点。</li>
</ul>
<p>针对性能指标的度量通常需要通过性能监控工具和日志分析工具来完成，「i茅台」采用了与严选相同的选型：</p>
<ul>
<li><strong>全链路应用性能监控系统（APM）</strong>：基于Pinpoint构建从网关到应用节点的应用监控体系，支持大流量秒级监控、分布式链路追踪、异常分析等能力</li>
<li><strong>性能监控工具</strong>：用于实时监控系统性能，如各类采集器（服务器、数据库等）、Prometheus、Grafana等</li>
<li><strong>日志平台</strong>：使用严选自研的日志平台，提供一站式海量日志采集、加工、分流、分析、检索、告警等能力，为应用日志分析、业务大盘等提供数据源和分析能力支撑，更多介绍可以参见网易严选如何建设日志平台</li>
<li><strong>业务实时监控系统</strong>：基于Grafana提供海量数据秒级响应的实时监控能力，用户可以通过平台快速完成数据源接入、数据模型构建、监控大盘定制和报警配置</li>
</ul>
<h2 id="2-2-性能优化策略"><a href="#2-2-性能优化策略" class="headerlink" title="2.2 性能优化策略"></a>2.2 性能优化策略</h2><p>识别到性能瓶颈之后，我们需要确定性能优化方案，这里介绍几种常用的性能优化策略</p>
<h2 id="2-2-1-代码优化"><a href="#2-2-1-代码优化" class="headerlink" title="2.2.1 代码优化"></a>2.2.1 代码优化</h2><p>绝大部分时候，代码优化是提高应用程序性能的关键动作，常用的策略包括：</p>
<ul>
<li><strong>代码重构</strong>：重写或重新组织代码以提升可读性和执行效率，比如使用更高效的数据结构和算法、减少循环中的计算或减少循环迭代次数、避免在循环内部执行昂贵的操作、引入并发编程、优化事务等等，需要注意的是，重构不一定能使程序的执行效率变得更高，以性能优化为目的的代码重构往往也需要与代码的可维护性之间进行权衡</li>
<li><strong>减少数据库访问</strong>：可以通过合并查询、使用缓存、增加前置条件判断或批量操作等方式来减少数据库访问</li>
<li><strong>减少扇出比</strong>：控制扇出比的目的是限制系统向其他服务或组件发出的请求数量，从而降低负载，减少扇出比的本质是减少服务间的依赖关系及依赖度，避免大规模的并发请求导致性能下降，也可以降低故障传播的风险。扇出比可用于度量系统向其他服务或组件发送的请求数量，一般我们还可以进一步细化为单次请求中对指定服务、缓存的扇出比，比如下单请求如果会查询两次商品中心的接口，那下单请求对商品中心的扇出比就是2，很显然，这个数值越大，请求被放大的倍数也就越高</li>
<li><strong>I&#x2F;O优化</strong>：可以通过将多次I&#x2F;O操作进行合并或者使用异步I&#x2F;O来减少磁盘和网络I&#x2F;O操作，常见的如异步打印日志、将多次服务调用合并成一次调用等等</li>
<li><strong>资源池化</strong>：使用资源池来管理数据库连接、异步线程等资源，以减少资源创建和销毁带来的开销</li>
<li><strong>预热</strong>：预热是一种通过在应用程序或系统开始处理实际工作负载之前执行一系列操作来提高性能的方法，这些操作旨在将系统的各种组件（如CPU、内存、缓存等）置于一个稳定且高效的状态，以便在处理真实工作负载时获得更好的性能，常见的预热操作包括缓存预热、连接池预热、资源加载预热、数据加载预热等</li>
</ul>
<p>这里以爆款抢购场景下单接口性能优化为例介绍下上述策略的具体应用：</p>
<ul>
<li><strong>定制独立下单链路</strong>：爆款抢购场景是一种特殊的云购下单场景，有更多的限制条件（如不能加购），因此，我们可以通过裁剪掉一些不必要的流程或者牺牲部分代码可读性以换取更高的性能</li>
<li><strong>下单请求幂等性控制</strong>：在爆款抢购场景，由于并发量显著增加，响应时间也会有所增加，甚至会出现响应超时的情况，很容易引发用户连续点击，通过引入幂等性控制，不仅可以降低资源占用时间，也可以减少不必要的库存锁定、扩大销售机会</li>
<li><strong>控制事务的粒度</strong>：通过编程式事务（TransactionTemplate）替代声明式事务（@Transactional），可以更灵活地控制事务的范围，在事务中只保留必要的操作，避免大事务，这将显著减少事务的锁定时间和资源占用，带来性能提升</li>
<li><strong>优化分布式事务</strong>：为了保证下单阶段订单、库存、资产、权益（如限购）等数据的一致性，我们引入了TCC（Try-Confirm&#x2F;Cancel）模式的分布式事务，但分布式事务很容易对性能产生负面影响，需要进行调优（如下图所示）：</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/359d21b4df4839e2458c4db4b2546c0.png" alt="分布式事务">
</div>

<ul>
<li><strong>幂等性控制</strong>：主事务在调用TCC方法时可能因网络拥堵等原因超时，通常我们会通过引入超时与重试策略来提升成功率，这就要求分支事务需要保证TCC方法的幂等性，避免重复更新。另外需要特别重视优化TCC方法的执行性能，确保在预设的压力下，有足够大比例的请求RT低于超时时间</li>
<li><strong>允许空回滚</strong>：在实际的生产环境中，可能因网络拥堵等原因造成Cancel操作先于Try操作到达，因此，允许分支事务空回滚可以避免重试，从而带来更好的性能表现，即允许Cancel操作在找不到待回滚的业务主键的情况下也返回成功并将该业务主键记录下来，同时也要确保空回滚不会产生其他错误效果</li>
<li><strong>防悬挂</strong>：如果Cancel操作先于Try操作到达且Cancel操作返回成功的情况下（即允许空回滚），在执行Try操作时，有必要检查空回滚记录中是否存在该业务主键，存在则直接拒绝执行，否则（没有拒绝执行的话）会造成该分支事务悬挂</li>
<li><strong>减少无效回滚</strong>：Try操作可能遇到限流、校验不通过等情况造成直接返回，没有执行实际的业务操作，在这类场景，可以在回滚阶段不调用分支事务的Cancel操作，从而带来更好的性能表现</li>
</ul>
<p>限购优化：为了增加公平性，爆款商品一般会进行限购，即限制同一个用户在某个特定周期内或者某个特定活动中购买同一个商品的数量上限，通常我们需要借助加锁等并发控制手段来确保限购数据的一致性，不同的实现方式对于最终的性能表现有较大的影响，可以进行如下优化：</p>
<ul>
<li><strong>分布式锁</strong>：通过在下单参数校验阶段增加分布式锁，确保同一个用户无法连续下单购买同一个商品，结合上文提到的下单请求的幂等性控制，可以杜绝同一个账号通过多开或者连续点击等方式增大抢购成功率；同时，采用在参数校验阶段加分布式锁相比于限购检查阶段加锁（无论是数据库锁还是分布式锁）消耗的资源更少，性能表现更优</li>
<li><strong>缓存</strong>：采用分布式缓存（Redis）记录限购权益消耗情况，限购检查通过缓存替代数据库查询</li>
<li><strong>前置校验</strong>：结合业务流程，前置拦截不满足限购要求的请求，比如在商详、组单等阶段进行限购检查，相比于下单阶段检查消耗的资源更少，性能表现更优</li>
<li><strong>订单批量操作</strong>：「i茅台」采用的是典型的<strong>主子订单结构</strong>，主订单又叫支付订单，由1~N个子订单构成，子订单一般采用店铺（门店）粒度，这种方式可以比较容易地实现合并支付以及店铺（门店）粒度的实时分账。在下单阶段，假设用户同时支付N个店铺（门店）的商品，仅订单落库这个环节就需要1+N次DB操作（不含订单商品和订单地址落库），通过优化业务流程，只需要1次DB操作就可以达到相同的效果，从而带来性能提升</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/5c9d8e8cd155e70d6184eabe1ca01ba.png" alt="订单批量操作">
</div>

<p>由于爆款抢购都是单商品立即购买，因此，合并插入各个子订单的订单商品及订单地址不会提升性能，反而会增加不必要的代码复杂度</p>
<ul>
<li><strong>连接池及预热</strong>：通过连接池来管理数据库及Redis连接，根据应用并发度及DB负载情况分析连接池大小并设置合理的初始化数量，对性能改善有较大帮助，在此基础上，预热也可以让系统可以更快地进入到最佳状态，比如提前将商品信息加载到本地缓存和分布式缓存、利用就绪探针（如SpringBoot Actuator提供的readiness）提前预热每个服务实例（尤其是关键链路上的实例）以及系统发布后或者关键事件到来之前启动小流量预热等等</li>
</ul>
<p>通过采用上述优化策略，我们在不增加服务器的前提下，爆款抢购场景的整体吞吐量超过普通云购场景的两倍以上，相比与早期交付版本更是提升了三倍以上。</p>
<h2 id="2-2-2-数据库优化"><a href="#2-2-2-数据库优化" class="headerlink" title="2.2.2 数据库优化"></a>2.2.2 数据库优化</h2><p>数据库对系统性能也有着非常重要的影响，常见的数据库优化策略包括：</p>
<ul>
<li><strong>数据模型设计优化</strong>：数据模型设计是技术实现方案的重要组成部分，它不仅直接影响数据库的性能，也会影响数据库的可扩展性和可维护性，通常需要考虑以下两个方面：</li>
<li><strong>选择合适的设计范式</strong></li>
<li><strong>规范化</strong>（Normalization）可以减少数据冗余，但可能需要更多的联表操作</li>
<li><strong>反规范化</strong>（Denormalization）可以通过增加冗余列、派生列、合并表等策略最大程度避免联表操作或函数计算，提高查询性能，但会增加数据冗余，比较典型的反规范化设计是订单表，通过额外冗余门店、经销商等常用但变更频率很低的信息，可以提升订单查询的效率</li>
<li><strong>适当的数据类型和长度</strong>：根据业务需求选择适当的类型和长度来存储数据可以减少存储空间，也可以提升查询性能，如谨慎使用大数据类型（TEXT,CLOB,BLOB等），使用整数而不是字符串存储布尔值，避免存储null值等</li>
<li><strong>索引优化</strong>： 数据库索引可以显著提升查询性能，需要合理创建并维护索引，包括考虑哪些列以怎样的次序组合索引、选择适当的索引类型以及定期重建或重新组织索引等；同时，我们也需要了解索引匹配的基本原则，变更前对SQL与索引进行审查，避免最终使用的索引不符合预期（可以借助慢查询日志、explain等工具进行分析调优），需要注意的是，索引也并不是越多越好，它会占用额外的空间，会影响更新操作的性能</li>
<li><strong>查询优化</strong>：编写高效的SQL查询语句，包括尽可能避免使用SELECT *、避免全表扫描、谨慎使用联表查询和子查询（我们在业务代码中禁止使用）、限制查询返回的数据量等</li>
<li><strong>缓存</strong>：选择合适的缓存组件和缓存策略来存储频繁访问的数据（参见「无处不在的缓存」章节）以减少对数据库的访问，从而降低数据库负载，提升响应速度</li>
<li><strong>读写分离</strong>：在一些数据库负载比较高的业务中，可以将读取操作与写入操作进行分离，分别路由到不同的数据库服务器或数据库副本，从而降低主库（写库）的负载，提升响应速度</li>
<li><strong>分库分表</strong>：对于数据规模非常大的数据库，可以借助分库分表技术减少单库的负载，从而提升数据库的性能、可伸缩性和容错性</li>
</ul>
<p>这里以爆款抢购场景库存服务的性能优化为例介绍下这些策略的具体应用：</p>
<ul>
<li><strong>数据模型设计</strong>：结合商城的业务场景，存在数千家店铺（门店）投放同一个商品的情况（即多门店共用同一个商品），也存在商品独家销售的情况（即商品只在同一家店铺销售），每家店铺（门店）的销售库存需要单独管理，基于此，我们为库存服务设计了两张核心表，即库存表和库存流水表（如图所示）</li>
<li><strong>反规范化</strong>：库存表新建唯一索引(ShopId, SkuId)，库存流水表则冗余字段ShopId和SkuId，新建唯一索引(ShopId, SkuId, OrderId, Type)</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/8b5a051f0d633dad5fef4a41aa9d6f3.png" alt="库存相关的查询">
</div>

<ul>
<li><strong>选择的数据类型</strong>：以库存流水表中的Type字段为例，用来表示库存扣减、回滚、投放、回收等状态，显然用tinyint就足够进行存储了，相比于smallint、int类型可以节省存储空间</li>
<li><strong>数据库选型</strong>：库存流水表预计每年新产生的数据在千万级且会持续增长，而库存服务又是交易链路的核心依赖，读写操作频繁且有明显业务峰值，如果用单个MySQL实例去支持，存储和性能瓶颈较为明显，因此我们采用了分库分表的技术（<strong>网易自研的DDB</strong>）</li>
<li><strong>负载均衡</strong>：均衡字段（拆分键）和均衡策略的选择对于性能有非常明显的影响，需要格外重视，在库存服务这个例子中，库存表和库存流水表我们都使用ShopId作为均衡字段且使用相同的均衡策略，主要有以下几点考虑：</li>
<li><strong>库存相关的查询</strong>、变更都会指定ShopId和SkuId，在有数千家门店投放同一个爆款商品的情况下，采用ShopId作为均衡字段可以使数据分布和流量分布更为均衡，库存表采用与库存流水表相同的均衡字段和均衡策略，可以避免XA事务，减少锁竞争</li>
<li><strong>分布式ID</strong>：基于美团的分布式Id算法Leaf的统一ID生成服务在高并发场景具有低延迟、高吞吐、高可用、支持水平扩展的特点，同时也可以满足业务上自定义的需求，我们将它作为分布式ID生成的解决方案</li>
<li><strong>定期归档</strong>：数据规模的持续增长会对性能带来负面影响，可以考虑将早期的库存流水信息迁移到归档表，可以提升数据库性能</li>
</ul>
<h2 id="2-2-3-无处不在的缓存"><a href="#2-2-3-无处不在的缓存" class="headerlink" title="2.2.3 无处不在的缓存"></a>2.2.3 无处不在的缓存</h2><p>缓存技术是一种被广泛应用于计算机系统和应用程序中的性能优化方法，它通过将数据或计算结果暂时存储在高速存储介质中，使系统可以快速响应请求、返回数据，而无需每次都从慢速存储介质（如磁盘或远程服务器等）中获取数据。</p>
<p>利用好缓存技术可以降低资源负载，减少对数据库、网络或后端应用等外部资源的依赖，显著提升系统的性能与可用性。可以说，在我们现有的系统架构中，缓存几乎无处不在，以申购场景为例：</p>
<ul>
<li><strong>客户端（APP）</strong>：客户端通过缓存预置在APP的数据、缓存数据请求响应等方式减少对服务端的频繁访问，提供更为流畅的用户体验，尤其有助于改善首次访问或不稳定网络环境下的访问体验</li>
<li><strong>静态资源访问加速</strong>：静态资源访问加速的核心在于就近访问，我们可以通过静态化技术将动态生成的内容或网页转换成静态文件并存储到CDN（Content Delivery Network，内容分发网络）或LB（Load Balancer，负载均衡），在用户请求时离用户更近的节点可以直接提供这些静态文件，而不必再次请求服务端进行动态生成，因此，可以加快页面加载速度、提升网站或应用程序的性能、减少服务器负载并降低对服务器资源的需求。通常静态化技术可以应用于不经常变更的内容、访问量较大的页面、需要SEO优化的页面、静态资源等</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/70d65dd9ee6014e47e150729c3cffbd.png" alt="CDN">
</div>

<ul>
<li><strong>服务端</strong>：借助缓存可以减少当前应用对数据库或者其他后端服务的访问，通常我们可以直接使用分布式缓存（如Redis），但在高并发场景（如申购场景），为了增加系统整体的吞吐量，也可以考虑将热点数据设计成二级缓存，即同时使用本地缓存（Local Cache）和远端缓存（Remote Cache，或者叫分布式缓存）</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/0b822a67d09bd467efca771b70bcf64.png" alt="服务端">
</div>

<p>虽然缓存技术可以显著提升性能，但同时也极大提升了系统设计的复杂度，需要考虑缓存的一致性、失效策略和缓存维护等关键问题，如果没有处理好，很容易发生缓存数据不一致、缓存大面积穿透甚至引发雪崩。</p>
<p>以申购场景使用的二级缓存为例，我们需要处理好以下问题：</p>
<ul>
<li><strong>技术选型</strong>：本地缓存采用Caffeine，远端缓存采用Redis Cluster</li>
<li><strong>Caffeine</strong>：相比于EhCache、Guava等主流的缓存框架，拥有更加强大的性能表现，使用方式上与Guava类似，非常方便</li>
<li><strong>Redis Cluster</strong>：Redis Cluster是Redis提供的分布式缓存解决方案，也是目前主流的解决方案，相比于Proxy模式有更好的性能表现，但我们仍然需要重点关注硬件以及混部等因素对于性能及稳定性的影响</li>
<li><strong>避免缓存穿透</strong>：传统的关系型数据库对于并发的承受能力非常脆弱，如果我们设计的缓存命中率不高出现大面积缓存穿透，很有可能将数据库拖垮，如何避免缓存穿透是我们设计缓存时需要重点考虑的问题：</li>
<li>热点缓存采用预加载、定时刷新及事件触发刷新（如数据变更）的策略，保证100%命中率</li>
<li>当查询的结果为空时，仍然将空结果（自定义NullObject）存储到缓存中（可以设置一个较短的过期时间），这样可以防止恶意请求的连续查询</li>
<li><strong>消息队列与异步化</strong><br>异步化的核心思想是将耗时的操作从主流程中分离出来，以允许应用程序在等待这些操作完成的同时继续执行其他任务而不会被阻塞，从而改善系统的响应性和资源利用率。</li>
</ul>
<p>异步化通常可以通过多线程、多进程、事件驱动或异步编程模型等方式来实现，有很多中间件和框架可供我们选择，比如通过<strong>Disruptor</strong>、<strong>BlockingQueue</strong>等技术将任务分解为多个线程或进程以充分利用多核处理器的性能，通过消息队列（MQ）实现异步消息通信和服务解耦，达到对流量进行削峰填谷的效果，提升系统的可扩展性和性能。</p>
<p>这里重点提一下消息队列在「i茅台」的应用，无论在申购场景还是在爆款抢购场景（如下图所示），我们都需要借助消息队列实现对洪峰流量的削峰填谷，避免服务器过载或系统宕机，同时也可以实现数据的最终一致性，确保消息处理的结果与业务逻辑的一致性。</p>
<div style="text-align: center;">
  <img src="../img/netease/fff9e5cb5d1d4a7dbdbd4dc7f2b0fcc.png" alt="场景">
</div>

<p>不难发现，这其中的关键挑战在于消息队列本身的高性能以及在设计上如何确保数据的最终一致性。</p>
<p>先来看消息队列的选型，在严选，因为历史原因同时存在Kafka、Rabbitmq和RocketMQ，但综合考虑性能和稳定性表现（高吞吐量、低延迟、高可用）、功能特性丰富度、工具支持丰富度、社区活跃度等维度，RocketMQ最终成为业务系统消息队列的主流选型，「i茅台」则延续了这一选型，采用主从部署模式（4.8版本之前主从模式相对Dledger模式在性能上更有优势）。</p>
<p>接下来我们看一下如何确保数据的最终一致性。</p>
<p>先介绍四种我们平时开发过程中比较容易出错的实现方法（如下图所示）：</p>
<div style="text-align: center;">
  <img src="../img/netease/667be695bf6001287371101aa348f56.png" alt="四个方案">
</div>

<ul>
<li><strong>方案一</strong>：先执行数据库操作再发送消息到MQ，可能会出现数据库操作成功，消息发送失败的情况</li>
<li><strong>方案二</strong>：先发送消息到MQ再执行数据库操作，可能出现消息发送成功，数据库操作失败的情况</li>
<li><strong>方案三</strong>：在方案一的基础上，开启数据库事务，这个方案在消息发送失败抛出异常的情况下可以正常回滚，但有可能会出现消息发布至MQ成功但请求失败的情况（如网络拥堵等原因响应超时），这种情况也会引发事务整体回滚</li>
<li><strong>方案四</strong>：在方案二的基础上，开启数据库事务，这个方案如果数据库操作失败需要回滚，但MQ已经发生成功，没有办法回滚</li>
</ul>
<p>可见，上述四个方案都有可能出现数据库操作状态和消息发送状态不一致的情况，其中方案一可能出现数据库操作成功、消息发送失败，这类异常可以通过引入消息补偿机制来确保消息最终成功投递；方案二、三、四可能出现消息发送成功、数据库操作失败，这类异常可以通过在消息消费端增加消息状态确认或者类似的校验机制，确保被投递出去的消息不会对业务产生负面影响。</p>
<p>最后介绍两种比较常用的正确实现方法：</p>
<ul>
<li><strong>方案五</strong>：基于RocketMQ的事务消息来实现</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/4dbdec6fba905b4f5e19540f7607a53.png" alt="基于RocketMQ的事务消息来实现">
</div>

<ul>
<li>步骤一：消息生产者向RocketMQ发送半事务消息（1. Prepare），RocketMQ确认消息接收状态</li>
<li>步骤二：RocketMQ消息接收成功，消息生产者执行本地事务的业务逻辑</li>
<li>步骤三：消息生产者根据本地事务的执行结果向RocketMQ提交二次确认（2. Commit&#x2F;Rollback），RocketMQ将步骤一中收到的半事务消息标记为可投递（消费者就可以消费到这个消息）<br>如果因断网或者应用重启等原因，二次确认（2. Commit&#x2F;Rollback）没有成功提交，RocketMQ会定时触发事务消息回查，确认是否需要投递（兜底策略），无需投递的消息会在过期后删除</li>
<li>步骤四：RocketMQ将消息投递给消息消费者（3. 投递消息），消息消费者首先需要进行幂等性检查，通过检查后执行本地事务的业务逻辑，最后返回执行结果（4. Ack）</li>
<li><strong>方案六</strong>：基于消息补偿机制来实现</li>
</ul>
<div style="text-align: center;">
  <img src="../img/netease/97457e7c70edc79df86acdf29075d74.png" alt="基于消息补偿机制来实现">
</div>

<ul>
<li>步骤一：在同一个本地事务中执行业务逻辑中的数据库操作和新增消息补偿记录（1. Prepare: 新增记录）</li>
<li>步骤二：本地事务提交后，启动异步线程，向RocketMQ发送消息（2. 发送消息），消息发送成功后删除消息补偿记录（3. Confirm: 删除记录）<br>如果因断网或者应用重启等原因，发送消息失败或者未成功删除消息补偿记录，消息生产者会定时触发消息补偿，确保发送到RocketMQ的消息至少发送一次（at least once策略，MQ有可能存在多条相同的消息）</li>
<li>步骤三：RocketMQ将消息投递给消息消费者（4. 投递消息），消息消费者首先需要进行幂等性检查（避免重复执行同一个消息），通过检查后执行本地事务的业务逻辑，最后返回执行结果（5. Ack）</li>
</ul>
<p>结合业务实际情况，由于RocketMQ的事务消息相比于普通消息性能上还是有不小的损失，无法完全满足我们的性能要求（服务器规模不变的前提下），因此我们最终选择了实现上更加复杂的方案六。</p>
<h2 id="2-2-4-硬件升级及资源优化"><a href="#2-2-4-硬件升级及资源优化" class="headerlink" title="2.2.4 硬件升级及资源优化"></a>2.2.4 硬件升级及资源优化</h2><p>硬件的性能和资源利用率同样也是我们性能优化过程中需要关注的地方，如果我们把不同的应用比喻成军队中不同的兵种，那么硬件就给不同兵种配置的装备，只有合理搭配，这些装备才能最大程度提升各兵种的战斗力，而合理搭配装备的底层逻辑，是对资源的最大化利用、避免浪费。</p>
<p>事实上，资源筹备工作往往是先于产品开发工作开展的，因此，我们的性能优化工作在绝大部分时候是在资源不变的前提下进行的。为了利用好这些资源，通常我们需要解决以下三个问题：</p>
<ol>
<li><p><strong>资源筹备阶段</strong>：如何准确地预估需要的资源？</p>
</li>
<li><p><strong>应用架构</strong>：从已知的业务信息中分离出不变的部分和变化的部分，输出全局应用架构和系统应用架构（包含应用及其依赖项），一般而言，中后台应用不变的部分更多容易预估，前台应用不确定性高也更难预估，但随着需求逐渐明朗（逐步进入产品研发阶段、产品运营阶段后），加上有更多的测试数据，预估也会越来越准确，因此，应用架构应保持持续演进以更好地厘清依赖关系及资源需求</p>
</li>
<li><p><strong>部署架构及资源清单</strong>：将应用架构映射成部署架构是资源预估的重要步骤，这个阶段一般还没有办法输出完整的流量模型，但架构师可以借助业务预判（如什么样的业务形态、多少用户参与等）拆解出核心域的前端入口流量（如申购流量、交易流量），各个域再逐层拆解到各个应用，最终映射出资源清单（也就是第一版资源清单），不难想象，要提升这个阶段资源预估准确性非常困难，需要业务方、开发团队、运维团队紧密协同，业务输入越充分预估会越准确，应用架构设计越完整预估会越准确</p>
</li>
</ol>
<p>产品研发阶段：如何结合应用特性合理地搭配和使用资源？</p>
<p>通常SRE会定义出不同的资源规格供各类应用选择：</p>
<ul>
<li><strong>CPU性能</strong>：CPU性能对于计算密集型任务非常重要，应用如果需要大量计算，需要配置高性能的CPU</li>
<li><strong>内存容量</strong>：内存容量对于数据密集型应用和需要缓存大量数据的应用至关重要，足够的内存可以减少对磁盘或网络的访问，提高性能</li>
<li><strong>存储</strong>：存储配置取决于数据量和性能需求，使用高性能固态硬盘（SSD）可以提高数据读写速度</li>
<li><strong>网络带宽</strong>： 如果应用需要大量的数据传输，网络带宽是一个瓶颈，一般负载均衡设备、应用网关、CDN需要重点考虑</li>
<li><strong>容量规划与流量模型设计</strong>：这个阶段需求已经非常明确，可以基于场景及最新的应用架构进行更为细致的流量拆解，评估出每个系统（尤其是核心系统）的容量要求及资源清单，并通过压测进行验证，确保系统在各种负载情况下都能够正常运行</li>
<li><strong>产品运营阶段</strong>：如何最大化地利用好现有的资源？</li>
<li><strong>资源超售或混部</strong>：一般可以通过云厂商提供的资源超售能力或者研发团队主动发起应用混部来提高资源利用率，然而这却是把双刃剑，更高的资源利用率也就意味着更低的资源容错率，一旦出现预期之外的流量或者资源占用，很容易成为压垮系统的最后一根稻草</li>
<li><strong>硬件升级及资源优化</strong>：通过诊断工具识别在压测或产品运营过程中出现的资源异常，如CPU使用率或Load不均衡、I&#x2F;O延迟大、内存使用率高等特征</li>
</ul>
<h2 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h2><p>性能优化是产品设计、研发和运营过程中的一个极其重要的环节，通过性能优化可以确保我们的系统满足性能设计目标。通常我们需要先借助性能诊断工具识别性能瓶颈，然后结合实际情况综合选择一种或者多种性能优化策略。</p>
<p>但需要特别注意的是，过早的优化可能会引入不必要的代码复杂性而性能却未必改善，因此，我们建议在系统开发的早期阶段应更侧重于保持代码的可维护性和可读性，随着系统的持续演进，再基于性能诊断结果对代码进行针对性地优化以满足性能需求。</p>
<h2 id="3-实现高可用的主要策略"><a href="#3-实现高可用的主要策略" class="headerlink" title="3 实现高可用的主要策略"></a>3 实现高可用的主要策略</h2><p>高性能并不意味着高可用，有些提升性能的手段会增加系统负载，反而还会降低可用性，而为了实现系统的高可用，我们通常需要引入一些复杂性或冗余，可能还会对性能产生一定负面影响。</p>
<p>本章节会重点探讨一下在系统架构和设计阶段如何考虑可用性目标。</p>
<h2 id="3-1-面向失败的设计"><a href="#3-1-面向失败的设计" class="headerlink" title="3.1 面向失败的设计"></a>3.1 面向失败的设计</h2><p>任何服务和组件都不是100%可靠的，因此核心系统的设计建议面向失败进行设计，即确保在部分组件或服务故障时仍然能够继续提供服务，比如前文提到的申购场景和爆款抢购场景都使用了这一设计理念。</p>
<p>这里我们总结下几种常用的策略：</p>
<ul>
<li><strong>最小化依赖</strong>：要减少对外部服务和组件的依赖，特别是减少强依赖，从而降低故障传播的风险</li>
<li><strong>冗余和备份</strong>：通过引入冗余组件或备份系统，在主要组件故障时可以无缝切换到备用组件，从而确保服务的连续性，需要特别重视的是，关键组件要避免单点</li>
<li><strong>自动故障检测和恢复</strong>：使系统能够主动检测故障或异常情况，并采取自动化措施以恢复正常运行，通过这种方式可以减少对人工干预的依赖，从而更快地响应问题，降低服务中断的风险</li>
<li><strong>超时与重试</strong>：在网络通信中，设置适当的超时时间，以防止请求挂起；使用重试机制确保请求的可靠性；结合合理的退避策略，避免过度重试导致服务器负载过高</li>
<li><strong>限流与降级</strong>：实施限流策略，控制请求流量以防止系统过载，在高负载或故障时降级部分功能，保持核心功能的可用性</li>
<li><strong>监控与报警</strong>：建立监控系统，实时追踪系统性能和健康状态，设置报警规则以在问题发生时及时通知运维团队采取行动</li>
<li><strong>应急预案</strong>：制定应急预案，在系统故障或紧急情况下快速采取行动以达到最大限度保护系统的目的，包括降低系统负载、故障止血与恢复、数据备份等等</li>
</ul>
<h2 id="3-2-微服务架构"><a href="#3-2-微服务架构" class="headerlink" title="3.2 微服务架构"></a>3.2 微服务架构</h2><p>微服务架构是一种典型的容错架构，由于「i茅台」商城在设计阶段已经明确了业务模式和流量挑战，因此我们没有像严选早期那样采用单体架构快速上线，而是直接采用微服务架构进行设计，基础设施则复用了严选的Service Mesh架构（参见网易严选ServiceMesh实践），相比于单体架构在以下几个方面具有明显优势：</p>
<ul>
<li><strong>故障隔离</strong>：微服务架构将一个应用程序被拆分成一组小型、独立的服务，每个服务都专注于执行特定的业务功能，当一个服务发生故障时，不会影响其他服务的正常运行，从而减小了故障的传播范围，提高了整体系统的可用性</li>
<li><strong>水平扩展</strong>：微服务架构使得每个服务可以独立地进行水平扩展，可以根据需求增加或减少服务实例的数量，以满足不同的负载要求，从而提高了系统的弹性和可用性</li>
<li><strong>快速故障恢复</strong>：微服务架构具备自动故障检测和切换机制，系统能够在检测到故障时自动将流量切换到其他服务实例，从而实现快速故障恢复，减少了服务中断的时间</li>
<li><strong>分布式部署</strong>：微服务架构支持分布式部署，服务可以部署在不同的服务器上（甚至可以跨数据中心进行部署），这提供了更高级别的容错性，避免单点故障</li>
<li><strong>灵活的更新和维护</strong>：由于每个服务都是独立的，可以单独更新和维护，而不会影响整个系统的可用性，这降低了维护和更新过程中的风险，减少了系统的停机时间</li>
</ul>
<p>有了基础架构提供的服务治理能力加持，开发需要在系统设计和开发阶段重点关注以下几点方面：</p>
<ul>
<li><strong>服务分级</strong>：服务分级是服务关联的一个标签，可以区分出每个服务对于业务影响的重要程度，我们认为每个服务都应该有对应的分级标签，它可以让我们更清晰地了解服务的可用性目标以及服务之间的依赖关系是否合理</li>
</ul>
<p>通常更高等级的服务应该匹配更高等级的服务保障，也应该具备更高的可用性，因此，要避免高等级的服务强依赖低等级的服务，否则容易造成高等级的服务无法达到既定的可用性目标</p>
<ul>
<li><strong>服务依赖</strong>：由于微服务架构会将服务拆分成更小的单元，这就不可避免地增加了服务之间的依赖关系，通常我们可以根据对故障的容忍度将依赖关系区分为强依赖和弱依赖，在设计上建议遵循以下原则：</li>
<li><strong>强依赖弱化</strong>：强依赖的服务应当尽量减少或减弱，以降低整个系统中某个服务的故障对其他服务的影响</li>
<li><strong>弱依赖异步化</strong>：弱依赖的服务可以采用异步通信方式（如消息队列），以降低对依赖服务的直接调用，提高系统的弹性和响应性</li>
<li><strong>超时治理</strong>：超时治理是通过优化超时时间与重试策略，使尽可能多的请求能够在预期时间内得到正常响应，提高系统的响应性，是一种重要的服务治理手段</li>
</ul>
<p>超时时间的设置应充分考虑业务本身的复杂性和预期响应时间，应设置足够长以容忍正常的响应延迟，但也不能过长避免无限期挂起等待</p>
<p>响应超时并不一定意味着目标服务已经不能工作，通过合理的重试机制，即使在目标服务器或网络故障的情况下也能够成功完成请求，但要确保请求的幂等性，避免重试请求对业务产生负面影响</p>
<p>设计合理的退避策略（如指数退避），避免连续重试导致服务器负载过高，另外，重试次数也应该有限，避免无限重试</p>
<p>在放弃请求后，系统可能采用降级策略，提供有限的服务，以确保核心功能的可用性</p>
<ul>
<li><strong>限流策略</strong>：限流是一种通过控制请求流量以防止系统过载的策略，也是一种非常重要的服务治理手段</li>
</ul>
<p>限流会带来一定的性能损耗，我们借助应用网关与限流中间件实现对流入网关及业务系统的流量进行限制，各个系统需结合服务等级、预估流量及应用当前能力选择是否开启</p>
<p>限流值的设置应充分考虑应用自身的能力，由于系统演进过程中的熵增是一种不可避免的趋势，建议限流值设置时保持一定的余量，以最大限度为系统提供有效保护</p>
<p>限流策略上可以为每个服务或接口设置最大请求速率，也可以进一步基于时间段、用户、IP地址等因素进行细化</p>
<ul>
<li><strong>降级策略</strong>：降级策略是一种应对系统负载过高或故障的策略，通过牺牲非关键功能以保持核心功能的正常运行</li>
<li><strong>主动降级</strong>：系统在监测到一定条件或预设的规则触发下，自动执行降级策略，包括自动关闭非关键功能、拒绝某些请求、减少资源分配等</li>
<li><strong>手动降级</strong>：运维人员或开发人员手动介入执行降级策略以应对特定的问题或异常情况，通常都是应对已知的问题或紧急情况，基于预案进行操作</li>
<li><strong>熔断策略</strong>：当一个服务在一段时间内出现连续的失败，熔断策略会中断对该服务的请求，避免因频繁请求失败而导致的资源浪费</li>
</ul>
<h2 id="3-3-客户端（APP）容错设计"><a href="#3-3-客户端（APP）容错设计" class="headerlink" title="3.3 客户端（APP）容错设计"></a>3.3 客户端（APP）容错设计</h2><p>客户端（APP）作为用户获得产品服务的主要入口，也大量使用了容错设计。</p>
<p>容错设计可以提升客户端整体的鲁棒性和可用性，以更好地应对服务端或网络等各种故障和异常情况，确保客户端在面临这些问题时仍然能够提供有限的服务，保持良好的用户体验。因此，客户端的容错设计往往也和产品策略息息相关，而不同的产品策略最终也会影响技术方案的选择，比如：</p>
<ol>
<li>首页无论在出现哪类异常都不应该挂掉，那么，我们在设计阶段就应该充分考虑请求失败等异常情况下如何进行兜底展示</li>
<li>大流量场景可能遇到限流等异常，可以通过设计等待页面或者排队动画避免流程中断（比如操作了一半进入错误页面）、减轻用户等待的焦虑感</li>
<li>随着版本的持续迭代，旧版本APP的用户是否还能正常使用产品服务</li>
</ol>
<p>设计明确的前后端交互协议有助于更好地解决上述问题：</p>
<ul>
<li><strong>错误处理和容错机制</strong>：通过规定统一的错误码和错误信息传递方式，使APP能够捕获和处理各种错误情况，包括网络错误、服务端错误、数据格式错误等，这有助于客户端实现统一的错误处理方法以应对各种异常情况</li>
<li><strong>版本兼容性</strong>：通过版本控制，可以确保在服务端升级或修改接口时不会影响现有的APP版本，保持兼容性；也可以通过版本控制，提醒用户或者强制用户升级到最新版本的APP</li>
<li><strong>通信安全</strong>：通过定义加密和认证规范，以确保通信的安全性，这有助于防止数据泄露和中间人攻击，提高系统的可靠性和安全性</li>
</ul>
<h2 id="3-4-全链路压测"><a href="#3-4-全链路压测" class="headerlink" title="3.4 全链路压测"></a>3.4 全链路压测</h2><p>类似「i茅台」这样大型的电商系统，具有业务场景复杂、核心链路长的特点，通过传统的测试方法在测试环境进行压测，已经难以确保系统在高负载和极端场景下的性能、可用性和稳定性了，因此，我们需要引入全链路压测。</p>
<p>全链路压测是在生产环境中基于真实的业务场景模拟用户操作和流量，以对整条业务链路进行压力测试，从而识别潜在的性能瓶颈或异常，有助于我们及时发现并解决，确保系统的高性能、高可用和稳定性。</p>
<p>要实现生产环境全链路可压测，除了前文提到的APM、日志平台等监控诊断工具之外，还需要具备以下能力：</p>
<ul>
<li><strong>全链路流量标记透传能力</strong>：通过全链路支持压测流量标记识别和传递，使线上全链路能区分压测流量和真实用户流量，保证在大流量压力测试时不会对真实用户体验以及真实用户数据造成影响，解决了因环境差异造成压测结果不真实，可以充分验证线上服务在大流量下的承载能力</li>
<li><strong>数据存储路由</strong>：使数据库、缓存、MQ、日志等存储介质可以识别压测流量，将压测产生的数据与真实用户数据分开保存，实现存储隔离，为线上压测提供数据安全保障</li>
<li><strong>压测平台</strong>：提供分布式高并发压测能力，支持上千台压测机同时发出压测流量、模拟千万级用户访问，支持大流量下的压测结果分析</li>
</ul>
<p>全链路压测要求技术团队进行更高效的协同，因此，除了工具和能力层面的支持，团队的成熟度也是影响这项工作能否顺利开展的关键因素：</p>
<ul>
<li><strong>明确核心链路</strong>：需要共同明确哪些是需要重点保障的场景，并通过业务梳理明确每个场景对应的核心链路</li>
<li><strong>容量规划与流量模型设计</strong>：结合产品运营计划，对每个场景的流量进行预估与拆解，明确核心链路上各个系统的性能指标、容量指标、SLA以及各自的强弱依赖（包括第三方服务，如各类云服务），并明确对依赖方的性能要求及降级预案</li>
<li><strong>限流配置及预案制定</strong>：结合各个系统的性能指标和容量指标，明确限流策略及限流值，梳理可能出现的异常场景并制定针对性的预案（如降级、熔断等）</li>
<li><strong>压测执行及预案演练</strong>：定期组织全链路压测并在压测前、压测中进行预案演练</li>
<li><strong>监控与报警</strong>：每个系统需要在各自的关键链路上设置监控和报警，以便在压测期间能实时监测性能及异常，并能够进行快速响应</li>
<li><strong>结果分析</strong>：分析并解释压测结果，识别预案及监控报警是否有效，识别是否存在潜在的性能问题和优化机会，最终产出压测报告</li>
<li><strong>改进优化</strong>：各个团队根据压测报告讨论并实施优化策略</li>
<li><strong>常态化基线压测及性能巡检</strong>：建立常态化机制，定期对系统进行性能测试以建立性能基线，以便了解系统在正常工作负载下的性能指标；定期监测和评估系统的性能，以便及早发现和解决性能问题</li>
</ul>
<h2 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h2><p>要实现系统的高可用性，我们需要在系统架构和设计阶段充分考虑各种故障和异常场景，包括硬件故障、网络中断、软件错误等，通过减少依赖、引入冗余和备份、实现自动故障检测与恢复、增加限流及应急预案、引入监控报警机制等策略来减轻突发流量或故障对系统产生的影响，确保在部分组件或服务故障时系统仍然能够继续提供服务，同时我们也必要借助全链路压测等手段识别潜在的问题以确保上述策略是持续有效的。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>「i茅台」商城作为茅台酒线上销售的主要入口，从诞生的第一天开始就需要考虑如何有效地应对大流量高并发的考验，这要求我们在保证数据一致性的前提下，实现系统的高性能和高可用，其中高性能意味着更快的响应时间和更大的吞吐量，可以同时为更多的用户提供流畅的服务，而高可用则意味着系统需要在面临故障或异常情况时仍然保持可用性。</p>
<p>为了实现系统的高性能和高可用，我们需要结合业务诉求、产品运营情况及系统现状进行分析，综合选取一些性能优化技术与高可用系统的设计方法，使系统在性能、可用性、安全性、可维护性等方面保持一种最佳的平衡状态。</p>
<p>本质上，系统的架构和设计就是权衡和取舍的过程，权衡性能与可用性、成本与性能、安全性与便利性、扩展性与复杂性，不同的系统可能需要不同的权衡，本文希望通过这些实际的案例帮助大家更好地理解这些技术和策略以及背后的权衡过程，从而可以更好地应用在我们日常的设计与开发过程中。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/01/22/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week8/">网易牛马日志-week8</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-01-22
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>System.out.println(“I am back”);</p>
</blockquote>
<h2 id="需求10：俄罗斯印度公司的后端改造"><a href="#需求10：俄罗斯印度公司的后端改造" class="headerlink" title="需求10：俄罗斯印度公司的后端改造"></a>需求10：俄罗斯印度公司的后端改造</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>为了能尽快丰富页面实现seo，优先开放数据组刚挖掘出来的俄罗斯印度公司详细信息，当存量不足的时候再去按照原有逻辑开放普通公司。此外为了优化全球搜变动导致的页面失效，需要在出海项目的es里面保存一份副本，否则会影响谷歌收录。</p>
<h3 id="改进结构"><a href="#改进结构" class="headerlink" title="改进结构"></a>改进结构</h3><div style="text-align: center;">
  <img src="../img/netease/1736739033864.svg" alt="后端架构">
</div>

<p>分为两个方面取数据，全球搜和扩展es，扩展es洗了一些俄罗斯印度公司的拓展信息用于展示，与全球搜主键id关联，从而可以组装起来作为一个更大的bo。但是如果当公司开放之后，全球搜es有变动导致无法访问就会严重影响谷歌收录。所以需要更改保存逻辑，直接在每日新增中执行组装，如果此时全球搜有那就保留，且写回扩展索引中。如果没有就跳过，这样以来所有的信息全部都持久化到扩展es中，用公式写就是A（全球搜）+B（扩展）-&gt;AB（组装后的大对象）-&gt;写回扩展es。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>sourceBuilder构造：查询指定国家，根据质量分数倒序排序，但是这样顺序开放会导致重复扫描的越来越多，后续一个小时有可能都跑不完了。</li>
<li>查询开放公司的最大dataId，然后追加dataId，得到原始输入List。</li>
<li>接下来要一个个去请求全球搜去组装一个更大的对象，如果返回有问题就过滤掉不入库，返回无问题就直接upsert拓展索引。</li>
<li>最后作为开放公司写入数据库</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【俄罗斯、印度】extendIndex组合全球搜base信息重新写入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> country</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">upsertExtendDetailToDbAndEs</span><span class="params">(String country, String param)</span> &#123;</span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    boolQuery.must(QueryBuilders.termQuery(<span class="string">&quot;standardCountry&quot;</span>, country));</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>()</span><br><span class="line">            .query(boolQuery)</span><br><span class="line">            .fetchSource(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;companyId&quot;</span>,<span class="string">&quot;name&quot;</span>&#125;, <span class="literal">null</span>)</span><br><span class="line">            .sort(<span class="string">&quot;dataQualityScore&quot;</span>,SortOrder.DESC)</span><br><span class="line">            .size(Integer.parseInt(param));</span><br><span class="line">    <span class="comment">//从es中抽取指定数量的companyList</span></span><br><span class="line">    List&lt;SiteMapCompanyEntity&gt; originalCompanyList = loadCompanyToExtendIndex(companyExtendIndex, sourceBuilder, param);</span><br><span class="line">    <span class="comment">//过滤全球搜不开放的公司</span></span><br><span class="line">    List&lt;SiteMapCompanyEntity&gt; filterCompanyList = originalCompanyList.stream().filter(<span class="built_in">this</span>::filterAndUpsertCompanyExtendIndex).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//保存进db</span></span><br><span class="line">    saveBatch(filterCompanyList);</span><br><span class="line">    log.info(<span class="string">&quot;upsertExtendDetailToDbAndEs success record &#123;&#125;&quot;</span>,filterCompanyList.size());</span><br><span class="line">    <span class="keyword">return</span> filterCompanyList.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【其他国家】extendIndex组合全球搜base信息重新写入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 补齐条数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upsertNormalDetailToDbAndEs</span><span class="params">(String param)</span> &#123;</span><br><span class="line">    <span class="comment">// 有域名的排前面(强制排序)</span></span><br><span class="line">    <span class="type">Script</span> <span class="variable">hasDomainScript</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Script</span>(<span class="string">&quot;if(doc[&#x27;domainCount&#x27;].size()&gt;0 &amp;&amp; doc[&#x27;domainCount&#x27;].value&gt;=1) return 1; else return 0&quot;</span>);</span><br><span class="line">    <span class="comment">// 域名无效的后置(强制排序)</span></span><br><span class="line">    <span class="type">Script</span> <span class="variable">invalidDomainScript</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Script</span>(<span class="string">&quot;if(doc[&#x27;domainStatus&#x27;].size()&gt;0 &amp;&amp; doc[&#x27;domainStatus&#x27;].value&gt;0) return 0; else return 1&quot;</span>);</span><br><span class="line">    <span class="comment">// 有邮箱前置</span></span><br><span class="line">    <span class="type">Script</span> <span class="variable">hasEmailScript</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Script</span>(<span class="string">&quot;if(doc[&#x27;emailCount&#x27;].size()&gt;0 &amp;&amp; doc[&#x27;emailCount&#x27;].value&gt;=1) return 1; else return 0&quot;</span>);</span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;overviewDescription&quot;</span>));</span><br><span class="line">    boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;companyId&quot;</span>));</span><br><span class="line">    boolQuery.mustNot(QueryBuilders.termQuery(<span class="string">&quot;disable&quot;</span>, <span class="string">&quot;true&quot;</span>));</span><br><span class="line">    boolQuery.must(QueryBuilders.wildcardQuery(<span class="string">&quot;overviewDescription&quot;</span>, <span class="string">&quot;*&quot;</span>));</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>()</span><br><span class="line">            .query(boolQuery) <span class="comment">// 查询参数</span></span><br><span class="line">            .fetchSource(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;companyId&quot;</span>&#125;,</span><br><span class="line">                    <span class="literal">null</span>)</span><br><span class="line">            .size(<span class="number">1000</span>)</span><br><span class="line">            <span class="comment">// 有无域名排序</span></span><br><span class="line">            .sort(SortBuilders.scriptSort(hasDomainScript, ScriptSortBuilder.ScriptSortType.NUMBER).order(SortOrder.DESC))</span><br><span class="line">            <span class="comment">// 无效域名排序</span></span><br><span class="line">            .sort(SortBuilders.scriptSort(invalidDomainScript, ScriptSortBuilder.ScriptSortType.NUMBER).order(SortOrder.DESC))</span><br><span class="line">            <span class="comment">// 有邮箱前置</span></span><br><span class="line">            .sort(SortBuilders.scriptSort(hasEmailScript, ScriptSortBuilder.ScriptSortType.NUMBER).order(SortOrder.DESC));</span><br><span class="line">    <span class="comment">//从es中抽取指定数量的companyList</span></span><br><span class="line">    List&lt;SiteMapCompanyEntity&gt; originalCompanyList = loadCompanyToExtendIndex(openCompanyIndex, sourceBuilder, param);</span><br><span class="line">    <span class="comment">//过滤全球搜不开放的公司</span></span><br><span class="line">    List&lt;SiteMapCompanyEntity&gt; filterCompanyList = originalCompanyList.stream().filter(<span class="built_in">this</span>::filterAndUpsertCompanyExtendIndex).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//保存进db</span></span><br><span class="line">    saveBatch(filterCompanyList);</span><br><span class="line">    log.info(<span class="string">&quot;upsertNormalDetailToDbAndEs success record &#123;&#125;&quot;</span>,filterCompanyList.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询索引并转换为数据库逻辑，输出是实际新增开放公司，小循环用set去重，大循环直接去数据库count&gt;0去重。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用新增开放公司逻辑</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> abstractIndex es索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceBuilder es查询条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param 查询数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 实际新增开放公司List</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;SiteMapCompanyEntity&gt; <span class="title function_">loadCompanyToExtendIndex</span><span class="params">(AbstractIndex&lt;T&gt; abstractIndex,SearchSourceBuilder sourceBuilder,String param)</span>&#123;</span><br><span class="line">    <span class="type">SiteMapCompanyEntity</span> <span class="variable">maxCompany</span> <span class="operator">=</span> getMaxDataId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">maxDataId</span> <span class="operator">=</span> maxCompany == <span class="literal">null</span> ? <span class="number">1</span> : maxCompany.getDataId();</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    count.incrementAndGet();</span><br><span class="line">    List&lt;SiteMapCompanyEntity&gt; addList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    abstractIndex.scrollSearch(sourceBuilder, searchHits -&gt; &#123;</span><br><span class="line">        Set&lt;String&gt; companyIdSets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addList.size() &gt;= Integer.parseInt(param)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Object&gt; result = searchHit.getSourceAsMap();</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> result.get(<span class="string">&quot;name&quot;</span>).toString();</span><br><span class="line">            <span class="type">String</span> <span class="variable">companyId</span> <span class="operator">=</span> result.get(<span class="string">&quot;companyId&quot;</span>).toString();</span><br><span class="line">            <span class="comment">//本轮去重</span></span><br><span class="line">            <span class="keyword">if</span> (companyIdSets.contains(companyId)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            companyIdSets.add(companyId);</span><br><span class="line">            <span class="comment">//全局去重</span></span><br><span class="line">            <span class="keyword">if</span> (isOpeningCompany(companyId))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数据库对象转换，包装首字母等</span></span><br><span class="line">            <span class="type">SiteMapCompanyEntity</span> <span class="variable">siteMapCompanyEntity</span> <span class="operator">=</span> convertIndexToDbEntity(name, companyId);</span><br><span class="line">            siteMapCompanyEntity.setDataId(maxDataId + count.longValue());</span><br><span class="line">            count.getAndIncrement();</span><br><span class="line">            addList.add(siteMapCompanyEntity);</span><br><span class="line">            log.info(<span class="string">&quot;loadCompanyToExtendIndex add record &#123;&#125;&quot;</span>,JSON.toJSONString(siteMapCompanyEntity));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> addList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在xxl-job里面定义定时任务，开两个定时任务，分别输入”Russia|1500”，”India|1500”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增公司数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@XxlJob(&quot;addExtendToOpenDb&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">addExtendToOpenDb</span><span class="params">(String param)</span> &#123;</span><br><span class="line">    param = StringUtils.isEmpty(param) ? <span class="string">&quot;1500&quot;</span> : param;</span><br><span class="line">    XxlJobLogger.log(<span class="string">&quot;addExtendToOpenDb job start&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String[] params = param.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line">        <span class="comment">//带国家和数量</span></span><br><span class="line">        <span class="keyword">if</span> (params.length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">loadedSize</span> <span class="operator">=</span> siteMapCompanyService.upsertExtendDetailToDbAndEs(params[<span class="number">0</span>], params[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">remainSize</span> <span class="operator">=</span> Integer.parseInt(params[<span class="number">1</span>]) - loadedSize;</span><br><span class="line">            <span class="keyword">if</span>(remainSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                siteMapCompanyService.upsertNormalDetailToDbAndEs(String.valueOf(remainSize));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.length == <span class="number">1</span>) &#123;</span><br><span class="line">            siteMapCompanyService.upsertNormalDetailToDbAndEs(String.valueOf(params[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        XxlJobLogger.log(<span class="string">&quot;addExtendToOpenDb error&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;addExtendToOpenDb error&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    XxlJobLogger.log(<span class="string">&quot;addExtendToOpenDb job end&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="需求11：AIGC能力——大模型总结网页"><a href="#需求11：AIGC能力——大模型总结网页" class="headerlink" title="需求11：AIGC能力——大模型总结网页"></a>需求11：AIGC能力——大模型总结网页</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>前面补充的数据还是没能影响seo，可能是因为数据不够独特，同质性太强。因此需要用ai总结一下，做出差异化的内容。</p>
<h3 id="提示词"><a href="#提示词" class="headerlink" title="提示词"></a>提示词</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">The following text is taken from the official website of a company named: [bi-ehealthcare]. </span><br><span class="line">Based on the content provided, generate 6-8 self-questions and answers related to the company&#x27;s information. </span><br><span class="line">The question is information related to the company: the company&#x27;s products, industry, services, address and contact information (telephone, email, etc.), and other points of fact mentioned in the content provided, but not limited to this.</span><br><span class="line">Provide quality responses and avoid general responses such as &quot;Unfortunately, the text does not provide...&quot; . </span><br><span class="line">Avoid interference from privacy policies and cookies, and ensure that the total length of the reply is not less than 500 characters. In particular.</span><br><span class="line">Organize and translate your answers in English, as shown below:</span><br><span class="line">Q1: XXXX,</span><br><span class="line">A1: XXXX,</span><br><span class="line">Q2: XXXX,</span><br><span class="line">A2: XXXX</span><br></pre></td></tr></table></figure>

<h3 id="大模型的原理（挖个坑、后续研究）"><a href="#大模型的原理（挖个坑、后续研究）" class="headerlink" title="大模型的原理（挖个坑、后续研究）"></a>大模型的原理（挖个坑、后续研究）</h3><p>输入的是提示词和域名，大模型会去根据域名获得html页面，然后根据python某些工具去递归挖掘子url和html，拼接token，结合RAG从而获得更大规模的输入，然后根据提示词去调用llama3.2，得到输出。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/12/25/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week5%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%89%88%EF%BC%89/">网易牛马日志-week5（学习版）</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-12-25
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h1><h2 id="邮箱注册"><a href="#邮箱注册" class="headerlink" title="邮箱注册"></a>邮箱注册</h2><p>用户视角：输入邮箱和密码（有校验）-&gt;填写个人信息-&gt;收到确认邮件-&gt;点击跳转链接</p>
<h3 id="输入邮箱和密码（有校验）"><a href="#输入邮箱和密码（有校验）" class="headerlink" title="输入邮箱和密码（有校验）"></a>输入邮箱和密码（有校验）</h3><p>输入邮箱密码，前端通过正则表达式校验密码格式，后端请求&#x2F;email&#x2F;check来检查账号是否启用。这里启用指的是已经点击过验证邮件的或者用oauth已经校验过的。这里没校验过邮件的应该还是可以重新发起注册的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> EmailSignUpCheckResp <span class="title function_">emailSignUpCheck</span><span class="params">(EmailSignupCheckReq emailSignupCheckReq, HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">EmailSignUpCheckResp</span> <span class="variable">emailSignUpCheckResp</span> <span class="operator">=</span> EmailSignUpCheckResp.builder()</span><br><span class="line">            .emailSignUpCheckStatus(EmailSignUpCheckStatus.UN_SIGN_UP)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 校验注册邮箱</span></span><br><span class="line">    <span class="type">UserEntity</span> <span class="variable">user</span> <span class="operator">=</span> userServiceImpl.getUserEntityByLoginUsername(emailSignupCheckReq.getEmail());</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(user)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UserState.OPEN.getCode() == user.getState()) &#123;</span><br><span class="line">            emailSignUpCheckResp.setEmailSignUpCheckStatus(EmailSignUpCheckStatus.ALREADY_VERIFIED);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            emailSignUpCheckResp.setEmailSignUpCheckStatus(EmailSignUpCheckStatus.ALREADY_SIGN_UP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> emailSignUpCheckResp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册逻辑-确认邮件的回调逻辑"><a href="#注册逻辑-确认邮件的回调逻辑" class="headerlink" title="注册逻辑+确认邮件的回调逻辑"></a>注册逻辑+确认邮件的回调逻辑</h3><ol>
<li>查询用户信息：check校验的是是否有效。这里检查是否别的方式已经注册了（通过email字段查）</li>
<li>检查密码强度</li>
<li>邀请码（暂时不需要）</li>
<li>保存用户信息（两张表，一张存用户实体，另一张存账号密码和盐）</li>
<li>埋点上报</li>
</ol>
<p>这里最重要的是“保存用户信息”。在注册之后会入库账号密码，但是未激活（就是check检查的那个字段，只有点击了邮件链接才会接收到）。</p>
<p>随后生成一个UUID作为参数传给邮件，同时缓存在redis中。在邮件里面放这个链接和参数，点击的时候自动就会去请求“&#x2F;verify&#x2F;email?cs&#x3D;”。<br>这个方法会解析加密参数，与redis中进行比较。校验成功后激活用户状态，最后走获取token的逻辑，那部分等讲登录的时候再说。</p>
<h3 id="邮箱相关"><a href="#邮箱相关" class="headerlink" title="邮箱相关"></a>邮箱相关</h3><p>发送的是html，这里用到了FreeMarker，模板里面只有两个需要动态换的，一个是称呼一个是对应的重定向链接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; templateParams = Maps.newHashMap();</span><br><span class="line">templateParams.put(<span class="string">&quot;accountName&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">templateParams.put(<span class="string">&quot;registerLink&quot;</span>, <span class="string">&quot;https://www.bilibili.com&quot;</span>);</span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> resourceLoader.getResource(<span class="string">&quot;classpath:template/&quot;</span>+registerTemplate);</span><br><span class="line"><span class="type">byte</span>[] fileData = FileCopyUtils.copyToByteArray(resource.getInputStream());</span><br><span class="line"><span class="type">String</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(fileData, StandardCharsets.UTF_8);</span><br><span class="line">textPart.setContent(template, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(template.getBytes())) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> FreemarkerUtils.process(inputStream, templateParams);</span><br><span class="line">    System.out.println(content);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后发送邮件配置就完了，这里暂时用的是gmail，最后得搭建公司邮件服务器。</p>
<h3 id="邮箱登录"><a href="#邮箱登录" class="headerlink" title="邮箱登录"></a>邮箱登录</h3><ol>
<li>各种参数校验，包括上面一直在讲的激活状态。</li>
<li>密码校验（数据库盐是Base64，可以加密解密的）： encode(用户输入+Base64Decode(数据库盐)) &#x3D;&#x3D; 数据库加密后的密码。</li>
<li>校验成功则登录成功，首先解析ip到国家和省份保存。然后生成token作为session保存在redis里面，设定过期时间为7天。</li>
<li>将token返回给前端，每次请求都要携带。</li>
</ol>
<h1 id="oauth"><a href="#oauth" class="headerlink" title="oauth"></a>oauth</h1><h2 id="谷歌code解析"><a href="#谷歌code解析" class="headerlink" title="谷歌code解析"></a>谷歌code解析</h2><p>类似微信小程序，前端先去请求谷歌登录，谷歌会返回一个code，后端拿到这个code去oauth里获得用户登录信息。拿这个信息去业务数据库里查询是否有记录来判断是注册还是登录。</p>
<p>如果没有实际用户说明是注册，如果有还需要判断注册方式是否是oauth，分为其他方式注册和直接登录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OAuthLoginUser <span class="title function_">getAuthUserInfo</span><span class="params">(OAuthUserInfoReq req)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!oAuthRequestFactory.support().contains(req.getOAuthType().toUpperCase())) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;getAuthUserInfo, source not supported, req: &#123;&#125;&quot;</span>, req);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;unsupported oauth type&quot;</span>, BizError.ENUM_PARAM_ERR.getCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拿着oauth去解析，获得用户数据</span></span><br><span class="line">    <span class="type">AuthRequest</span> <span class="variable">authRequest</span> <span class="operator">=</span> oAuthRequestFactory.create(req.getOAuthType());</span><br><span class="line">    AuthResponse&lt;AuthUser&gt; authResponse = authRequest.login(AuthCallback.builder().code(req.getCode()).build());</span><br><span class="line">    <span class="type">AuthUser</span> <span class="variable">authUserInfo</span> <span class="operator">=</span> authResponse.getData();</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(authUserInfo)) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;getAuthUserInfo, authUserInfo is null, req: &#123;&#125;&quot;</span>, req);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.COMMON_ERR.getName(), BizError.COMMON_ERR.getCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存获取的用户信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">accessCode</span> <span class="operator">=</span> CodeUtils.generateOAuthSignupCode();</span><br><span class="line">    redisManager.addOAuthUser(accessCode, authUserInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前OAuth状态</span></span><br><span class="line">    <span class="type">OAuthType</span> <span class="variable">oAuthType</span> <span class="operator">=</span> OAuthType.of(req.getOAuthType());</span><br><span class="line">    <span class="type">String</span> <span class="variable">userIdentify</span> <span class="operator">=</span> authUserInfo.getUsername();</span><br><span class="line">    OAuthStatus oAuthStatus;</span><br><span class="line">    <span class="type">UserEntity</span> <span class="variable">user</span> <span class="operator">=</span> userServiceImpl.getUserEntityByLoginUsername(userIdentify);</span><br><span class="line">    <span class="comment">//用户实体表没有就是没注册</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(user)) &#123;</span><br><span class="line">        <span class="comment">//查指定枚举信息的</span></span><br><span class="line">        <span class="type">UserAuthEntity</span> <span class="variable">auth</span> <span class="operator">=</span> userAuthServiceImpl.getByIdentifier(userIdentify,</span><br><span class="line">                IdentityType.convert(oAuthType).getCode());</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(auth)) &#123;</span><br><span class="line">            <span class="comment">// 同种类型重复注册</span></span><br><span class="line">            oAuthStatus = OAuthStatus.LOGIN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已经存在其他方式注册</span></span><br><span class="line">            oAuthStatus = OAuthStatus.ANOTHER_SIGNUP_WAY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oAuthStatus = OAuthStatus.SIGNUP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OAuthLoginUser.convert(authUserInfo, accessCode, oAuthStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端可能会根据三种枚举值来走登录、注册和提示逻辑。</p>
<h3 id="oauth注册"><a href="#oauth注册" class="headerlink" title="oauth注册"></a>oauth注册</h3><p>注册逻辑基本一致，多了一个从redis中查询oauth的用户信息的过程（例如google保存的头像链接），如果没查到就是验证超时，如果查到了但是用户不匹配就抛异常。最后给token，然后删除oauth的验证信息。</p>
<h3 id="oauth登录"><a href="#oauth登录" class="headerlink" title="oauth登录"></a>oauth登录</h3><p>基本一致，也是多了一个从redis里面拿accesscode的过程。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/12/25/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week5/">网易牛马日志-week5</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-12-25
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>写在前面：经过一个月的实习，我逐渐觉得沟通能力和理解能力远比代码能力重要。不论是在科研组会上的哑口无言，还是在工作上对接的七嘴八舌，都暴露出了我语言能力的欠缺。我从初中开始就知道这是我的短板，但没想到有这么短。这也再次给我敲响了警钟，不管你是什么学术或者技术大师，学说话和听说话是最基本的。</p>
</blockquote>
<h2 id="需求7：【出海项目】ip限流"><a href="#需求7：【出海项目】ip限流" class="headerlink" title="需求7：【出海项目】ip限流"></a>需求7：【出海项目】ip限流</h2><p>注解+aop+lua+redis+滑动窗口限流算法</p>
<h3 id="注解和aop"><a href="#注解和aop" class="headerlink" title="注解和aop"></a>注解和aop</h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>根据多个时间单位配置限流器，定义了时间枚举类，按照毫秒存储持续时间（因为注解只能用枚举，不能用正常类）。</p>
<blockquote>
<p>正常是要传3个值的：次数，时间单位，超时时间（主要是给后面对redis设置expireTime）。这里为了方便超时时间与时间单位一致。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用示例：1分钟限制10次，1小时限制500次</span></span><br><span class="line"><span class="meta">@IpRateLimit(limit = &#123;10,500&#125;, timeUnit = &#123;TimeUnit.MINUTE,TimeUnit.HOUR&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注解定义</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IpRateLimit &#123;</span><br><span class="line">    <span class="type">int</span>[] limit();  <span class="comment">// 限流值</span></span><br><span class="line">    TimeUnit[] timeUnit();  <span class="comment">// 时间单位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TimeUnit</span> &#123;</span><br><span class="line">    YEAR(<span class="number">1</span>, <span class="string">&quot;YEAR&quot;</span>, <span class="number">1000L</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span> * <span class="number">365</span>),</span><br><span class="line">    MONTH(<span class="number">2</span>, <span class="string">&quot;MONTH&quot;</span>, <span class="number">1000L</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>),</span><br><span class="line">    DAY(<span class="number">3</span>, <span class="string">&quot;DAY&quot;</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>),</span><br><span class="line">    HOUR(<span class="number">4</span>, <span class="string">&quot;HOUR&quot;</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>),</span><br><span class="line">    MINUTE(<span class="number">5</span>, <span class="string">&quot;MINUTE&quot;</span>, <span class="number">1000</span> * <span class="number">60</span>),</span><br><span class="line">    SECOND(<span class="number">6</span>, <span class="string">&quot;SECOND&quot;</span>, <span class="number">1000</span>),</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//单位是毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> periodInMills;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="aop"><a href="#aop" class="headerlink" title="aop"></a>aop</h4><p>校验注解里两个数组长度必须相同，对每一个配置new一个限流器来执行redis脚本。（我在想这里每次限流就new一个开销会不会有点大，但是不能用@service，因为有状态的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpRateLimiterAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisLuaRateLimiter redisLuaRateLimiter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.netease.cowork.sirius.it.data.overseas.server.frame.anno.IpRateLimit)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rateLimiter</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;rateLimiter() &amp;&amp; @annotation(ipLimiter)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">(JoinPoint joinPoint, IpRateLimit ipLimiter)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">int</span>[] limit = ipLimiter.limit();</span><br><span class="line">        TimeUnit[] timeUnits = ipLimiter.timeUnit();</span><br><span class="line">        <span class="keyword">if</span> (limit.length != timeUnits.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取用户ip</span></span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="keyword">assert</span> attributes != <span class="literal">null</span>;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; limit.length; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">periodInMills</span> <span class="operator">=</span> timeUnits[i].getPeriodInMills();</span><br><span class="line">            redisLuaRateLimiter = <span class="keyword">new</span> <span class="title class_">RedisLuaRateLimiter</span>(limit[i], periodInMills, periodInMills,timeUnits[i].getName());</span><br><span class="line">            <span class="keyword">if</span> (!redisLuaRateLimiter.tryAcquired(ip))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;操作频繁，请稍后重试&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redis-lua实现滑动窗口限流算法"><a href="#redis-lua实现滑动窗口限流算法" class="headerlink" title="redis+lua实现滑动窗口限流算法"></a>redis+lua实现滑动窗口限流算法</h3><p>lua脚本在这里最大的作用就是解决并发问题，且保证原子性。分别说这个几个参数：</p>
<ul>
<li>KEYS[1]：String key &#x3D; prefix + ip。业务名称+ip。因为可能有多个业务都需要限流。</li>
<li>ARGV[1]：now-periodInMills。时间校验的分界线，往后为需要计算的流量。</li>
<li>ARGV[2]：now</li>
<li>ARGV[3]：UUID.randomUUID()真正的value值，随便写一个</li>
<li>ARGV[4]：expireInMills</li>
<li>ARGV[5]：limit</li>
</ul>
<p>基本原理是zset的score存时间戳，ZREMRANGEBYSCORE这个方法会去除0到now-periodInMills的所有元素，剩下的就是要统计的元素。ZCARD用来统计当前元素数量，如果比count小就没有达到限流，ZADD设置value，score和超时时间。如果限流就返回特殊数字。<br>最后只用判断lua脚本执行是否是1来判断限流。</p>
<p>其他的代码都是java操作lua的方法，核心如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限流</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_LIMIT_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;local removedCount = redis.call(&#x27;ZREMRANGEBYSCORE&#x27;, KEYS[1], 0, ARGV[1])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;local currentCount = redis.call(&#x27;ZCARD&#x27;, KEYS[1])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;if currentCount &lt; tonumber(ARGV[5]) then\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    redis.call(&#x27;ZADD&#x27;, KEYS[1], ARGV[2], ARGV[3])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    redis.call(&#x27;PEXPIRE&#x27;, KEYS[1], ARGV[4])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return 1\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;else\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return 0\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line"><span class="comment">//统计rate</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_LIMIT_COUNT_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;local removedCount = redis.call(&#x27;ZREMRANGEBYSCORE&#x27;, KEYS[1], 0, ARGV[1])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;local currentCount = redis.call(&#x27;ZCARD&#x27;, KEYS[1])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;return currentCount&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>结论是对比海关服务的限流，这种写lua的方法能快三倍，限流速度50ms，他们的150ms。而且配置也很简单。</p>
<h2 id="需求8：【出海项目】sitemap与seo优化"><a href="#需求8：【出海项目】sitemap与seo优化" class="headerlink" title="需求8：【出海项目】sitemap与seo优化"></a>需求8：【出海项目】sitemap与seo优化</h2><blockquote>
<p><strong>什么是seo？</strong></p>
<p>搜索引擎优化，指的是通过合理手段和一些小技巧提升在谷歌上面的排名。这个出海项目最终要达到的效果是，在谷歌上查询一个公司，我们的界面要比这个公司靠前，从而获取自然流量，有了自然流量就可以变现了。<br>类似天眼查，每次去查询一个公司的官网，天眼查总能比官网靠前（其实也有可能是百度自家特殊关照）。</p>
<p><strong>什么是sitemap？</strong></p>
<p>sitemap.xml是一个站点地图，相当于给谷歌的爬虫一个指引，告诉他我的网站都有哪些路径需要你来访问的，这个地图一级只能有5w条，而我们的业务规模有6kw，所以采取两级索引，并采用gz进行压缩。<br>而我做的工作是定时更新这个sitemap并放到前端服务器上给爬虫来爬。</p>
</blockquote>
<h3 id="sitemap自底向上构建"><a href="#sitemap自底向上构建" class="headerlink" title="sitemap自底向上构建"></a>sitemap自底向上构建</h3><p>给了两张表，底层存公司，顶层存索引。我最初的想法是自底向上构建，每次更新去删除顶层，然后底层分页进行压缩，最后构建顶层。这样会有几个问题：</p>
<ol>
<li>深度分页问题：前面说了数据量最终大于6kw，如此大的数据量到了后面肯定更新不动的。想了半天索引优化最后mentor给否决了。</li>
<li>删表问题：数据库不允许传空参数直接删表，而且开销很大。</li>
<li>seo问题：虽然密集化了表但是可能会造成波动，例如某个公司的前几个失效了，这个公司变动到别的索引之下，可能会对seo产生影响，最好还是固定不变。</li>
</ol>
<h3 id="sitemap自顶向下构建"><a href="#sitemap自顶向下构建" class="headerlink" title="sitemap自顶向下构建"></a>sitemap自顶向下构建</h3><p>自顶向下构建就是直接算好id范围，数据库between一下就可以找到，把索引当作槽来用，填满了就放下一个。优点：</p>
<ol>
<li>没有深度分页问题，直接根据有索引的id查询，效率肯定是比limit高的。</li>
<li>一级索引满了就开辟一个新的，效率也高。</li>
</ol>
<p>缺点：</p>
<ol>
<li>依赖顺序性，稍微中间跨度大了就会有问题。例如首先存了1-100，再从40000-40100。每页100条，此时来了10000-10100就不能保证一级索引的顺序了。</li>
<li>一级索引的起始和终点会显得没有意义，中间有大量失效的，且不一定有序。</li>
</ol>
<p>最终采用了这种方式，es中的数据是不区分新旧的，所以得做一个唯一性校验。除此之外还有一个当前循环的唯一性校验。</p>
<ul>
<li>首先查询当前最大公司的id，通过AtomicInteger解决线程安全问题，从es来的新增数据加入，同时要校验是否是英文公司，并取出首字母。（这里写了一大堆字符串工具）</li>
<li>这样做了重复性校验的话即使是失败了也能保证不会重复。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getOpenCompanyIndex</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">        boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;summary.formatDomains&quot;</span>));</span><br><span class="line">        boolQuery.must(QueryBuilders.rangeQuery(<span class="string">&quot;emailCount&quot;</span>)</span><br><span class="line">                .gt(<span class="number">1</span>));</span><br><span class="line">        boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;detail.productList&quot;</span>));</span><br><span class="line">        boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;overviewDescription&quot;</span>));</span><br><span class="line">        boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;detail.sic&quot;</span>));</span><br><span class="line">        boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;detail.naics&quot;</span>));</span><br><span class="line">        boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;customsItems&quot;</span>));</span><br><span class="line"></span><br><span class="line">        boolQuery.mustNot(QueryBuilders.termQuery(<span class="string">&quot;disable&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>()</span><br><span class="line">                .query(boolQuery) <span class="comment">// 查询参数</span></span><br><span class="line">                .fetchSource(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;companyId&quot;</span>&#125;,</span><br><span class="line">                        <span class="literal">null</span>)</span><br><span class="line">                .size(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (openCompanyIndex == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;openCompanyIndex is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">SiteMapCompanyEntity</span> <span class="variable">maxCompany</span> <span class="operator">=</span> siteMapCompanyService.getMaxDataId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">maxDataId</span> <span class="operator">=</span> maxCompany == <span class="literal">null</span> ? <span class="number">1</span> : maxCompany.getDataId();</span><br><span class="line">        Set&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        openCompanyIndex.scrollSearch(sourceBuilder, searchHits -&gt; &#123;</span><br><span class="line">            List&lt;SiteMapCompanyEntity&gt; addList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">                Map&lt;String, Object&gt; result = searchHit.getSourceAsMap();</span><br><span class="line">                <span class="type">SiteMapCompanyEntity</span> <span class="variable">siteMapCompanyEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SiteMapCompanyEntity</span>();</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> result.get(<span class="string">&quot;name&quot;</span>).toString();</span><br><span class="line">                <span class="type">String</span> <span class="variable">companyId</span> <span class="operator">=</span> result.get(<span class="string">&quot;companyId&quot;</span>).toString();</span><br><span class="line">                <span class="comment">//本轮去重</span></span><br><span class="line">                <span class="keyword">if</span> (strings.contains(companyId)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                strings.add(companyId);</span><br><span class="line">                <span class="comment">//全局去重</span></span><br><span class="line">                LambdaQueryWrapper&lt;SiteMapCompanyEntity&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">                lambdaQueryWrapper.eq(SiteMapCompanyEntity::getCompanyId, companyId);</span><br><span class="line">                <span class="keyword">if</span> (siteMapCompanyService.count(lambdaQueryWrapper) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                siteMapCompanyEntity.setCompanyId(companyId);</span><br><span class="line">                <span class="comment">//保留原始名称</span></span><br><span class="line">                siteMapCompanyEntity.setCompanyName(name);</span><br><span class="line">                siteMapCompanyEntity.setChangeFreq(ChangeFreqEnum.WEEKLY.getCode());</span><br><span class="line">                siteMapCompanyEntity.setDataPriority(<span class="number">1f</span>);</span><br><span class="line">                siteMapCompanyEntity.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                siteMapCompanyEntity.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                siteMapCompanyEntity.setDataId(maxDataId + count.longValue());</span><br><span class="line">                <span class="comment">//非英语公司</span></span><br><span class="line">                <span class="keyword">if</span> (!StringUtil.checkEnglishChar(name))&#123;</span><br><span class="line">                    siteMapCompanyEntity.setNavLetter(<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> StringUtil.removeAllPattern(name);</span><br><span class="line">                    siteMapCompanyEntity.setNavLetter(temp.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase());</span><br><span class="line">                &#125;</span><br><span class="line">                count.getAndIncrement();</span><br><span class="line">                addList.add(siteMapCompanyEntity);</span><br><span class="line">            &#125;</span><br><span class="line">            siteMapCompanyService.saveBatch(addList);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(String.valueOf(count));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">        log.error(String.valueOf(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那怎么做生成的，根据公司的最大值最小值&#x2F;页面大小得到偏移量。根据这个偏移量去更新和查询，只关注最后一个索引块，如果没满就从这里开始加，更新最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">    preprocess();</span><br><span class="line">    <span class="type">SiteMapCompanyEntity</span> <span class="variable">maxCompany</span> <span class="operator">=</span> siteMapCompanyService.getMaxDataId();</span><br><span class="line">    <span class="type">SiteMapCompanyEntity</span> <span class="variable">minCompany</span> <span class="operator">=</span> siteMapCompanyService.getMinDataId();</span><br><span class="line">    <span class="keyword">if</span> (maxCompany == <span class="literal">null</span> || minCompany == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;CompletableFuture&lt;Void&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Long,String&gt; siteMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">long</span> <span class="variable">minDataId</span> <span class="operator">=</span> minCompany.getDataId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">maxDataId</span> <span class="operator">=</span> maxCompany.getDataId();</span><br><span class="line">    <span class="type">long</span> <span class="variable">pageLength</span> <span class="operator">=</span> (<span class="type">long</span>) Math.ceil((<span class="type">double</span>) (maxDataId - minDataId + <span class="number">1</span>) / PAGE_SIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= pageLength; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startDataId</span> <span class="operator">=</span> minDataId +  (i - <span class="number">1</span>) * PAGE_SIZE;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endDataId</span> <span class="operator">=</span> minDataId + i * PAGE_SIZE - <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">page</span> <span class="operator">=</span> i;</span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">gzip</span> <span class="operator">=</span> xmlCompanyMapGenerator.generateCompanyMap(startDataId, endDataId,page);</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.isEmpty(gzip)) &#123;</span><br><span class="line">                siteMap.put(page,gzip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, EXECUTOR);</span><br><span class="line">        futures.add(future);</span><br><span class="line">    &#125;</span><br><span class="line">    CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).join();</span><br><span class="line">    generateXML(siteMap);</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> siteMapTopService.count();</span><br><span class="line">    List&lt;SiteMapTopEntity&gt; insertList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> Math.max(<span class="number">1</span>,count); i &lt;= pageLength; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startDataId</span> <span class="operator">=</span> minDataId +  (i - <span class="number">1</span>) * PAGE_SIZE;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endDataId</span> <span class="operator">=</span> Math.min(minDataId + i * PAGE_SIZE - <span class="number">1</span>, maxDataId);</span><br><span class="line">        <span class="type">SiteMapTopEntity</span> <span class="variable">siteMapTopEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SiteMapTopEntity</span>();</span><br><span class="line">        siteMapTopEntity.setStartDataId(startDataId);</span><br><span class="line">        siteMapTopEntity.setEndDataId(endDataId);</span><br><span class="line"></span><br><span class="line">        siteMapTopEntity.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        siteMapTopEntity.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span> &amp;&amp; i == count)&#123;</span><br><span class="line">            LambdaUpdateWrapper&lt;SiteMapTopEntity&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">            updateWrapper.eq(SiteMapTopEntity::getName,siteMap.get(i));</span><br><span class="line">            siteMapTopService.update(siteMapTopEntity,updateWrapper);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        siteMapTopEntity.setName(siteMap.get(i));</span><br><span class="line">        insertList.add(siteMapTopEntity);</span><br><span class="line">    &#125;</span><br><span class="line">    siteMapTopService.saveBatch(insertList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一周首先上了3w数据，未来数据量大了肯定要分库分表的，以后的事情以后再说。</p>
<h2 id="需求9：【出海项目】一些零碎的小需求"><a href="#需求9：【出海项目】一些零碎的小需求" class="headerlink" title="需求9：【出海项目】一些零碎的小需求"></a>需求9：【出海项目】一些零碎的小需求</h2><h3 id="【接口】根据首字母和页码返回数据"><a href="#【接口】根据首字母和页码返回数据" class="headerlink" title="【接口】根据首字母和页码返回数据"></a>【接口】根据首字母和页码返回数据</h3><p>就是简单的分页问题，但是有一些字符串处理。我写了一大堆字符串工具。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PageResp&lt;CompanyUrlResp&gt; <span class="title function_">getCompanyUrl</span><span class="params">(String navLetter, Integer pageNum)</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;SiteMapCompanyEntity&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(navLetter)) &#123;</span><br><span class="line">        <span class="comment">//非英文国家</span></span><br><span class="line">        <span class="keyword">if</span> (navLetter.equals(<span class="string">&quot;Other&quot;</span>)) &#123;</span><br><span class="line">            queryWrapper.isNull(SiteMapCompanyEntity::getNavLetter);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!navLetter.matches(<span class="string">&quot;^[a-zA-Z]$&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERR.getName(), BizError.PARAM_ERR.getCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            queryWrapper.eq(SiteMapCompanyEntity::getNavLetter, navLetter.toUpperCase());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERR.getName(), BizError.PARAM_ERR.getCode());</span><br><span class="line">    &#125;</span><br><span class="line">    queryWrapper.eq(SiteMapCompanyEntity::getStatus, CompanyStatus.ACTIVE.getCode());</span><br><span class="line"></span><br><span class="line">    IPage&lt;SiteMapCompanyEntity&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageNum, COMPANY_URL_PAGE_SIZE);</span><br><span class="line">    IPage&lt;SiteMapCompanyEntity&gt; userPage = siteMapCompanyService.page(page, queryWrapper);</span><br><span class="line">    List&lt;SiteMapCompanyEntity&gt; userList = userPage.getRecords();</span><br><span class="line">    <span class="comment">//组装返回结果</span></span><br><span class="line">    PageResp&lt;CompanyUrlResp&gt; pageResp = <span class="keyword">new</span> <span class="title class_">PageResp</span>&lt;&gt;();</span><br><span class="line">    pageResp.setPageNo(pageNum);</span><br><span class="line">    pageResp.setPageSize(COMPANY_URL_PAGE_SIZE);</span><br><span class="line">    pageResp.setTotalPage(userPage.getPages());</span><br><span class="line">    pageResp.setTotalSize(userPage.getTotal());</span><br><span class="line">    pageResp.setContent(userList.stream().map(item -&gt; &#123;</span><br><span class="line">        <span class="type">CompanyUrlResp</span> <span class="variable">companyUrlResp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompanyUrlResp</span>();</span><br><span class="line">        companyUrlResp.setCompanyId(item.getCompanyId());</span><br><span class="line">        companyUrlResp.setCompanyName(StringUtil.firstLetterToUpperCaseByBlank(item.getCompanyName()));</span><br><span class="line">        <span class="keyword">if</span> (!StringUtil.checkEnglishChar(item.getCompanyName()))&#123;</span><br><span class="line">            companyUrlResp.setCompanyFormatName(<span class="string">&quot;Non-English-Company&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> StringUtil.formatCompanyNameToUrl(item.getCompanyName());</span><br><span class="line">            companyUrlResp.setCompanyFormatName(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> companyUrlResp;</span><br><span class="line">    &#125;).collect(Collectors.toList()));</span><br><span class="line">    <span class="keyword">return</span> pageResp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【接口】公司详情获取"><a href="#【接口】公司详情获取" class="headerlink" title="【接口】公司详情获取"></a>【接口】公司详情获取</h3><p>修改了mentor的一点逻辑，做了一点校验：</p>
<ul>
<li>因为查的是全球搜的数据，有可能未公开，校验只有开启的公司才能查询。</li>
<li>如果没有登录，domain隐蔽，这里看threadlocal有没有东西就好了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompanyBaseVO <span class="title function_">base</span><span class="params">(String companyId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!siteMapCompanyService.isOpeningCompany(companyId)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.NON_OPENING_COMPANY.getName(), BizError.NON_OPENING_COMPANY.getCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> host+<span class="string">&quot;/api/auth/global/overseas/base&quot;</span>;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;companyId&quot;</span>, companyId);</span><br><span class="line">        map.put(<span class="string">&quot;appKey&quot;</span>, appKey);</span><br><span class="line">        map.put(<span class="string">&quot;appSecret&quot;</span>, appSecret);</span><br><span class="line">        map.put(<span class="string">&quot;timestamp&quot;</span>, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        map = OpenApiUtil.packageSign(map, appKey, appSecret);</span><br><span class="line">        <span class="type">String</span> <span class="variable">resut</span> <span class="operator">=</span> OkHttpUtil.get(url, map);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(resut)) &#123;</span><br><span class="line">            <span class="comment">// 图片链接转换</span></span><br><span class="line">            resut = ImagePathConvert.convert(resut);</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSON.parseObject(resut);</span><br><span class="line">            <span class="type">String</span> <span class="variable">dataResult</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> loginAuth(JSON.parseObject(dataResult, CompanyBaseVO.class));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.info(<span class="string">&quot;demo error&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> CompanyBaseVO <span class="title function_">loginAuth</span><span class="params">(CompanyBaseVO companyBaseVO)</span>&#123;</span><br><span class="line">    <span class="type">UserInfoToken</span> <span class="variable">userInfoToken</span> <span class="operator">=</span> UserContext.getContent().getUserInfoToken();</span><br><span class="line">    <span class="comment">//未登录</span></span><br><span class="line">    <span class="keyword">if</span> (userInfoToken == <span class="literal">null</span>) &#123;</span><br><span class="line">        companyBaseVO.setDomain(<span class="string">&quot;*****&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> companyBaseVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/12/15/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week4/">网易牛马日志-week4</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-12-15
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="需求5：优化prompt"><a href="#需求5：优化prompt" class="headerlink" title="需求5：优化prompt"></a>需求5：优化prompt</h2><h3 id="1-提示词优化"><a href="#1-提示词优化" class="headerlink" title="1.提示词优化"></a>1.提示词优化</h3><blockquote>
<p>学习了prompt工程，主要的优化思路有（<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/QDzbfUkvSEalLxm3XX9rtA">参考连接</a>）：</p>
<ol>
<li>角色提示：“假设我是一个刚入行的电商买家”，类似这种可以将gpt带入角色，以该角色的视角进行输出</li>
<li>思维链提示：让gpt一步一步进行思考，例如计算1+2+3，先让gpt算出1+2&#x3D;3，然后再去算3+3&#x3D;6，有了思维链能够使ai清晰思考路径，犯错的可能性降低</li>
<li>思维树提示：跟上面的思维链比起来，思维树要考虑不同的分叉，在执行过程中要考虑不同的情况</li>
<li>自一致性提示：将模型的温度升高，多次去执行一个问题，返回其中最高频率的答案。对于推荐词的场景不太适用，因为调用次数有限而且时延较大，被mentor否决。</li>
<li>ReAct提示：用python的api进行调用，功能强大但用不了。<br>综合以上的方法，只有思维链可以作为优化。</li>
</ol>
</blockquote>
<ol>
<li>近似词：中译英</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String synonymsPrompt = MessageFormat.format(&quot;与\&quot;&#123;0&#125;\&quot;意思相近的产品有哪些，</span><br><span class="line">        请用&#123;1&#125;列举10个产品名。要求不包含\&quot;&#123;0&#125;\&quot;，</span><br><span class="line">        输出格式为：jsonArray&quot;, formatValue, language) + &quot;,[]&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String synonymsPrompt = MessageFormat.format(&quot;What are the products with the similar meaning of \&quot;&#123;0&#125;\&quot;,\n&quot; +</span><br><span class="line">        &quot;Please list 10 product names in &#123;1&#125;. My request is not to include \&quot;&#123;0&#125;\&quot;,\n&quot; +</span><br><span class="line">        &quot;The output format is jsonArray&quot;, formatValue, language) + &quot;,[]&quot;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>电商词：转为中文思维链</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String platformPrompt = MessageFormat.format(&quot;假设我是一个新入行的电商卖家，</span><br><span class="line">        主要经营的是\&quot;&#123;0&#125;\&quot;。我希望能有更多的用户在amazon.com等同类电商网站中搜索到我，</span><br><span class="line">        我可以使用怎样的&#123;1&#125;产品名对自己的产品进行描述？要求不包含\&quot;&#123;0&#125;\&quot;，</span><br><span class="line">        请去掉尽可能多的长尾词，提炼共同的产品描述词。帮我用&#123;2&#125;同义替换10个不同的产品描述。仅输出替换后的数据，</span><br><span class="line">        格式为：jsonArray&quot;, formatValue, language, language) + &quot;,[]&quot;;   </span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String platformPrompt = MessageFormat.format(&quot;请按照如下提示一步步推理：\n&quot; +</span><br><span class="line">        &quot;第一步，请将产品\&quot;&#123;0&#125;\&quot;从品牌、型号、材料、用途等方面进行扩展，尽量细分且具体到某个品牌的某个产品。\n&quot; +</span><br><span class="line">        &quot;第二步，思考该产品在amazon.com等同类电商网站中显示给用户的商品词是什么。\n&quot; +</span><br><span class="line">        &quot;第三步，提取商品词中的关键信息，不允许出现品牌和型号，长度严格限制在30个字母以内。\n&quot; +</span><br><span class="line">        &quot;综合以上三步，仅用&#123;1&#125;输出十个这样的产品名，要求不包含\&quot;&#123;0&#125;\&quot;格式为：jsonArray,[]&quot;, formatValue, language) + &quot;,[]&quot;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>行业词：中译英</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prompt = &quot;我是一个新入行的外贸供应商，主要经营的是&quot;+ formatValue +&quot;。我的产品可以应用于哪些行业的哪些产品？帮我列举3个行业，并描述推荐这些行业的理由，在每个行业下列举5个使用该产品制造出来的产品名称。\n&quot; +</span><br><span class="line">        &quot;用json输出，格式为：\n&quot; +</span><br><span class="line">        &quot;行业1\n&quot; +</span><br><span class="line">        &quot;行业名：xxx\n&quot; +</span><br><span class="line">        &quot;推荐理由：xxx\n&quot; +</span><br><span class="line">        &quot;相关产品：xxx\n&quot; +</span><br><span class="line">        &quot;要求：\n&quot; +</span><br><span class="line">        &quot;1、行业名称用&#123;&quot;+languageVersion+&quot;&#125;。\n&quot; +</span><br><span class="line">        &quot;2、推荐理由用&#123;&quot;+languageVersion+&quot;&#125;。\n&quot; +</span><br><span class="line">        &quot;3、相关产品用&#123;&quot;+language+&quot;&#125;。\n&quot; +</span><br><span class="line">        &quot;4、产品名称不能重复。\n&quot; +</span><br><span class="line">        &quot;5、产品名称不需要包含材质等限制。\n&quot; +</span><br><span class="line">        &quot;6、相关产品用#格开。&quot; +</span><br><span class="line">        &quot;7、不包含\&quot;&quot;+formatValue+&quot;\&quot;。&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prompt = &quot;I am a new foreign trade supplier, the main business is \&quot;&quot;+formatValue+&quot;\&quot;. Which products can my product be used in which industries? Give me a list of 3 industries and describe the reasons why you recommend them, and list 5 names of products made with that product under each industry.\n&quot; +</span><br><span class="line">        &quot;Output in json format:\n&quot; +</span><br><span class="line">        &quot; 行业1\n&quot; +</span><br><span class="line">        &quot; 行业名：xxx\n&quot; +</span><br><span class="line">        &quot; 推荐理由：xxx\n&quot; +</span><br><span class="line">        &quot; 相关产品：xxx\n&quot; +</span><br><span class="line">        &quot;Requirement: \&quot;\n&quot; +</span><br><span class="line">        &quot;1. the industry name with &#123;&quot;+languageVersion+&quot;&#125;.\n&quot; +</span><br><span class="line">        &quot;2. recommended reasons use &#123;&quot;+languageVersion+&quot;+&#125;.\n&quot; +</span><br><span class="line">        &quot;3. Use &#123;&quot;+language+&quot;&#125; for related products.\n&quot; +</span><br><span class="line">        &quot;4. the product name can not be repeated.\n&quot; +</span><br><span class="line">        &quot;5. the product name does not need to include material and other restrictions.\n&quot; +</span><br><span class="line">        &quot;6. related products are delimited with #\n&quot; +</span><br><span class="line">        &quot;7. \&quot;&quot;+formatValue+&quot;\&quot; is not included.&quot;;</span><br></pre></td></tr></table></figure>

<p>三个小小的优化耗费了我一周的时间，实际上也没多少提升。</p>
<h3 id="2-代码逻辑"><a href="#2-代码逻辑" class="headerlink" title="2.代码逻辑"></a>2.代码逻辑</h3><h4 id="近似词和电商词"><a href="#近似词和电商词" class="headerlink" title="近似词和电商词"></a>近似词和电商词</h4><ul>
<li>首先判断是否为空，或者是否为敏感词（调用网易易盾），随后传入用户信息，访问服务。</li>
<li>服务内部：传入参数中语言为空默认为英语，然后用CompletableFuture.supplyAsync()搭配线程池完成gpt的两次请求。线程池如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程工厂仅仅改名，拒绝策略是发起者自己消化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadFactory</span> <span class="variable">GPT_THREAD_FACTORY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;GptGrpcWrapper-gpt-pool-%d&quot;</span>).build();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">GPT_REQUEST_EXECUTOR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">20</span>,</span><br><span class="line">        <span class="number">40</span>, <span class="number">60</span> * <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">3000</span>), GPT_THREAD_FACTORY, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>

<ul>
<li>请求成功的结果缓存在redis中100天，缓存的key是”cacheKeyPreFix + “v6” + “:” + gptRecommendReqVO.getLanguage()+”:”+gptRecommendReqVO.getValue();”</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;String&gt; <span class="title function_">getRecommendWordV1</span><span class="params">(GptRecommendReqVO gptRecommendReqVO, AuthInfo authInfo, String prompt, String cacheKeyPreFix)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheValue</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(gptRecommendReqVO.getValue())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">formatValue</span> <span class="operator">=</span> FormatUtil.escapeFormat(gptRecommendReqVO.getValue());</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(formatValue) || formatValue.length()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;GptGrpcWrapper value:&#123;&#125;,formatValue:&#123;&#125;&quot;</span>,gptRecommendReqVO.getValue(),formatValue);</span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(gptRecommendReqVO.getLanguage()==<span class="literal">null</span>)&#123;</span><br><span class="line">            gptRecommendReqVO.setLanguage(<span class="string">&quot;英语&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">language</span> <span class="operator">=</span> gptRecommendReqVO.getLanguage();</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> cacheKeyPreFix + <span class="string">&quot;v6&quot;</span> + <span class="string">&quot;:&quot;</span> + gptRecommendReqVO.getLanguage()+<span class="string">&quot;:&quot;</span>+gptRecommendReqVO.getValue();</span><br><span class="line">        cacheValue = recommendWordCache.get(cacheKey);</span><br><span class="line">        <span class="comment">//命中</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotBlank(cacheValue))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;GptGrpcWrapper call success,param:&#123;&#125;,result:&#123;&#125;&quot;</span>,JSON.toJSONString(gptRecommendReqVO),cacheValue);</span><br><span class="line">            <span class="comment">//大段文字中的[&quot;xxx1&quot;,&quot;xxx2&quot;,&quot;xxx3&quot;]</span></span><br><span class="line">            <span class="keyword">if</span>(cacheValue.contains(<span class="string">&quot;[&quot;</span>) &amp;&amp; cacheValue.contains(<span class="string">&quot;]&quot;</span>))&#123;</span><br><span class="line">                cacheValue = cacheValue.substring(cacheValue.indexOf(<span class="string">&quot;[&quot;</span>), cacheValue.lastIndexOf(<span class="string">&quot;]&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只取前6个，这个数值是前端定的</span></span><br><span class="line">            Set&lt;String&gt; synonyms = getLimitSize(Lists.newArrayList(JSON.parseArray(cacheValue, String.class)), gptRecommendReqVO.getSize());</span><br><span class="line">            <span class="keyword">return</span> synonyms;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//未命中</span></span><br><span class="line">        log.info(<span class="string">&quot;GptGrpcWrapper call param:&#123;&#125;,prompt:&#123;&#125;&quot;</span>,JSON.toJSONString(gptRecommendReqVO),prompt);</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(</span><br><span class="line">                () -&gt; gptRequest(authInfo.getOrgId(),authInfo.getAccId(),authInfo.getEmail(),prompt, GPTModelVersionEnum.GPT_4O_MINI.getVersion()), GPT_REQUEST_EXECUTOR);</span><br><span class="line">        <span class="comment">//这里实际上还是同步请求，&quot;gpt-recommard-future&quot;是一个日志的名称，超时时间120s</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> (String)FutureResultUtil.getResult(<span class="string">&quot;gpt-recommard-future&quot;</span>,future,<span class="number">120</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(res)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;getRecommend failed.name:&#123;&#125;,language:&#123;&#125;&quot;</span>,formatValue, language);</span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        cacheValue = res;</span><br><span class="line">        <span class="comment">// 推荐词缓存100天</span></span><br><span class="line">        recommendWordCache.set(cacheKey,cacheValue,TimeUnit.DAYS.toMillis(<span class="number">100</span>));</span><br><span class="line">        log.info(<span class="string">&quot;GptGrpcWrapper call success,param:&#123;&#125;,result:&#123;&#125;&quot;</span>,JSON.toJSONString(gptRecommendReqVO),cacheValue);</span><br><span class="line">        <span class="keyword">if</span>(cacheValue.contains(<span class="string">&quot;[&quot;</span>) &amp;&amp; cacheValue.contains(<span class="string">&quot;]&quot;</span>))&#123;</span><br><span class="line">            cacheValue = cacheValue.substring(cacheValue.indexOf(<span class="string">&quot;[&quot;</span>), cacheValue.lastIndexOf(<span class="string">&quot;]&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; synonyms = getLimitSize(Lists.newArrayList(JSON.parseArray(cacheValue, String.class)), gptRecommendReqVO.getSize());</span><br><span class="line">        <span class="keyword">return</span> synonyms;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//gpt出的词如果不常规。例如是“好的，接下来为您输出....”，在JSON.parseArray就会报异常不返回给前端。</span></span><br><span class="line">        log.error(<span class="string">&quot;getGptRecommend param:&#123;&#125;&quot;</span>,JSON.toJSONString(gptRecommendReqVO), e);</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>redis只存gpt原始回答，可以改成处理后的回答</li>
<li>线程池实际上只将近似词和电商词做了异步，在这两个单独的请求里面用future实际还是同步。</li>
<li>gpt如果输出不理想有两重处理，首先看是否包含了”[“xxx1”,”xxx2”,”xxx3”]”，用subString提取出来，实在是没有那在parseObject就会报错，结果返回为空。</li>
</ol>
</blockquote>
<ul>
<li>最后处理近似词和电商词的结果，用一个大的hashset去重（但是大小写敏感，这里可以优化成全部小写再比较）</li>
<li>调用GRPC（有道翻译）兜底，先判断是否出现中文，有中文就翻译。批量翻译返回值是map，key是原文，value是翻译后的。最后进行组装返回。</li>
</ul>
<p><strong>总结：调用易盾进行敏感词检测，线程池+CompletableFuture完成两次gpt查询，gpt查询做了一系列异常处理，在redis中缓存100天，最后调用有道翻译的grpc进行兜底。</strong></p>
<h4 id="行业词"><a href="#行业词" class="headerlink" title="行业词"></a>行业词</h4><ul>
<li>首先判断是否为空，或者是否为敏感词（调用网易易盾），随后传入用户信息，访问服务。</li>
<li>服务内部：处理逻辑跟上文类似，在redis中存储gpt原始回答，但是由于输出的是json，相比于近似词和行业词的数组，这里有改变。</li>
<li>去除”```json”和”```“这类md语法，再根据”行业一，二，三”json形式包装。</li>
<li>这里要做一些异常处理以增加可用性和鲁棒性，虽然提示词里面写的是用”#“隔开，但是实际上可能返回的还是”,”或者”、”，用一个函数对其进行拆分。</li>
<li>最后调用有道翻译兜底。</li>
</ul>
<h2 id="需求6：订阅更新任务"><a href="#需求6：订阅更新任务" class="headerlink" title="需求6：订阅更新任务"></a>需求6：订阅更新任务</h2><p>订阅更新链路：</p>
<ol>
<li>用户前端点击页面就会更新订阅公司的watchTime字段，一天之内只更新一次。</li>
<li>xxljob每周扫库，搜索的是订阅公司的那个表，将watchTime在前一周的公司发送kafka（自增id而不是公司id）</li>
<li>kafka消费者拿到这些id去数据库找对应的公司，将订阅公司表项和公司实体项（从es来的，如果前者有companyId就直接查询，如果没有就需要根据名字和地区来查询并保存）作为参数传分别分析<strong>facebook信息，facebook提及信息，海关信息，联系人信息</strong>，开了一个线程池并行处理这些。</li>
</ol>
<h3 id="1-facebook信息"><a href="#1-facebook信息" class="headerlink" title="1.facebook信息"></a>1.facebook信息</h3><p>代码太长了，梳理一下就这几部分：</p>
<ol>
<li>根据公司实体中的相关facebook链接去请求GRPC接口，返回facebook实体，其中包含个人信息，点赞数量，最近推文等信息。</li>
<li>从这里开始要注意逻辑，比对的是<strong>GRPC请求来的数据</strong>和<strong>当前数据库中最新的log</strong>。</li>
<li>去数据库中查询7种type的log，先全部查出来，然后再通过stream和sort得到最近时间的log。</li>
<li>将这些log分别与GRPC请求来的数据进行比较，例如判断facebook是否更新了，将最近的一条相关log的内容拉出来与GRPC请求来的数据进行比较，如果不一样就需要更新，在库里面新增一条。</li>
</ol>
<blockquote>
<ol>
<li>facebook地址初始化&#x2F;变更</li>
<li>facebook邮箱初始化&#x2F;变更</li>
<li>facebook网站地址初始化&#x2F;变更</li>
<li>facebook电话初始化&#x2F;变更</li>
<li>facebook点赞、关注初始化</li>
<li>facebook中发布了新帖子</li>
<li>facebook获得1个新评论</li>
</ol>
</blockquote>
<h3 id="2-facebook提及信息"><a href="#2-facebook提及信息" class="headerlink" title="2.facebook提及信息"></a>2.facebook提及信息</h3><ol>
<li>类似上面的，提及消息也是从GRPC来的，如果返回为null直接返回，这里是一个list，只关注最新的，所以也有stream+sort。</li>
<li>去数据库查询当前最新的log，主要关注的是这个记录的createTime。</li>
<li>如果数据库没有，那就说明是最新更新的，向数据库插入一条新的log表明有被提及，直接返回。</li>
<li>如果数据库有但log的时间比GRPC来的早，说明有新提及，进行更新。</li>
</ol>
<h3 id="3-海关信息"><a href="#3-海关信息" class="headerlink" title="3.海关信息"></a>3.海关信息</h3><ol>
<li>将公司名称格式化，随后去海关数据里面查找新增进出口数据，分别放在两个list里面。</li>
<li>如果有进出口就分别新增log。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customProcess</span><span class="params">(TbGlobalCollectEntity record, CompanySearchBO companyBO, Date startDate, Date endDate)</span> &#123;</span><br><span class="line">    <span class="comment">//海关那边的统一格式&quot;CompanyName-COMBINE-TANZANIA&quot;例如&quot;101 INVESTMENT-COMBINE-TANZANIA&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">nameAndCountry</span> <span class="operator">=</span> CompanyFormatUtils.combineCompanyNameAndCountry(companyBO.getName(), companyBO.getCountry());</span><br><span class="line">    <span class="comment">//去取出昨天的新增hscode，这个表主要是海关系统在维护</span></span><br><span class="line">    Map&lt;String, CustomInfoBO&gt; map = customDataComponent.batchGetCompanyNewTrxHscode(Lists.newArrayList(nameAndCountry), startDate, endDate);</span><br><span class="line">    List&lt;TbGlobalCollectLogEntity&gt; tbGlobalCollectLogEntities = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(nameAndCountry))&#123;</span><br><span class="line">        <span class="type">CustomInfoBO</span> <span class="variable">customInfoBO</span> <span class="operator">=</span> map.get(nameAndCountry);</span><br><span class="line">        <span class="comment">//出口</span></span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(customInfoBO.getExportHsCodeList()))&#123;</span><br><span class="line">            <span class="type">TbGlobalCollectLogEntity</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TbGlobalCollectLogEntity</span>();</span><br><span class="line">            t.setCollectId(record.getId());</span><br><span class="line">            t.setLogDesc(<span class="string">&quot;新供应了hscode为&quot;</span> + Strings.join(customInfoBO.getExportHsCodeList(), <span class="string">&quot;,&quot;</span>) + <span class="string">&quot;等的商品&quot;</span>);</span><br><span class="line">            t.setContent(JSON.toJSONString(customInfoBO.getExportHsCodeList()));</span><br><span class="line">            t.setType(CollectLogTypeEnum.CUSTOM_SHN.getType());</span><br><span class="line">            t.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            t.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            t.setInit12(<span class="number">0</span>);</span><br><span class="line">            tbGlobalCollectLogEntities.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进口</span></span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(customInfoBO.getImportHsCodeList()))&#123;</span><br><span class="line">            <span class="type">TbGlobalCollectLogEntity</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TbGlobalCollectLogEntity</span>();</span><br><span class="line">            t.setCollectId(record.getId());</span><br><span class="line">            t.setLogDesc(<span class="string">&quot;新采购了hscode为&quot;</span> + Strings.join(customInfoBO.getImportHsCodeList(), <span class="string">&quot;,&quot;</span>) + <span class="string">&quot;等的商品&quot;</span>);</span><br><span class="line">            t.setContent(JSON.toJSONString(customInfoBO.getImportHsCodeList()));</span><br><span class="line">            t.setType(CollectLogTypeEnum.CUSTOM_CON.getType());</span><br><span class="line">            t.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            t.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            t.setInit12(<span class="number">0</span>);</span><br><span class="line">            tbGlobalCollectLogEntities.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!CollectionUtils.isEmpty(tbGlobalCollectLogEntities))&#123;</span><br><span class="line">        tbGlobalCollectLogEntityService.saveAll(tbGlobalCollectLogEntities);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-联系人信息"><a href="#4-联系人信息" class="headerlink" title="4.联系人信息"></a>4.联系人信息</h3>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/12/05/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week3/">网易牛马日志-week3</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-12-05
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="需求3：优化应用侧分页查询收藏接口"><a href="#需求3：优化应用侧分页查询收藏接口" class="headerlink" title="需求3：优化应用侧分页查询收藏接口"></a>需求3：优化应用侧分页查询收藏接口</h1><p>利用上watchTime字段，xxljob只更新上一周查看过的条目，可以减少带宽。</p>
<h2 id="1-改造判断逻辑"><a href="#1-改造判断逻辑" class="headerlink" title="1.改造判断逻辑"></a>1.改造判断逻辑</h2><p>保存watchTime，首先需要获得该用户的accountId，还要获取某一条推荐对象的旧watchTime，判断是否是今天，如果是一天那就不用更新，如果是一天就需要更新。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!pageRes.getContent().isEmpty())&#123;</span><br><span class="line">    Date oldWatchTime = pageRes.getContent().get(0).getWatchTime();</span><br><span class="line">    watchTimeJudgeAndUpdate(Long.parseLong(AuthInfoUtils.getContext().getAuthInfo().getAccId()),oldWatchTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个方法按道理来说要变成异步的，看后续用多线程或者@Async解决</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">watchTimeJudgeAndUpdate</span><span class="params">(Long accountId,Date oldWatchTime)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//一天只保存一次watchTime</span></span><br><span class="line">        <span class="keyword">if</span> (oldWatchTime == <span class="literal">null</span> || !isSameDay(oldWatchTime,<span class="keyword">new</span> <span class="title class_">Date</span>()))&#123;</span><br><span class="line">            tbGlobalCollectEntityService.updateWatchTime(accountId);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;watchTimeUpdate success , accountId : &#123;&#125;&quot;</span>,accountId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;watchTimeUpdate failed , accountId : &#123;&#125;&quot;</span>,accountId,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSameDay</span><span class="params">(Date date1, Date date2)</span> &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sdf.format(date1).equals(sdf.format(date2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里刚开始是用了jpa的抽象仓库一个一个更新，但是mentor说效率太低了，不如直接写sql，在这个方法里面支持跟mybatis那样直接执行sql。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TbGlobalCollectEntityService</span> <span class="keyword">extends</span> <span class="title class_">AbstractEasyEntityService</span>&lt;TbGlobalCollectEntity&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TbGlobalCollectRepository repository;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWatchTime</span><span class="params">(Long accountId)</span>&#123;</span><br><span class="line">        repository.updateWatchTime(accountId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sql是更新所有当前accountId下，没有取消掉的推荐条目，把他们的watchTime都改为现在。</p>
<p>这里不需要返回当前时间，就更加说明这个判断逻辑跟前端没什么关系了，所以应该用异步。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Modifying</span><br><span class="line">@Transactional</span><br><span class="line">@Query(value = &quot;update TbGlobalCollectEntity p set p.watchTime=NOW() where p.status != -1 and p.accountId = :accountId&quot;)</span><br><span class="line">int updateWatchTime(@Param(&quot;accountId&quot;) Long accountId);</span><br></pre></td></tr></table></figure>

<h2 id="2-xxljob改造"><a href="#2-xxljob改造" class="headerlink" title="2.xxljob改造"></a>2.xxljob改造</h2><p>保存了watchTime，每周执行一次的定时任务需要改成查询所有watchTime为上周的条目。</p>
<p>DateUtil这个工具可以找到今天0点和上周0点的Date对象，然后再用jpa进行查询，把所有的数据投入kafka里。</p>
<blockquote>
<p>优化的本意是减少部分挖掘facebook的流量。但是因为在这个topic里面不止有这个任务，还有部分通讯录挖掘的任务。减少了这部分流量同时也会减少通讯录挖掘的流量，但是后者更加有价值，并不应该减少。所以按照道理来说应该分为两个topic进行操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collectLogUpdate</span><span class="params">(<span class="type">int</span> param)</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">endDate</span> <span class="operator">=</span> DateUtil.trimAndIncreDate(<span class="keyword">new</span> <span class="title class_">Date</span>(),<span class="number">0</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">startDate</span> <span class="operator">=</span> DateUtil.trimAndDecreDate(<span class="keyword">new</span> <span class="title class_">Date</span>(), param);</span><br><span class="line">    List&lt;Specification&lt;TbGlobalCollectEntity&gt;&gt; specifications = Lists.newArrayList();</span><br><span class="line">    specifications.add(of(TbGlobalCollectEntity.class, <span class="string">&quot;status&quot;</span>, NEQ, GlobalSubscribeStatusEnum.DELETE.getStatus()));</span><br><span class="line">    specifications.add(of(TbGlobalCollectEntity.class, <span class="string">&quot;watchTime&quot;</span>, GTE, startDate));</span><br><span class="line">    specifications.add(of(TbGlobalCollectEntity.class, <span class="string">&quot;watchTime&quot;</span>, LTE, endDate));</span><br><span class="line">    List&lt;TbGlobalCollectEntity&gt; records = tbGlobalCollectEntityService.findAll(specifications);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(records)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (TbGlobalCollectEntity record : records) &#123;</span><br><span class="line">        kafkaProducer.send(KafkaConstants.COWORK_GLOBAL_COLLECT_DETAIL_CHANGE, String.valueOf(record.getId()), String.valueOf(record.getId()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="需求4：查验500条数据"><a href="#需求4：查验500条数据" class="headerlink" title="需求4：查验500条数据"></a>需求4：查验500条数据</h2><p>这个的工作量不在代码上而在于excel上，学到了一些技巧。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GET cowork_global_domain_info/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot; must &quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;exists&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;recommendData&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ,&quot;sort&quot;: &#123;</span><br><span class="line">    &quot;_script&quot;: &#123;</span><br><span class="line">      &quot;script&quot;: &quot;Math.random()&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;number&quot;,</span><br><span class="line">      &quot;order&quot;: &quot;asc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ,&quot;_source&quot;: [&quot;recommendData&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的点：</p>
<ol>
<li>随机从917w中找，这里sort要用random脚本</li>
<li>最好不要用滚动查询，有多少条是多少条</li>
<li>searchHit对象是一个大的对象DomainIndexBO，recommendData只是其中的一个字段。所以getSourceAsString包装的是DomainIndexBO，刚开始类型转换没弄明白耽误很久。</li>
<li>excel小技巧：在这种需要保留很多字段的时候可以用￥(dollar符)分开，因为很少有业务里面会用，防止误操作。例如在这个场景里面日志可以打印成”{recommendData.domain}￥{recomendData.other}”，然后在excel按照￥分行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">esGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Script</span> <span class="variable">script</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Script</span>(<span class="string">&quot;Math.random()&quot;</span>);</span><br><span class="line">    <span class="type">ScriptSortBuilder</span> <span class="variable">sortBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptSortBuilder</span>(script, ScriptSortBuilder.ScriptSortType.NUMBER)</span><br><span class="line">            .order(SortOrder.ASC);</span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;recommendData&quot;</span>));</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>()</span><br><span class="line">            .query(boolQuery) <span class="comment">// 查询参数</span></span><br><span class="line">            .fetchSource(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;recommendData&quot;</span>&#125;, <span class="literal">null</span>)</span><br><span class="line">            .sort(sortBuilder)</span><br><span class="line">            .size(<span class="number">500</span>);</span><br><span class="line">    SearchHit[] searchHits = domainDataIndex.query(sourceBuilder);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">        <span class="type">DomainIndexBO</span> <span class="variable">domainIndexBO</span> <span class="operator">=</span> JSON.parseObject(searchHit.getSourceAsString(),DomainIndexBO.class);</span><br><span class="line">        <span class="type">RecommendDataBO</span> <span class="variable">recommendData</span> <span class="operator">=</span> domainIndexBO.getRecommendData();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        stringBuilder.append(recommendData.getDomain()).append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        stringBuilder.append(String.join(<span class="string">&quot;,&quot;</span>, recommendData.getProducts())).append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (recommendData.getAliCategories().isEmpty())&#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (RecommendDataBO.AliCategory aliCategory : recommendData.getAliCategories()) &#123;</span><br><span class="line">                stringBuilder.append(aliCategory.getName()).append(<span class="string">&quot;:&quot;</span>).append(aliCategory.getScore()).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stringBuilder.append(<span class="string">&quot;$&quot;</span>).append(recommendData.getIsBizP()).append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        stringBuilder.append(recommendData.getIsBizVersion()).append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        stringBuilder.append(recommendData.getProductsVersion()).append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(recommendData.getAliCategoryVersion()))&#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            stringBuilder.append(recommendData.getAliCategoryVersion());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> stringBuilder.toString();</span><br><span class="line">        log.info(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;个:&quot;</span>+result);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>。。。未完待续</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/12/02/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week1-2/">网易牛马日志-week1-2</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-12-02
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="需求1：与推荐侧数据同步"><a href="#需求1：与推荐侧数据同步" class="headerlink" title="需求1：与推荐侧数据同步"></a>需求1：与推荐侧数据同步</h1><h2 id="1-配置kafka"><a href="#1-配置kafka" class="headerlink" title="1.配置kafka"></a>1.配置kafka</h2><p>kafka批量消费，设置消费者组，使得每次消费的时候从头消费</p>
<blockquote>
<p>消费者组能从头开始消费必须得有消息，也就是说如果消息过期了还是消费不了的，这个过期时间在delete.retention.ms里面配置，当前topic的过期时间是604800000，也就是一个礼拜。</p>
<p>还有一种办法是通过kafka给定的某个脚本参数来指定offset的消费位置。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, String&gt;&gt;</span><br><span class="line"><span class="title function_">recommendDomainDataListenerContainer</span><span class="params">(KafkaProperties kafkaProperties)</span> &#123;</span><br><span class="line">    ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = <span class="keyword">new</span> <span class="title class_">ConcurrentKafkaListenerContainerFactory</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Object&gt; map = kafkaProperties.buildConsumerProperties();</span><br><span class="line">    <span class="comment">//批量消费50个</span></span><br><span class="line">    map.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, <span class="number">50</span>);</span><br><span class="line">    map.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">    map.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, <span class="number">3000</span>); <span class="comment">// 3秒上报一次心跳</span></span><br><span class="line">    map.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">    map.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">&quot;earliest&quot;</span>);<span class="comment">//消费者组每次都从头开始消费</span></span><br><span class="line">    ConsumerFactory&lt;String, String&gt; consumerFactory = <span class="keyword">new</span> <span class="title class_">DefaultKafkaConsumerFactory</span>&lt;&gt;(map);</span><br><span class="line">    factory.setConsumerFactory(consumerFactory);</span><br><span class="line">    factory.setConcurrency(<span class="number">2</span>); <span class="comment">// 2个线程</span></span><br><span class="line">    factory.setBatchListener(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-配置kafka的消费者"><a href="#2-配置kafka的消费者" class="headerlink" title="2.配置kafka的消费者"></a>2.配置kafka的消费者</h2><p>由于是批量请求rpc接口，因此需要解决请求失败带来的<strong>消息丢失</strong>问题，意思是如果请求失败了，这些domain还会被消费，这里的思路是用一个set来保存没有消费的domain，如果在某处出错了，就会重新往kafka里面发消息，实现不漏消息。</p>
<blockquote>
<p>2024.12.2 在这上面栽了跟头</p>
<p>想法很美好但是实际上线还是出现了漏消息，成功率只有90%。</p>
<p>首先这个domainSet不能设置成全局变量，因为所有的线程都会更改这个变量，会有复杂的并发安全问题。其次是可能出现异常的时间点：</p>
<ul>
<li>消费的时候就出现问题，可能性很小</li>
<li>拿着所有50条去请求rpc接口的时候</li>
<li>rpc接口失败或者别的状态码</li>
<li>es更新出错</li>
</ul>
<p>由此可见需要在rpc接口请求之前就要初始化domainSet，所以在消费消息的时候就需要同时加入domainSet。但如果rpc接口请求成功了，需要清空domainSet，为什么呢？因为有可能domain是50个，那边只有40个可返回域名，如果再按照50个就会有消息被重复发送，例如虽然消息里面有<a target="_blank" rel="noopener" href="http://www.baidu.com,但是rpc接口里面死活没有,这个时候再去重新往kafka里面投重新消费是不合适的,所以在这里需要遍历response,然后保存进清空了的domainset里面./">www.baidu.com，但是rpc接口里面死活没有，这个时候再去重新往kafka里面投重新消费是不合适的，所以在这里需要遍历response，然后保存进清空了的domainSet里面。</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener(</span></span><br><span class="line"><span class="meta">        //这里是&#123;&#125;，可以配置多个topic</span></span><br><span class="line"><span class="meta">        topics = &#123;TOPIC&#125;,</span></span><br><span class="line"><span class="meta">        groupId = &quot;recommendation-ready-group-bugfix-v1&quot;,</span></span><br><span class="line"><span class="meta">        containerFactory = &quot;recommendDomainDataListenerContainer&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(List&lt;ConsumerRecord&lt;String, String&gt;&gt; records)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;RecommendDomainDataListener | size:&#123;&#125;&quot;</span>, records.size());</span><br><span class="line">    Set&lt;String&gt; domains = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; domainSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StopWatch</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">    sw.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(ConsumerRecord&lt;String, String&gt; record :records) &#123;</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">kafkaMsg</span> <span class="operator">=</span> JSON.parseObject(record.value());</span><br><span class="line">            <span class="type">String</span> <span class="variable">domain</span> <span class="operator">=</span> kafkaMsg.getString(<span class="string">&quot;domain&quot;</span>);</span><br><span class="line">            domain = DomainUtil.format(domain);</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isBlank(domain)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            domains.add(domain);</span><br><span class="line">            domainSet.add(domain);</span><br><span class="line">        &#125;</span><br><span class="line">        batchGetRecommendationDetail(domains,domainSet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">        <span class="keyword">for</span> (String domain : domainSet)&#123;</span><br><span class="line">            Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;domain&quot;</span>,domain);</span><br><span class="line">            kafkaProducer.send(TOPIC, domain, JSON.toJSONString(map));</span><br><span class="line">        &#125;</span><br><span class="line">        log.error(<span class="string">&quot;RecommendDomainDataListener | consumer message error. put in queue &#123;&#125;.&quot;</span>, JSON.toJSONString(domains),e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        sw.stop();</span><br><span class="line">        log.info(<span class="string">&quot;RecommendDomainDataListener | &#123;&#125;, cost: &#123;&#125;&quot;</span>, domains.size(), sw.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-GRPC请求"><a href="#3-GRPC请求" class="headerlink" title="3.GRPC请求"></a>3.GRPC请求</h2><p>grpc是让远程方法变得像本地方法一样简单，这里用了推荐侧的一个接口，确实只用引用一个jar包就行，背后就是一些复杂的网络请求。这个接口的可以一次传50个domain，状态码主要关注429，这里是触发了限流，需要按照上面的方法进行重新消费，消费多少发送多少相同的域名。</p>
<blockquote>
<p>grpc方法的qps是1，触发了限流要降速，Thread.sleep(1000);</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchGetRecommendationDetail</span><span class="params">(Set&lt;String&gt; domains,Set&lt;String&gt; domainSet)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Recommendation.<span class="type">GetDomainInfosRequest</span> <span class="variable">request</span> <span class="operator">=</span> Recommendation.GetDomainInfosRequest.newBuilder()</span><br><span class="line">            .addAllDomains(domains)</span><br><span class="line">            .setDomainSourceValue(DOMAIN_SOURCE_GRPC_VALUE).build();</span><br><span class="line">    Recommendation.<span class="type">GetDomainInfosResponse</span> <span class="variable">response</span> <span class="operator">=</span> recommendationClient.getDomainInfos(request);</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!response.getSuccess() || response.getCode() != GRPC_SUCCESS_CODE)&#123;</span><br><span class="line">            <span class="comment">//触发grpc限流，该方法降速，重新消费</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.valueOf(response.getCode()));</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;getRecommendationDetail. code:&#123;&#125;&quot;</span>,response.getCode());</span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(response.getDataList()))&#123;</span><br><span class="line">            List&lt;Recommendation.DomainInfo&gt; domainInfoList = response.getDataList();</span><br><span class="line">            <span class="keyword">for</span> (Recommendation.DomainInfo domainInfo : domainInfoList)&#123;</span><br><span class="line">                domainSet.add(domainInfo.getDomain());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Recommendation.DomainInfo domainInfo : domainInfoList)&#123;</span><br><span class="line">                convert(domainInfo,domainSet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Recommendation.GetDomainInfosResponse returns null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-转换对象"><a href="#4-转换对象" class="headerlink" title="4.转换对象"></a>4.转换对象</h2><p>这个没什么好说的，就是拷贝属性到当前项目的bean</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要熟悉了测试环境和线上环境，以及kafka的一些配置和机制，对于异常处理的理解加深了。</p>
<h1 id="需求2：定时发送新域名"><a href="#需求2：定时发送新域名" class="headerlink" title="需求2：定时发送新域名"></a>需求2：定时发送新域名</h1><p>需要每天的00:00去es里面检查昨天新增的域名，通过kafka发送消息。</p>
<ol>
<li>计算昨天00:00到23：59的时间戳：由于字段里面只有updateTime没有createTime，而且也是用时间戳来保存的，要先计算一下时间。</li>
<li>拼es的查询语句：range来查询时间，synFlag是防止重复发送的，有这个字段的可以认为已经发过了。</li>
<li>scrollSearch循环查找，不了解，但是大家都是这样用的。</li>
</ol>
<blockquote>
<p>es的操作跟数据库很像，而且网易封装的很好，index就相当于数据库表名，DomainDataIndex可以看作mybatis的实现类，AbstractIndex就是BaseMapper那种用来基础的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;newDomainSyncRecommend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">newDomainSyncRecommend</span> <span class="params">(String param)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="comment">//昨天的同一时刻</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">yesterday</span> <span class="operator">=</span> System.currentTimeMillis() - <span class="number">1000</span> * <span class="number">3600</span> * <span class="number">24</span>;</span><br><span class="line">    <span class="comment">//昨天零点零分零秒的毫秒数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">zero</span> <span class="operator">=</span> yesterday / (<span class="number">1000</span> * <span class="number">3600</span> * <span class="number">24</span>) * (<span class="number">1000</span> * <span class="number">3600</span> * <span class="number">24</span>) - TimeZone.getDefault().getRawOffset();<span class="comment">//今天零点零分零秒的毫秒数</span></span><br><span class="line">    <span class="comment">//昨天23点59分59秒的毫秒数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">twelve</span> <span class="operator">=</span> zero + <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">&quot;updateTime&quot;</span>)</span><br><span class="line">            .gte(zero)</span><br><span class="line">            .lte(twelve));</span><br><span class="line">    boolQuery.mustNot(QueryBuilders.existsQuery(<span class="string">&quot;synFlag&quot;</span>));</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>()</span><br><span class="line">            .query(boolQuery) <span class="comment">// 查询参数</span></span><br><span class="line">            .fetchSource(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;domain&quot;</span>&#125;,</span><br><span class="line">                    <span class="literal">null</span>)</span><br><span class="line">            .size(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (domainDataIndex == <span class="literal">null</span>) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;domainDataIndex is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    domainDataIndex.scrollSearch(sourceBuilder, searchHits -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">domain</span> <span class="operator">=</span> searchHit.getId();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//更新同步标识</span></span><br><span class="line">                Map&lt;String,Boolean&gt; updateMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                updateMap.put(<span class="string">&quot;synFlag&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">                domainDataIndex.updateByProcessor(domain,updateMap);</span><br><span class="line">                log.info(<span class="string">&quot;domainDataIndex upsert success ,domain : &#123;&#125;&quot;</span>,domain);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">                log.error(<span class="string">&quot;domainDataIndex upsert failed ,domain : &#123;&#125;&quot;</span>,domain,e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//组织kafka消息</span></span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">            jsonObject.put(<span class="string">&quot;domain&quot;</span>,domain);</span><br><span class="line">            kafkaProducer.send(<span class="string">&quot;new_domain_sync_recommend_topic&quot;</span>,domain,JSON.toJSONString(jsonObject));</span><br><span class="line">            log.info(<span class="string">&quot;kafka send success ,domain : &#123;&#125;&quot;</span>,domain);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/10/19/%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/">项目面试</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-10-19
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="登录流程和登录状态保存"><a href="#登录流程和登录状态保存" class="headerlink" title="登录流程和登录状态保存"></a>登录流程和登录状态保存</h2><ul>
<li>乘客登录：首先根据前端微信小程序传来的code进行乘客openid的解析，根据这个openid进行落库。在我们的项目中不会对外暴露这个openid，使用的是自己系统的自增id。如果没有注册就insert一条。接着用redis存储登录状态，key是UUID，value是自己数据库的自增id。我们这里用的aop+threadlocal+注解类似网关的prehandle，处理前端每次都携带的token字段，然后在redis里根据这个key进行查询，如果是没有这个key就是没有登录过期了，如果是key为空就是没有登录。然后根据redis里的这个value存储到threadlocal中，后续就可以从threadlocal中get这个字段进行操作。</li>
<li>司机登录：流程与上面的类似，只不过多了阿里云的身份校验。</li>
</ul>
<p><strong>threadLocal的原理</strong></p>
<p>threadlocal是根据线程独立的变量，也就是说每一个线程可以存储不同的threadlocal，彼此是隔离的。其原理是每一个Thread类都有一个threadLocalMap，这个map相当于一个hashmap，key是threadLocal对象，value是存储的值。threadLocal查询的时候就会先获取当前线程，根据这个线程找到threadLocalmap，再找到其中的threadLocal对应的值。</p>
<p><strong>threadLocal的内存泄露问题</strong></p>
<p>threadLocalmap的key是弱引用，value是强引用，也就是说如果threadlocal没有外部强引用就会被回收，而value不会被回收。这个时候就会有内存泄露问题了。解决方法是不再使用threadLocal就手动remove</p>
<h2 id="搜寻周围司机和订单推送"><a href="#搜寻周围司机和订单推送" class="headerlink" title="搜寻周围司机和订单推送"></a>搜寻周围司机和订单推送</h2><p>在司机开始接单之后会把自己的位置上传到redis，然后进行等待，在这个过程中司机会不断轮询自己redis的list是否有数据。同时乘客端下单之后会新增一个定时任务，使用redis的gredius命令查询方圆5km内的符合要求的司机。并且为这些司机的list都添加该订单号。</p>
<p><strong>为什么要用定时任务</strong></p>
<p>因为执行一次并不一定就能及时发现司机，轮询又太消耗cpu，所以采用了定时任务。使用xxl-job可以管理这些定时任务。</p>
<p><strong>异常怎么处理的</strong></p>
<p>有一个兜底策略就是超时15分钟自动取消，如果在运行过程中出现失败首先xxl-job会显示执行失败，同时记录日志。</p>
<p><strong>如果周围只有一个司机，但是一直不接单，如何保证他的list中消息不重复</strong></p>
<p>这里使用了redis的set集合，key是订单的id，每当任务调度搜索到最近的司机之后首先会校验司机的id是否在set中，如果不在才可以加入自己的list。如果在的话说明是重复提交了。</p>
<p><strong>任务调度何时终止</strong></p>
<p>在查询周围司机之前都会先检查当前订单的状态，通过另一个微服务的调用。如果这个订单的状态发生改变说明已经有司机接单了，这个任务就会提前终止。</p>
<p><strong>为什么不用mq实现这一部分逻辑</strong></p>
<p>redis的速度较快，毕竟用户的规模不会很大，list的规模也不会很大，暂时不会存在大key问题。而且也需要批量处理这些消息和频繁的删除，如果为每一个司机都建立一个queue有一点奢侈，综合下来还是redis中list能够简化操作。</p>
<h2 id="司机抢单"><a href="#司机抢单" class="headerlink" title="司机抢单"></a>司机抢单</h2><p>每个司机在接单的过程中都会轮询自己在redis中的list是否有数据，如果有前端就会显示并且可以选择订单进行抢单。主要逻辑是首先会检查是否还有订单，这个是通过在redis的一个标识实现的，再下单的时候会给redis一个标识。目的是不用去数据库查找当前订单的状态节约数据库开销。为了防止超卖要用分布式锁，为当前订单id加锁。加锁之后再次校验是否有标识，进行接单操作后删除这个标识和释放锁，完成抢单逻辑。</p>
<p><strong>分布式锁用的是什么</strong></p>
<p>基于redision的分布式锁，锁住的是司机list中的订单id。本质还是基于setnx的，只不过redission有看门狗机制能够延长执行时间，保证任务能够进行完成而不会出现删除别人的锁的情况。这里可以优化的地方可以做成lua脚本，反正标识也是在redis里面的。逻辑是查询标识然后异步下单给mq。也会缩短司机抢单的响应时间，</p>
<h2 id="司乘同显"><a href="#司乘同显" class="headerlink" title="司乘同显"></a>司乘同显</h2><p>在司机正在前往起始点和进行服务的时候，乘客也需要知道司机在哪里。司机会定时将自己的数据上传到mongodb中，乘客端会找到最近时间的司机点坐标，然后调用map微服务渲染出路径。</p>
<p><strong>为什么使用mongodb，用redis或者mysql存储呢</strong></p>
<ul>
<li>路径数据是需要持久化保存的，用redis毕竟不是落库，而且存储的数据量大且只需要找出最近的一个点，大部分的数据没有用，会浪费珍贵的缓存空间，所以最好不用redis。</li>
<li>mysql也不太适合，存储的点数据量很大而mysql超过1kw查询效率就会很低，也会存在深度分页问题，如果多个订单同时进行并发也是mysql的问题。多一个少一个坐标点不会有很大的问题，所以使用另一个数据库进行存储，经过调研mongo能够满足。</li>
</ul>
<p><strong>基于rocketmq的<del>延迟队列</del>完成批量写是怎么实现的</strong></p>
<blockquote>
<p>这里真是犯了一个大错误。</p>
</blockquote>
<p>为了实现高效率写可以合并多次写请求，实现批量写。具体是设置rocketmq的批量处理功能。但是会增加代码的复杂度，更加轻量级的做法是线程池和阻塞队列。</p>
<h2 id="异步编排"><a href="#异步编排" class="headerlink" title="异步编排"></a>异步编排</h2><p>在完成订单后会有一系列的计算过程，例如防刷单校验，分账计算，推送账单等。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[Start]</span><br><span class="line">   |</span><br><span class="line">   +--&gt; [获取订单信息]  ----+</span><br><span class="line">   |                        |</span><br><span class="line">   +--&gt; [获取司机位置] ------+--&gt; [等待两个任务完成]</span><br><span class="line">                                 |</span><br><span class="line">                                 v</span><br><span class="line">                       [计算距离]</span><br><span class="line">                                 |</span><br><span class="line">               +-----------------+-----------------+</span><br><span class="line">               |                                   |</span><br><span class="line">        [距离 &gt; 2公里]                       [距离 &lt;= 2公里]</span><br><span class="line">               |                                   |</span><br><span class="line">         [抛出异常]                         +----+----+</span><br><span class="line">                                               |         |</span><br><span class="line">                                       [计算实际里程]   [获取订单数量]</span><br><span class="line">                                               |         |</span><br><span class="line">                                       [计算费用]    [计算奖励]</span><br><span class="line">                                               \         /</span><br><span class="line">                                                \       /</span><br><span class="line">                                        [计算分账信息]</span><br><span class="line">                                               |</span><br><span class="line">                                      [封装并更新账单]</span><br><span class="line">                                               |</span><br><span class="line">                                            [End]</span><br></pre></td></tr></table></figure>

<p>考虑将获取订单信息和获取目的地距离进行并行处理，使用supplyAsync实现两个线程，最后合并一起进行计算得到结果；再校验距离是否再可以接收的范围内，如果是不是刷单就并行获取订单数量和计算实际里程，这个是根据mongodb中的数据计算的，得到这两个信息进行账单计算和推送账单。主要是将几个不相关的微服务通过多线程并行获取了。</p>
<p><strong>如何测试的40%提升</strong></p>
<p>测试的该方法的执行时间发现比原来快了40%。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><strong>TCC的流程</strong></p>
<p>try-confirm-cancel，是一种业务入侵的分布式事务方法。try阶段会预留资源，confirm阶段确定分布式事务下所有的执行器都已经成功预留，如果全部成功就执行confirm提交事务，如果失败了就执行补偿措施cancel。这种方式比较灵活，可以自己控制事务，但是也入侵了业务，会造成一些别的问题，例如幂等性问题，空回滚和资源倒挂。</p>
<p><strong>解释一下这三个问题</strong></p>
<ul>
<li>幂等性：由于网络抖动等问题导致在confirm阶段可能出现超时重试，但是最终两个请求都收到了。在seata的解决方式是用一个事务状态表，在confirm&#x2F;cancel的时候提交给事务状态表，在开始的时候又去检查字段状态，如果是已经confirm了的，第二个请求就会被忽略，从而达到了幂等性</li>
<li>空回滚：在try阶段没有成功的微服务仍然执行了回滚，需要对失败的微服务进行区别。在seata里仍然是用事务状态表，在try成功了才会有status，回滚阶段有status的才能回滚</li>
<li>资源倒挂：由于网络原因try阻塞了，结果回滚了，但是后续网络恢复了仍然会预留资源，使得资源被倒挂。解决方案仍然是事务状态表，在回滚的时候插入一条suspend&#x3D;4，在try的时候先校验是不是倒挂了，如果&#x3D;4就不用预留资源。</li>
</ul>
<p><strong>具体在代码里是怎么做的</strong></p>
<p>例如我们的支付模块，需要修改金额和商品数量，然后下单。这个时候就要用到分布式事务了。每一个微服务模块都要实现tcc三个接口，在try的接口上使用@TwoPhaseBusinessAction，指定在seata服务中的id以及回滚和提交的方法名，接着在代码实现响应逻辑。对于数据库而言增加一个frozen字段，try阶段首先减少数量，frozen增加，cancel了就做相反操作，如果confirm了就减少frozen实际提交。</p>
<h2 id="规则引擎"><a href="#规则引擎" class="headerlink" title="规则引擎"></a>规则引擎</h2><p>用规则引擎做了一些计算</p>
<ul>
<li>例如根据距离和实际预估出价格，例如在7点之前起步价是多少多少钱，每公里的价格计算。使用规则引擎防止将规则和价格硬编码在代码里，方便实际部署动态变更。</li>
<li>计算账单也使用到了规则引擎，例如按照什么比例分成，根据订单多少给予奖励</li>
</ul>
<p><strong>但是实际工作里面都不太会用到这个你知道是为什么吗</strong></p>
<p>我觉得首先是学习成本的问题，这个东西语法确实也很冗杂，虽然在java代码里面不用硬编码了，但是几个ifelse却要用更长的代码表示。某些时候这个服务也会成为瓶颈。</p>
<h2 id="实习项目"><a href="#实习项目" class="headerlink" title="实习项目"></a>实习项目</h2><h3 id="业务是什么"><a href="#业务是什么" class="headerlink" title="业务是什么"></a>业务是什么</h3><p>实现人工智能检测平台和主平台的接口，具体是定时发送指令到视频流平台，截图入库后通过这个接口的一系列定时任务提交给人工智能检测平台返回结果进行统计。统计完成后用kafka异步落库并返回给前端。除此之外还有一些文档和增删改查的工作。</p>
<h3 id="xxl-job是怎么用的，你的项目里面有哪些定时任务会需要用到这个"><a href="#xxl-job是怎么用的，你的项目里面有哪些定时任务会需要用到这个" class="headerlink" title="xxl-job是怎么用的，你的项目里面有哪些定时任务会需要用到这个"></a>xxl-job是怎么用的，你的项目里面有哪些定时任务会需要用到这个</h3><p>xxl-job是一个开箱即用的分布式调度平台，与传统的quataz相比可以动态改变cron表达式，还具有可视化的界面。由于实习单位后端有很多的定时任务，写死cron表达式不利于管理</p>
<ol>
<li>首先是截图指令，会传递几个参数通过http控制视频流平台，其中参数会包含间隔时间，视频流平台也会根据这个进行定时落库。</li>
<li>接着是定时给人工智能平台传输，因为平台有很多的检测算法，接口都不是很统一。这里有一些很长的if判定过程。例如未佩戴安全帽 未佩戴绝缘手套  靠近变压器告警、工作服，或者是画面无人。这里用了一个线程池来并发完成这些图片的校验和传输，还用了策略模式把这些校验的很长的ifelse给简化了。具体是用一个公用的策略接口，然后上下文类中替换这个接口的实现类来完成策略选择。最后在策略工厂里面用哈希表来保存类型和具体策略的映射关系。</li>
<li>还有一个定时任务是每天早上1点钟删除保存了3天以上的照片</li>
<li>人脸注册每分钟从数据库抽200张给人工智能平台，人工智能平台自己也有数据库，在这个系统里面也有，这个时候虽然是通过http传输的，但是也可以看作一个分布式的事务，由于这个系统业务范围不是我们的，所以用分布式事务也不太合理。所以就想到用kafka保证最终一致性。</li>
</ol>
<h3 id="kafka怎么保证最终一致性的"><a href="#kafka怎么保证最终一致性的" class="headerlink" title="kafka怎么保证最终一致性的"></a>kafka怎么保证最终一致性的</h3><p>主要依赖kafka的exactly once语义。要实现只提交一次且只能消费一次需要三方都协调。对于生产者也就是我们这个代码里面，要使用kafka的幂等和事务，配置kafka的幂等性可以使生产者的消息只会被kafka接收一次，配置事务使得消费者在消费消息的时候只能看到提交事务的，对于kafka而言，由于我们公司也没配置kafka集群，所以只设置了acks&#x3D;1，也就是写入成功后返回回调函数，这样能保证kafka不丢消息。消费者为了不重复消费消息也需要做到幂等，这里的幂等校验是redis进行去重的，然后再手动提交ack。这样能保证如果前面的平台执行失败了，这里的接口也不会落库；如果执行成功，通过kafka的这个exactly once就可以只落库一次。</p>

    
    
  </div>

  

  

</article>
  
    
  <nav class="pagination">  
      
      
      <a class="next" href="/page/2/">  
        <span class="next-text">下一页</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  
</section>
        </div>
          

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:1050886654@qq.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/yyf1050886654" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2024 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">Yifan Yang</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    

  







<script type="text/javascript" src="/lib/jquery"></script>



<script type="text/javascript" src="/lib/slideout"></script>



<script type="text/javascript" src="/lib/fancybox"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>