<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/default" title="YYF's Blog" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://yyf1050886654.github.io/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>YYF&#39;s Blog</title>

<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">YYF&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        首页              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        归档              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        标签              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        分类              </li>
    </a>
    
    <a href="/collect/">
      <li class="mobile-menu-item">
        
        
        收藏              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        关于              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">YYF's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              首页  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              归档  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              标签  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              分类  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/collect/">  
              
              
              收藏  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              关于  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <section id="posts" class="posts">
  
  
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/12/25/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week5%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%89%88%EF%BC%89/">网易牛马日志-week5（学习版）</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-12-25
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><h3 id="邮箱注册"><a href="#邮箱注册" class="headerlink" title="邮箱注册"></a>邮箱注册</h3><p>用户视角：输入邮箱和密码（有校验）-&gt;填写个人信息-&gt;收到确认邮件-&gt;点击跳转链接</p>
<h4 id="输入邮箱和密码（有校验）"><a href="#输入邮箱和密码（有校验）" class="headerlink" title="输入邮箱和密码（有校验）"></a>输入邮箱和密码（有校验）</h4><p>输入邮箱密码，前端通过正则表达式校验密码格式，后端请求&#x2F;email&#x2F;check来检查账号是否启用。这里启用指的是已经点击过验证邮件的或者用oauth已经校验过的。这里没校验过邮件的应该还是可以重新发起注册的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> EmailSignUpCheckResp <span class="title function_">emailSignUpCheck</span><span class="params">(EmailSignupCheckReq emailSignupCheckReq, HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">EmailSignUpCheckResp</span> <span class="variable">emailSignUpCheckResp</span> <span class="operator">=</span> EmailSignUpCheckResp.builder()</span><br><span class="line">            .emailSignUpCheckStatus(EmailSignUpCheckStatus.UN_SIGN_UP)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 校验注册邮箱</span></span><br><span class="line">    <span class="type">UserEntity</span> <span class="variable">user</span> <span class="operator">=</span> userServiceImpl.getUserEntityByLoginUsername(emailSignupCheckReq.getEmail());</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(user)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UserState.OPEN.getCode() == user.getState()) &#123;</span><br><span class="line">            emailSignUpCheckResp.setEmailSignUpCheckStatus(EmailSignUpCheckStatus.ALREADY_VERIFIED);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            emailSignUpCheckResp.setEmailSignUpCheckStatus(EmailSignUpCheckStatus.ALREADY_SIGN_UP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> emailSignUpCheckResp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注册逻辑-确认邮件的回调逻辑"><a href="#注册逻辑-确认邮件的回调逻辑" class="headerlink" title="注册逻辑+确认邮件的回调逻辑"></a>注册逻辑+确认邮件的回调逻辑</h4><ol>
<li>查询用户信息：check校验的是是否有效。这里检查是否别的方式已经注册了（通过email字段查）</li>
<li>检查密码强度</li>
<li>邀请码（暂时不需要）</li>
<li>保存用户信息（两张表，一张存用户实体，另一张存账号密码和盐）</li>
<li>埋点上报</li>
</ol>
<p>这里最重要的是“保存用户信息”。在注册之后会入库账号密码，但是未激活（就是check检查的那个字段，只有点击了邮件链接才会接收到）。</p>
<p>随后生成一个UUID作为参数传给邮件，同时缓存在redis中。在邮件里面放这个链接和参数，点击的时候自动就会去请求“&#x2F;verify&#x2F;email?cs&#x3D;”。<br>这个方法会解析加密参数，与redis中进行比较。校验成功后激活用户状态，最后走获取token的逻辑，那部分等讲登录的时候再说。</p>
<h4 id="邮箱相关"><a href="#邮箱相关" class="headerlink" title="邮箱相关"></a>邮箱相关</h4><p>发送的是html，这里用到了FreeMarker，模板里面只有两个需要动态换的，一个是称呼一个是对应的重定向链接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; templateParams = Maps.newHashMap();</span><br><span class="line">templateParams.put(<span class="string">&quot;accountName&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">templateParams.put(<span class="string">&quot;registerLink&quot;</span>, <span class="string">&quot;https://www.bilibili.com&quot;</span>);</span><br><span class="line"><span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> resourceLoader.getResource(<span class="string">&quot;classpath:template/&quot;</span>+registerTemplate);</span><br><span class="line"><span class="type">byte</span>[] fileData = FileCopyUtils.copyToByteArray(resource.getInputStream());</span><br><span class="line"><span class="type">String</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(fileData, StandardCharsets.UTF_8);</span><br><span class="line">textPart.setContent(template, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(template.getBytes())) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> FreemarkerUtils.process(inputStream, templateParams);</span><br><span class="line">    System.out.println(content);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后发送邮件配置就完了，这里暂时用的是gmail，最后得搭建公司邮件服务器。</p>
<h4 id="邮箱登录"><a href="#邮箱登录" class="headerlink" title="邮箱登录"></a>邮箱登录</h4><ol>
<li>各种参数校验，包括上面一直在讲的激活状态。</li>
<li>密码校验（数据库盐是Base64，可以加密解密的）： encode(用户输入+Base64Decode(数据库盐)) &#x3D;&#x3D; 数据库加密后的密码。</li>
<li>校验成功则登录成功，首先解析ip到国家和省份保存。然后生成token作为session保存在redis里面，设定过期时间为7天。</li>
<li>将token返回给前端，每次请求都要携带。</li>
</ol>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/12/25/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week5/">网易牛马日志-week5</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-12-25
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <blockquote>
<p>写在前面：经过一个月的实习，我逐渐觉得沟通能力和理解能力远比代码能力重要。不论是在科研组会上的哑口无言，还是在工作上对接的七嘴八舌，都暴露出了我语言能力的欠缺。我从初中开始就知道这是我的短板，但没想到有这么短。这也再次给我敲响了警钟，不管你是什么学术或者技术大师，学说话和听说话是最基本的。</p>
</blockquote>
<h2 id="需求7：【出海项目】ip限流"><a href="#需求7：【出海项目】ip限流" class="headerlink" title="需求7：【出海项目】ip限流"></a>需求7：【出海项目】ip限流</h2><p>注解+aop+lua+redis+滑动窗口限流算法</p>
<h3 id="注解和aop"><a href="#注解和aop" class="headerlink" title="注解和aop"></a>注解和aop</h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>根据多个时间单位配置限流器，定义了时间枚举类，按照毫秒存储持续时间（因为注解只能用枚举，不能用正常类）。</p>
<blockquote>
<p>正常是要传3个值的：次数，时间单位，超时时间（主要是给后面对redis设置expireTime）。这里为了方便超时时间与时间单位一致。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用示例：1分钟限制10次，1小时限制500次</span></span><br><span class="line"><span class="meta">@IpRateLimit(limit = &#123;10,500&#125;, timeUnit = &#123;TimeUnit.MINUTE,TimeUnit.HOUR&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注解定义</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IpRateLimit &#123;</span><br><span class="line">    <span class="type">int</span>[] limit();  <span class="comment">// 限流值</span></span><br><span class="line">    TimeUnit[] timeUnit();  <span class="comment">// 时间单位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TimeUnit</span> &#123;</span><br><span class="line">    YEAR(<span class="number">1</span>, <span class="string">&quot;YEAR&quot;</span>, <span class="number">1000L</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span> * <span class="number">365</span>),</span><br><span class="line">    MONTH(<span class="number">2</span>, <span class="string">&quot;MONTH&quot;</span>, <span class="number">1000L</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span>),</span><br><span class="line">    DAY(<span class="number">3</span>, <span class="string">&quot;DAY&quot;</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>),</span><br><span class="line">    HOUR(<span class="number">4</span>, <span class="string">&quot;HOUR&quot;</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>),</span><br><span class="line">    MINUTE(<span class="number">5</span>, <span class="string">&quot;MINUTE&quot;</span>, <span class="number">1000</span> * <span class="number">60</span>),</span><br><span class="line">    SECOND(<span class="number">6</span>, <span class="string">&quot;SECOND&quot;</span>, <span class="number">1000</span>),</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//单位是毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> periodInMills;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="aop"><a href="#aop" class="headerlink" title="aop"></a>aop</h4><p>校验注解里两个数组长度必须相同，对每一个配置new一个限流器来执行redis脚本。（我在想这里每次限流就new一个开销会不会有点大，但是不能用@service，因为有状态的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpRateLimiterAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisLuaRateLimiter redisLuaRateLimiter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.netease.cowork.sirius.it.data.overseas.server.frame.anno.IpRateLimit)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rateLimiter</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;rateLimiter() &amp;&amp; @annotation(ipLimiter)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">(JoinPoint joinPoint, IpRateLimit ipLimiter)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">int</span>[] limit = ipLimiter.limit();</span><br><span class="line">        TimeUnit[] timeUnits = ipLimiter.timeUnit();</span><br><span class="line">        <span class="keyword">if</span> (limit.length != timeUnits.length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取用户ip</span></span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="keyword">assert</span> attributes != <span class="literal">null</span>;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; limit.length; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">periodInMills</span> <span class="operator">=</span> timeUnits[i].getPeriodInMills();</span><br><span class="line">            redisLuaRateLimiter = <span class="keyword">new</span> <span class="title class_">RedisLuaRateLimiter</span>(limit[i], periodInMills, periodInMills,timeUnits[i].getName());</span><br><span class="line">            <span class="keyword">if</span> (!redisLuaRateLimiter.tryAcquired(ip))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;操作频繁，请稍后重试&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redis-lua实现滑动窗口限流算法"><a href="#redis-lua实现滑动窗口限流算法" class="headerlink" title="redis+lua实现滑动窗口限流算法"></a>redis+lua实现滑动窗口限流算法</h3><p>lua脚本在这里最大的作用就是解决并发问题，且保证原子性。分别说这个几个参数：</p>
<ul>
<li>KEYS[1]：String key &#x3D; prefix + ip。业务名称+ip。因为可能有多个业务都需要限流。</li>
<li>ARGV[1]：now-periodInMills。时间校验的分界线，往后为需要计算的流量。</li>
<li>ARGV[2]：now</li>
<li>ARGV[3]：UUID.randomUUID()真正的value值，随便写一个</li>
<li>ARGV[4]：expireInMills</li>
<li>ARGV[5]：limit</li>
</ul>
<p>基本原理是zset的score存时间戳，ZREMRANGEBYSCORE这个方法会去除0到now-periodInMills的所有元素，剩下的就是要统计的元素。ZCARD用来统计当前元素数量，如果比count小就没有达到限流，ZADD设置value，score和超时时间。如果限流就返回特殊数字。<br>最后只用判断lua脚本执行是否是1来判断限流。</p>
<p>其他的代码都是java操作lua的方法，核心如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限流</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_LIMIT_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;local removedCount = redis.call(&#x27;ZREMRANGEBYSCORE&#x27;, KEYS[1], 0, ARGV[1])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;local currentCount = redis.call(&#x27;ZCARD&#x27;, KEYS[1])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;if currentCount &lt; tonumber(ARGV[5]) then\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    redis.call(&#x27;ZADD&#x27;, KEYS[1], ARGV[2], ARGV[3])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    redis.call(&#x27;PEXPIRE&#x27;, KEYS[1], ARGV[4])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return 1\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;else\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    return 0\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;end&quot;</span>;</span><br><span class="line"><span class="comment">//统计rate</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_LIMIT_COUNT_SCRIPT</span> <span class="operator">=</span> <span class="string">&quot;local removedCount = redis.call(&#x27;ZREMRANGEBYSCORE&#x27;, KEYS[1], 0, ARGV[1])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;local currentCount = redis.call(&#x27;ZCARD&#x27;, KEYS[1])\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;return currentCount&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>结论是对比海关服务的限流，这种写lua的方法能快三倍，限流速度50ms，他们的150ms。而且配置也很简单。</p>
<h2 id="需求8：【出海项目】sitemap与seo优化"><a href="#需求8：【出海项目】sitemap与seo优化" class="headerlink" title="需求8：【出海项目】sitemap与seo优化"></a>需求8：【出海项目】sitemap与seo优化</h2><h2 id="需求9：【出海项目】sentinel和apollo持久化"><a href="#需求9：【出海项目】sentinel和apollo持久化" class="headerlink" title="需求9：【出海项目】sentinel和apollo持久化"></a>需求9：【出海项目】sentinel和apollo持久化</h2>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/12/15/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week4/">网易牛马日志-week4</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-12-15
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="需求5：优化prompt"><a href="#需求5：优化prompt" class="headerlink" title="需求5：优化prompt"></a>需求5：优化prompt</h2><h3 id="1-提示词优化"><a href="#1-提示词优化" class="headerlink" title="1.提示词优化"></a>1.提示词优化</h3><blockquote>
<p>学习了prompt工程，主要的优化思路有（<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/QDzbfUkvSEalLxm3XX9rtA">参考连接</a>）：</p>
<ol>
<li>角色提示：“假设我是一个刚入行的电商买家”，类似这种可以将gpt带入角色，以该角色的视角进行输出</li>
<li>思维链提示：让gpt一步一步进行思考，例如计算1+2+3，先让gpt算出1+2&#x3D;3，然后再去算3+3&#x3D;6，有了思维链能够使ai清晰思考路径，犯错的可能性降低</li>
<li>思维树提示：跟上面的思维链比起来，思维树要考虑不同的分叉，在执行过程中要考虑不同的情况</li>
<li>自一致性提示：将模型的温度升高，多次去执行一个问题，返回其中最高频率的答案。对于推荐词的场景不太适用，因为调用次数有限而且时延较大，被mentor否决。</li>
<li>ReAct提示：用python的api进行调用，功能强大但用不了。<br>综合以上的方法，只有思维链可以作为优化。</li>
</ol>
</blockquote>
<ol>
<li>近似词：中译英</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String synonymsPrompt = MessageFormat.format(&quot;与\&quot;&#123;0&#125;\&quot;意思相近的产品有哪些，</span><br><span class="line">        请用&#123;1&#125;列举10个产品名。要求不包含\&quot;&#123;0&#125;\&quot;，</span><br><span class="line">        输出格式为：jsonArray&quot;, formatValue, language) + &quot;,[]&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String synonymsPrompt = MessageFormat.format(&quot;What are the products with the similar meaning of \&quot;&#123;0&#125;\&quot;,\n&quot; +</span><br><span class="line">        &quot;Please list 10 product names in &#123;1&#125;. My request is not to include \&quot;&#123;0&#125;\&quot;,\n&quot; +</span><br><span class="line">        &quot;The output format is jsonArray&quot;, formatValue, language) + &quot;,[]&quot;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>电商词：转为中文思维链</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String platformPrompt = MessageFormat.format(&quot;假设我是一个新入行的电商卖家，</span><br><span class="line">        主要经营的是\&quot;&#123;0&#125;\&quot;。我希望能有更多的用户在amazon.com等同类电商网站中搜索到我，</span><br><span class="line">        我可以使用怎样的&#123;1&#125;产品名对自己的产品进行描述？要求不包含\&quot;&#123;0&#125;\&quot;，</span><br><span class="line">        请去掉尽可能多的长尾词，提炼共同的产品描述词。帮我用&#123;2&#125;同义替换10个不同的产品描述。仅输出替换后的数据，</span><br><span class="line">        格式为：jsonArray&quot;, formatValue, language, language) + &quot;,[]&quot;;   </span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String platformPrompt = MessageFormat.format(&quot;请按照如下提示一步步推理：\n&quot; +</span><br><span class="line">        &quot;第一步，请将产品\&quot;&#123;0&#125;\&quot;从品牌、型号、材料、用途等方面进行扩展，尽量细分且具体到某个品牌的某个产品。\n&quot; +</span><br><span class="line">        &quot;第二步，思考该产品在amazon.com等同类电商网站中显示给用户的商品词是什么。\n&quot; +</span><br><span class="line">        &quot;第三步，提取商品词中的关键信息，不允许出现品牌和型号，长度严格限制在30个字母以内。\n&quot; +</span><br><span class="line">        &quot;综合以上三步，仅用&#123;1&#125;输出十个这样的产品名，要求不包含\&quot;&#123;0&#125;\&quot;格式为：jsonArray,[]&quot;, formatValue, language) + &quot;,[]&quot;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>行业词：中译英</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prompt = &quot;我是一个新入行的外贸供应商，主要经营的是&quot;+ formatValue +&quot;。我的产品可以应用于哪些行业的哪些产品？帮我列举3个行业，并描述推荐这些行业的理由，在每个行业下列举5个使用该产品制造出来的产品名称。\n&quot; +</span><br><span class="line">        &quot;用json输出，格式为：\n&quot; +</span><br><span class="line">        &quot;行业1\n&quot; +</span><br><span class="line">        &quot;行业名：xxx\n&quot; +</span><br><span class="line">        &quot;推荐理由：xxx\n&quot; +</span><br><span class="line">        &quot;相关产品：xxx\n&quot; +</span><br><span class="line">        &quot;要求：\n&quot; +</span><br><span class="line">        &quot;1、行业名称用&#123;&quot;+languageVersion+&quot;&#125;。\n&quot; +</span><br><span class="line">        &quot;2、推荐理由用&#123;&quot;+languageVersion+&quot;&#125;。\n&quot; +</span><br><span class="line">        &quot;3、相关产品用&#123;&quot;+language+&quot;&#125;。\n&quot; +</span><br><span class="line">        &quot;4、产品名称不能重复。\n&quot; +</span><br><span class="line">        &quot;5、产品名称不需要包含材质等限制。\n&quot; +</span><br><span class="line">        &quot;6、相关产品用#格开。&quot; +</span><br><span class="line">        &quot;7、不包含\&quot;&quot;+formatValue+&quot;\&quot;。&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prompt = &quot;I am a new foreign trade supplier, the main business is \&quot;&quot;+formatValue+&quot;\&quot;. Which products can my product be used in which industries? Give me a list of 3 industries and describe the reasons why you recommend them, and list 5 names of products made with that product under each industry.\n&quot; +</span><br><span class="line">        &quot;Output in json format:\n&quot; +</span><br><span class="line">        &quot; 行业1\n&quot; +</span><br><span class="line">        &quot; 行业名：xxx\n&quot; +</span><br><span class="line">        &quot; 推荐理由：xxx\n&quot; +</span><br><span class="line">        &quot; 相关产品：xxx\n&quot; +</span><br><span class="line">        &quot;Requirement: \&quot;\n&quot; +</span><br><span class="line">        &quot;1. the industry name with &#123;&quot;+languageVersion+&quot;&#125;.\n&quot; +</span><br><span class="line">        &quot;2. recommended reasons use &#123;&quot;+languageVersion+&quot;+&#125;.\n&quot; +</span><br><span class="line">        &quot;3. Use &#123;&quot;+language+&quot;&#125; for related products.\n&quot; +</span><br><span class="line">        &quot;4. the product name can not be repeated.\n&quot; +</span><br><span class="line">        &quot;5. the product name does not need to include material and other restrictions.\n&quot; +</span><br><span class="line">        &quot;6. related products are delimited with #\n&quot; +</span><br><span class="line">        &quot;7. \&quot;&quot;+formatValue+&quot;\&quot; is not included.&quot;;</span><br></pre></td></tr></table></figure>

<p>三个小小的优化耗费了我一周的时间，实际上也没多少提升。</p>
<h3 id="2-代码逻辑"><a href="#2-代码逻辑" class="headerlink" title="2.代码逻辑"></a>2.代码逻辑</h3><h4 id="近似词和电商词"><a href="#近似词和电商词" class="headerlink" title="近似词和电商词"></a>近似词和电商词</h4><ul>
<li>首先判断是否为空，或者是否为敏感词（调用网易易盾），随后传入用户信息，访问服务。</li>
<li>服务内部：传入参数中语言为空默认为英语，然后用CompletableFuture.supplyAsync()搭配线程池完成gpt的两次请求。线程池如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程工厂仅仅改名，拒绝策略是发起者自己消化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadFactory</span> <span class="variable">GPT_THREAD_FACTORY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>().setNameFormat(<span class="string">&quot;GptGrpcWrapper-gpt-pool-%d&quot;</span>).build();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">GPT_REQUEST_EXECUTOR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">20</span>,</span><br><span class="line">        <span class="number">40</span>, <span class="number">60</span> * <span class="number">5L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">3000</span>), GPT_THREAD_FACTORY, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>

<ul>
<li>请求成功的结果缓存在redis中100天，缓存的key是”cacheKeyPreFix + “v6” + “:” + gptRecommendReqVO.getLanguage()+”:”+gptRecommendReqVO.getValue();”</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;String&gt; <span class="title function_">getRecommendWordV1</span><span class="params">(GptRecommendReqVO gptRecommendReqVO, AuthInfo authInfo, String prompt, String cacheKeyPreFix)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheValue</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(gptRecommendReqVO.getValue())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">formatValue</span> <span class="operator">=</span> FormatUtil.escapeFormat(gptRecommendReqVO.getValue());</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(formatValue) || formatValue.length()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;GptGrpcWrapper value:&#123;&#125;,formatValue:&#123;&#125;&quot;</span>,gptRecommendReqVO.getValue(),formatValue);</span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(gptRecommendReqVO.getLanguage()==<span class="literal">null</span>)&#123;</span><br><span class="line">            gptRecommendReqVO.setLanguage(<span class="string">&quot;英语&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">language</span> <span class="operator">=</span> gptRecommendReqVO.getLanguage();</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> cacheKeyPreFix + <span class="string">&quot;v6&quot;</span> + <span class="string">&quot;:&quot;</span> + gptRecommendReqVO.getLanguage()+<span class="string">&quot;:&quot;</span>+gptRecommendReqVO.getValue();</span><br><span class="line">        cacheValue = recommendWordCache.get(cacheKey);</span><br><span class="line">        <span class="comment">//命中</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotBlank(cacheValue))&#123;</span><br><span class="line">            log.info(<span class="string">&quot;GptGrpcWrapper call success,param:&#123;&#125;,result:&#123;&#125;&quot;</span>,JSON.toJSONString(gptRecommendReqVO),cacheValue);</span><br><span class="line">            <span class="comment">//大段文字中的[&quot;xxx1&quot;,&quot;xxx2&quot;,&quot;xxx3&quot;]</span></span><br><span class="line">            <span class="keyword">if</span>(cacheValue.contains(<span class="string">&quot;[&quot;</span>) &amp;&amp; cacheValue.contains(<span class="string">&quot;]&quot;</span>))&#123;</span><br><span class="line">                cacheValue = cacheValue.substring(cacheValue.indexOf(<span class="string">&quot;[&quot;</span>), cacheValue.lastIndexOf(<span class="string">&quot;]&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只取前6个，这个数值是前端定的</span></span><br><span class="line">            Set&lt;String&gt; synonyms = getLimitSize(Lists.newArrayList(JSON.parseArray(cacheValue, String.class)), gptRecommendReqVO.getSize());</span><br><span class="line">            <span class="keyword">return</span> synonyms;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//未命中</span></span><br><span class="line">        log.info(<span class="string">&quot;GptGrpcWrapper call param:&#123;&#125;,prompt:&#123;&#125;&quot;</span>,JSON.toJSONString(gptRecommendReqVO),prompt);</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(</span><br><span class="line">                () -&gt; gptRequest(authInfo.getOrgId(),authInfo.getAccId(),authInfo.getEmail(),prompt, GPTModelVersionEnum.GPT_4O_MINI.getVersion()), GPT_REQUEST_EXECUTOR);</span><br><span class="line">        <span class="comment">//这里实际上还是同步请求，&quot;gpt-recommard-future&quot;是一个日志的名称，超时时间120s</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> (String)FutureResultUtil.getResult(<span class="string">&quot;gpt-recommard-future&quot;</span>,future,<span class="number">120</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(res)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;getRecommend failed.name:&#123;&#125;,language:&#123;&#125;&quot;</span>,formatValue, language);</span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        cacheValue = res;</span><br><span class="line">        <span class="comment">// 推荐词缓存100天</span></span><br><span class="line">        recommendWordCache.set(cacheKey,cacheValue,TimeUnit.DAYS.toMillis(<span class="number">100</span>));</span><br><span class="line">        log.info(<span class="string">&quot;GptGrpcWrapper call success,param:&#123;&#125;,result:&#123;&#125;&quot;</span>,JSON.toJSONString(gptRecommendReqVO),cacheValue);</span><br><span class="line">        <span class="keyword">if</span>(cacheValue.contains(<span class="string">&quot;[&quot;</span>) &amp;&amp; cacheValue.contains(<span class="string">&quot;]&quot;</span>))&#123;</span><br><span class="line">            cacheValue = cacheValue.substring(cacheValue.indexOf(<span class="string">&quot;[&quot;</span>), cacheValue.lastIndexOf(<span class="string">&quot;]&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; synonyms = getLimitSize(Lists.newArrayList(JSON.parseArray(cacheValue, String.class)), gptRecommendReqVO.getSize());</span><br><span class="line">        <span class="keyword">return</span> synonyms;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//gpt出的词如果不常规。例如是“好的，接下来为您输出....”，在JSON.parseArray就会报异常不返回给前端。</span></span><br><span class="line">        log.error(<span class="string">&quot;getGptRecommend param:&#123;&#125;&quot;</span>,JSON.toJSONString(gptRecommendReqVO), e);</span><br><span class="line">        <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>redis只存gpt原始回答，可以改成处理后的回答</li>
<li>线程池实际上只将近似词和电商词做了异步，在这两个单独的请求里面用future实际还是同步。</li>
<li>gpt如果输出不理想有两重处理，首先看是否包含了”[“xxx1”,”xxx2”,”xxx3”]”，用subString提取出来，实在是没有那在parseObject就会报错，结果返回为空。</li>
</ol>
</blockquote>
<ul>
<li>最后处理近似词和电商词的结果，用一个大的hashset去重（但是大小写敏感，这里可以优化成全部小写再比较）</li>
<li>调用GRPC（有道翻译）兜底，先判断是否出现中文，有中文就翻译。批量翻译返回值是map，key是原文，value是翻译后的。最后进行组装返回。</li>
</ul>
<p><strong>总结：调用易盾进行敏感词检测，线程池+CompletableFuture完成两次gpt查询，gpt查询做了一系列异常处理，在redis中缓存100天，最后调用有道翻译的grpc进行兜底。</strong></p>
<h4 id="行业词"><a href="#行业词" class="headerlink" title="行业词"></a>行业词</h4><ul>
<li>首先判断是否为空，或者是否为敏感词（调用网易易盾），随后传入用户信息，访问服务。</li>
<li>服务内部：处理逻辑跟上文类似，在redis中存储gpt原始回答，但是由于输出的是json，相比于近似词和行业词的数组，这里有改变。</li>
<li>去除”```json”和”```“这类md语法，再根据”行业一，二，三”json形式包装。</li>
<li>这里要做一些异常处理以增加可用性和鲁棒性，虽然提示词里面写的是用”#“隔开，但是实际上可能返回的还是”,”或者”、”，用一个函数对其进行拆分。</li>
<li>最后调用有道翻译兜底。</li>
</ul>
<h2 id="需求6：订阅更新任务"><a href="#需求6：订阅更新任务" class="headerlink" title="需求6：订阅更新任务"></a>需求6：订阅更新任务</h2><p>订阅更新链路：</p>
<ol>
<li>用户前端点击页面就会更新订阅公司的watchTime字段，一天之内只更新一次。</li>
<li>xxljob每周扫库，搜索的是订阅公司的那个表，将watchTime在前一周的公司发送kafka（自增id而不是公司id）</li>
<li>kafka消费者拿到这些id去数据库找对应的公司，将订阅公司表项和公司实体项（从es来的，如果前者有companyId就直接查询，如果没有就需要根据名字和地区来查询并保存）作为参数传分别分析<strong>facebook信息，facebook提及信息，海关信息，联系人信息</strong>，开了一个线程池并行处理这些。</li>
</ol>
<h3 id="1-facebook信息"><a href="#1-facebook信息" class="headerlink" title="1.facebook信息"></a>1.facebook信息</h3><p>代码太长了，梳理一下就这几部分：</p>
<ol>
<li>根据公司实体中的相关facebook链接去请求GRPC接口，返回facebook实体，其中包含个人信息，点赞数量，最近推文等信息。</li>
<li>从这里开始要注意逻辑，比对的是<strong>GRPC请求来的数据</strong>和<strong>当前数据库中最新的log</strong>。</li>
<li>去数据库中查询7种type的log，先全部查出来，然后再通过stream和sort得到最近时间的log。</li>
<li>将这些log分别与GRPC请求来的数据进行比较，例如判断facebook是否更新了，将最近的一条相关log的内容拉出来与GRPC请求来的数据进行比较，如果不一样就需要更新，在库里面新增一条。</li>
</ol>
<blockquote>
<ol>
<li>facebook地址初始化&#x2F;变更</li>
<li>facebook邮箱初始化&#x2F;变更</li>
<li>facebook网站地址初始化&#x2F;变更</li>
<li>facebook电话初始化&#x2F;变更</li>
<li>facebook点赞、关注初始化</li>
<li>facebook中发布了新帖子</li>
<li>facebook获得1个新评论</li>
</ol>
</blockquote>
<h3 id="2-facebook提及信息"><a href="#2-facebook提及信息" class="headerlink" title="2.facebook提及信息"></a>2.facebook提及信息</h3><ol>
<li>类似上面的，提及消息也是从GRPC来的，如果返回为null直接返回，这里是一个list，只关注最新的，所以也有stream+sort。</li>
<li>去数据库查询当前最新的log，主要关注的是这个记录的createTime。</li>
<li>如果数据库没有，那就说明是最新更新的，向数据库插入一条新的log表明有被提及，直接返回。</li>
<li>如果数据库有但log的时间比GRPC来的早，说明有新提及，进行更新。</li>
</ol>
<h3 id="3-海关信息"><a href="#3-海关信息" class="headerlink" title="3.海关信息"></a>3.海关信息</h3><ol>
<li>将公司名称格式化，随后去海关数据里面查找新增进出口数据，分别放在两个list里面。</li>
<li>如果有进出口就分别新增log。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customProcess</span><span class="params">(TbGlobalCollectEntity record, CompanySearchBO companyBO, Date startDate, Date endDate)</span> &#123;</span><br><span class="line">    <span class="comment">//海关那边的统一格式&quot;CompanyName-COMBINE-TANZANIA&quot;例如&quot;101 INVESTMENT-COMBINE-TANZANIA&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">nameAndCountry</span> <span class="operator">=</span> CompanyFormatUtils.combineCompanyNameAndCountry(companyBO.getName(), companyBO.getCountry());</span><br><span class="line">    <span class="comment">//去取出昨天的新增hscode，这个表主要是海关系统在维护</span></span><br><span class="line">    Map&lt;String, CustomInfoBO&gt; map = customDataComponent.batchGetCompanyNewTrxHscode(Lists.newArrayList(nameAndCountry), startDate, endDate);</span><br><span class="line">    List&lt;TbGlobalCollectLogEntity&gt; tbGlobalCollectLogEntities = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(nameAndCountry))&#123;</span><br><span class="line">        <span class="type">CustomInfoBO</span> <span class="variable">customInfoBO</span> <span class="operator">=</span> map.get(nameAndCountry);</span><br><span class="line">        <span class="comment">//出口</span></span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(customInfoBO.getExportHsCodeList()))&#123;</span><br><span class="line">            <span class="type">TbGlobalCollectLogEntity</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TbGlobalCollectLogEntity</span>();</span><br><span class="line">            t.setCollectId(record.getId());</span><br><span class="line">            t.setLogDesc(<span class="string">&quot;新供应了hscode为&quot;</span> + Strings.join(customInfoBO.getExportHsCodeList(), <span class="string">&quot;,&quot;</span>) + <span class="string">&quot;等的商品&quot;</span>);</span><br><span class="line">            t.setContent(JSON.toJSONString(customInfoBO.getExportHsCodeList()));</span><br><span class="line">            t.setType(CollectLogTypeEnum.CUSTOM_SHN.getType());</span><br><span class="line">            t.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            t.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            t.setInit12(<span class="number">0</span>);</span><br><span class="line">            tbGlobalCollectLogEntities.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进口</span></span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(customInfoBO.getImportHsCodeList()))&#123;</span><br><span class="line">            <span class="type">TbGlobalCollectLogEntity</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TbGlobalCollectLogEntity</span>();</span><br><span class="line">            t.setCollectId(record.getId());</span><br><span class="line">            t.setLogDesc(<span class="string">&quot;新采购了hscode为&quot;</span> + Strings.join(customInfoBO.getImportHsCodeList(), <span class="string">&quot;,&quot;</span>) + <span class="string">&quot;等的商品&quot;</span>);</span><br><span class="line">            t.setContent(JSON.toJSONString(customInfoBO.getImportHsCodeList()));</span><br><span class="line">            t.setType(CollectLogTypeEnum.CUSTOM_CON.getType());</span><br><span class="line">            t.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            t.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            t.setInit12(<span class="number">0</span>);</span><br><span class="line">            tbGlobalCollectLogEntities.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!CollectionUtils.isEmpty(tbGlobalCollectLogEntities))&#123;</span><br><span class="line">        tbGlobalCollectLogEntityService.saveAll(tbGlobalCollectLogEntities);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-联系人信息"><a href="#4-联系人信息" class="headerlink" title="4.联系人信息"></a>4.联系人信息</h3>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/12/05/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week3/">网易牛马日志-week3</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-12-05
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="需求3：优化应用侧分页查询收藏接口"><a href="#需求3：优化应用侧分页查询收藏接口" class="headerlink" title="需求3：优化应用侧分页查询收藏接口"></a>需求3：优化应用侧分页查询收藏接口</h1><p>利用上watchTime字段，xxljob只更新上一周查看过的条目，可以减少带宽。</p>
<h2 id="1-改造判断逻辑"><a href="#1-改造判断逻辑" class="headerlink" title="1.改造判断逻辑"></a>1.改造判断逻辑</h2><p>保存watchTime，首先需要获得该用户的accountId，还要获取某一条推荐对象的旧watchTime，判断是否是今天，如果是一天那就不用更新，如果是一天就需要更新。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!pageRes.getContent().isEmpty())&#123;</span><br><span class="line">    Date oldWatchTime = pageRes.getContent().get(0).getWatchTime();</span><br><span class="line">    watchTimeJudgeAndUpdate(Long.parseLong(AuthInfoUtils.getContext().getAuthInfo().getAccId()),oldWatchTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个方法按道理来说要变成异步的，看后续用多线程或者@Async解决</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">watchTimeJudgeAndUpdate</span><span class="params">(Long accountId,Date oldWatchTime)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//一天只保存一次watchTime</span></span><br><span class="line">        <span class="keyword">if</span> (oldWatchTime == <span class="literal">null</span> || !isSameDay(oldWatchTime,<span class="keyword">new</span> <span class="title class_">Date</span>()))&#123;</span><br><span class="line">            tbGlobalCollectEntityService.updateWatchTime(accountId);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;watchTimeUpdate success , accountId : &#123;&#125;&quot;</span>,accountId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;watchTimeUpdate failed , accountId : &#123;&#125;&quot;</span>,accountId,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSameDay</span><span class="params">(Date date1, Date date2)</span> &#123;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sdf.format(date1).equals(sdf.format(date2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里刚开始是用了jpa的抽象仓库一个一个更新，但是mentor说效率太低了，不如直接写sql，在这个方法里面支持跟mybatis那样直接执行sql。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TbGlobalCollectEntityService</span> <span class="keyword">extends</span> <span class="title class_">AbstractEasyEntityService</span>&lt;TbGlobalCollectEntity&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TbGlobalCollectRepository repository;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateWatchTime</span><span class="params">(Long accountId)</span>&#123;</span><br><span class="line">        repository.updateWatchTime(accountId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sql是更新所有当前accountId下，没有取消掉的推荐条目，把他们的watchTime都改为现在。</p>
<p>这里不需要返回当前时间，就更加说明这个判断逻辑跟前端没什么关系了，所以应该用异步。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Modifying</span><br><span class="line">@Transactional</span><br><span class="line">@Query(value = &quot;update TbGlobalCollectEntity p set p.watchTime=NOW() where p.status != -1 and p.accountId = :accountId&quot;)</span><br><span class="line">int updateWatchTime(@Param(&quot;accountId&quot;) Long accountId);</span><br></pre></td></tr></table></figure>

<h2 id="2-xxljob改造"><a href="#2-xxljob改造" class="headerlink" title="2.xxljob改造"></a>2.xxljob改造</h2><p>保存了watchTime，每周执行一次的定时任务需要改成查询所有watchTime为上周的条目。</p>
<p>DateUtil这个工具可以找到今天0点和上周0点的Date对象，然后再用jpa进行查询，把所有的数据投入kafka里。</p>
<blockquote>
<p>优化的本意是减少部分挖掘facebook的流量。但是因为在这个topic里面不止有这个任务，还有部分通讯录挖掘的任务。减少了这部分流量同时也会减少通讯录挖掘的流量，但是后者更加有价值，并不应该减少。所以按照道理来说应该分为两个topic进行操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">collectLogUpdate</span><span class="params">(<span class="type">int</span> param)</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">endDate</span> <span class="operator">=</span> DateUtil.trimAndIncreDate(<span class="keyword">new</span> <span class="title class_">Date</span>(),<span class="number">0</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">startDate</span> <span class="operator">=</span> DateUtil.trimAndDecreDate(<span class="keyword">new</span> <span class="title class_">Date</span>(), param);</span><br><span class="line">    List&lt;Specification&lt;TbGlobalCollectEntity&gt;&gt; specifications = Lists.newArrayList();</span><br><span class="line">    specifications.add(of(TbGlobalCollectEntity.class, <span class="string">&quot;status&quot;</span>, NEQ, GlobalSubscribeStatusEnum.DELETE.getStatus()));</span><br><span class="line">    specifications.add(of(TbGlobalCollectEntity.class, <span class="string">&quot;watchTime&quot;</span>, GTE, startDate));</span><br><span class="line">    specifications.add(of(TbGlobalCollectEntity.class, <span class="string">&quot;watchTime&quot;</span>, LTE, endDate));</span><br><span class="line">    List&lt;TbGlobalCollectEntity&gt; records = tbGlobalCollectEntityService.findAll(specifications);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(records)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (TbGlobalCollectEntity record : records) &#123;</span><br><span class="line">        kafkaProducer.send(KafkaConstants.COWORK_GLOBAL_COLLECT_DETAIL_CHANGE, String.valueOf(record.getId()), String.valueOf(record.getId()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="需求4：查验500条数据"><a href="#需求4：查验500条数据" class="headerlink" title="需求4：查验500条数据"></a>需求4：查验500条数据</h2><p>这个的工作量不在代码上而在于excel上，学到了一些技巧。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GET cowork_global_domain_info/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot; must &quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;exists&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;recommendData&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ,&quot;sort&quot;: &#123;</span><br><span class="line">    &quot;_script&quot;: &#123;</span><br><span class="line">      &quot;script&quot;: &quot;Math.random()&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;number&quot;,</span><br><span class="line">      &quot;order&quot;: &quot;asc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ,&quot;_source&quot;: [&quot;recommendData&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的点：</p>
<ol>
<li>随机从917w中找，这里sort要用random脚本</li>
<li>最好不要用滚动查询，有多少条是多少条</li>
<li>searchHit对象是一个大的对象DomainIndexBO，recommendData只是其中的一个字段。所以getSourceAsString包装的是DomainIndexBO，刚开始类型转换没弄明白耽误很久。</li>
<li>excel小技巧：在这种需要保留很多字段的时候可以用￥(dollar符)分开，因为很少有业务里面会用，防止误操作。例如在这个场景里面日志可以打印成”{recommendData.domain}￥{recomendData.other}”，然后在excel按照￥分行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">esGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Script</span> <span class="variable">script</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Script</span>(<span class="string">&quot;Math.random()&quot;</span>);</span><br><span class="line">    <span class="type">ScriptSortBuilder</span> <span class="variable">sortBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptSortBuilder</span>(script, ScriptSortBuilder.ScriptSortType.NUMBER)</span><br><span class="line">            .order(SortOrder.ASC);</span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    boolQuery.must(QueryBuilders.existsQuery(<span class="string">&quot;recommendData&quot;</span>));</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>()</span><br><span class="line">            .query(boolQuery) <span class="comment">// 查询参数</span></span><br><span class="line">            .fetchSource(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;recommendData&quot;</span>&#125;, <span class="literal">null</span>)</span><br><span class="line">            .sort(sortBuilder)</span><br><span class="line">            .size(<span class="number">500</span>);</span><br><span class="line">    SearchHit[] searchHits = domainDataIndex.query(sourceBuilder);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">        <span class="type">DomainIndexBO</span> <span class="variable">domainIndexBO</span> <span class="operator">=</span> JSON.parseObject(searchHit.getSourceAsString(),DomainIndexBO.class);</span><br><span class="line">        <span class="type">RecommendDataBO</span> <span class="variable">recommendData</span> <span class="operator">=</span> domainIndexBO.getRecommendData();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        stringBuilder.append(recommendData.getDomain()).append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        stringBuilder.append(String.join(<span class="string">&quot;,&quot;</span>, recommendData.getProducts())).append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (recommendData.getAliCategories().isEmpty())&#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (RecommendDataBO.AliCategory aliCategory : recommendData.getAliCategories()) &#123;</span><br><span class="line">                stringBuilder.append(aliCategory.getName()).append(<span class="string">&quot;:&quot;</span>).append(aliCategory.getScore()).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stringBuilder.append(<span class="string">&quot;$&quot;</span>).append(recommendData.getIsBizP()).append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        stringBuilder.append(recommendData.getIsBizVersion()).append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        stringBuilder.append(recommendData.getProductsVersion()).append(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(recommendData.getAliCategoryVersion()))&#123;</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            stringBuilder.append(recommendData.getAliCategoryVersion());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> stringBuilder.toString();</span><br><span class="line">        log.info(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;个:&quot;</span>+result);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>。。。未完待续</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/12/02/%E7%BD%91%E6%98%93%E7%89%9B%E9%A9%AC%E6%97%A5%E5%BF%97-week1-2/">网易牛马日志-week1-2</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-12-02
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h1 id="需求1：与推荐侧数据同步"><a href="#需求1：与推荐侧数据同步" class="headerlink" title="需求1：与推荐侧数据同步"></a>需求1：与推荐侧数据同步</h1><h2 id="1-配置kafka"><a href="#1-配置kafka" class="headerlink" title="1.配置kafka"></a>1.配置kafka</h2><p>kafka批量消费，设置消费者组，使得每次消费的时候从头消费</p>
<blockquote>
<p>消费者组能从头开始消费必须得有消息，也就是说如果消息过期了还是消费不了的，这个过期时间在delete.retention.ms里面配置，当前topic的过期时间是604800000，也就是一个礼拜。</p>
<p>还有一种办法是通过kafka给定的某个脚本参数来指定offset的消费位置。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, String&gt;&gt;</span><br><span class="line"><span class="title function_">recommendDomainDataListenerContainer</span><span class="params">(KafkaProperties kafkaProperties)</span> &#123;</span><br><span class="line">    ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = <span class="keyword">new</span> <span class="title class_">ConcurrentKafkaListenerContainerFactory</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Object&gt; map = kafkaProperties.buildConsumerProperties();</span><br><span class="line">    <span class="comment">//批量消费50个</span></span><br><span class="line">    map.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, <span class="number">50</span>);</span><br><span class="line">    map.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">    map.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, <span class="number">3000</span>); <span class="comment">// 3秒上报一次心跳</span></span><br><span class="line">    map.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">    map.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">&quot;earliest&quot;</span>);<span class="comment">//消费者组每次都从头开始消费</span></span><br><span class="line">    ConsumerFactory&lt;String, String&gt; consumerFactory = <span class="keyword">new</span> <span class="title class_">DefaultKafkaConsumerFactory</span>&lt;&gt;(map);</span><br><span class="line">    factory.setConsumerFactory(consumerFactory);</span><br><span class="line">    factory.setConcurrency(<span class="number">2</span>); <span class="comment">// 2个线程</span></span><br><span class="line">    factory.setBatchListener(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-配置kafka的消费者"><a href="#2-配置kafka的消费者" class="headerlink" title="2.配置kafka的消费者"></a>2.配置kafka的消费者</h2><p>由于是批量请求rpc接口，因此需要解决请求失败带来的<strong>消息丢失</strong>问题，意思是如果请求失败了，这些domain还会被消费，这里的思路是用一个set来保存没有消费的domain，如果在某处出错了，就会重新往kafka里面发消息，实现不漏消息。</p>
<blockquote>
<p>2024.12.2 在这上面栽了跟头</p>
<p>想法很美好但是实际上线还是出现了漏消息，成功率只有90%。</p>
<p>首先这个domainSet不能设置成全局变量，因为所有的线程都会更改这个变量，会有复杂的并发安全问题。其次是可能出现异常的时间点：</p>
<ul>
<li>消费的时候就出现问题，可能性很小</li>
<li>拿着所有50条去请求rpc接口的时候</li>
<li>rpc接口失败或者别的状态码</li>
<li>es更新出错</li>
</ul>
<p>由此可见需要在rpc接口请求之前就要初始化domainSet，所以在消费消息的时候就需要同时加入domainSet。但如果rpc接口请求成功了，需要清空domainSet，为什么呢？因为有可能domain是50个，那边只有40个可返回域名，如果再按照50个就会有消息被重复发送，例如虽然消息里面有<a target="_blank" rel="noopener" href="http://www.baidu.com,但是rpc接口里面死活没有,这个时候再去重新往kafka里面投重新消费是不合适的,所以在这里需要遍历response,然后保存进清空了的domainset里面./">www.baidu.com，但是rpc接口里面死活没有，这个时候再去重新往kafka里面投重新消费是不合适的，所以在这里需要遍历response，然后保存进清空了的domainSet里面。</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener(</span></span><br><span class="line"><span class="meta">        //这里是&#123;&#125;，可以配置多个topic</span></span><br><span class="line"><span class="meta">        topics = &#123;TOPIC&#125;,</span></span><br><span class="line"><span class="meta">        groupId = &quot;recommendation-ready-group-bugfix-v1&quot;,</span></span><br><span class="line"><span class="meta">        containerFactory = &quot;recommendDomainDataListenerContainer&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(List&lt;ConsumerRecord&lt;String, String&gt;&gt; records)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;RecommendDomainDataListener | size:&#123;&#125;&quot;</span>, records.size());</span><br><span class="line">    Set&lt;String&gt; domains = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; domainSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StopWatch</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">    sw.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(ConsumerRecord&lt;String, String&gt; record :records) &#123;</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">kafkaMsg</span> <span class="operator">=</span> JSON.parseObject(record.value());</span><br><span class="line">            <span class="type">String</span> <span class="variable">domain</span> <span class="operator">=</span> kafkaMsg.getString(<span class="string">&quot;domain&quot;</span>);</span><br><span class="line">            domain = DomainUtil.format(domain);</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isBlank(domain)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            domains.add(domain);</span><br><span class="line">            domainSet.add(domain);</span><br><span class="line">        &#125;</span><br><span class="line">        batchGetRecommendationDetail(domains,domainSet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">        <span class="keyword">for</span> (String domain : domainSet)&#123;</span><br><span class="line">            Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;domain&quot;</span>,domain);</span><br><span class="line">            kafkaProducer.send(TOPIC, domain, JSON.toJSONString(map));</span><br><span class="line">        &#125;</span><br><span class="line">        log.error(<span class="string">&quot;RecommendDomainDataListener | consumer message error. put in queue &#123;&#125;.&quot;</span>, JSON.toJSONString(domains),e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        sw.stop();</span><br><span class="line">        log.info(<span class="string">&quot;RecommendDomainDataListener | &#123;&#125;, cost: &#123;&#125;&quot;</span>, domains.size(), sw.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-GRPC请求"><a href="#3-GRPC请求" class="headerlink" title="3.GRPC请求"></a>3.GRPC请求</h2><p>grpc是让远程方法变得像本地方法一样简单，这里用了推荐侧的一个接口，确实只用引用一个jar包就行，背后就是一些复杂的网络请求。这个接口的可以一次传50个domain，状态码主要关注429，这里是触发了限流，需要按照上面的方法进行重新消费，消费多少发送多少相同的域名。</p>
<blockquote>
<p>grpc方法的qps是1，触发了限流要降速，Thread.sleep(1000);</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchGetRecommendationDetail</span><span class="params">(Set&lt;String&gt; domains,Set&lt;String&gt; domainSet)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Recommendation.<span class="type">GetDomainInfosRequest</span> <span class="variable">request</span> <span class="operator">=</span> Recommendation.GetDomainInfosRequest.newBuilder()</span><br><span class="line">            .addAllDomains(domains)</span><br><span class="line">            .setDomainSourceValue(DOMAIN_SOURCE_GRPC_VALUE).build();</span><br><span class="line">    Recommendation.<span class="type">GetDomainInfosResponse</span> <span class="variable">response</span> <span class="operator">=</span> recommendationClient.getDomainInfos(request);</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!response.getSuccess() || response.getCode() != GRPC_SUCCESS_CODE)&#123;</span><br><span class="line">            <span class="comment">//触发grpc限流，该方法降速，重新消费</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.valueOf(response.getCode()));</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;getRecommendationDetail. code:&#123;&#125;&quot;</span>,response.getCode());</span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(response.getDataList()))&#123;</span><br><span class="line">            List&lt;Recommendation.DomainInfo&gt; domainInfoList = response.getDataList();</span><br><span class="line">            <span class="keyword">for</span> (Recommendation.DomainInfo domainInfo : domainInfoList)&#123;</span><br><span class="line">                domainSet.add(domainInfo.getDomain());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Recommendation.DomainInfo domainInfo : domainInfoList)&#123;</span><br><span class="line">                convert(domainInfo,domainSet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Recommendation.GetDomainInfosResponse returns null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-转换对象"><a href="#4-转换对象" class="headerlink" title="4.转换对象"></a>4.转换对象</h2><p>这个没什么好说的，就是拷贝属性到当前项目的bean</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要熟悉了测试环境和线上环境，以及kafka的一些配置和机制，对于异常处理的理解加深了。</p>
<h1 id="需求2：定时发送新域名"><a href="#需求2：定时发送新域名" class="headerlink" title="需求2：定时发送新域名"></a>需求2：定时发送新域名</h1><p>需要每天的00:00去es里面检查昨天新增的域名，通过kafka发送消息。</p>
<ol>
<li>计算昨天00:00到23：59的时间戳：由于字段里面只有updateTime没有createTime，而且也是用时间戳来保存的，要先计算一下时间。</li>
<li>拼es的查询语句：range来查询时间，synFlag是防止重复发送的，有这个字段的可以认为已经发过了。</li>
<li>scrollSearch循环查找，不了解，但是大家都是这样用的。</li>
</ol>
<blockquote>
<p>es的操作跟数据库很像，而且网易封装的很好，index就相当于数据库表名，DomainDataIndex可以看作mybatis的实现类，AbstractIndex就是BaseMapper那种用来基础的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;newDomainSyncRecommend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">newDomainSyncRecommend</span> <span class="params">(String param)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="comment">//昨天的同一时刻</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">yesterday</span> <span class="operator">=</span> System.currentTimeMillis() - <span class="number">1000</span> * <span class="number">3600</span> * <span class="number">24</span>;</span><br><span class="line">    <span class="comment">//昨天零点零分零秒的毫秒数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">zero</span> <span class="operator">=</span> yesterday / (<span class="number">1000</span> * <span class="number">3600</span> * <span class="number">24</span>) * (<span class="number">1000</span> * <span class="number">3600</span> * <span class="number">24</span>) - TimeZone.getDefault().getRawOffset();<span class="comment">//今天零点零分零秒的毫秒数</span></span><br><span class="line">    <span class="comment">//昨天23点59分59秒的毫秒数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">twelve</span> <span class="operator">=</span> zero + <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">&quot;updateTime&quot;</span>)</span><br><span class="line">            .gte(zero)</span><br><span class="line">            .lte(twelve));</span><br><span class="line">    boolQuery.mustNot(QueryBuilders.existsQuery(<span class="string">&quot;synFlag&quot;</span>));</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>()</span><br><span class="line">            .query(boolQuery) <span class="comment">// 查询参数</span></span><br><span class="line">            .fetchSource(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;domain&quot;</span>&#125;,</span><br><span class="line">                    <span class="literal">null</span>)</span><br><span class="line">            .size(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (domainDataIndex == <span class="literal">null</span>) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;domainDataIndex is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    domainDataIndex.scrollSearch(sourceBuilder, searchHits -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">domain</span> <span class="operator">=</span> searchHit.getId();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//更新同步标识</span></span><br><span class="line">                Map&lt;String,Boolean&gt; updateMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                updateMap.put(<span class="string">&quot;synFlag&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">                domainDataIndex.updateByProcessor(domain,updateMap);</span><br><span class="line">                log.info(<span class="string">&quot;domainDataIndex upsert success ,domain : &#123;&#125;&quot;</span>,domain);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">                log.error(<span class="string">&quot;domainDataIndex upsert failed ,domain : &#123;&#125;&quot;</span>,domain,e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//组织kafka消息</span></span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">            jsonObject.put(<span class="string">&quot;domain&quot;</span>,domain);</span><br><span class="line">            kafkaProducer.send(<span class="string">&quot;new_domain_sync_recommend_topic&quot;</span>,domain,JSON.toJSONString(jsonObject));</span><br><span class="line">            log.info(<span class="string">&quot;kafka send success ,domain : &#123;&#125;&quot;</span>,domain);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/10/19/%E9%A1%B9%E7%9B%AE%E9%9D%A2%E8%AF%95/">项目面试</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-10-19
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="登录流程和登录状态保存"><a href="#登录流程和登录状态保存" class="headerlink" title="登录流程和登录状态保存"></a>登录流程和登录状态保存</h2><ul>
<li>乘客登录：首先根据前端微信小程序传来的code进行乘客openid的解析，根据这个openid进行落库。在我们的项目中不会对外暴露这个openid，使用的是自己系统的自增id。如果没有注册就insert一条。接着用redis存储登录状态，key是UUID，value是自己数据库的自增id。我们这里用的aop+threadlocal+注解类似网关的prehandle，处理前端每次都携带的token字段，然后在redis里根据这个key进行查询，如果是没有这个key就是没有登录过期了，如果是key为空就是没有登录。然后根据redis里的这个value存储到threadlocal中，后续就可以从threadlocal中get这个字段进行操作。</li>
<li>司机登录：流程与上面的类似，只不过多了阿里云的身份校验。</li>
</ul>
<p><strong>threadLocal的原理</strong></p>
<p>threadlocal是根据线程独立的变量，也就是说每一个线程可以存储不同的threadlocal，彼此是隔离的。其原理是每一个Thread类都有一个threadLocalMap，这个map相当于一个hashmap，key是threadLocal对象，value是存储的值。threadLocal查询的时候就会先获取当前线程，根据这个线程找到threadLocalmap，再找到其中的threadLocal对应的值。</p>
<p><strong>threadLocal的内存泄露问题</strong></p>
<p>threadLocalmap的key是弱引用，value是强引用，也就是说如果threadlocal没有外部强引用就会被回收，而value不会被回收。这个时候就会有内存泄露问题了。解决方法是不再使用threadLocal就手动remove</p>
<h2 id="搜寻周围司机和订单推送"><a href="#搜寻周围司机和订单推送" class="headerlink" title="搜寻周围司机和订单推送"></a>搜寻周围司机和订单推送</h2><p>在司机开始接单之后会把自己的位置上传到redis，然后进行等待，在这个过程中司机会不断轮询自己redis的list是否有数据。同时乘客端下单之后会新增一个定时任务，使用redis的gredius命令查询方圆5km内的符合要求的司机。并且为这些司机的list都添加该订单号。</p>
<p><strong>为什么要用定时任务</strong></p>
<p>因为执行一次并不一定就能及时发现司机，轮询又太消耗cpu，所以采用了定时任务。使用xxl-job可以管理这些定时任务。</p>
<p><strong>异常怎么处理的</strong></p>
<p>有一个兜底策略就是超时15分钟自动取消，如果在运行过程中出现失败首先xxl-job会显示执行失败，同时记录日志。</p>
<p><strong>如果周围只有一个司机，但是一直不接单，如何保证他的list中消息不重复</strong></p>
<p>这里使用了redis的set集合，key是订单的id，每当任务调度搜索到最近的司机之后首先会校验司机的id是否在set中，如果不在才可以加入自己的list。如果在的话说明是重复提交了。</p>
<p><strong>任务调度何时终止</strong></p>
<p>在查询周围司机之前都会先检查当前订单的状态，通过另一个微服务的调用。如果这个订单的状态发生改变说明已经有司机接单了，这个任务就会提前终止。</p>
<p><strong>为什么不用mq实现这一部分逻辑</strong></p>
<p>redis的速度较快，毕竟用户的规模不会很大，list的规模也不会很大，暂时不会存在大key问题。而且也需要批量处理这些消息和频繁的删除，如果为每一个司机都建立一个queue有一点奢侈，综合下来还是redis中list能够简化操作。</p>
<h2 id="司机抢单"><a href="#司机抢单" class="headerlink" title="司机抢单"></a>司机抢单</h2><p>每个司机在接单的过程中都会轮询自己在redis中的list是否有数据，如果有前端就会显示并且可以选择订单进行抢单。主要逻辑是首先会检查是否还有订单，这个是通过在redis的一个标识实现的，再下单的时候会给redis一个标识。目的是不用去数据库查找当前订单的状态节约数据库开销。为了防止超卖要用分布式锁，为当前订单id加锁。加锁之后再次校验是否有标识，进行接单操作后删除这个标识和释放锁，完成抢单逻辑。</p>
<p><strong>分布式锁用的是什么</strong></p>
<p>基于redision的分布式锁，锁住的是司机list中的订单id。本质还是基于setnx的，只不过redission有看门狗机制能够延长执行时间，保证任务能够进行完成而不会出现删除别人的锁的情况。这里可以优化的地方可以做成lua脚本，反正标识也是在redis里面的。逻辑是查询标识然后异步下单给mq。也会缩短司机抢单的响应时间，</p>
<h2 id="司乘同显"><a href="#司乘同显" class="headerlink" title="司乘同显"></a>司乘同显</h2><p>在司机正在前往起始点和进行服务的时候，乘客也需要知道司机在哪里。司机会定时将自己的数据上传到mongodb中，乘客端会找到最近时间的司机点坐标，然后调用map微服务渲染出路径。</p>
<p><strong>为什么使用mongodb，用redis或者mysql存储呢</strong></p>
<ul>
<li>路径数据是需要持久化保存的，用redis毕竟不是落库，而且存储的数据量大且只需要找出最近的一个点，大部分的数据没有用，会浪费珍贵的缓存空间，所以最好不用redis。</li>
<li>mysql也不太适合，存储的点数据量很大而mysql超过1kw查询效率就会很低，也会存在深度分页问题，如果多个订单同时进行并发也是mysql的问题。多一个少一个坐标点不会有很大的问题，所以使用另一个数据库进行存储，经过调研mongo能够满足。</li>
</ul>
<p><strong>基于rocketmq的<del>延迟队列</del>完成批量写是怎么实现的</strong></p>
<blockquote>
<p>这里真是犯了一个大错误。</p>
</blockquote>
<p>为了实现高效率写可以合并多次写请求，实现批量写。具体是设置rocketmq的批量处理功能。但是会增加代码的复杂度，更加轻量级的做法是线程池和阻塞队列。</p>
<h2 id="异步编排"><a href="#异步编排" class="headerlink" title="异步编排"></a>异步编排</h2><p>在完成订单后会有一系列的计算过程，例如防刷单校验，分账计算，推送账单等。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[Start]</span><br><span class="line">   |</span><br><span class="line">   +--&gt; [获取订单信息]  ----+</span><br><span class="line">   |                        |</span><br><span class="line">   +--&gt; [获取司机位置] ------+--&gt; [等待两个任务完成]</span><br><span class="line">                                 |</span><br><span class="line">                                 v</span><br><span class="line">                       [计算距离]</span><br><span class="line">                                 |</span><br><span class="line">               +-----------------+-----------------+</span><br><span class="line">               |                                   |</span><br><span class="line">        [距离 &gt; 2公里]                       [距离 &lt;= 2公里]</span><br><span class="line">               |                                   |</span><br><span class="line">         [抛出异常]                         +----+----+</span><br><span class="line">                                               |         |</span><br><span class="line">                                       [计算实际里程]   [获取订单数量]</span><br><span class="line">                                               |         |</span><br><span class="line">                                       [计算费用]    [计算奖励]</span><br><span class="line">                                               \         /</span><br><span class="line">                                                \       /</span><br><span class="line">                                        [计算分账信息]</span><br><span class="line">                                               |</span><br><span class="line">                                      [封装并更新账单]</span><br><span class="line">                                               |</span><br><span class="line">                                            [End]</span><br></pre></td></tr></table></figure>

<p>考虑将获取订单信息和获取目的地距离进行并行处理，使用supplyAsync实现两个线程，最后合并一起进行计算得到结果；再校验距离是否再可以接收的范围内，如果是不是刷单就并行获取订单数量和计算实际里程，这个是根据mongodb中的数据计算的，得到这两个信息进行账单计算和推送账单。主要是将几个不相关的微服务通过多线程并行获取了。</p>
<p><strong>如何测试的40%提升</strong></p>
<p>测试的该方法的执行时间发现比原来快了40%。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><strong>TCC的流程</strong></p>
<p>try-confirm-cancel，是一种业务入侵的分布式事务方法。try阶段会预留资源，confirm阶段确定分布式事务下所有的执行器都已经成功预留，如果全部成功就执行confirm提交事务，如果失败了就执行补偿措施cancel。这种方式比较灵活，可以自己控制事务，但是也入侵了业务，会造成一些别的问题，例如幂等性问题，空回滚和资源倒挂。</p>
<p><strong>解释一下这三个问题</strong></p>
<ul>
<li>幂等性：由于网络抖动等问题导致在confirm阶段可能出现超时重试，但是最终两个请求都收到了。在seata的解决方式是用一个事务状态表，在confirm&#x2F;cancel的时候提交给事务状态表，在开始的时候又去检查字段状态，如果是已经confirm了的，第二个请求就会被忽略，从而达到了幂等性</li>
<li>空回滚：在try阶段没有成功的微服务仍然执行了回滚，需要对失败的微服务进行区别。在seata里仍然是用事务状态表，在try成功了才会有status，回滚阶段有status的才能回滚</li>
<li>资源倒挂：由于网络原因try阻塞了，结果回滚了，但是后续网络恢复了仍然会预留资源，使得资源被倒挂。解决方案仍然是事务状态表，在回滚的时候插入一条suspend&#x3D;4，在try的时候先校验是不是倒挂了，如果&#x3D;4就不用预留资源。</li>
</ul>
<p><strong>具体在代码里是怎么做的</strong></p>
<p>例如我们的支付模块，需要修改金额和商品数量，然后下单。这个时候就要用到分布式事务了。每一个微服务模块都要实现tcc三个接口，在try的接口上使用@TwoPhaseBusinessAction，指定在seata服务中的id以及回滚和提交的方法名，接着在代码实现响应逻辑。对于数据库而言增加一个frozen字段，try阶段首先减少数量，frozen增加，cancel了就做相反操作，如果confirm了就减少frozen实际提交。</p>
<h2 id="规则引擎"><a href="#规则引擎" class="headerlink" title="规则引擎"></a>规则引擎</h2><p>用规则引擎做了一些计算</p>
<ul>
<li>例如根据距离和实际预估出价格，例如在7点之前起步价是多少多少钱，每公里的价格计算。使用规则引擎防止将规则和价格硬编码在代码里，方便实际部署动态变更。</li>
<li>计算账单也使用到了规则引擎，例如按照什么比例分成，根据订单多少给予奖励</li>
</ul>
<p><strong>但是实际工作里面都不太会用到这个你知道是为什么吗</strong></p>
<p>我觉得首先是学习成本的问题，这个东西语法确实也很冗杂，虽然在java代码里面不用硬编码了，但是几个ifelse却要用更长的代码表示。某些时候这个服务也会成为瓶颈。</p>
<h2 id="实习项目"><a href="#实习项目" class="headerlink" title="实习项目"></a>实习项目</h2><h3 id="业务是什么"><a href="#业务是什么" class="headerlink" title="业务是什么"></a>业务是什么</h3><p>实现人工智能检测平台和主平台的接口，具体是定时发送指令到视频流平台，截图入库后通过这个接口的一系列定时任务提交给人工智能检测平台返回结果进行统计。统计完成后用kafka异步落库并返回给前端。除此之外还有一些文档和增删改查的工作。</p>
<h3 id="xxl-job是怎么用的，你的项目里面有哪些定时任务会需要用到这个"><a href="#xxl-job是怎么用的，你的项目里面有哪些定时任务会需要用到这个" class="headerlink" title="xxl-job是怎么用的，你的项目里面有哪些定时任务会需要用到这个"></a>xxl-job是怎么用的，你的项目里面有哪些定时任务会需要用到这个</h3><p>xxl-job是一个开箱即用的分布式调度平台，与传统的quataz相比可以动态改变cron表达式，还具有可视化的界面。由于实习单位后端有很多的定时任务，写死cron表达式不利于管理</p>
<ol>
<li>首先是截图指令，会传递几个参数通过http控制视频流平台，其中参数会包含间隔时间，视频流平台也会根据这个进行定时落库。</li>
<li>接着是定时给人工智能平台传输，因为平台有很多的检测算法，接口都不是很统一。这里有一些很长的if判定过程。例如未佩戴安全帽 未佩戴绝缘手套  靠近变压器告警、工作服，或者是画面无人。这里用了一个线程池来并发完成这些图片的校验和传输，还用了策略模式把这些校验的很长的ifelse给简化了。具体是用一个公用的策略接口，然后上下文类中替换这个接口的实现类来完成策略选择。最后在策略工厂里面用哈希表来保存类型和具体策略的映射关系。</li>
<li>还有一个定时任务是每天早上1点钟删除保存了3天以上的照片</li>
<li>人脸注册每分钟从数据库抽200张给人工智能平台，人工智能平台自己也有数据库，在这个系统里面也有，这个时候虽然是通过http传输的，但是也可以看作一个分布式的事务，由于这个系统业务范围不是我们的，所以用分布式事务也不太合理。所以就想到用kafka保证最终一致性。</li>
</ol>
<h3 id="kafka怎么保证最终一致性的"><a href="#kafka怎么保证最终一致性的" class="headerlink" title="kafka怎么保证最终一致性的"></a>kafka怎么保证最终一致性的</h3><p>主要依赖kafka的exactly once语义。要实现只提交一次且只能消费一次需要三方都协调。对于生产者也就是我们这个代码里面，要使用kafka的幂等和事务，配置kafka的幂等性可以使生产者的消息只会被kafka接收一次，配置事务使得消费者在消费消息的时候只能看到提交事务的，对于kafka而言，由于我们公司也没配置kafka集群，所以只设置了acks&#x3D;1，也就是写入成功后返回回调函数，这样能保证kafka不丢消息。消费者为了不重复消费消息也需要做到幂等，这里的幂等校验是redis进行去重的，然后再手动提交ack。这样能保证如果前面的平台执行失败了，这里的接口也不会落库；如果执行成功，通过kafka的这个exactly once就可以只落库一次。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/10/08/%E7%BD%91%E7%BB%9C%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E7%AF%87/">网络和操作系统面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-10-08
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h2><p>https主要有非对称加密，对称加密和数字签名三部分。具体流程是服务器先向证书颁发机构注册和验证。客户端请求服务器的时候，服务器会把自己非对称加密的钥匙发给客户端，这个钥匙是需要数字签名进行盖章的，这样客户端就知道这个网站是合法的而不是钓鱼网站。接收到了服务器非对称加密的钥匙，再把对称加密的钥匙通过这个公钥发给服务器，服务器用私钥进行解密。后续就根据对称加密进行传输。</p>
<h2 id="http的状态码"><a href="#http的状态码" class="headerlink" title="http的状态码"></a>http的状态码</h2><ul>
<li>1xx：正在处理的状态，一般见不到</li>
<li>2xx：成功状态码</li>
<li>3XX：301永久重定向，302临时重定向</li>
<li>4XX：401资源未授权，403被屏蔽了，404找不到</li>
<li>5XX：500服务器问题。502网关收到了，但是服务器转发有问题</li>
</ul>
<h2 id="http版本"><a href="#http版本" class="headerlink" title="http版本"></a>http版本</h2><ul>
<li>http1.0：短链接，一个资源一次tcp。</li>
<li>http1.1：长连接，但是还是有hol问题，即大文件传输会挡住小文件传输从而影响体验</li>
<li>http2.0：长连接，通过二进制帧解决了hol的问题，将大文件分成小份传输。同时长连接也改进成了多路复用</li>
<li>http3.0：tcp+quic（udp）优化了握手，安全性也进行了更新</li>
</ul>
<h2 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h2><ul>
<li>客户端先发送同步信号SYN，再带上自己的seq，进入syn-send状态</li>
<li>服务器接收到了发送ack和sys，进入syn-recv</li>
<li>客户端收到了之后在发送一个ack，建立连接</li>
</ul>
<p><strong>为什么是三次握手</strong></p>
<p>因为只有三次握手才能使双方都知道各方面正常。</p>
<ul>
<li>第一次握手，客户端什么都不能确认，服务器可以确认自己接受正常，客户端发送正常。</li>
<li>第二次握手，客户端可以确认自己发送和接收正常，服务器发送和接收正常；服务器可以确认自己接收正常，客户端发送正常</li>
<li>第三次握手，服务器可以确认自己发送和接收正常，客户端发送和接收正常</li>
</ul>
<h2 id="tcp四次握手"><a href="#tcp四次握手" class="headerlink" title="tcp四次握手"></a>tcp四次握手</h2><ul>
<li>客户端发送fin和seq，进入fin-wait-1</li>
<li>服务器接收到发送ack和seq，进入close-wait，客户端接收到了变为fin-wait-2</li>
<li>可能服务器还会有要发送的，发送完了发送fin，变为last-ack</li>
<li>客户端接收到了变为time-wait，等到2ttl时间，如果没有等到服务器的消息就自己关闭。</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/10/05/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-seata/">分布式事务-seata</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-10-05
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h2><p>TCC模式是try，confirm，cancel。不依赖本地事务，通过业务代码解决。try先预留事务所需的资源，confirm确保任务的执行并且消耗第一阶段预留的资源，如果在这个阶段出现差错就进入cancel。</p>
<p>优点：</p>
<ul>
<li>不依赖数据库的事务，可以用在非事务型数据库</li>
<li>不用全局锁，无需生成快照，效率较高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>代码侵入：需要程序员手动设计事务逻辑，增加了开发的复杂度</li>
<li>中间有软状态，是最终一致性，confirm和cancel出现问题会有一致性问题。</li>
<li>幂等问题：如果由于在confirm和cancel阶段出现网络波动，可能多次释放资源，出现严重后果。所以为了保证信息只被回滚一次需要保证幂等性。可以用状态表来实现（但是我觉得还是会有并发问题）</li>
<li>空回滚：try的期间阻塞一条，回滚的时候也会回滚这个空的。可能造成资源无故释放。解决方法也是状态表，如果第一阶段有记录成功过了就执行回滚。如果没有就不用</li>
<li>资源倒挂：也是网络环境变化，try阶段某个分支事务阻塞了直到最后回滚了才执行，是空回滚的另一个结果。解决方案是空回滚的时候加一条状态记录。在try阶段如果没有这个就执行，如果有分支事务的id。说明已经被空回滚发现，不再执行。</li>
</ul>
<h2 id="saga模式"><a href="#saga模式" class="headerlink" title="saga模式"></a>saga模式</h2><p>Saga模式是一种用于处理分布式事务的模式，它通过将长时间的、复杂的事务分解为多个小的、可逆的事务片段，以实现事务的一致性和可靠性。</p>
<p>在Saga模式中，每个事务片段称为一个补偿操作。每个补偿操作都与一个正向操作相对应，正向操作是事务的一部分，而补偿操作是用于撤销或修复正向操作的。Saga模式通过按照事务执行的顺序，依次执行正向操作和补偿操作，来确保事务在发生失败或异常时能够进行回滚或恢复。</p>
<p>Saga模式的执行过程如下：</p>
<p>执行正向操作：按照事务的逻辑顺序，依次执行正向操作。每个正向操作都会记录事务的执行状态。<br>如果所有的正向操作都成功执行，则事务提交完成。<br>如果某个正向操作失败，将会触发相应的补偿操作。补偿操作会撤销或修复正向操作的影响。<br>执行补偿操作：按照逆序依次执行已经触发的补偿操作。补偿操作应该具备幂等性，以便可以多次执行而不会造成副作用。<br>如果所有的补偿操作都成功执行，则事务回滚完成。<br>如果补偿操作也失败，需要人工介入或其他手段来解决事务的一致性问题。</p>
<p>Seata的Saga模式：</p>
<p>Seata的Saga模式通过Seata框架来管理和协调分布式事务，提供了对事务的编排和状态管理的支持。它与Seata的其他特性（如AT模式、TCC模式）结合在一起，构成了Seata全面的分布式事务解决方案。</p>
<p>Seata的Saga模式相对于传统的Saga模式，具有以下特点：</p>
<ul>
<li>集成性：Seata的Saga模式与Seata框架紧密集成，可以与Seata的其他特性一起使用，如分布式事务日志和分布式锁等。</li>
<li>强一致性：Seata的Saga模式提供了强一致性的事务支持，确保事务的执行顺序和一致性。</li>
<li>可靠性：Seata的Saga模式在补偿操作的执行过程中，支持重试和恢复机制，提高了事务的可靠性和恢复能力。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>业务流程长、业务流程多</li>
<li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>一阶段提交本地事务，无锁，高性能</li>
<li>事件驱动架构，参与者可异步执行，高吞吐</li>
<li>补偿服务易于实现，不用编写TCC中的三个阶段，实现简单</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>没有锁，不保证隔离性，会有脏写；</li>
<li>软状态持续时间不确定，时效性差；</li>
</ul>
<h2 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h2><p>就是二阶段提交2pc模式。保证强一致性，只能一起提交或者失效。效率最低。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/10/04/%E5%9C%BA%E6%99%AF%E9%A2%98/">场景题</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-10-04
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="如何设计一个秒杀系统"><a href="#如何设计一个秒杀系统" class="headerlink" title="如何设计一个秒杀系统"></a>如何设计一个秒杀系统</h2><ul>
<li>高性能：高性能核心就是响应时间快，一般来说都会把热点数据放在redis中，但是秒杀高峰的时候有可能连redis都应付不了。有几种解决方案：首先是二级缓存，redis之外用jvm的缓存例如caffeine，一定要控制空间大小，所以必须上淘汰策略例如lru；或者在业务层面进行UV统计，但是需要改写redis的jar；或者直接使用开源解决方案比如京东的hotkey。此外为了提高响应速度还可以将静态资源放到cdn上，例如七牛云阿里云，图片不会再占用服务器的带宽，但是这种属于钞能力的解决方案。</li>
<li>高可用：保证节点的故障恢复。需要用集群。包括但不限redis-sentinel，redis-cluster；此外还可以用分布式限流框架sentinel，实现服务限流和降级；优化异步请求可以用mq，mq对于高可用的贡献是流量削峰，将请求打入消息队列，对于高性能的贡献是将减库存缓存和减数据异步化，更快返回请求。</li>
<li>一致性：如何防止超卖，可以用lua脚本查询redis中的余量，但是lua的原子性保证的是脚本内都是一条语句，而不是事务上的原子性，出错了是不会回滚的；redis减库存后需要同步到mysql中，可以用mq完成。扣减余额也要考虑并发问题，可以用mysql的排他锁。</li>
<li>幂等性：也就是常说的一人一单，可以考虑用分布式锁来锁住当前用户。</li>
</ul>
<h2 id="大文件断点续传问题"><a href="#大文件断点续传问题" class="headerlink" title="大文件断点续传问题"></a>大文件断点续传问题</h2><ul>
<li>前端文件分片，并且通过sha算法生成一个校验和。</li>
<li>后端根据这个校验和先去查minio是否有当前分片，如果有就直接跳过</li>
<li>如果没有先检验sha校验和，如果匹配说明有效。可以采用并行的方式加快传输</li>
<li>所有分片发送完毕后，前端会进行校验，发送整个的sha，与后端合并后的文件进行校验</li>
</ul>
<h2 id="40亿qq号，如何去重"><a href="#40亿qq号，如何去重" class="headerlink" title="40亿qq号，如何去重"></a>40亿qq号，如何去重</h2><p>哈希表和哈希集肯定是不行的，可以考虑用位图。或者数据结构那种外部归并排序</p>
<h2 id="动态线程池"><a href="#动态线程池" class="headerlink" title="动态线程池"></a>动态线程池</h2><p>要用到nacos动态配置核心参数</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/09/30/JVM%E9%9D%A2%E8%AF%95%E7%AF%87/">JVM面试篇</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-09-30
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="JVM如何解决跨代问题"><a href="#JVM如何解决跨代问题" class="headerlink" title="JVM如何解决跨代问题"></a>JVM如何解决跨代问题</h2><p>如果在年轻代的某个对象引用了老年代的对象，在触发Young GC的时候只会检查年轻代而不会检查老年代，此时如果老年代引用了一个年轻代的对象就不会被YGC发现而回收了此对象。但是这种情况出现的比较少，除非是老年代动态的引用了一个刚产生的对象。</p>
<p><strong>记忆集和卡表</strong><br>如果为了小概率事件每次YGC都去扫描一遍永久代，开销会很大。此时我们只需要保存从非扫描区域到扫描区域的指针就可以了。这个保存的扫描指针逻辑上叫做记忆集，放在新生代中。</p>
<p>卡表是hotspot虚拟机对于记忆集的具体实现，类似位图，把非扫描区域分块，然后用一个卡表数组来记录对应块是否变脏，如果记录的为1说明变脏，在YGC的时候把对应块加入扫描。本质上是用空间换时间。</p>
<p><strong>写屏障</strong><br>这里的写屏障跟volatile的不一样，这里仅仅是对引用操作做了一层aop，在写后屏障加入添加卡表的操作，在写前屏障添加该页是否脏的判断，可以解决伪共享问题。</p>
<h2 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h2><p>三色标记算法是可达性分析的一个扫描过程，例如CMS，先做初始标记标记出GCroot，然后再并发标记，这个过程是通过三色标记算法实现的。最后扫描到的白色节点就被视为没有引用，在下一轮GC会被回收。</p>
<ul>
<li>黑色，直接或者间接连接到GCroot并且自身所有引用都被扫描过了</li>
<li>灰色：从黑色节点扩散，但是自己的子节点还没有被完全扫描</li>
<li>白色：没有被染指的节点，也就是不可达区域</li>
</ul>
<p><strong>三色标记的缺点</strong></p>
<ol>
<li>多标问题：在一个节点被标记成灰色之后，上一个节点断开联系，最终这个节点还是会被染黑，但实际上是垃圾。这个现象称为浮动垃圾，在下一轮会被回收。</li>
<li>漏标问题：多标至少可以通过下一轮垃圾回收清除，漏标就严重多了。当一个灰色节点与一个白色节点断掉之后立刻有黑色节点相连。这个时候三色标记算法还是会认为这个节点是白色的，就会被垃圾回收，而此时确实有黑色节点的引用，会报空指针异常。</li>
</ol>
<div style="text-align: center;">
  <img src="../img/jvm/img_5.png" alt="" />
</div>

<p><strong>如何解决</strong><br>两个条件同时发生才会有漏标现象：首先是有灰色节点与白色节点断开联系，又有黑色节点与白色节点产生联系。</p>
<p>破坏一个就不会产生漏标：</p>
<ul>
<li>增量更新：增量更新破坏了第一个条件：「至少有一个黑色对象新增了对白色对象的引用」，在并发标记阶段，黑色对象D指向了白色对象G，这时会把黑色对象D记录下来，在重新标记阶段，会把黑色对象D标记为灰色对象D，然后以灰色对象D为根节点，扫描整个引用链，白色对象G就会被依次标记为灰色、黑色，白色对象G漏标的问题就解决了。 缺点是会重新扫描以黑色对象为根节点的子树，时间长（CMS解决方案）</li>
<li>原始快照：原始快照破坏了第二个条件：「所有灰色对象指向该白色对象的引用都断开了」，在并发标记阶段，灰色对象E断开了对白色对象G的引用，这是会把白色对象G记录下来，在最终标记阶段，会把白色对象G标记为灰色，然后以灰色对象G为根节点，扫描整个引用链，如此以来原来的白色对象G就会被依次标记为灰色、黑色，白色对象G漏标的问题就解决了。缺点是如果没有黑色对象来引用就会变成浮动垃圾（G1解决方案）</li>
</ul>
<h2 id="类的回收"><a href="#类的回收" class="headerlink" title="类的回收"></a>类的回收</h2><p>类的元数据在方法区也就是元空间中，在fullGC是有可能会被垃圾回收的。一个类能被垃圾回收需要满足三个要求：</p>
<ol>
<li>没有实例对象</li>
<li>没有静态方法的引用</li>
<li>类加载器已经被GC</li>
</ol>
<p><strong>private static final int I &#x3D; 0，这个i会回收吗</strong></p>
<p>看情况，跟着类走，本身这就是一个GCroot，一共有四种GCroot（类的常量引用类似这种，静态引用，虚拟机栈的引用，本地方法栈的引用）。如果不是类被卸载的话是不能被GC的。</p>

    
    
  </div>

  

  

</article>
  
    
  <nav class="pagination">  
      
      
      <a class="next" href="/page/2/">  
        <span class="next-text">下一页</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  
</section>
        </div>
          

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:1050886654@qq.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/yyf1050886654" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/zeed-w-beez/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2024      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">Yifan Yang</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    

  







<script type="text/javascript" src="/lib/jquery"></script>



<script type="text/javascript" src="/lib/slideout"></script>



<script type="text/javascript" src="/lib/fancybox"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>